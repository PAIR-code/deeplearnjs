(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("../src/index"));

},{"../src/index":13}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Note_1 = require("./Note");
var offsets = [0, 0.5, 1, 1.5, 2, 3, 3.5, 4, 4.5, 5, 5.5, 6];
var KeyboardElement = (function () {
    function KeyboardElement(container, lowest, octaves) {
        if (lowest === void 0) { lowest = 36; }
        if (octaves === void 0) { octaves = 4; }
        this._container = document.createElement('div');
        this._container.id = 'keyboard';
        container.appendChild(this._container);
        this._keys = {};
        this.resize(lowest, octaves);
        this._notes = {};
    }
    KeyboardElement.prototype.resize = function (lowest, octaves) {
        this._keys = {};
        this._container.innerHTML = '';
        var keyWidth = (1 / 7) / octaves;
        for (var i = lowest; i < lowest + octaves * 12; i++) {
            var key = document.createElement('div');
            key.classList.add('key');
            var isSharp = ([1, 3, 6, 8, 10].indexOf(i % 12) !== -1);
            key.classList.add(isSharp ? 'black' : 'white');
            this._container.appendChild(key);
            var noteOctave = Math.floor(i / 12) - Math.floor(lowest / 12);
            var offset = offsets[i % 12] + noteOctave * 7;
            key.style.width = keyWidth * 100 + "%";
            key.style.left = offset * keyWidth * 100 + "%";
            key.id = i.toString();
            var fill = document.createElement('div');
            fill.id = 'fill';
            key.appendChild(fill);
            this._keys[i] = key;
        }
    };
    KeyboardElement.prototype.keyDown = function (noteNum) {
        if (this._keys.hasOwnProperty(noteNum)) {
            var key = this._keys[noteNum];
            key.classList.remove('hover');
            var note = new Note_1.Note(key.querySelector('#fill'));
            if (!this._notes[noteNum]) {
                this._notes[noteNum] = [];
            }
            this._notes[noteNum].push(note);
        }
    };
    KeyboardElement.prototype.keyUp = function (noteNum) {
        if (this._keys.hasOwnProperty(noteNum)) {
            if (!(this._notes[noteNum] && this._notes[noteNum].length)) {
                console.warn('note off before note on');
            }
            else {
                this._notes[noteNum].shift().noteOff();
            }
        }
    };
    return KeyboardElement;
}());
exports.KeyboardElement = KeyboardElement;

},{"./Note":3}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Note = (function () {
    function Note(container, ai) {
        this.element = document.createElement('div');
        this.element.classList.add('highlight');
        this.element.classList.add('active');
        if (ai) {
            this.element.classList.add('ai');
        }
        container.appendChild(this.element);
    }
    Note.prototype.noteOff = function () {
        var _this = this;
        this.element.classList.remove('active');
        setTimeout(function () {
            _this.element.remove();
        }, 1000);
    };
    return Note;
}());
exports.Note = Note;

},{}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var deeplearnjs_1 = require("../deeplearnjs");
var Element_1 = require("./js/Element");
var Piano = require('tone-piano').Piano;
var lstmKernel1;
var lstmBias1;
var lstmKernel2;
var lstmBias2;
var lstmKernel3;
var lstmBias3;
var c;
var h;
var fullyConnectedBiases;
var fullyConnectedWeights;
var forgetBias = deeplearnjs_1.Scalar.new(1.0);
var currentTime = 0;
var currentVelocity = 1;
var math = new deeplearnjs_1.NDArrayMathGPU();
var INPUT_SIZE = 388;
var PRIMER_IDX = 355;
var lastSample = PRIMER_IDX;
var container = document.querySelector('#container');
var keyboardInterface = new Element_1.KeyboardElement(container, 0, 4);
var piano = new Piano({ velocities: 4 }).toMaster();
var output;
piano.load('https://tambien.github.io/Piano/Salamander/').then(function () {
    var reader = new deeplearnjs_1.CheckpointLoader('.');
    return reader.getAllVariables();
}).then(function (vars) {
    document.querySelector('#status').classList.add('hidden');
    lstmKernel1 = vars['rnn/multi_rnn_cell/cell_0/basic_lstm_cell/kernel'];
    lstmBias1 = vars['rnn/multi_rnn_cell/cell_0/basic_lstm_cell/bias'];
    lstmKernel2 = vars['rnn/multi_rnn_cell/cell_1/basic_lstm_cell/kernel'];
    lstmBias2 = vars['rnn/multi_rnn_cell/cell_1/basic_lstm_cell/bias'];
    lstmKernel3 = vars['rnn/multi_rnn_cell/cell_2/basic_lstm_cell/kernel'];
    lstmBias3 = vars['rnn/multi_rnn_cell/cell_2/basic_lstm_cell/bias'];
    fullyConnectedBiases = vars['fully_connected/biases'];
    fullyConnectedWeights = vars['fully_connected/weights'];
    c = [
        deeplearnjs_1.Array2D.zeros([1, lstmBias1.shape[0] / 4]),
        deeplearnjs_1.Array2D.zeros([1, lstmBias2.shape[0] / 4]),
        deeplearnjs_1.Array2D.zeros([1, lstmBias3.shape[0] / 4]),
    ];
    h = [
        deeplearnjs_1.Array2D.zeros([1, lstmBias1.shape[0] / 4]),
        deeplearnjs_1.Array2D.zeros([1, lstmBias2.shape[0] / 4]),
        deeplearnjs_1.Array2D.zeros([1, lstmBias3.shape[0] / 4]),
    ];
    currentTime = piano.now();
    generateStep();
});
window.addEventListener('resize', resize);
function resize() {
    var keyWidth = 20;
    var octaves = Math.round((window.innerWidth / keyWidth) / 12);
    octaves = Math.max(octaves, 2);
    octaves = Math.min(octaves, 7);
    var baseNote = 48;
    if (octaves > 5) {
        baseNote -= (octaves - 5) * 12;
    }
    keyboardInterface.resize(baseNote, octaves);
}
resize();
function generateStep() {
    math.scope(function (keep, track) {
        var lstm1 = math.basicLSTMCell.bind(math, forgetBias, lstmKernel1, lstmBias1);
        var lstm2 = math.basicLSTMCell.bind(math, forgetBias, lstmKernel2, lstmBias2);
        var lstm3 = math.basicLSTMCell.bind(math, forgetBias, lstmKernel3, lstmBias3);
        var input = track(deeplearnjs_1.Array2D.zeros([1, INPUT_SIZE]));
        input.set(1.0, 0, lastSample);
        for (var i = 0; i < 10; i++) {
            output = math.multiRNNCell([lstm1, lstm2, lstm3], input, c, h);
            output[0].map(function (val) {
                keep(val);
            });
            output[1].map(function (val) {
                keep(val);
            });
            c = output[0];
            h = output[1];
            var outputH = h[2];
            var weightedResult = math.matMul(outputH, fullyConnectedWeights);
            var logits = math.add(weightedResult, fullyConnectedBiases);
            var softmax = math.softmax(logits.as1D());
            var sampledOutput = sampleFromSoftmax(math, softmax);
            playOutput(sampledOutput);
            lastSample = sampledOutput;
            input = track(deeplearnjs_1.Array2D.zeros([1, INPUT_SIZE]));
            input.set(1.0, 0, lastSample);
        }
    });
    var delta = currentTime - piano.now();
    setTimeout(function () { return generateStep(); }, delta * 1000);
}
var MIN_MIDI_PITCH = 0;
var MAX_MIDI_PITCH = 127;
var VELOCITY_BINS = 32;
var MAX_SHIFT_STEPS = 100;
var STEPS_PER_SECOND = 100;
var EVENT_RANGES = [
    ['note_on', MIN_MIDI_PITCH, MAX_MIDI_PITCH],
    ['note_off', MIN_MIDI_PITCH, MAX_MIDI_PITCH],
    ['time_shift', 1, MAX_SHIFT_STEPS],
    ['velocity_change', 1, VELOCITY_BINS],
];
function playOutput(index) {
    var offset = 0;
    var _loop_1 = function (eventRange) {
        var eventType = eventRange[0];
        var minValue = eventRange[1];
        var maxValue = eventRange[2];
        if (offset <= index && index <= offset + maxValue - minValue) {
            if (eventType === 'note_on') {
                var noteNum_1 = index - offset;
                setTimeout(function () {
                    keyboardInterface.keyDown(noteNum_1);
                    setTimeout(function () {
                        keyboardInterface.keyUp(noteNum_1);
                    }, 100);
                }, (currentTime - piano.now()) * 1000);
                return { value: piano.keyDown(noteNum_1, currentTime, currentVelocity) };
            }
            else if (eventType === 'note_off') {
                var noteNum = index - offset;
                return { value: piano.keyUp(noteNum, currentTime) };
            }
            else if (eventType === 'time_shift') {
                currentTime += (index - offset + 1) / STEPS_PER_SECOND;
                return { value: currentTime };
            }
            else if (eventType === 'velocity_change') {
                currentVelocity = (index - offset + 1) * Math.ceil(127 / VELOCITY_BINS);
                currentVelocity = currentVelocity / 127;
                return { value: currentVelocity };
            }
            else {
                throw new Error('Could not decode eventType: ' + eventType);
            }
        }
        offset += maxValue - minValue + 1;
    };
    for (var _i = 0, EVENT_RANGES_1 = EVENT_RANGES; _i < EVENT_RANGES_1.length; _i++) {
        var eventRange = EVENT_RANGES_1[_i];
        var state_1 = _loop_1(eventRange);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    throw new Error('Could not decode index: ' + index);
}
function sampleFromSoftmax(math, softmax) {
    var softmaxValues = softmax.getValues();
    var rand = deeplearnjs_1.Scalar.randUniform([], 0, 1).get();
    var cdf = 0;
    for (var i = 0; i < softmaxValues.length; i++) {
        cdf += softmaxValues[i];
        if (cdf > rand) {
            return i;
        }
    }
    throw new Error('Could not sample from softmax.');
}

},{"../deeplearnjs":1,"./js/Element":2,"tone-piano":5}],5:[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("tone")):"function"==typeof define&&define.amd?define(["tone"],t):"object"==typeof exports?exports.Piano=t(require("tone")):e.Piano=t(e.tone)}(this,function(e){return function(e){function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:o})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=8)}([function(t,n){t.exports=e},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=n(2);t.default={getReleasesUrl:function(e){return"rel"+(e-20)+".mp3?"+(100*Math.random()).toFixed(0)},getHarmonicsUrl:function(e){return"harmL"+(0,o.midiToNote)(e).replace("#","s")+".mp3?"+(100*Math.random()).toFixed(0)},getNotesUrl:function(e,t){return(0,o.midiToNote)(e).replace("#","s")+"v"+t+".mp3?"+(100*Math.random()).toFixed(0)}}},function(e,t,n){"use strict";function o(e){return(0,s.Frequency)(e).toMidi()}function r(e){return(0,s.Frequency)(e,"midi").toNote()}function i(e){var t=e%3;return 1===t?[e-1,c.default.intervalToFrequencyRatio(1)]:2===t?[e+1,c.default.intervalToFrequencyRatio(-1)]:[e,1]}function u(e){return new s.BufferSource(e)}function a(e,t){return Math.random()*(t-e)+e}Object.defineProperty(t,"__esModule",{value:!0}),t.randomBetween=t.midiToFrequencyRatio=t.createSource=t.noteToMidi=t.midiToNote=void 0;var s=n(0),c=function(e){return e&&e.__esModule?e:{default:e}}(s);t.midiToNote=r,t.noteToMidi=o,t.createSource=u,t.midiToFrequencyRatio=i,t.randomBetween=a},function(e,t,n){"use strict";function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var u=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(0),s=function(e){return e&&e.__esModule?e:{default:e}}(a),c=function(e){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;o(this,t);var n=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return n.createInsOuts(0,1),n.volume=e,n}return i(t,e),u(t,[{key:"volume",get:function(){return s.default.gainToDb(this.output.gain.value)},set:function(e){this.output.gain.value=s.default.dbToGain(e)}}]),t}(a.AudioNode);t.default=c},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(1),c=o(s),l=n(3),f=o(l),p=n(2),h=n(0),d=[21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87],_=function(e){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[21,108];r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this)),o=d.findIndex(function(t){return t>=e[0]}),u=d.findIndex(function(t){return t>=e[1]});u=-1===u?u=d.length:u;var a=d.slice(o,u);n._samples={};var s=!0,l=!1,f=void 0;try{for(var p,h=a[Symbol.iterator]();!(s=(p=h.next()).done);s=!0){var _=p.value;n._samples[_]=c.default.getHarmonicsUrl(_)}}catch(e){l=!0,f=e}finally{try{!s&&h.return&&h.return()}finally{if(l)throw f}}return n}return u(t,e),a(t,[{key:"start",value:function(e,t,n){this._sampler.triggerAttack((0,p.midiToNote)(e),t,n*(0,p.randomBetween)(.5,1))}},{key:"load",value:function(e){var t=this;return new Promise(function(n,o){t._sampler=new h.Sampler(t._samples,n,e).connect(t.output),t._sampler.release=1})}}]),t}(f.default);t.default=_},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0}),t.Notes=void 0;var a=function(){function e(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var u,a=e[Symbol.iterator]();!(o=(u=a.next()).done)&&(n.push(u.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e}finally{try{!o&&a.return&&a.return()}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),l=(o(c),n(1)),f=o(l),p=n(3),h=o(p),d=n(2),_={1:[8],2:[6,12],3:[1,8,15],4:[1,5,10,15],5:[1,4,8,12,16],6:[1,3,7,10,13,16],7:[1,3,6,9,11,13,16],8:[1,3,5,7,9,11,13,15],9:[1,3,5,7,9,11,13,15,16],10:[1,2,3,5,7,9,11,13,15,16],11:[1,2,3,5,7,9,11,13,14,15,16],12:[1,2,3,4,5,7,9,11,13,14,15,16],13:[1,2,3,4,5,7,9,11,12,13,14,15,16],14:[1,2,3,4,5,6,7,9,11,12,13,14,15,16],15:[1,2,3,4,5,6,7,9,10,11,12,13,14,15,16],16:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]},y=[21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99,102,105,108];t.Notes=function(e){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[21,108],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;r(this,t);var o=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this)),u=y.findIndex(function(t){return t>=e[0]}),a=y.findIndex(function(t){return t>=e[1]});a=-1===a?a=y.length:a+1;var s=y.slice(u,a);return o._samplers=_[n].slice(),o._activeNotes=new Map,o._samplers.forEach(function(e,t){o._samplers[t]={},s.forEach(function(n){o._samplers[t][n]=f.default.getNotesUrl(n,e)})}),o}return u(t,e),s(t,[{key:"_hasNote",value:function(e,t){return this._samplers.hasOwnProperty(t)&&this._samplers[t].has(e)}},{key:"_getNote",value:function(e,t){return this._samplers[t].get(e)}},{key:"stop",value:function(e,t,n){this._activeNotes.has(e)&&(this._activeNotes.get(e).forEach(function(e){e.stop(t+.25,.25)}),this._activeNotes.delete(e))}},{key:"start",value:function(e,t,n){var o=n*(this._samplers.length-1),r=Math.round(o),i=r-o,u=1-.5*i,s=(0,d.midiToFrequencyRatio)(e),c=a(s,2),l=c[0],f=c[1];if(this._hasNote(l,r)){var p=(0,d.createSource)(this._getNote(l,r));p.playbackRate.value=f,p.connect(this.output),p.start(t,0,void 0,u,0),this._activeNotes.has(e)||this._activeNotes.set(e,[]),this._activeNotes.get(e).push(p)}}},{key:"load",value:function(e){var t=this,n=[];return this._samplers.forEach(function(o,r){var i=new Promise(function(n){t._samplers[r]=new c.Buffers(o,n,e)});n.push(i)}),Promise.all(n)}}]),t}(h.default)},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(3),c=o(s),l=n(1),f=(o(l),n(2)),p=n(0),h=(o(p),function(e){function t(){r(this,t);var e=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return e._downTime=1/0,e._currentSound=null,e._buffers=null,e}return u(t,e),a(t,[{key:"load",value:function(e){var t=this;return new Promise(function(n){t._buffers=new p.Buffers({up:"pedalU1.mp3",down:"pedalD1.mp3"},n,e)})}},{key:"_squash",value:function(e){this._currentSound&&this._currentSound.stop(e,.1),this._currentSound=null}},{key:"_playSample",value:function(e,t){this._currentSound=(0,f.createSource)(this._buffers.get(t)),this._currentSound.connect(this.output).start(e,(0,f.randomBetween)(0,.1),void 0,.2*(0,f.randomBetween)(.5,1),.05)}},{key:"down",value:function(e){this._squash(e),this._downTime=e,this._playSample(e,"down")}},{key:"up",value:function(e){this._squash(e),this._downTime=1/0,this._playSample(e,"up")}},{key:"isDown",value:function(e){return e>this._downTime}}]),t}(c.default));t.default=h},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(1),c=o(s),l=n(3),f=o(l),p=n(2),h=n(0),d=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));n._buffers={};for(var o=e[0];o<=e[1];o++)n._buffers[o]=c.default.getReleasesUrl(o);return n}return u(t,e),a(t,[{key:"load",value:function(e){var t=this;return new Promise(function(n){t._buffers=new h.Buffers(t._buffers,n,e)})}},{key:"start",value:function(e,t,n){if(this._buffers.has(e)){var o=(0,p.createSource)(this._buffers.get(e)).connect(this.output);n*=(0,p.randomBetween)(.5,1),o.start(t,0,void 0,.01*n,0)}}}]),t}(f.default);t.default=d},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0}),t.Piano=void 0;var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),c=o(s),l=n(6),f=o(l),p=n(5),h=n(4),d=o(h),_=n(7),y=o(_),v=n(1);o(v),t.Piano=function(e){function t(){r(this,t);var e=c.default.defaults(arguments,["range","velocities"],{velocities:1,range:[21,108],release:!0}),n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return n.createInsOuts(0,1),n._loaded=!1,n._heldNotes=new Map,n._sustainedNotes=new Map,n._notes=new p.Notes(e.range,e.velocities).connect(n.output),n._pedal=(new f.default).connect(n.output),e.release&&(n._harmonics=new d.default(e.range).connect(n.output),n._release=new y.default(e.range).connect(n.output)),n}return u(t,e),a(t,[{key:"load",value:function(e){var t=this,n=[this._notes.load(e),this._pedal.load(e)];return this._harmonics&&n.push(this._harmonics.load(e)),this._release&&n.push(this._release.load(e)),Promise.all(n).then(function(){t._loaded=!0})}},{key:"pedalDown",value:function(e){return this.loaded&&(e=this.toSeconds(e),this._pedal.isDown(e)||this._pedal.down(e)),this}},{key:"pedalUp",value:function(e){var t=this;return this.loaded&&(e=this.toSeconds(e),this._pedal.isDown(e)&&(this._pedal.up(e),this._sustainedNotes.forEach(function(n,o){t._heldNotes.has(o)||t._notes.stop(o,e)}),this._sustainedNotes.clear())),this}},{key:"keyDown",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.default.now(),n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.8;return this.loaded&&(t=this.toSeconds(t),c.default.isString(e)&&(e=Math.round((0,s.Frequency)(e).toMidi())),this._heldNotes.has(e)||(this._heldNotes.set(e,{time:t,velocity:n}),this._notes.start(e,t,n))),this}},{key:"keyUp",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.default.now(),n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.8;if(this.loaded&&(t=this.toSeconds(t),c.default.isString(e)&&(e=Math.round((0,s.Frequency)(e).toMidi())),this._heldNotes.has(e))){var o=this._heldNotes.get(e);this._heldNotes.delete(e),this._release&&this._release.start(e,t,n);var r=t-o.time,i=o.velocity,u=.5/Math.max(r,.1)+i+n;u=Math.pow(Math.log(Math.max(u,1)),2)/2,this._pedal.isDown(t)?this._sustainedNotes.has(e)||this._sustainedNotes.set(e,t):(this._notes.stop(e,t,n),this._harmonics&&this._harmonics.start(e,t,u))}return this}},{key:"setVolume",value:function(e,t){switch(e){case"note":this._notes.volume=t;break;case"pedal":this._pedal.volume=t;break;case"release":this._release&&(this._release.volume=t);break;case"harmonics":this._harmonics&&(this._harmonics.volume=t)}return this}},{key:"loaded",get:function(){return this._loaded}}]),t}(s.AudioNode)}])});

},{"tone":6}],6:[function(require,module,exports){
(function(root, factory){

	//UMD
	if ( typeof define === "function" && define.amd ) {
		define(function() {
			return factory();
		});
	} else if (typeof module === "object") {
		module.exports = factory();
 	} else {
		root.Tone = factory();
	}

}(this, function(){

	"use strict";
	
	var Tone;
	//constructs the main Tone object
	function Main(func){
		Tone = func();
	}
	//invokes each of the modules with the main Tone object as the argument
	function Module(func){
		func(Tone);
	}	/**
	 *  Tone.js
	 *  @author Yotam Mann
	 *  @license http://opensource.org/licenses/MIT MIT License
	 *  @copyright 2014-2017 Yotam Mann
	 */
	Main(function () {
	    
	    ///////////////////////////////////////////////////////////////////////////
	    //	TONE
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  @class  Tone is the base class of all other classes.
		 *  @constructor
		 */
	    var Tone = function () {
	    };
	    /**
		 *  @memberOf Tone#
		 *  @returns {string} returns the name of the class as a string
		 */
	    Tone.prototype.toString = function () {
	        for (var className in Tone) {
	            var isLetter = className[0].match(/^[A-Z]$/);
	            var sameConstructor = Tone[className] === this.constructor;
	            if (Tone.isFunction(Tone[className]) && isLetter && sameConstructor) {
	                return className;
	            }
	        }
	        return 'Tone';
	    };
	    /**
		 *  @memberOf Tone#
		 *  disconnect and dispose
		 *  @returns {Tone} this
		 */
	    Tone.prototype.dispose = function () {
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	GET/SET
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Set the parameters at once. Either pass in an
		 *  object mapping parameters to values, or to set a
		 *  single parameter, by passing in a string and value.
		 *  The last argument is an optional ramp time which
		 *  will ramp any signal values to their destination value
		 *  over the duration of the rampTime.
		 *  @param {Object|string} params
		 *  @param {number=} value
		 *  @param {Time=} rampTime
		 *  @returns {Tone} this
		 *  @memberOf Tone#
		 *  @example
		 * //set values using an object
		 * filter.set({
		 * 	"frequency" : 300,
		 * 	"type" : highpass
		 * });
		 *  @example
		 * filter.set("type", "highpass");
		 *  @example
		 * //ramp to the value 220 over 3 seconds.
		 * oscillator.set({
		 * 	"frequency" : 220
		 * }, 3);
		 */
	    Tone.prototype.set = function (params, value, rampTime) {
	        if (Tone.isObject(params)) {
	            rampTime = value;
	        } else if (Tone.isString(params)) {
	            var tmpObj = {};
	            tmpObj[params] = value;
	            params = tmpObj;
	        }
	        paramLoop:
	            for (var attr in params) {
	                value = params[attr];
	                var parent = this;
	                if (attr.indexOf('.') !== -1) {
	                    var attrSplit = attr.split('.');
	                    for (var i = 0; i < attrSplit.length - 1; i++) {
	                        parent = parent[attrSplit[i]];
	                        if (parent instanceof Tone) {
	                            attrSplit.splice(0, i + 1);
	                            var innerParam = attrSplit.join('.');
	                            parent.set(innerParam, value);
	                            continue paramLoop;
	                        }
	                    }
	                    attr = attrSplit[attrSplit.length - 1];
	                }
	                var param = parent[attr];
	                if (Tone.isUndef(param)) {
	                    continue;
	                }
	                if (Tone.Signal && param instanceof Tone.Signal || Tone.Param && param instanceof Tone.Param) {
	                    if (param.value !== value) {
	                        if (Tone.isUndef(rampTime)) {
	                            param.value = value;
	                        } else {
	                            param.rampTo(value, rampTime);
	                        }
	                    }
	                } else if (param instanceof AudioParam) {
	                    if (param.value !== value) {
	                        param.value = value;
	                    }
	                } else if (param instanceof Tone) {
	                    param.set(value);
	                } else if (param !== value) {
	                    parent[attr] = value;
	                }
	            }
	        return this;
	    };
	    /**
		 *  Get the object's attributes. Given no arguments get
		 *  will return all available object properties and their corresponding
		 *  values. Pass in a single attribute to retrieve or an array
		 *  of attributes. The attribute strings can also include a "."
		 *  to access deeper properties.
		 *  @memberOf Tone#
		 *  @example
		 * osc.get();
		 * //returns {"type" : "sine", "frequency" : 440, ...etc}
		 *  @example
		 * osc.get("type");
		 * //returns { "type" : "sine"}
		 * @example
		 * //use dot notation to access deep properties
		 * synth.get(["envelope.attack", "envelope.release"]);
		 * //returns {"envelope" : {"attack" : 0.2, "release" : 0.4}}
		 *  @param {Array=|string|undefined} params the parameters to get, otherwise will return
		 *  					                  all available.
		 *  @returns {Object}
		 */
	    Tone.prototype.get = function (params) {
	        if (Tone.isUndef(params)) {
	            params = this._collectDefaults(this.constructor);
	        } else if (Tone.isString(params)) {
	            params = [params];
	        }
	        var ret = {};
	        for (var i = 0; i < params.length; i++) {
	            var attr = params[i];
	            var parent = this;
	            var subRet = ret;
	            if (attr.indexOf('.') !== -1) {
	                var attrSplit = attr.split('.');
	                for (var j = 0; j < attrSplit.length - 1; j++) {
	                    var subAttr = attrSplit[j];
	                    subRet[subAttr] = subRet[subAttr] || {};
	                    subRet = subRet[subAttr];
	                    parent = parent[subAttr];
	                }
	                attr = attrSplit[attrSplit.length - 1];
	            }
	            var param = parent[attr];
	            if (Tone.isObject(params[attr])) {
	                subRet[attr] = param.get();
	            } else if (Tone.Signal && param instanceof Tone.Signal) {
	                subRet[attr] = param.value;
	            } else if (Tone.Param && param instanceof Tone.Param) {
	                subRet[attr] = param.value;
	            } else if (param instanceof AudioParam) {
	                subRet[attr] = param.value;
	            } else if (param instanceof Tone) {
	                subRet[attr] = param.get();
	            } else if (!Tone.isFunction(param) && !Tone.isUndef(param)) {
	                subRet[attr] = param;
	            }
	        }
	        return ret;
	    };
	    /**
		 *  collect all of the default attributes in one
		 *  @private
		 *  @param {function} constr the constructor to find the defaults from
		 *  @return {Array} all of the attributes which belong to the class
		 */
	    Tone.prototype._collectDefaults = function (constr) {
	        var ret = [];
	        if (!Tone.isUndef(constr.defaults)) {
	            ret = Object.keys(constr.defaults);
	        }
	        if (!Tone.isUndef(constr._super)) {
	            var superDefs = this._collectDefaults(constr._super);
	            //filter out repeats
	            for (var i = 0; i < superDefs.length; i++) {
	                if (ret.indexOf(superDefs[i]) === -1) {
	                    ret.push(superDefs[i]);
	                }
	            }
	        }
	        return ret;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	DEFAULTS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  @memberOf Tone
		 *  @param  {Array}  values  The arguments array
		 *  @param  {Array}  keys    The names of the arguments
		 *  @param {Function|Object} constr The class constructor
		 *  @return  {Object}  An object composed of the  defaults between the class' defaults
		 *                        and the passed in arguments.
		 */
	    Tone.defaults = function (values, keys, constr) {
	        var options = {};
	        if (values.length === 1 && Tone.isObject(values[0])) {
	            options = values[0];
	        } else {
	            for (var i = 0; i < keys.length; i++) {
	                options[keys[i]] = values[i];
	            }
	        }
	        if (!Tone.isUndef(constr.defaults)) {
	            return Tone.defaultArg(options, constr.defaults);
	        } else if (Tone.isObject(constr)) {
	            return Tone.defaultArg(options, constr);
	        } else {
	            return options;
	        }
	    };
	    /**
		 *  If the `given` parameter is undefined, use the `fallback`.
		 *  If both `given` and `fallback` are object literals, it will
		 *  return a deep copy which includes all of the parameters from both
		 *  objects. If a parameter is undefined in given, it will return
		 *  the fallback property.
		 *  <br><br>
		 *  WARNING: if object is self referential, it will go into an an
		 *  infinite recursive loop.
		 *  @memberOf Tone
		 *  @param  {*} given
		 *  @param  {*} fallback
		 *  @return {*}
		 */
	    Tone.defaultArg = function (given, fallback) {
	        if (Tone.isObject(given) && Tone.isObject(fallback)) {
	            var ret = {};
	            //make a deep copy of the given object
	            for (var givenProp in given) {
	                ret[givenProp] = Tone.defaultArg(fallback[givenProp], given[givenProp]);
	            }
	            for (var fallbackProp in fallback) {
	                ret[fallbackProp] = Tone.defaultArg(given[fallbackProp], fallback[fallbackProp]);
	            }
	            return ret;
	        } else {
	            return Tone.isUndef(given) ? fallback : given;
	        }
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	CONNECTIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  connect together all of the arguments in series
		 *  @param {...AudioParam|Tone|AudioNode} nodes
		 *  @returns {Tone}
		 *  @memberOf Tone
		 *  @static
		 */
	    Tone.connectSeries = function () {
	        var currentUnit = arguments[0];
	        for (var i = 1; i < arguments.length; i++) {
	            var toUnit = arguments[i];
	            currentUnit.connect(toUnit);
	            currentUnit = toUnit;
	        }
	        return Tone;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    // TYPE CHECKING
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  test if the arg is undefined
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is undefined
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isUndef = function (val) {
	        return typeof val === 'undefined';
	    };
	    /**
		 *  test if the arg is a function
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a function
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isFunction = function (val) {
	        return typeof val === 'function';
	    };
	    /**
		 *  Test if the argument is a number.
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a number
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isNumber = function (arg) {
	        return typeof arg === 'number';
	    };
	    /**
		 *  Test if the given argument is an object literal (i.e. `{}`);
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is an object literal.
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isObject = function (arg) {
	        return Object.prototype.toString.call(arg) === '[object Object]' && arg.constructor === Object;
	    };
	    /**
		 *  Test if the argument is a boolean.
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a boolean
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isBoolean = function (arg) {
	        return typeof arg === 'boolean';
	    };
	    /**
		 *  Test if the argument is an Array
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is an array
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isArray = function (arg) {
	        return Array.isArray(arg);
	    };
	    /**
		 *  Test if the argument is a string.
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a string
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isString = function (arg) {
	        return typeof arg === 'string';
	    };
	    /**
		 *  Test if the argument is in the form of a note in scientific pitch notation.
		 *  e.g. "C4"
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a string
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isNote = function (arg) {
	        return Tone.isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);
	    };
	    /**
		 *  An empty function.
		 *  @static
		 */
	    Tone.noOp = function () {
	    };
	    /**
		 *  Make the property not writable. Internal use only.
		 *  @private
		 *  @param  {string}  property  the property to make not writable
		 */
	    Tone.prototype._readOnly = function (property) {
	        if (Array.isArray(property)) {
	            for (var i = 0; i < property.length; i++) {
	                this._readOnly(property[i]);
	            }
	        } else {
	            Object.defineProperty(this, property, {
	                writable: false,
	                enumerable: true
	            });
	        }
	    };
	    /**
		 *  Make an attribute writeable. Interal use only.
		 *  @private
		 *  @param  {string}  property  the property to make writable
		 */
	    Tone.prototype._writable = function (property) {
	        if (Array.isArray(property)) {
	            for (var i = 0; i < property.length; i++) {
	                this._writable(property[i]);
	            }
	        } else {
	            Object.defineProperty(this, property, { writable: true });
	        }
	    };
	    /**
		 * Possible play states.
		 * @enum {string}
		 */
	    Tone.State = {
	        Started: 'started',
	        Stopped: 'stopped',
	        Paused: 'paused'
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    // CONVERSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Equal power gain scale. Good for cross-fading.
		 *  @param  {NormalRange} percent (0-1)
		 *  @return {Number}         output gain (0-1)
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.equalPowerScale = function (percent) {
	        var piFactor = 0.5 * Math.PI;
	        return Math.sin(percent * piFactor);
	    };
	    /**
		 *  Convert decibels into gain.
		 *  @param  {Decibels} db
		 *  @return {Number}
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.dbToGain = function (db) {
	        return Math.pow(2, db / 6);
	    };
	    /**
		 *  Convert gain to decibels.
		 *  @param  {Number} gain (0-1)
		 *  @return {Decibels}
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.gainToDb = function (gain) {
	        return 20 * (Math.log(gain) / Math.LN10);
	    };
	    /**
		 *  Convert an interval (in semitones) to a frequency ratio.
		 *  @param  {Interval} interval the number of semitones above the base note
		 *  @return {number}          the frequency ratio
		 *  @static
		 *  @memberOf Tone
		 *  @example
		 * tone.intervalToFrequencyRatio(0); // 1
		 * tone.intervalToFrequencyRatio(12); // 2
		 * tone.intervalToFrequencyRatio(-12); // 0.5
		 */
	    Tone.intervalToFrequencyRatio = function (interval) {
	        return Math.pow(2, interval / 12);
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	TIMING
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Return the current time of the AudioContext clock.
		 *  @return {Number} the currentTime from the AudioContext
		 *  @memberOf Tone#
		 */
	    Tone.prototype.now = function () {
	        return Tone.context.now();
	    };
	    /**
		 *  Return the current time of the AudioContext clock.
		 *  @return {Number} the currentTime from the AudioContext
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.now = function () {
	        return Tone.context.now();
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	INHERITANCE
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  have a child inherit all of Tone's (or a parent's) prototype
		 *  to inherit the parent's properties, make sure to call
		 *  Parent.call(this) in the child's constructor
		 *
		 *  based on closure library's inherit function
		 *
		 *  @memberOf Tone
		 *  @static
		 *  @param  {function} 	child
		 *  @param  {function=} parent (optional) parent to inherit from
		 *                             if no parent is supplied, the child
		 *                             will inherit from Tone
		 */
	    Tone.extend = function (child, parent) {
	        if (Tone.isUndef(parent)) {
	            parent = Tone;
	        }
	        function TempConstructor() {
	        }
	        TempConstructor.prototype = parent.prototype;
	        child.prototype = new TempConstructor();
	        /** @override */
	        child.prototype.constructor = child;
	        child._super = parent;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	CONTEXT
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  The private audio context shared by all Tone Nodes.
		 *  @private
		 *  @type {Tone.Context}
		 */
	    var audioContext = null;
	    /**
		 *  A static pointer to the audio context accessible as Tone.context.
		 *  @type {Tone.Context}
		 *  @name context
		 *  @memberOf Tone
		 */
	    Object.defineProperty(Tone, 'context', {
	        get: function () {
	            return audioContext;
	        },
	        set: function (context) {
	            if (Tone.Context && context instanceof Tone.Context) {
	                audioContext = context;
	            } else {
	                audioContext = new Tone.Context(context);
	            }
	            //initialize the new audio context
	            Tone.Context.emit('init', audioContext);
	        }
	    });
	    /**
		 *  The AudioContext
		 *  @type {Tone.Context}
		 *  @name context
		 *  @memberOf Tone#
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.prototype, 'context', {
	        get: function () {
	            return Tone.context;
	        }
	    });
	    /**
		 *  Tone automatically creates a context on init, but if you are working
		 *  with other libraries which also create an AudioContext, it can be
		 *  useful to set your own. If you are going to set your own context,
		 *  be sure to do it at the start of your code, before creating any objects.
		 *  @static
		 *  @param {AudioContext} ctx The new audio context to set
		 */
	    Tone.setContext = function (ctx) {
	        Tone.context = ctx;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	ATTRIBUTES
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  The number of seconds of 1 processing block (128 samples)
		 *  @type {Number}
		 *  @name blockTime
		 *  @memberOf Tone
		 *  @static
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.prototype, 'blockTime', {
	        get: function () {
	            return 128 / this.context.sampleRate;
	        }
	    });
	    /**
		 *  The duration in seconds of one sample.
		 *  @type {Number}
		 *  @name sampleTime
		 *  @memberOf Tone
		 *  @static
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.prototype, 'sampleTime', {
	        get: function () {
	            return 1 / this.context.sampleRate;
	        }
	    });
	    /**
		 *  Whether or not all the technologies that Tone.js relies on are supported by the current browser.
		 *  @type {Boolean}
		 *  @name supported
		 *  @memberOf Tone
		 *  @readOnly
		 *  @static
		 */
	    Object.defineProperty(Tone, 'supported', {
	        get: function () {
	            var hasAudioContext = window.hasOwnProperty('AudioContext') || window.hasOwnProperty('webkitAudioContext');
	            var hasPromises = window.hasOwnProperty('Promise');
	            var hasWorkers = window.hasOwnProperty('Worker');
	            return hasAudioContext && hasPromises && hasWorkers;
	        }
	    });
	    /**
		 *  Boolean value if the audio context has been initialized.
		 *  @type {Boolean}
		 *  @memberOf Tone
		 *  @static
		 *  @name initialized
		 */
	    Object.defineProperty(Tone, 'initialized', {
	        get: function () {
	            return audioContext !== null;
	        }
	    });
	    /**
		 *  Get the context when it becomes available
		 *  @param  {Function}  resolve  Callback when the context is initialized
		 *  @return  {Tone}
		 */
	    Tone.getContext = function (resolve) {
	        if (Tone.initialized) {
	            resolve(Tone.context);
	        } else {
	            var resCallback = function () {
	                resolve(Tone.context);
	                Tone.Context.off('init', resCallback);
	            };
	            Tone.Context.on('init', resCallback);
	        }
	        return Tone;
	    };
	    /**
		 * The version number
		 * @type {String}
		 * @static
		 */
	    Tone.version = 'r11';
	    // allow optional silencing of this log
	    if (!window.TONE_SILENCE_VERSION_LOGGING) {
	        console.log('%c * Tone.js ' + Tone.version + ' * ', 'background: #000; color: #fff');
	    }
	    return Tone;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Emitter gives classes which extend it
		 *         the ability to listen for and emit events. 
		 *         Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).
		 *         MIT (c) 2011 Jerome Etienne.
		 *         
		 *  @extends {Tone}
		 */
	    Tone.Emitter = function () {
	        Tone.call(this);
	        /**
			 *  Contains all of the events.
			 *  @private
			 *  @type  {Object}
			 */
	        this._events = {};
	    };
	    Tone.extend(Tone.Emitter);
	    /**
		 *  Bind a callback to a specific event.
		 *  @param  {String}    event     The name of the event to listen for.
		 *  @param  {Function}  callback  The callback to invoke when the
		 *                                event is emitted
		 *  @return  {Tone.Emitter}    this
		 */
	    Tone.Emitter.prototype.on = function (event, callback) {
	        //split the event
	        var events = event.split(/\W+/);
	        for (var i = 0; i < events.length; i++) {
	            var eventName = events[i];
	            if (!this._events.hasOwnProperty(eventName)) {
	                this._events[eventName] = [];
	            }
	            this._events[eventName].push(callback);
	        }
	        return this;
	    };
	    /**
		 *  Remove the event listener.
		 *  @param  {String}    event     The event to stop listening to.
		 *  @param  {Function=}  callback  The callback which was bound to 
		 *                                the event with Tone.Emitter.on.
		 *                                If no callback is given, all callbacks
		 *                                events are removed.
		 *  @return  {Tone.Emitter}    this
		 */
	    Tone.Emitter.prototype.off = function (event, callback) {
	        var events = event.split(/\W+/);
	        for (var ev = 0; ev < events.length; ev++) {
	            event = events[ev];
	            if (this._events.hasOwnProperty(event)) {
	                if (Tone.isUndef(callback)) {
	                    this._events[event] = [];
	                } else {
	                    var eventList = this._events[event];
	                    for (var i = 0; i < eventList.length; i++) {
	                        if (eventList[i] === callback) {
	                            eventList.splice(i, 1);
	                        }
	                    }
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Invoke all of the callbacks bound to the event
		 *  with any arguments passed in. 
		 *  @param  {String}  event  The name of the event.
		 *  @param {*} args... The arguments to pass to the functions listening.
		 *  @return  {Tone.Emitter}  this
		 */
	    Tone.Emitter.prototype.emit = function (event) {
	        if (this._events) {
	            var args = Array.apply(null, arguments).slice(1);
	            if (this._events.hasOwnProperty(event)) {
	                var eventList = this._events[event];
	                for (var i = 0, len = eventList.length; i < len; i++) {
	                    eventList[i].apply(this, args);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Add Emitter functions (on/off/emit) to the object
		 *  @param  {Object|Function}  object  The object or class to extend.
		 *  @returns {Tone.Emitter}
		 */
	    Tone.Emitter.mixin = function (object) {
	        var functions = [
	            'on',
	            'off',
	            'emit'
	        ];
	        object._events = {};
	        for (var i = 0; i < functions.length; i++) {
	            var func = functions[i];
	            var emitterFunc = Tone.Emitter.prototype[func];
	            object[func] = emitterFunc;
	        }
	        return Tone.Emitter;
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.Emitter}  this
		 */
	    Tone.Emitter.prototype.dispose = function () {
	        Tone.prototype.dispose.call(this);
	        this._events = null;
	        return this;
	    };
	    return Tone.Emitter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A Timeline class for scheduling and maintaining state
		 *         along a timeline. All events must have a "time" property. 
		 *         Internally, events are stored in time order for fast 
		 *         retrieval.
		 *  @extends {Tone}
		 *  @param {Positive} [memory=Infinity] The number of previous events that are retained.
		 */
	    Tone.Timeline = function () {
	        var options = Tone.defaults(arguments, ['memory'], Tone.Timeline);
	        Tone.call(this);
	        /**
			 *  The array of scheduled timeline events
			 *  @type  {Array}
			 *  @private
			 */
	        this._timeline = [];
	        /**
			 *  An array of items to remove from the list. 
			 *  @type {Array}
			 *  @private
			 */
	        this._toRemove = [];
	        /**
			 *  Flag if the timeline is mid iteration
			 *  @private
			 *  @type {Boolean}
			 */
	        this._iterating = false;
	        /**
			 *  The memory of the timeline, i.e.
			 *  how many events in the past it will retain
			 *  @type {Positive}
			 */
	        this.memory = options.memory;
	    };
	    Tone.extend(Tone.Timeline);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 */
	    Tone.Timeline.defaults = { 'memory': Infinity };
	    /**
		 *  The number of items in the timeline.
		 *  @type {Number}
		 *  @memberOf Tone.Timeline#
		 *  @name length
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Timeline.prototype, 'length', {
	        get: function () {
	            return this._timeline.length;
	        }
	    });
	    /**
		 *  Insert an event object onto the timeline. Events must have a "time" attribute.
		 *  @param  {Object}  event  The event object to insert into the 
		 *                           timeline. 
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.add = function (event) {
	        //the event needs to have a time attribute
	        if (Tone.isUndef(event.time)) {
	            throw new Error('Tone.Timeline: events must have a time attribute');
	        }
	        if (this._timeline.length) {
	            var index = this._search(event.time);
	            this._timeline.splice(index + 1, 0, event);
	        } else {
	            this._timeline.push(event);
	        }
	        //if the length is more than the memory, remove the previous ones
	        if (this.length > this.memory) {
	            var diff = this.length - this.memory;
	            this._timeline.splice(0, diff);
	        }
	        return this;
	    };
	    /**
		 *  Remove an event from the timeline.
		 *  @param  {Object}  event  The event object to remove from the list.
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.remove = function (event) {
	        if (this._iterating) {
	            this._toRemove.push(event);
	        } else {
	            var index = this._timeline.indexOf(event);
	            if (index !== -1) {
	                this._timeline.splice(index, 1);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Get the nearest event whose time is less than or equal to the given time.
		 *  @param  {Number}  time  The time to query.
		 *  @param  {String}  comparitor Which value in the object to compare
		 *  @returns {Object} The event object set after that time.
		 */
	    Tone.Timeline.prototype.get = function (time, comparitor) {
	        comparitor = Tone.defaultArg(comparitor, 'time');
	        var index = this._search(time, comparitor);
	        if (index !== -1) {
	            return this._timeline[index];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Return the first event in the timeline without removing it
		 *  @returns {Object} The first event object
		 */
	    Tone.Timeline.prototype.peek = function () {
	        return this._timeline[0];
	    };
	    /**
		 *  Return the first event in the timeline and remove it
		 *  @returns {Object} The first event object
		 */
	    Tone.Timeline.prototype.shift = function () {
	        return this._timeline.shift();
	    };
	    /**
		 *  Get the event which is scheduled after the given time.
		 *  @param  {Number}  time  The time to query.
		 *  @param  {String}  comparitor Which value in the object to compare
		 *  @returns {Object} The event object after the given time
		 */
	    Tone.Timeline.prototype.getAfter = function (time, comparitor) {
	        comparitor = Tone.defaultArg(comparitor, 'time');
	        var index = this._search(time, comparitor);
	        if (index + 1 < this._timeline.length) {
	            return this._timeline[index + 1];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Get the event before the event at the given time.
		 *  @param  {Number}  time  The time to query.
		 *  @param  {String}  comparitor Which value in the object to compare
		 *  @returns {Object} The event object before the given time
		 */
	    Tone.Timeline.prototype.getBefore = function (time, comparitor) {
	        comparitor = Tone.defaultArg(comparitor, 'time');
	        var len = this._timeline.length;
	        //if it's after the last item, return the last item
	        if (len > 0 && this._timeline[len - 1][comparitor] < time) {
	            return this._timeline[len - 1];
	        }
	        var index = this._search(time, comparitor);
	        if (index - 1 >= 0) {
	            return this._timeline[index - 1];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Cancel events after the given time
		 *  @param  {Number}  time  The time to query.
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.cancel = function (after) {
	        if (this._timeline.length > 1) {
	            var index = this._search(after);
	            if (index >= 0) {
	                if (this._timeline[index].time === after) {
	                    //get the first item with that time
	                    for (var i = index; i >= 0; i--) {
	                        if (this._timeline[i].time === after) {
	                            index = i;
	                        } else {
	                            break;
	                        }
	                    }
	                    this._timeline = this._timeline.slice(0, index);
	                } else {
	                    this._timeline = this._timeline.slice(0, index + 1);
	                }
	            } else {
	                this._timeline = [];
	            }
	        } else if (this._timeline.length === 1) {
	            //the first item's time
	            if (this._timeline[0].time >= after) {
	                this._timeline = [];
	            }
	        }
	        return this;
	    };
	    /**
		 *  Cancel events before or equal to the given time.
		 *  @param  {Number}  time  The time to cancel before.
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.cancelBefore = function (time) {
	        if (this._timeline.length) {
	            var index = this._search(time);
	            if (index >= 0) {
	                this._timeline = this._timeline.slice(index + 1);
	            }
	        }
	        return this;
	    };
	    /**
		 * Returns the previous event if there is one. null otherwise
		 * @param  {Object} event The event to find the previous one of
		 * @return {Object}       The event right before the given event
		 */
	    Tone.Timeline.prototype.previousEvent = function (event) {
	        var index = this._timeline.indexOf(event);
	        if (index > 0) {
	            return this._timeline[index - 1];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Does a binary serach on the timeline array and returns the 
		 *  nearest event index whose time is after or equal to the given time.
		 *  If a time is searched before the first index in the timeline, -1 is returned.
		 *  If the time is after the end, the index of the last item is returned.
		 *  @param  {Number}  time  
		 *  @param  {String}  comparitor Which value in the object to compare
		 *  @return  {Number} the index in the timeline array 
		 *  @private
		 */
	    Tone.Timeline.prototype._search = function (time, comparitor) {
	        comparitor = Tone.defaultArg(comparitor, 'time');
	        var beginning = 0;
	        var len = this._timeline.length;
	        var end = len;
	        if (len > 0 && this._timeline[len - 1][comparitor] <= time) {
	            return len - 1;
	        }
	        while (beginning < end) {
	            // calculate the midpoint for roughly equal partition
	            var midPoint = Math.floor(beginning + (end - beginning) / 2);
	            var event = this._timeline[midPoint];
	            var nextEvent = this._timeline[midPoint + 1];
	            if (event[comparitor] === time) {
	                //choose the last one that has the same time
	                for (var i = midPoint; i < this._timeline.length; i++) {
	                    var testEvent = this._timeline[i];
	                    if (testEvent[comparitor] === time) {
	                        midPoint = i;
	                    }
	                }
	                return midPoint;
	            } else if (event[comparitor] < time && nextEvent[comparitor] > time) {
	                return midPoint;
	            } else if (event[comparitor] > time) {
	                //search lower
	                end = midPoint;
	            } else {
	                //search upper
	                beginning = midPoint + 1;
	            }
	        }
	        return -1;
	    };
	    /**
		 *  Internal iterator. Applies extra safety checks for 
		 *  removing items from the array. 
		 *  @param  {Function}  callback 
		 *  @param  {Number=}    lowerBound     
		 *  @param  {Number=}    upperBound    
		 *  @private
		 */
	    Tone.Timeline.prototype._iterate = function (callback, lowerBound, upperBound) {
	        this._iterating = true;
	        lowerBound = Tone.defaultArg(lowerBound, 0);
	        upperBound = Tone.defaultArg(upperBound, this._timeline.length - 1);
	        for (var i = lowerBound; i <= upperBound; i++) {
	            callback.call(this, this._timeline[i]);
	        }
	        this._iterating = false;
	        if (this._toRemove.length > 0) {
	            for (var j = 0; j < this._toRemove.length; j++) {
	                var index = this._timeline.indexOf(this._toRemove[j]);
	                if (index !== -1) {
	                    this._timeline.splice(index, 1);
	                }
	            }
	            this._toRemove = [];
	        }
	    };
	    /**
		 *  Iterate over everything in the array
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEach = function (callback) {
	        this._iterate(callback);
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array at or before the given time.
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEachBefore = function (time, callback) {
	        //iterate over the items in reverse so that removing an item doesn't break things
	        var upperBound = this._search(time);
	        if (upperBound !== -1) {
	            this._iterate(callback, 0, upperBound);
	        }
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array after the given time.
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEachAfter = function (time, callback) {
	        //iterate over the items in reverse so that removing an item doesn't break things
	        var lowerBound = this._search(time);
	        this._iterate(callback, lowerBound + 1);
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array at or after the given time. Similar to 
		 *  forEachAfter, but includes the item(s) at the given time.
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEachFrom = function (time, callback) {
	        //iterate over the items in reverse so that removing an item doesn't break things
	        var lowerBound = this._search(time);
	        //work backwards until the event time is less than time
	        while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {
	            lowerBound--;
	        }
	        this._iterate(callback, lowerBound + 1);
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array at the given time
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEachAtTime = function (time, callback) {
	        //iterate over the items in reverse so that removing an item doesn't break things
	        var upperBound = this._search(time);
	        if (upperBound !== -1) {
	            this._iterate(function (event) {
	                if (event.time === time) {
	                    callback.call(this, event);
	                }
	            }, 0, upperBound);
	        }
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @return  {Tone.Timeline}  this
		 */
	    Tone.Timeline.prototype.dispose = function () {
	        Tone.prototype.dispose.call(this);
	        this._timeline = null;
	        this._toRemove = null;
	        return this;
	    };
	    return Tone.Timeline;
	});
	Module(function (Tone) {
	    /**
		 *  shim
		 *  @private
		 */
	    if (!window.hasOwnProperty('AudioContext') && window.hasOwnProperty('webkitAudioContext')) {
	        window.AudioContext = window.webkitAudioContext;
	    }
	    /**
		 *  @class Wrapper around the native AudioContext.
		 *  @extends {Tone.Emitter}
		 *  @param {AudioContext=} context optionally pass in a context
		 */
	    Tone.Context = function () {
	        Tone.Emitter.call(this);
	        var options = Tone.defaults(arguments, ['context'], Tone.Context);
	        if (!options.context) {
	            options.context = new window.AudioContext();
	        }
	        this._context = options.context;
	        // extend all of the methods
	        for (var prop in this._context) {
	            this._defineProperty(this._context, prop);
	        }
	        /**
			 *  The default latency hint
			 *  @type  {String}
			 *  @private
			 */
	        this._latencyHint = options.latencyHint;
	        /**
			 *  An object containing all of the constants AudioBufferSourceNodes
			 *  @type  {Object}
			 *  @private
			 */
	        this._constants = {};
	        ///////////////////////////////////////////////////////////////////////
	        // WORKER
	        ///////////////////////////////////////////////////////////////////////
	        /**
			 *  The amount of time events are scheduled
			 *  into the future
			 *  @type  {Number}
			 *  @private
			 */
	        this.lookAhead = options.lookAhead;
	        /**
			 *  A reference to the actual computed update interval
			 *  @type  {Number}
			 *  @private
			 */
	        this._computedUpdateInterval = 0;
	        /**
			 *  A reliable callback method
			 *  @private
			 *  @type  {Ticker}
			 */
	        this._ticker = new Ticker(this.emit.bind(this, 'tick'), options.clockSource, options.updateInterval);
	        ///////////////////////////////////////////////////////////////////////
	        // TIMEOUTS
	        ///////////////////////////////////////////////////////////////////////
	        /**
			 *  All of the setTimeout events.
			 *  @type  {Tone.Timeline}
			 *  @private
			 */
	        this._timeouts = new Tone.Timeline();
	        /**
			 *  The timeout id counter
			 *  @private
			 *  @type {Number}
			 */
	        this._timeoutIds = 0;
	        this.on('tick', this._timeoutLoop.bind(this));
	    };
	    Tone.extend(Tone.Context, Tone.Emitter);
	    Tone.Emitter.mixin(Tone.Context);
	    /**
		 * defaults
		 * @static
		 * @type {Object}
		 */
	    Tone.Context.defaults = {
	        'clockSource': 'worker',
	        'latencyHint': 'interactive',
	        'lookAhead': 0.1,
	        'updateInterval': 0.03
	    };
	    /**
		 *  Define a property on this Tone.Context. 
		 *  This is used to extend the native AudioContext
		 *  @param  {AudioContext}  context
		 *  @param  {String}  prop 
		 *  @private
		 */
	    Tone.Context.prototype._defineProperty = function (context, prop) {
	        if (Tone.isUndef(this[prop])) {
	            Object.defineProperty(this, prop, {
	                get: function () {
	                    if (typeof context[prop] === 'function') {
	                        return context[prop].bind(context);
	                    } else {
	                        return context[prop];
	                    }
	                },
	                set: function (val) {
	                    context[prop] = val;
	                }
	            });
	        }
	    };
	    /**
		 *  The current audio context time
		 *  @return  {Number}
		 */
	    Tone.Context.prototype.now = function () {
	        return this._context.currentTime + this.lookAhead;
	    };
	    /**
		 *  Generate a looped buffer at some constant value.
		 *  @param  {Number}  val
		 *  @return  {BufferSourceNode}
		 */
	    Tone.Context.prototype.getConstant = function (val) {
	        if (this._constants[val]) {
	            return this._constants[val];
	        } else {
	            var buffer = this._context.createBuffer(1, 128, this._context.sampleRate);
	            var arr = buffer.getChannelData(0);
	            for (var i = 0; i < arr.length; i++) {
	                arr[i] = val;
	            }
	            var constant = this._context.createBufferSource();
	            constant.channelCount = 1;
	            constant.channelCountMode = 'explicit';
	            constant.buffer = buffer;
	            constant.loop = true;
	            constant.start(0);
	            this._constants[val] = constant;
	            return constant;
	        }
	    };
	    /**
		 *  The private loop which keeps track of the context scheduled timeouts
		 *  Is invoked from the clock source
		 *  @private
		 */
	    Tone.Context.prototype._timeoutLoop = function () {
	        var now = this.now();
	        while (this._timeouts && this._timeouts.length && this._timeouts.peek().time <= now) {
	            this._timeouts.shift().callback();
	        }
	    };
	    /**
		 *  A setTimeout which is gaurenteed by the clock source. 
		 *  Also runs in the offline context.
		 *  @param  {Function}  fn       The callback to invoke
		 *  @param  {Seconds}    timeout  The timeout in seconds
		 *  @returns {Number} ID to use when invoking Tone.Context.clearTimeout
		 */
	    Tone.Context.prototype.setTimeout = function (fn, timeout) {
	        this._timeoutIds++;
	        var now = this.now();
	        this._timeouts.add({
	            callback: fn,
	            time: now + timeout,
	            id: this._timeoutIds
	        });
	        return this._timeoutIds;
	    };
	    /**
		 *  Clears a previously scheduled timeout with Tone.context.setTimeout
		 *  @param  {Number}  id  The ID returned from setTimeout
		 *  @return  {Tone.Context}  this
		 */
	    Tone.Context.prototype.clearTimeout = function (id) {
	        this._timeouts.forEach(function (event) {
	            if (event.id === id) {
	                this.remove(event);
	            }
	        });
	        return this;
	    };
	    /**
		 *  How often the Web Worker callback is invoked.
		 *  This number corresponds to how responsive the scheduling
		 *  can be. Context.updateInterval + Context.lookAhead gives you the
		 *  total latency between scheduling an event and hearing it.
		 *  @type {Number}
		 *  @memberOf Tone.Context#
		 *  @name updateInterval
		 */
	    Object.defineProperty(Tone.Context.prototype, 'updateInterval', {
	        get: function () {
	            return this._ticker.updateInterval;
	        },
	        set: function (interval) {
	            this._ticker.updateInterval = interval;
	        }
	    });
	    /**
		 *  What the source of the clock is, either "worker" (Web Worker [default]), 
		 *  "timeout" (setTimeout), or "offline" (none). 
		 *  @type {String}
		 *  @memberOf Tone.Context#
		 *  @name clockSource
		 */
	    Object.defineProperty(Tone.Context.prototype, 'clockSource', {
	        get: function () {
	            return this._ticker.type;
	        },
	        set: function (type) {
	            this._ticker.type = type;
	        }
	    });
	    /**
		 *  The type of playback, which affects tradeoffs between audio 
		 *  output latency and responsiveness. 
		 *  
		 *  In addition to setting the value in seconds, the latencyHint also
		 *  accepts the strings "interactive" (prioritizes low latency), 
		 *  "playback" (prioritizes sustained playback), "balanced" (balances
		 *  latency and performance), and "fastest" (lowest latency, might glitch more often). 
		 *  @type {String|Seconds}
		 *  @memberOf Tone.Context#
		 *  @name latencyHint
		 *  @example
		 * //set the lookAhead to 0.3 seconds
		 * Tone.context.latencyHint = 0.3;
		 */
	    Object.defineProperty(Tone.Context.prototype, 'latencyHint', {
	        get: function () {
	            return this._latencyHint;
	        },
	        set: function (hint) {
	            var lookAhead = hint;
	            this._latencyHint = hint;
	            if (Tone.isString(hint)) {
	                switch (hint) {
	                case 'interactive':
	                    lookAhead = 0.1;
	                    this._context.latencyHint = hint;
	                    break;
	                case 'playback':
	                    lookAhead = 0.8;
	                    this._context.latencyHint = hint;
	                    break;
	                case 'balanced':
	                    lookAhead = 0.25;
	                    this._context.latencyHint = hint;
	                    break;
	                case 'fastest':
	                    this._context.latencyHint = 'interactive';
	                    lookAhead = 0.01;
	                    break;
	                }
	            }
	            this.lookAhead = lookAhead;
	            this.updateInterval = lookAhead / 3;
	        }
	    });
	    /**
		 *  Clean up
		 *  @returns {Tone.Context} this
		 */
	    Tone.Context.prototype.dispose = function () {
	        Tone.Context.emit('close', this);
	        Tone.Emitter.prototype.dispose.call(this);
	        this._ticker.dispose();
	        this._ticker = null;
	        this._timeouts.dispose();
	        this._timeouts = null;
	        for (var con in this._constants) {
	            this._constants[con].disconnect();
	        }
	        this._constants = null;
	        this.close();
	        return this;
	    };
	    /**
		 * @class A class which provides a reliable callback using either
		 *        a Web Worker, or if that isn't supported, falls back to setTimeout.
		 * @private
		 */
	    var Ticker = function (callback, type, updateInterval) {
	        /**
			 * Either "worker" or "timeout"
			 * @type {String}
			 * @private
			 */
	        this._type = type;
	        /**
			 * The update interval of the worker
			 * @private
			 * @type {Number}
			 */
	        this._updateInterval = updateInterval;
	        /**
			 * The callback to invoke at regular intervals
			 * @type {Function}
			 * @private
			 */
	        this._callback = Tone.defaultArg(callback, Tone.noOp);
	        //create the clock source for the first time
	        this._createClock();
	    };
	    /**
		 * The possible ticker types
		 * @private
		 * @type {Object}
		 */
	    Ticker.Type = {
	        Worker: 'worker',
	        Timeout: 'timeout',
	        Offline: 'offline'
	    };
	    /**
		 *  Generate a web worker
		 *  @return  {WebWorker}
		 *  @private
		 */
	    Ticker.prototype._createWorker = function () {
	        //URL Shim
	        window.URL = window.URL || window.webkitURL;
	        var blob = new Blob([//the initial timeout time
	            'var timeoutTime = ' + (this._updateInterval * 1000).toFixed(1) + ';' + //onmessage callback
	            'self.onmessage = function(msg){' + '\ttimeoutTime = parseInt(msg.data);' + '};' + //the tick function which posts a message
	            //and schedules a new tick
	            'function tick(){' + '\tsetTimeout(tick, timeoutTime);' + '\tself.postMessage(\'tick\');' + '}' + //call tick initially
	            'tick();']);
	        var blobUrl = URL.createObjectURL(blob);
	        var worker = new Worker(blobUrl);
	        worker.onmessage = this._callback.bind(this);
	        this._worker = worker;
	    };
	    /**
		 * Create a timeout loop
		 * @private
		 */
	    Ticker.prototype._createTimeout = function () {
	        this._timeout = setTimeout(function () {
	            this._createTimeout();
	            this._callback();
	        }.bind(this), this._updateInterval * 1000);
	    };
	    /**
		 * Create the clock source.
		 * @private
		 */
	    Ticker.prototype._createClock = function () {
	        if (this._type === Ticker.Type.Worker) {
	            try {
	                this._createWorker();
	            } catch (e) {
	                // workers not supported, fallback to timeout
	                this._type = Ticker.Type.Timeout;
	                this._createClock();
	            }
	        } else if (this._type === Ticker.Type.Timeout) {
	            this._createTimeout();
	        }
	    };
	    /**
		 * @memberOf Ticker#
		 * @type {Number}
		 * @name updateInterval
		 * @private
		 */
	    Object.defineProperty(Ticker.prototype, 'updateInterval', {
	        get: function () {
	            return this._updateInterval;
	        },
	        set: function (interval) {
	            this._updateInterval = Math.max(interval, 128 / 44100);
	            if (this._type === Ticker.Type.Worker) {
	                this._worker.postMessage(Math.max(interval * 1000, 1));
	            }
	        }
	    });
	    /**
		 * The type of the ticker, either a worker or a timeout
		 * @memberOf Ticker#
		 * @type {Number}
		 * @name type
		 * @private
		 */
	    Object.defineProperty(Ticker.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            this._disposeClock();
	            this._type = type;
	            this._createClock();
	        }
	    });
	    /**
		 * Clean up the current clock source
		 * @private
		 */
	    Ticker.prototype._disposeClock = function () {
	        if (this._timeout) {
	            clearTimeout(this._timeout);
	            this._timeout = null;
	        }
	        if (this._worker) {
	            this._worker.terminate();
	            this._worker.onmessage = null;
	            this._worker = null;
	        }
	    };
	    /**
		 * Clean up
		 * @private
		 */
	    Ticker.prototype.dispose = function () {
	        this._disposeClock();
	        this._callback = null;
	    };
	    /**
		 *  Shim all connect/disconnect and some deprecated methods which are still in
		 *  some older implementations.
		 *  @private
		 */
	    Tone.getContext(function () {
	        var nativeConnect = AudioNode.prototype.connect;
	        var nativeDisconnect = AudioNode.prototype.disconnect;
	        //replace the old connect method
	        function toneConnect(B, outNum, inNum) {
	            if (B.input) {
	                inNum = Tone.defaultArg(inNum, 0);
	                if (Tone.isArray(B.input)) {
	                    this.connect(B.input[inNum]);
	                } else {
	                    this.connect(B.input, outNum, inNum);
	                }
	            } else {
	                try {
	                    if (B instanceof AudioNode) {
	                        nativeConnect.call(this, B, outNum, inNum);
	                    } else {
	                        nativeConnect.call(this, B, outNum);
	                    }
	                } catch (e) {
	                    throw new Error('error connecting to node: ' + B + '\n' + e);
	                }
	            }
	        }
	        //replace the old disconnect method
	        function toneDisconnect(B, outNum, inNum) {
	            if (B && B.input && Tone.isArray(B.input)) {
	                inNum = Tone.defaultArg(inNum, 0);
	                this.disconnect(B.input[inNum], outNum, 0);
	            } else if (B && B.input) {
	                this.disconnect(B.input, outNum, inNum);
	            } else {
	                try {
	                    nativeDisconnect.apply(this, arguments);
	                } catch (e) {
	                    throw new Error('error disconnecting node: ' + B + '\n' + e);
	                }
	            }
	        }
	        if (AudioNode.prototype.connect !== toneConnect) {
	            AudioNode.prototype.connect = toneConnect;
	            AudioNode.prototype.disconnect = toneDisconnect;
	        }
	    });
	    // set the audio context initially
	    if (Tone.supported) {
	        Tone.context = new Tone.Context();
	    } else {
	        console.warn('This browser does not support Tone.js');
	    }
	    return Tone.Context;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.AudioNode is a base class for classes which process audio.
		 *         AudioNodes have inputs and outputs.
		 *  @param	{AudioContext=} context	The audio context to use with the class
		 *  @extends {Tone}
		 */
	    Tone.AudioNode = function () {
	        Tone.call(this);
	        //use the default context if one is not passed in
	        var options = Tone.defaults(arguments, ['context'], { 'context': Tone.context });
	        /**
			 * The AudioContext of this instance
			 * @private
			 * @type {AudioContext}
			 */
	        this._context = options.context;
	    };
	    Tone.extend(Tone.AudioNode);
	    /**
		 * Get the audio context belonging to this instance.
		 * @type {AudioNode}
		 * @memberOf Tone.AudioNode#
		 * @name context
		 * @readOnly
		 */
	    Object.defineProperty(Tone.AudioNode.prototype, 'context', {
	        get: function () {
	            return this._context;
	        }
	    });
	    /**
		 *  Create input and outputs for this object.
		 *  @param  {Number}  [input=0]   The number of inputs
		 *  @param  {Number}  [outputs=0]  The number of outputs
		 *  @return  {Tone.AudioNode}  this
		 *  @private
		 */
	    Tone.AudioNode.prototype.createInsOuts = function (inputs, outputs) {
	        if (inputs === 1) {
	            this.input = this.context.createGain();
	        } else if (inputs > 1) {
	            this.input = new Array(inputs);
	        }
	        if (outputs === 1) {
	            this.output = this.context.createGain();
	        } else if (outputs > 1) {
	            this.output = new Array(outputs);
	        }
	    };
	    /**
		 *  The number of inputs feeding into the AudioNode.
		 *  For source nodes, this will be 0.
		 *  @type {Number}
		 *  @name numberOfInputs
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.AudioNode.prototype, 'numberOfInputs', {
	        get: function () {
	            if (this.input) {
	                if (Tone.isArray(this.input)) {
	                    return this.input.length;
	                } else {
	                    return 1;
	                }
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  The number of outputs coming out of the AudioNode.
		 *  @type {Number}
		 *  @name numberOfOutputs
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.AudioNode.prototype, 'numberOfOutputs', {
	        get: function () {
	            if (this.output) {
	                if (Tone.isArray(this.output)) {
	                    return this.output.length;
	                } else {
	                    return 1;
	                }
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  connect the output of a ToneNode to an AudioParam, AudioNode, or ToneNode
		 *  @param  {Tone | AudioParam | AudioNode} unit
		 *  @param {number} [outputNum=0] optionally which output to connect from
		 *  @param {number} [inputNum=0] optionally which input to connect to
		 *  @returns {Tone.AudioNode} this
		 */
	    Tone.AudioNode.prototype.connect = function (unit, outputNum, inputNum) {
	        if (Tone.isArray(this.output)) {
	            outputNum = Tone.defaultArg(outputNum, 0);
	            this.output[outputNum].connect(unit, 0, inputNum);
	        } else {
	            this.output.connect(unit, outputNum, inputNum);
	        }
	        return this;
	    };
	    /**
		 *  disconnect the output
		 *  @param {Number|AudioNode} output Either the output index to disconnect
		 *                                   if the output is an array, or the
		 *                                   node to disconnect from.
		 *  @returns {Tone.AudioNode} this
		 */
	    Tone.AudioNode.prototype.disconnect = function (destination, outputNum, inputNum) {
	        if (Tone.isArray(this.output)) {
	            if (Tone.isNumber(destination)) {
	                this.output[destination].disconnect();
	            } else {
	                outputNum = Tone.defaultArg(outputNum, 0);
	                this.output[outputNum].disconnect(destination, 0, inputNum);
	            }
	        } else {
	            this.output.disconnect.apply(this.output, arguments);
	        }
	    };
	    /**
		 *  Connect the output of this node to the rest of the nodes in series.
		 *  @example
		 *  //connect a node to an effect, panVol and then to the master output
		 *  node.chain(effect, panVol, Tone.Master);
		 *  @param {...AudioParam|Tone|AudioNode} nodes
		 *  @returns {Tone.AudioNode} this
		 */
	    Tone.AudioNode.prototype.chain = function () {
	        var currentUnit = this;
	        for (var i = 0; i < arguments.length; i++) {
	            var toUnit = arguments[i];
	            currentUnit.connect(toUnit);
	            currentUnit = toUnit;
	        }
	        return this;
	    };
	    /**
		 *  connect the output of this node to the rest of the nodes in parallel.
		 *  @param {...AudioParam|Tone|AudioNode} nodes
		 *  @returns {Tone.AudioNode} this
		 */
	    Tone.AudioNode.prototype.fan = function () {
	        for (var i = 0; i < arguments.length; i++) {
	            this.connect(arguments[i]);
	        }
	        return this;
	    };
	    if (window.AudioNode) {
	        //give native nodes chain and fan methods
	        AudioNode.prototype.chain = Tone.AudioNode.prototype.chain;
	        AudioNode.prototype.fan = Tone.AudioNode.prototype.fan;
	    }
	    /**
		 * Dispose and disconnect
		 * @return {Tone.AudioNode} this
		 */
	    Tone.AudioNode.prototype.dispose = function () {
	        if (!Tone.isUndef(this.input)) {
	            if (this.input instanceof AudioNode) {
	                this.input.disconnect();
	            }
	            this.input = null;
	        }
	        if (!Tone.isUndef(this.output)) {
	            if (this.output instanceof AudioNode) {
	                this.output.disconnect();
	            }
	            this.output = null;
	        }
	        this._context = null;
	        return this;
	    };
	    return Tone.AudioNode;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Base class for all Signals. Used Internally.
		 *
		 *  @constructor
		 *  @extends {Tone}
		 */
	    Tone.SignalBase = function () {
	        Tone.AudioNode.call(this);
	    };
	    Tone.extend(Tone.SignalBase, Tone.AudioNode);
	    /**
		 *  When signals connect to other signals or AudioParams,
		 *  they take over the output value of that signal or AudioParam.
		 *  For all other nodes, the behavior is the same as a default <code>connect</code>.
		 *
		 *  @override
		 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node
		 *  @param {number} [outputNumber=0] The output number to connect from.
		 *  @param {number} [inputNumber=0] The input number to connect to.
		 *  @returns {Tone.SignalBase} this
		 */
	    Tone.SignalBase.prototype.connect = function (node, outputNumber, inputNumber) {
	        //zero it out so that the signal can have full control
	        if (Tone.Signal && Tone.Signal === node.constructor || Tone.Param && Tone.Param === node.constructor || Tone.TimelineSignal && Tone.TimelineSignal === node.constructor) {
	            //cancel changes
	            node._param.cancelScheduledValues(0);
	            //reset the value
	            node._param.value = 0;
	            //mark the value as overridden
	            node.overridden = true;
	        } else if (node instanceof AudioParam) {
	            node.cancelScheduledValues(0);
	            node.value = 0;
	        }
	        Tone.AudioNode.prototype.connect.call(this, node, outputNumber, inputNumber);
	        return this;
	    };
	    return Tone.SignalBase;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Wraps the native Web Audio API 
		 *         [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @param {function|Array|Number} mapping The function used to define the values. 
		 *                                    The mapping function should take two arguments: 
		 *                                    the first is the value at the current position 
		 *                                    and the second is the array position. 
		 *                                    If the argument is an array, that array will be
		 *                                    set as the wave shaping function. The input
		 *                                    signal is an AudioRange [-1, 1] value and the output
		 *                                    signal can take on any numerical values. 
		 *                                    
		 *  @param {Number} [bufferLen=1024] The length of the WaveShaperNode buffer.
		 *  @example
		 * var timesTwo = new Tone.WaveShaper(function(val){
		 * 	return val * 2;
		 * }, 2048);
		 *  @example
		 * //a waveshaper can also be constructed with an array of values
		 * var invert = new Tone.WaveShaper([1, -1]);
		 */
	    Tone.WaveShaper = function (mapping, bufferLen) {
	        Tone.SignalBase.call(this);
	        /**
			 *  the waveshaper
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._shaper = this.input = this.output = this.context.createWaveShaper();
	        /**
			 *  the waveshapers curve
			 *  @type {Float32Array}
			 *  @private
			 */
	        this._curve = null;
	        if (Array.isArray(mapping)) {
	            this.curve = mapping;
	        } else if (isFinite(mapping) || Tone.isUndef(mapping)) {
	            this._curve = new Float32Array(Tone.defaultArg(mapping, 1024));
	        } else if (Tone.isFunction(mapping)) {
	            this._curve = new Float32Array(Tone.defaultArg(bufferLen, 1024));
	            this.setMap(mapping);
	        }
	    };
	    Tone.extend(Tone.WaveShaper, Tone.SignalBase);
	    /**
		 *  Uses a mapping function to set the value of the curve. 
		 *  @param {function} mapping The function used to define the values. 
		 *                            The mapping function take two arguments: 
		 *                            the first is the value at the current position 
		 *                            which goes from -1 to 1 over the number of elements
		 *                            in the curve array. The second argument is the array position. 
		 *  @returns {Tone.WaveShaper} this
		 *  @example
		 * //map the input signal from [-1, 1] to [0, 10]
		 * shaper.setMap(function(val, index){
		 * 	return (val + 1) * 5;
		 * })
		 */
	    Tone.WaveShaper.prototype.setMap = function (mapping) {
	        for (var i = 0, len = this._curve.length; i < len; i++) {
	            var normalized = i / (len - 1) * 2 - 1;
	            this._curve[i] = mapping(normalized, i);
	        }
	        this._shaper.curve = this._curve;
	        return this;
	    };
	    /**
		 * The array to set as the waveshaper curve. For linear curves
		 * array length does not make much difference, but for complex curves
		 * longer arrays will provide smoother interpolation. 
		 * @memberOf Tone.WaveShaper#
		 * @type {Array}
		 * @name curve
		 */
	    Object.defineProperty(Tone.WaveShaper.prototype, 'curve', {
	        get: function () {
	            return this._shaper.curve;
	        },
	        set: function (mapping) {
	            this._curve = new Float32Array(mapping);
	            this._shaper.curve = this._curve;
	        }
	    });
	    /**
		 * Specifies what type of oversampling (if any) should be used when 
		 * applying the shaping curve. Can either be "none", "2x" or "4x". 
		 * @memberOf Tone.WaveShaper#
		 * @type {string}
		 * @name oversample
		 */
	    Object.defineProperty(Tone.WaveShaper.prototype, 'oversample', {
	        get: function () {
	            return this._shaper.oversample;
	        },
	        set: function (oversampling) {
	            if ([
	                    'none',
	                    '2x',
	                    '4x'
	                ].indexOf(oversampling) !== -1) {
	                this._shaper.oversample = oversampling;
	            } else {
	                throw new RangeError('Tone.WaveShaper: oversampling must be either \'none\', \'2x\', or \'4x\'');
	            }
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.WaveShaper} this
		 */
	    Tone.WaveShaper.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._shaper.disconnect();
	        this._shaper = null;
	        this._curve = null;
	        return this;
	    };
	    return Tone.WaveShaper;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.TimeBase is a flexible encoding of time
		 *         which can be evaluated to and from a string.
		 *         Parsing code modified from https://code.google.com/p/tapdigit/
		 *         Copyright 2011 2012 Ariya Hidayat, New BSD License
		 *  @extends {Tone}
		 *  @param  {Time}  val    The time value as a number or string
		 *  @param  {String=}  units  Unit values
		 *  @example
		 * Tone.TimeBase(4, "n")
		 * Tone.TimeBase(2, "t")
		 * Tone.TimeBase("2t").add("1m")
		 * Tone.TimeBase("2t + 1m");
		 */
	    Tone.TimeBase = function (val, units) {
	        //allows it to be constructed with or without 'new'
	        if (this instanceof Tone.TimeBase) {
	            /**
				 *  Any expressions parsed from the Time
				 *  @type  {Array}
				 *  @private
				 */
	            this._expr = this._noOp;
	            if (val instanceof Tone.TimeBase) {
	                this.copy(val);
	            } else if (!Tone.isUndef(units) || Tone.isNumber(val)) {
	                //default units
	                units = Tone.defaultArg(units, this._defaultUnits);
	                var method = this._primaryExpressions[units].method;
	                this._expr = method.bind(this, val);
	            } else if (Tone.isString(val)) {
	                this.set(val);
	            } else if (Tone.isUndef(val)) {
	                //default expression
	                this._expr = this._defaultExpr();
	            }
	        } else {
	            return new Tone.TimeBase(val, units);
	        }
	    };
	    Tone.extend(Tone.TimeBase);
	    /**
		 *  Repalce the current time value with the value
		 *  given by the expression string.
		 *  @param  {String}  exprString
		 *  @return {Tone.TimeBase} this
		 */
	    Tone.TimeBase.prototype.set = function (exprString) {
	        this._expr = this._parseExprString(exprString);
	        return this;
	    };
	    /**
		 *  Return a clone of the TimeBase object.
		 *  @return  {Tone.TimeBase} The new cloned Tone.TimeBase
		 */
	    Tone.TimeBase.prototype.clone = function () {
	        var instance = new this.constructor();
	        instance.copy(this);
	        return instance;
	    };
	    /**
		 *  Copies the value of time to this Time
		 *  @param {Tone.TimeBase} time
		 *  @return  {TimeBase}
		 */
	    Tone.TimeBase.prototype.copy = function (time) {
	        var val = time._expr();
	        return this.set(val);
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	ABSTRACT SYNTAX TREE PARSER
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  All the primary expressions.
		 *  @private
		 *  @type  {Object}
		 */
	    Tone.TimeBase.prototype._primaryExpressions = {
	        'n': {
	            regexp: /^(\d+)n/i,
	            method: function (value) {
	                value = parseInt(value);
	                if (value === 1) {
	                    return this._beatsToUnits(this._timeSignature());
	                } else {
	                    return this._beatsToUnits(4 / value);
	                }
	            }
	        },
	        't': {
	            regexp: /^(\d+)t/i,
	            method: function (value) {
	                value = parseInt(value);
	                return this._beatsToUnits(8 / (parseInt(value) * 3));
	            }
	        },
	        'm': {
	            regexp: /^(\d+)m/i,
	            method: function (value) {
	                return this._beatsToUnits(parseInt(value) * this._timeSignature());
	            }
	        },
	        'i': {
	            regexp: /^(\d+)i/i,
	            method: function (value) {
	                return this._ticksToUnits(parseInt(value));
	            }
	        },
	        'hz': {
	            regexp: /^(\d+(?:\.\d+)?)hz/i,
	            method: function (value) {
	                return this._frequencyToUnits(parseFloat(value));
	            }
	        },
	        'tr': {
	            regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
	            method: function (m, q, s) {
	                var total = 0;
	                if (m && m !== '0') {
	                    total += this._beatsToUnits(this._timeSignature() * parseFloat(m));
	                }
	                if (q && q !== '0') {
	                    total += this._beatsToUnits(parseFloat(q));
	                }
	                if (s && s !== '0') {
	                    total += this._beatsToUnits(parseFloat(s) / 4);
	                }
	                return total;
	            }
	        },
	        's': {
	            regexp: /^(\d+(?:\.\d+)?s)/,
	            method: function (value) {
	                return this._secondsToUnits(parseFloat(value));
	            }
	        },
	        'samples': {
	            regexp: /^(\d+)samples/,
	            method: function (value) {
	                return parseInt(value) / this.context.sampleRate;
	            }
	        },
	        'default': {
	            regexp: /^(\d+(?:\.\d+)?)/,
	            method: function (value) {
	                return this._primaryExpressions[this._defaultUnits].method.call(this, value);
	            }
	        }
	    };
	    /**
		 *  All the binary expressions that TimeBase can accept.
		 *  @private
		 *  @type  {Object}
		 */
	    Tone.TimeBase.prototype._binaryExpressions = {
	        '+': {
	            regexp: /^\+/,
	            precedence: 2,
	            method: function (lh, rh) {
	                return lh() + rh();
	            }
	        },
	        '-': {
	            regexp: /^\-/,
	            precedence: 2,
	            method: function (lh, rh) {
	                return lh() - rh();
	            }
	        },
	        '*': {
	            regexp: /^\*/,
	            precedence: 1,
	            method: function (lh, rh) {
	                return lh() * rh();
	            }
	        },
	        '/': {
	            regexp: /^\//,
	            precedence: 1,
	            method: function (lh, rh) {
	                return lh() / rh();
	            }
	        }
	    };
	    /**
		 *  All the unary expressions.
		 *  @private
		 *  @type  {Object}
		 */
	    Tone.TimeBase.prototype._unaryExpressions = {
	        'neg': {
	            regexp: /^\-/,
	            method: function (lh) {
	                return -lh();
	            }
	        }
	    };
	    /**
		 *  Syntactic glue which holds expressions together
		 *  @private
		 *  @type  {Object}
		 */
	    Tone.TimeBase.prototype._syntaxGlue = {
	        '(': { regexp: /^\(/ },
	        ')': { regexp: /^\)/ }
	    };
	    /**
		 *  tokenize the expression based on the Expressions object
		 *  @param   {string} expr 
		 *  @return  {Object}      returns two methods on the tokenized list, next and peek
		 *  @private
		 */
	    Tone.TimeBase.prototype._tokenize = function (expr) {
	        var position = -1;
	        var tokens = [];
	        while (expr.length > 0) {
	            expr = expr.trim();
	            var token = getNextToken(expr, this);
	            tokens.push(token);
	            expr = expr.substr(token.value.length);
	        }
	        function getNextToken(expr, context) {
	            var expressions = [
	                '_binaryExpressions',
	                '_unaryExpressions',
	                '_primaryExpressions',
	                '_syntaxGlue'
	            ];
	            for (var i = 0; i < expressions.length; i++) {
	                var group = context[expressions[i]];
	                for (var opName in group) {
	                    var op = group[opName];
	                    var reg = op.regexp;
	                    var match = expr.match(reg);
	                    if (match !== null) {
	                        return {
	                            method: op.method,
	                            precedence: op.precedence,
	                            regexp: op.regexp,
	                            value: match[0]
	                        };
	                    }
	                }
	            }
	            throw new SyntaxError('Tone.TimeBase: Unexpected token ' + expr);
	        }
	        return {
	            next: function () {
	                return tokens[++position];
	            },
	            peek: function () {
	                return tokens[position + 1];
	            }
	        };
	    };
	    /**
		 *  Given a token, find the value within the groupName
		 *  @param {Object} token
		 *  @param {String} groupName
		 *  @param {Number} precedence
		 *  @private
		 */
	    Tone.TimeBase.prototype._matchGroup = function (token, group, prec) {
	        var ret = false;
	        if (!Tone.isUndef(token)) {
	            for (var opName in group) {
	                var op = group[opName];
	                if (op.regexp.test(token.value)) {
	                    if (!Tone.isUndef(prec)) {
	                        if (op.precedence === prec) {
	                            return op;
	                        }
	                    } else {
	                        return op;
	                    }
	                }
	            }
	        }
	        return ret;
	    };
	    /**
		 *  Match a binary expression given the token and the precedence
		 *  @param {Lexer} lexer
		 *  @param {Number} precedence
		 *  @private
		 */
	    Tone.TimeBase.prototype._parseBinary = function (lexer, precedence) {
	        if (Tone.isUndef(precedence)) {
	            precedence = 2;
	        }
	        var expr;
	        if (precedence < 0) {
	            expr = this._parseUnary(lexer);
	        } else {
	            expr = this._parseBinary(lexer, precedence - 1);
	        }
	        var token = lexer.peek();
	        while (token && this._matchGroup(token, this._binaryExpressions, precedence)) {
	            token = lexer.next();
	            expr = token.method.bind(this, expr, this._parseBinary(lexer, precedence - 1));
	            token = lexer.peek();
	        }
	        return expr;
	    };
	    /**
		 *  Match a unary expression.
		 *  @param {Lexer} lexer
		 *  @private
		 */
	    Tone.TimeBase.prototype._parseUnary = function (lexer) {
	        var token, expr;
	        token = lexer.peek();
	        var op = this._matchGroup(token, this._unaryExpressions);
	        if (op) {
	            token = lexer.next();
	            expr = this._parseUnary(lexer);
	            return op.method.bind(this, expr);
	        }
	        return this._parsePrimary(lexer);
	    };
	    /**
		 *  Match a primary expression (a value).
		 *  @param {Lexer} lexer
		 *  @private
		 */
	    Tone.TimeBase.prototype._parsePrimary = function (lexer) {
	        var token, expr;
	        token = lexer.peek();
	        if (Tone.isUndef(token)) {
	            throw new SyntaxError('Tone.TimeBase: Unexpected end of expression');
	        }
	        if (this._matchGroup(token, this._primaryExpressions)) {
	            token = lexer.next();
	            var matching = token.value.match(token.regexp);
	            return token.method.bind(this, matching[1], matching[2], matching[3]);
	        }
	        if (token && token.value === '(') {
	            lexer.next();
	            expr = this._parseBinary(lexer);
	            token = lexer.next();
	            if (!(token && token.value === ')')) {
	                throw new SyntaxError('Expected )');
	            }
	            return expr;
	        }
	        throw new SyntaxError('Tone.TimeBase: Cannot process token ' + token.value);
	    };
	    /**
		 *  Recursively parse the string expression into a syntax tree.
		 *  @param   {string} expr 
		 *  @return  {Function} the bound method to be evaluated later
		 *  @private
		 */
	    Tone.TimeBase.prototype._parseExprString = function (exprString) {
	        if (!Tone.isString(exprString)) {
	            exprString = exprString.toString();
	        }
	        var lexer = this._tokenize(exprString);
	        var tree = this._parseBinary(lexer);
	        return tree;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	DEFAULTS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  The initial expression value
		 *  @return  {Number}  The initial value 0
		 *  @private
		 */
	    Tone.TimeBase.prototype._noOp = function () {
	        return 0;
	    };
	    /**
		 *  The default expression value if no arguments are given
		 *  @private
		 */
	    Tone.TimeBase.prototype._defaultExpr = function () {
	        return this._noOp;
	    };
	    /**
		 *  The default units if none are given.
		 *  @private
		 */
	    Tone.TimeBase.prototype._defaultUnits = 's';
	    ///////////////////////////////////////////////////////////////////////////
	    //	UNIT CONVERSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Returns the value of a frequency in the current units
		 *  @param {Frequency} freq
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._frequencyToUnits = function (freq) {
	        return 1 / freq;
	    };
	    /**
		 *  Return the value of the beats in the current units
		 *  @param {Number} beats
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._beatsToUnits = function (beats) {
	        return 60 / Tone.Transport.bpm.value * beats;
	    };
	    /**
		 *  Returns the value of a second in the current units
		 *  @param {Seconds} seconds
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._secondsToUnits = function (seconds) {
	        return seconds;
	    };
	    /**
		 *  Returns the value of a tick in the current time units
		 *  @param {Ticks} ticks
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._ticksToUnits = function (ticks) {
	        return ticks * (this._beatsToUnits(1) / Tone.Transport.PPQ);
	    };
	    /**
		 *  Return the time signature.
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._timeSignature = function () {
	        return Tone.Transport.timeSignature;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	EXPRESSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Push an expression onto the expression list
		 *  @param  {Time}  val
		 *  @param  {String}  type
		 *  @param  {String}  units
		 *  @return  {Tone.TimeBase} 
		 *  @private
		 */
	    Tone.TimeBase.prototype._pushExpr = function (val, name, units) {
	        //create the expression
	        if (!(val instanceof Tone.TimeBase)) {
	            val = new this.constructor(val, units);
	        }
	        this._expr = this._binaryExpressions[name].method.bind(this, this._expr, val._expr);
	        return this;
	    };
	    /**
		 *  Add to the current value.
		 *  @param  {Time}  val    The value to add
		 *  @param  {String=}  units  Optional units to use with the value.
		 *  @return  {Tone.TimeBase}  this
		 *  @example
		 * Tone.TimeBase("2m").add("1m"); //"3m"
		 */
	    Tone.TimeBase.prototype.add = function (val, units) {
	        return this._pushExpr(val, '+', units);
	    };
	    /**
		 *  Subtract the value from the current time.
		 *  @param  {Time}  val    The value to subtract
		 *  @param  {String=}  units  Optional units to use with the value.
		 *  @return  {Tone.TimeBase}  this
		 *  @example
		 * Tone.TimeBase("2m").sub("1m"); //"1m"
		 */
	    Tone.TimeBase.prototype.sub = function (val, units) {
	        return this._pushExpr(val, '-', units);
	    };
	    /**
		 *  Multiply the current value by the given time.
		 *  @param  {Time}  val    The value to multiply
		 *  @param  {String=}  units  Optional units to use with the value.
		 *  @return  {Tone.TimeBase}  this
		 *  @example
		 * Tone.TimeBase("2m").mult("2"); //"4m"
		 */
	    Tone.TimeBase.prototype.mult = function (val, units) {
	        return this._pushExpr(val, '*', units);
	    };
	    /**
		 *  Divide the current value by the given time.
		 *  @param  {Time}  val    The value to divide by
		 *  @param  {String=}  units  Optional units to use with the value.
		 *  @return  {Tone.TimeBase}  this
		 *  @example
		 * Tone.TimeBase("2m").div(2); //"1m"
		 */
	    Tone.TimeBase.prototype.div = function (val, units) {
	        return this._pushExpr(val, '/', units);
	    };
	    /**
		 *  Evaluate the time value. Returns the time
		 *  in seconds.
		 *  @return  {Seconds} 
		 */
	    Tone.TimeBase.prototype.valueOf = function () {
	        return this._expr();
	    };
	    /**
		 *  Clean up
		 *  @return {Tone.TimeBase} this
		 */
	    Tone.TimeBase.prototype.dispose = function () {
	        this._expr = null;
	    };
	    return Tone.TimeBase;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Time is a primitive type for encoding Time values. 
		 *         Eventually all time values are evaluated to seconds
		 *         using the `eval` method. Tone.Time can be constructed
		 *         with or without the `new` keyword. Tone.Time can be passed
		 *         into the parameter of any method which takes time as an argument. 
		 *  @constructor
		 *  @extends {Tone.TimeBase}
		 *  @param  {String|Number}  val    The time value.
		 *  @param  {String=}  units  The units of the value.
		 *  @example
		 * var t = Tone.Time("4n");//encodes a quarter note
		 * t.mult(4); // multiply that value by 4
		 * t.toNotation(); //returns "1m"
		 */
	    Tone.Time = function (val, units) {
	        if (this instanceof Tone.Time) {
	            /**
				 *  If the current clock time should
				 *  be added to the output
				 *  @type  {Boolean}
				 *  @private
				 */
	            this._plusNow = false;
	            Tone.TimeBase.call(this, val, units);
	        } else {
	            return new Tone.Time(val, units);
	        }
	    };
	    Tone.extend(Tone.Time, Tone.TimeBase);
	    //clone the expressions so that 
	    //we can add more without modifying the original
	    Tone.Time.prototype._unaryExpressions = Object.create(Tone.TimeBase.prototype._unaryExpressions);
	    /*
		 *  Adds an additional unary expression
		 *  which quantizes values to the next subdivision
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Time.prototype._unaryExpressions.quantize = {
	        regexp: /^@/,
	        method: function (rh) {
	            return Tone.Transport.nextSubdivision(rh());
	        }
	    };
	    /*
		 *  Adds an additional unary expression
		 *  which adds the current clock time.
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Time.prototype._unaryExpressions.now = {
	        regexp: /^\+/,
	        method: function (lh) {
	            this._plusNow = true;
	            return lh();
	        }
	    };
	    /**
		 *  Quantize the time by the given subdivision. Optionally add a
		 *  percentage which will move the time value towards the ideal
		 *  quantized value by that percentage. 
		 *  @param  {Number|Time}  val    The subdivision to quantize to
		 *  @param  {NormalRange}  [percent=1]  Move the time value
		 *                                   towards the quantized value by
		 *                                   a percentage.
		 *  @return  {Tone.Time}  this
		 *  @example
		 * Tone.Time(21).quantize(2) //returns 22
		 * Tone.Time(0.6).quantize("4n", 0.5) //returns 0.55
		 */
	    Tone.Time.prototype.quantize = function (subdiv, percent) {
	        percent = Tone.defaultArg(percent, 1);
	        this._expr = function (expr, subdivision, percent) {
	            expr = expr();
	            subdivision = subdivision.toSeconds();
	            var multiple = Math.round(expr / subdivision);
	            var ideal = multiple * subdivision;
	            var diff = ideal - expr;
	            return expr + diff * percent;
	        }.bind(this, this._expr, new this.constructor(subdiv), percent);
	        return this;
	    };
	    /**
		 *  Adds the clock time to the time expression at the 
		 *  moment of evaluation. 
		 *  @return  {Tone.Time}  this
		 */
	    Tone.Time.prototype.addNow = function () {
	        this._plusNow = true;
	        return this;
	    };
	    /**
		 *  Override the default value return when no arguments are passed in.
		 *  The default value is 'now'
		 *  @override
		 *  @private
		 */
	    Tone.Time.prototype._defaultExpr = function () {
	        this._plusNow = true;
	        return this._noOp;
	    };
	    /**
		 *  Copies the value of time to this Time
		 *  @param {Tone.Time} time
		 *  @return  {Time}
		 */
	    Tone.Time.prototype.copy = function (time) {
	        Tone.TimeBase.prototype.copy.call(this, time);
	        this._plusNow = time._plusNow;
	        return this;
	    };
	    //CONVERSIONS//////////////////////////////////////////////////////////////
	    /**
		 *  Convert a Time to Notation. Values will be thresholded to the nearest 128th note. 
		 *  @return {Notation} 
		 *  @example
		 * //if the Transport is at 120bpm:
		 * Tone.Time(2).toNotation();//returns "1m"
		 */
	    Tone.Time.prototype.toNotation = function () {
	        var time = this.toSeconds();
	        var testNotations = [
	            '1m',
	            '2n',
	            '4n',
	            '8n',
	            '16n',
	            '32n',
	            '64n',
	            '128n'
	        ];
	        var retNotation = this._toNotationHelper(time, testNotations);
	        //try the same thing but with tripelets
	        var testTripletNotations = [
	            '1m',
	            '2n',
	            '2t',
	            '4n',
	            '4t',
	            '8n',
	            '8t',
	            '16n',
	            '16t',
	            '32n',
	            '32t',
	            '64n',
	            '64t',
	            '128n'
	        ];
	        var retTripletNotation = this._toNotationHelper(time, testTripletNotations);
	        //choose the simpler expression of the two
	        if (retTripletNotation.split('+').length < retNotation.split('+').length) {
	            return retTripletNotation;
	        } else {
	            return retNotation;
	        }
	    };
	    /**
		 *  Helper method for Tone.toNotation
		 *  @param {Number} units 
		 *  @param {Array} testNotations
		 *  @return {String}
		 *  @private
		 */
	    Tone.Time.prototype._toNotationHelper = function (units, testNotations) {
	        //the threshold is the last value in the array
	        var threshold = this._notationToUnits(testNotations[testNotations.length - 1]);
	        var retNotation = '';
	        for (var i = 0; i < testNotations.length; i++) {
	            var notationTime = this._notationToUnits(testNotations[i]);
	            //account for floating point errors (i.e. round up if the value is 0.999999)
	            var multiple = units / notationTime;
	            var floatingPointError = 0.000001;
	            if (1 - multiple % 1 < floatingPointError) {
	                multiple += floatingPointError;
	            }
	            multiple = Math.floor(multiple);
	            if (multiple > 0) {
	                if (multiple === 1) {
	                    retNotation += testNotations[i];
	                } else {
	                    retNotation += multiple.toString() + '*' + testNotations[i];
	                }
	                units -= multiple * notationTime;
	                if (units < threshold) {
	                    break;
	                } else {
	                    retNotation += ' + ';
	                }
	            }
	        }
	        if (retNotation === '') {
	            retNotation = '0';
	        }
	        return retNotation;
	    };
	    /**
		 *  Convert a notation value to the current units
		 *  @param  {Notation}  notation 
		 *  @return  {Number} 
		 *  @private
		 */
	    Tone.Time.prototype._notationToUnits = function (notation) {
	        var primaryExprs = this._primaryExpressions;
	        var notationExprs = [
	            primaryExprs.n,
	            primaryExprs.t,
	            primaryExprs.m
	        ];
	        for (var i = 0; i < notationExprs.length; i++) {
	            var expr = notationExprs[i];
	            var match = notation.match(expr.regexp);
	            if (match) {
	                return expr.method.call(this, match[1]);
	            }
	        }
	    };
	    /**
		 *  Return the time encoded as Bars:Beats:Sixteenths.
		 *  @return  {BarsBeatsSixteenths}
		 */
	    Tone.Time.prototype.toBarsBeatsSixteenths = function () {
	        var quarterTime = this._beatsToUnits(1);
	        var quarters = this.toSeconds() / quarterTime;
	        var measures = Math.floor(quarters / this._timeSignature());
	        var sixteenths = quarters % 1 * 4;
	        quarters = Math.floor(quarters) % this._timeSignature();
	        sixteenths = sixteenths.toString();
	        if (sixteenths.length > 3) {
	            // the additional parseFloat removes insignificant trailing zeroes
	            sixteenths = parseFloat(parseFloat(sixteenths).toFixed(3));
	        }
	        var progress = [
	            measures,
	            quarters,
	            sixteenths
	        ];
	        return progress.join(':');
	    };
	    /**
		 *  Return the time in ticks.
		 *  @return  {Ticks}
		 */
	    Tone.Time.prototype.toTicks = function () {
	        var quarterTime = this._beatsToUnits(1);
	        var quarters = this.valueOf() / quarterTime;
	        return Math.floor(quarters * Tone.Transport.PPQ);
	    };
	    /**
		 *  Return the time in samples
		 *  @return  {Samples}  
		 */
	    Tone.Time.prototype.toSamples = function () {
	        return this.toSeconds() * this.context.sampleRate;
	    };
	    /**
		 *  Return the time as a frequency value
		 *  @return  {Frequency} 
		 *  @example
		 * Tone.Time(2).toFrequency(); //0.5
		 */
	    Tone.Time.prototype.toFrequency = function () {
	        return 1 / this.toSeconds();
	    };
	    /**
		 *  Return the time in seconds.
		 *  @return  {Seconds} 
		 */
	    Tone.Time.prototype.toSeconds = function () {
	        return this.valueOf();
	    };
	    /**
		 *  Return the time in milliseconds.
		 *  @return  {Milliseconds} 
		 */
	    Tone.Time.prototype.toMilliseconds = function () {
	        return this.toSeconds() * 1000;
	    };
	    /**
		 *  Return the time in seconds.
		 *  @return  {Seconds} 
		 */
	    Tone.Time.prototype.valueOf = function () {
	        var val = this._expr();
	        return val + (this._plusNow ? this.now() : 0);
	    };
	    return Tone.Time;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Frequency is a primitive type for encoding Frequency values.
		 *         Eventually all time values are evaluated to hertz
		 *         using the `eval` method.
		 *  @constructor
		 *  @extends {Tone.TimeBase}
		 *  @param  {String|Number}  val    The time value.
		 *  @param  {String=}  units  The units of the value.
		 *  @example
		 * Tone.Frequency("C3") // 261
		 * Tone.Frequency(38, "midi") //
		 * Tone.Frequency("C3").transpose(4);
		 */
	    Tone.Frequency = function (val, units) {
	        if (this instanceof Tone.Frequency) {
	            Tone.TimeBase.call(this, val, units);
	        } else {
	            return new Tone.Frequency(val, units);
	        }
	    };
	    Tone.extend(Tone.Frequency, Tone.TimeBase);
	    ///////////////////////////////////////////////////////////////////////////
	    //	AUGMENT BASE EXPRESSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    //clone the expressions so that
	    //we can add more without modifying the original
	    Tone.Frequency.prototype._primaryExpressions = Object.create(Tone.TimeBase.prototype._primaryExpressions);
	    /*
		 *  midi type primary expression
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Frequency.prototype._primaryExpressions.midi = {
	        regexp: /^(\d+(?:\.\d+)?midi)/,
	        method: function (value) {
	            return this.midiToFrequency(value);
	        }
	    };
	    /*
		 *  note type primary expression
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Frequency.prototype._primaryExpressions.note = {
	        regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,
	        method: function (pitch, octave) {
	            var index = noteToScaleIndex[pitch.toLowerCase()];
	            var noteNumber = index + (parseInt(octave) + 1) * 12;
	            return this.midiToFrequency(noteNumber);
	        }
	    };
	    /*
		 *  BeatsBarsSixteenths type primary expression
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Frequency.prototype._primaryExpressions.tr = {
	        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
	        method: function (m, q, s) {
	            var total = 1;
	            if (m && m !== '0') {
	                total *= this._beatsToUnits(this._timeSignature() * parseFloat(m));
	            }
	            if (q && q !== '0') {
	                total *= this._beatsToUnits(parseFloat(q));
	            }
	            if (s && s !== '0') {
	                total *= this._beatsToUnits(parseFloat(s) / 4);
	            }
	            return total;
	        }
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	EXPRESSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Transposes the frequency by the given number of semitones.
		 *  @param  {Interval}  interval
		 *  @return  {Tone.Frequency} this
		 *  @example
		 * Tone.Frequency("A4").transpose(3); //"C5"
		 */
	    Tone.Frequency.prototype.transpose = function (interval) {
	        this._expr = function (expr, interval) {
	            var val = expr();
	            return val * Tone.intervalToFrequencyRatio(interval);
	        }.bind(this, this._expr, interval);
	        return this;
	    };
	    /**
		 *  Takes an array of semitone intervals and returns
		 *  an array of frequencies transposed by those intervals.
		 *  @param  {Array}  intervals
		 *  @return  {Tone.Frequency} this
		 *  @example
		 * Tone.Frequency("A4").harmonize([0, 3, 7]); //["A4", "C5", "E5"]
		 */
	    Tone.Frequency.prototype.harmonize = function (intervals) {
	        this._expr = function (expr, intervals) {
	            var val = expr();
	            var ret = [];
	            for (var i = 0; i < intervals.length; i++) {
	                ret[i] = val * Tone.intervalToFrequencyRatio(intervals[i]);
	            }
	            return ret;
	        }.bind(this, this._expr, intervals);
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	UNIT CONVERSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Return the value of the frequency as a MIDI note
		 *  @return  {MIDI}
		 *  @example
		 * Tone.Frequency("C4").toMidi(); //60
		 */
	    Tone.Frequency.prototype.toMidi = function () {
	        return this.frequencyToMidi(this.valueOf());
	    };
	    /**
		 *  Return the value of the frequency in Scientific Pitch Notation
		 *  @return  {Note}
		 *  @example
		 * Tone.Frequency(69, "midi").toNote(); //"A4"
		 */
	    Tone.Frequency.prototype.toNote = function () {
	        var freq = this.valueOf();
	        var log = Math.log(freq / Tone.Frequency.A4) / Math.LN2;
	        var noteNumber = Math.round(12 * log) + 57;
	        var octave = Math.floor(noteNumber / 12);
	        if (octave < 0) {
	            noteNumber += -12 * octave;
	        }
	        var noteName = scaleIndexToNote[noteNumber % 12];
	        return noteName + octave.toString();
	    };
	    /**
		 *  Return the duration of one cycle in seconds.
		 *  @return  {Seconds}
		 */
	    Tone.Frequency.prototype.toSeconds = function () {
	        return 1 / this.valueOf();
	    };
	    /**
		 *  Return the value in Hertz
		 *  @return  {Frequency}
		 */
	    Tone.Frequency.prototype.toFrequency = function () {
	        return this.valueOf();
	    };
	    /**
		 *  Return the duration of one cycle in ticks
		 *  @return  {Ticks}
		 */
	    Tone.Frequency.prototype.toTicks = function () {
	        var quarterTime = this._beatsToUnits(1);
	        var quarters = this.valueOf() / quarterTime;
	        return Math.floor(quarters * Tone.Transport.PPQ);
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	UNIT CONVERSIONS HELPERS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Returns the value of a frequency in the current units
		 *  @param {Frequency} freq
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.Frequency.prototype._frequencyToUnits = function (freq) {
	        return freq;
	    };
	    /**
		 *  Returns the value of a tick in the current time units
		 *  @param {Ticks} ticks
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.Frequency.prototype._ticksToUnits = function (ticks) {
	        return 1 / (ticks * 60 / (Tone.Transport.bpm.value * Tone.Transport.PPQ));
	    };
	    /**
		 *  Return the value of the beats in the current units
		 *  @param {Number} beats
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.Frequency.prototype._beatsToUnits = function (beats) {
	        return 1 / Tone.TimeBase.prototype._beatsToUnits.call(this, beats);
	    };
	    /**
		 *  Returns the value of a second in the current units
		 *  @param {Seconds} seconds
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.Frequency.prototype._secondsToUnits = function (seconds) {
	        return 1 / seconds;
	    };
	    /**
		 *  The default units if none are given.
		 *  @private
		 */
	    Tone.Frequency.prototype._defaultUnits = 'hz';
	    ///////////////////////////////////////////////////////////////////////////
	    //	FREQUENCY CONVERSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Note to scale index
		 *  @type  {Object}
		 */
	    var noteToScaleIndex = {
	        'cbb': -2,
	        'cb': -1,
	        'c': 0,
	        'c#': 1,
	        'cx': 2,
	        'dbb': 0,
	        'db': 1,
	        'd': 2,
	        'd#': 3,
	        'dx': 4,
	        'ebb': 2,
	        'eb': 3,
	        'e': 4,
	        'e#': 5,
	        'ex': 6,
	        'fbb': 3,
	        'fb': 4,
	        'f': 5,
	        'f#': 6,
	        'fx': 7,
	        'gbb': 5,
	        'gb': 6,
	        'g': 7,
	        'g#': 8,
	        'gx': 9,
	        'abb': 7,
	        'ab': 8,
	        'a': 9,
	        'a#': 10,
	        'ax': 11,
	        'bbb': 9,
	        'bb': 10,
	        'b': 11,
	        'b#': 12,
	        'bx': 13
	    };
	    /**
		 *  scale index to note (sharps)
		 *  @type  {Array}
		 */
	    var scaleIndexToNote = [
	        'C',
	        'C#',
	        'D',
	        'D#',
	        'E',
	        'F',
	        'F#',
	        'G',
	        'G#',
	        'A',
	        'A#',
	        'B'
	    ];
	    /**
		 *  The [concert pitch](https://en.wikipedia.org/wiki/Concert_pitch)
		 *  A4's values in Hertz.
		 *  @type {Frequency}
		 *  @static
		 */
	    Tone.Frequency.A4 = 440;
	    /**
		 *  Convert a MIDI note to frequency value.
		 *  @param  {MIDI} midi The midi number to convert.
		 *  @return {Frequency} the corresponding frequency value
		 *  @example
		 * tone.midiToFrequency(69); // returns 440
		 */
	    Tone.Frequency.prototype.midiToFrequency = function (midi) {
	        return Tone.Frequency.A4 * Math.pow(2, (midi - 69) / 12);
	    };
	    /**
		 *  Convert a frequency value to a MIDI note.
		 *  @param {Frequency} frequency The value to frequency value to convert.
		 *  @returns  {MIDI}
		 *  @example
		 * tone.midiToFrequency(440); // returns 69
		 */
	    Tone.Frequency.prototype.frequencyToMidi = function (frequency) {
	        return 69 + Math.round(12 * Math.log(frequency / Tone.Frequency.A4) / Math.LN2);
	    };
	    return Tone.Frequency;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.TransportTime is a the time along the Transport's
		 *         timeline. It is similar to Tone.Time, but instead of evaluating
		 *         against the AudioContext's clock, it is evaluated against
		 *         the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).
		 *  @constructor
		 *  @param  {Time}  val    The time value as a number or string
		 *  @param  {String=}  units  Unit values
		 *  @extends {Tone.Time}
		 */
	    Tone.TransportTime = function (val, units) {
	        if (this instanceof Tone.TransportTime) {
	            Tone.Time.call(this, val, units);
	        } else {
	            return new Tone.TransportTime(val, units);
	        }
	    };
	    Tone.extend(Tone.TransportTime, Tone.Time);
	    //clone the expressions so that 
	    //we can add more without modifying the original
	    Tone.TransportTime.prototype._unaryExpressions = Object.create(Tone.Time.prototype._unaryExpressions);
	    /**
		 *  Adds an additional unary expression
		 *  which quantizes values to the next subdivision
		 *  @type {Object}
		 *  @private
		 */
	    Tone.TransportTime.prototype._unaryExpressions.quantize = {
	        regexp: /^@/,
	        method: function (rh) {
	            var subdivision = this._secondsToTicks(rh());
	            var multiple = Math.ceil(Tone.Transport.ticks / subdivision);
	            return this._ticksToUnits(multiple * subdivision);
	        }
	    };
	    /**
		 *  Convert seconds into ticks
		 *  @param {Seconds} seconds
		 *  @return  {Ticks}
		 *  @private
		 */
	    Tone.TransportTime.prototype._secondsToTicks = function (seconds) {
	        var quarterTime = this._beatsToUnits(1);
	        var quarters = seconds / quarterTime;
	        return Math.round(quarters * Tone.Transport.PPQ);
	    };
	    /**
		 *  Evaluate the time expression. Returns values in ticks
		 *  @return {Ticks}
		 */
	    Tone.TransportTime.prototype.valueOf = function () {
	        var val = this._secondsToTicks(this._expr());
	        return val + (this._plusNow ? Tone.Transport.ticks : 0);
	    };
	    /**
		 *  Return the time in ticks.
		 *  @return  {Ticks}
		 */
	    Tone.TransportTime.prototype.toTicks = function () {
	        return this.valueOf();
	    };
	    /**
		 *  Return the time in seconds.
		 *  @return  {Seconds}
		 */
	    Tone.TransportTime.prototype.toSeconds = function () {
	        var val = this._expr();
	        return val + (this._plusNow ? Tone.Transport.seconds : 0);
	    };
	    /**
		 *  Return the time as a frequency value
		 *  @return  {Frequency} 
		 */
	    Tone.TransportTime.prototype.toFrequency = function () {
	        return 1 / this.toSeconds();
	    };
	    return Tone.TransportTime;
	});
	Module(function (Tone) {
	    ///////////////////////////////////////////////////////////////////////////
	    //	TYPES
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 * Units which a value can take on.
		 * @enum {String}
		 */
	    Tone.Type = {
	        /**
			 *  Default units
			 *  @typedef {Default}
			 */
	        Default: 'number',
	        /**
			 *  Time can be described in a number of ways. Read more [Time](https://github.com/Tonejs/Tone.js/wiki/Time).
			 *
			 *  * Numbers, which will be taken literally as the time (in seconds).
			 *  * Notation, ("4n", "8t") describes time in BPM and time signature relative values.
			 *  * TransportTime, ("4:3:2") will also provide tempo and time signature relative times
			 *  in the form BARS:QUARTERS:SIXTEENTHS.
			 *  * Frequency, ("8hz") is converted to the length of the cycle in seconds.
			 *  * Now-Relative, ("+1") prefix any of the above with "+" and it will be interpreted as
			 *  "the current time plus whatever expression follows".
			 *  * Expressions, ("3:0 + 2 - (1m / 7)") any of the above can also be combined
			 *  into a mathematical expression which will be evaluated to compute the desired time.
			 *  * No Argument, for methods which accept time, no argument will be interpreted as
			 *  "now" (i.e. the currentTime).
			 *
			 *  @typedef {Time}
			 */
	        Time: 'time',
	        /**
			 *  Frequency can be described similar to time, except ultimately the
			 *  values are converted to frequency instead of seconds. A number
			 *  is taken literally as the value in hertz. Additionally any of the
			 *  Time encodings can be used. Note names in the form
			 *  of NOTE OCTAVE (i.e. C4) are also accepted and converted to their
			 *  frequency value.
			 *  @typedef {Frequency}
			 */
	        Frequency: 'frequency',
	        /**
			 *  TransportTime describes a position along the Transport's timeline. It is
			 *  similar to Time in that it uses all the same encodings, but TransportTime specifically
			 *  pertains to the Transport's timeline, which is startable, stoppable, loopable, and seekable.
			 *  [Read more](https://github.com/Tonejs/Tone.js/wiki/TransportTime)
			 *  @typedef {TransportTime}
			 */
	        TransportTime: 'transportTime',
	        /**
			 *  Ticks are the basic subunit of the Transport. They are
			 *  the smallest unit of time that the Transport supports.
			 *  @typedef {Ticks}
			 */
	        Ticks: 'ticks',
	        /**
			 *  Normal values are within the range [0, 1].
			 *  @typedef {NormalRange}
			 */
	        NormalRange: 'normalRange',
	        /**
			 *  AudioRange values are between [-1, 1].
			 *  @typedef {AudioRange}
			 */
	        AudioRange: 'audioRange',
	        /**
			 *  Decibels are a logarithmic unit of measurement which is useful for volume
			 *  because of the logarithmic way that we perceive loudness. 0 decibels
			 *  means no change in volume. -10db is approximately half as loud and 10db
			 *  is twice is loud.
			 *  @typedef {Decibels}
			 */
	        Decibels: 'db',
	        /**
			 *  Half-step note increments, i.e. 12 is an octave above the root. and 1 is a half-step up.
			 *  @typedef {Interval}
			 */
	        Interval: 'interval',
	        /**
			 *  Beats per minute.
			 *  @typedef {BPM}
			 */
	        BPM: 'bpm',
	        /**
			 *  The value must be greater than or equal to 0.
			 *  @typedef {Positive}
			 */
	        Positive: 'positive',
	        /**
			 *  Gain is the ratio between input and output of a signal.
			 *  A gain of 0 is the same as silencing the signal. A gain of
			 *  1, causes no change to the incoming signal.
			 *  @typedef {Gain}
			 */
	        Gain: 'gain',
	        /**
			 *  A cent is a hundredth of a semitone.
			 *  @typedef {Cents}
			 */
	        Cents: 'cents',
	        /**
			 *  Angle between 0 and 360.
			 *  @typedef {Degrees}
			 */
	        Degrees: 'degrees',
	        /**
			 *  A number representing a midi note.
			 *  @typedef {MIDI}
			 */
	        MIDI: 'midi',
	        /**
			 *  A colon-separated representation of time in the form of
			 *  Bars:Beats:Sixteenths.
			 *  @typedef {BarsBeatsSixteenths}
			 */
	        BarsBeatsSixteenths: 'barsBeatsSixteenths',
	        /**
			 *  Sampling is the reduction of a continuous signal to a discrete signal.
			 *  Audio is typically sampled 44100 times per second.
			 *  @typedef {Samples}
			 */
	        Samples: 'samples',
	        /**
			 *  Hertz are a frequency representation defined as one cycle per second.
			 *  @typedef {Hertz}
			 */
	        Hertz: 'hertz',
	        /**
			 *  A frequency represented by a letter name,
			 *  accidental and octave. This system is known as
			 *  [Scientific Pitch Notation](https://en.wikipedia.org/wiki/Scientific_pitch_notation).
			 *  @typedef {Note}
			 */
	        Note: 'note',
	        /**
			 *  One millisecond is a thousandth of a second.
			 *  @typedef {Milliseconds}
			 */
	        Milliseconds: 'milliseconds',
	        /**
			 *  Seconds are the time unit of the AudioContext. In the end,
			 *  all values need to be evaluated to seconds.
			 *  @typedef {Seconds}
			 */
	        Seconds: 'seconds',
	        /**
			 *  A string representing a duration relative to a measure.
			 *  * "4n" = quarter note
			 *  * "2m" = two measures
			 *  * "8t" = eighth-note triplet
			 *  @typedef {Notation}
			 */
	        Notation: 'notation'
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    // AUGMENT TONE's PROTOTYPE
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Convert Time into seconds.
		 *
		 *  Unlike the method which it overrides, this takes into account
		 *  transporttime and musical notation.
		 *
		 *  Time : 1.40
		 *  Notation: 4n or 1m or 2t
		 *  Now Relative: +3n
		 *  Math: 3n+16n or even complicated expressions ((3n*2)/6 + 1)
		 *
		 *  @param  {Time} time
		 *  @return {Seconds}
		 */
	    Tone.prototype.toSeconds = function (time) {
	        if (Tone.isNumber(time)) {
	            return time;
	        } else if (Tone.isUndef(time)) {
	            return this.now();
	        } else if (Tone.isString(time)) {
	            return new Tone.Time(time).toSeconds();
	        } else if (time instanceof Tone.TimeBase) {
	            return time.toSeconds();
	        }
	    };
	    /**
		 *  Convert a frequency representation into a number.
		 *  @param  {Frequency} freq
		 *  @return {Hertz}      the frequency in hertz
		 */
	    Tone.prototype.toFrequency = function (freq) {
	        if (Tone.isNumber(freq)) {
	            return freq;
	        } else if (Tone.isString(freq) || Tone.isUndef(freq)) {
	            return new Tone.Frequency(freq).valueOf();
	        } else if (freq instanceof Tone.TimeBase) {
	            return freq.toFrequency();
	        }
	    };
	    /**
		 *  Convert a time representation into ticks.
		 *  @param  {Time} time
		 *  @return {Ticks}  the time in ticks
		 */
	    Tone.prototype.toTicks = function (time) {
	        if (Tone.isNumber(time) || Tone.isString(time)) {
	            return new Tone.TransportTime(time).toTicks();
	        } else if (Tone.isUndef(time)) {
	            return Tone.Transport.ticks;
	        } else if (time instanceof Tone.TimeBase) {
	            return time.toTicks();
	        }
	    };
	    return Tone;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Param wraps the native Web Audio's AudioParam to provide
		 *         additional unit conversion functionality. It also
		 *         serves as a base-class for classes which have a single,
		 *         automatable parameter.
		 *  @extends {Tone.AudioNode}
		 *  @param  {AudioParam}  param  The parameter to wrap.
		 *  @param  {Tone.Type} units The units of the audio param.
		 *  @param  {Boolean} convert If the param should be converted.
		 */
	    Tone.Param = function () {
	        var options = Tone.defaults(arguments, [
	            'param',
	            'units',
	            'convert'
	        ], Tone.Param);
	        Tone.AudioNode.call(this);
	        /**
			 *  The native parameter to control
			 *  @type  {AudioParam}
			 *  @private
			 */
	        this._param = this.input = options.param;
	        /**
			 *  The units of the parameter
			 *  @type {Tone.Type}
			 */
	        this.units = options.units;
	        /**
			 *  If the value should be converted or not
			 *  @type {Boolean}
			 */
	        this.convert = options.convert;
	        /**
			 *  True if the signal value is being overridden by
			 *  a connected signal.
			 *  @readOnly
			 *  @type  {boolean}
			 *  @private
			 */
	        this.overridden = false;
	        /**
			 *  If there is an LFO, this is where it is held.
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfo = null;
	        if (Tone.isObject(options.lfo)) {
	            this.value = options.lfo;
	        } else if (!Tone.isUndef(options.value)) {
	            this.value = options.value;
	        }
	    };
	    Tone.extend(Tone.Param, Tone.AudioNode);
	    /**
		 *  Defaults
		 *  @type  {Object}
		 *  @const
		 */
	    Tone.Param.defaults = {
	        'units': Tone.Type.Default,
	        'convert': true,
	        'param': undefined
	    };
	    /**
		 * The current value of the parameter.
		 * @memberOf Tone.Param#
		 * @type {Number}
		 * @name value
		 */
	    Object.defineProperty(Tone.Param.prototype, 'value', {
	        get: function () {
	            return this._toUnits(this._param.value);
	        },
	        set: function (value) {
	            if (Tone.isObject(value)) {
	                //throw an error if the LFO needs to be included
	                if (Tone.isUndef(Tone.LFO)) {
	                    throw new Error('Include \'Tone.LFO\' to use an LFO as a Param value.');
	                }
	                //remove the old one
	                if (this._lfo) {
	                    this._lfo.dispose();
	                }
	                this._lfo = new Tone.LFO(value).start();
	                this._lfo.connect(this.input);
	            } else {
	                var convertedVal = this._fromUnits(value);
	                this._param.cancelScheduledValues(0);
	                this._param.value = convertedVal;
	            }
	        }
	    });
	    /**
		 *  Convert the given value from the type specified by Tone.Param.units
		 *  into the destination value (such as Gain or Frequency).
		 *  @private
		 *  @param  {*} val the value to convert
		 *  @return {number}     the number which the value should be set to
		 */
	    Tone.Param.prototype._fromUnits = function (val) {
	        if (this.convert || Tone.isUndef(this.convert)) {
	            switch (this.units) {
	            case Tone.Type.Time:
	                return this.toSeconds(val);
	            case Tone.Type.Frequency:
	                return this.toFrequency(val);
	            case Tone.Type.Decibels:
	                return Tone.dbToGain(val);
	            case Tone.Type.NormalRange:
	                return Math.min(Math.max(val, 0), 1);
	            case Tone.Type.AudioRange:
	                return Math.min(Math.max(val, -1), 1);
	            case Tone.Type.Positive:
	                return Math.max(val, 0);
	            default:
	                return val;
	            }
	        } else {
	            return val;
	        }
	    };
	    /**
		 * Convert the parameters value into the units specified by Tone.Param.units.
		 * @private
		 * @param  {number} val the value to convert
		 * @return {number}
		 */
	    Tone.Param.prototype._toUnits = function (val) {
	        if (this.convert || Tone.isUndef(this.convert)) {
	            switch (this.units) {
	            case Tone.Type.Decibels:
	                return Tone.gainToDb(val);
	            default:
	                return val;
	            }
	        } else {
	            return val;
	        }
	    };
	    /**
		 *  the minimum output value
		 *  @type {Number}
		 *  @private
		 */
	    Tone.Param.prototype._minOutput = 0.00001;
	    /**
		 *  Schedules a parameter value change at the given time.
		 *  @param {*}	value The value to set the signal.
		 *  @param {Time}  time The time when the change should occur.
		 *  @returns {Tone.Param} this
		 *  @example
		 * //set the frequency to "G4" in exactly 1 second from now.
		 * freq.setValueAtTime("G4", "+1");
		 */
	    Tone.Param.prototype.setValueAtTime = function (value, time) {
	        this._param.setValueAtTime(this._fromUnits(value), this.toSeconds(time));
	        return this;
	    };
	    /**
		 *  Creates a schedule point with the current value at the current time.
		 *  This is useful for creating an automation anchor point in order to
		 *  schedule changes from the current value.
		 *
		 *  @param {number=} now (Optionally) pass the now value in.
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.setRampPoint = function (now) {
	        now = Tone.defaultArg(now, this.now());
	        var currentVal = this._param.value;
	        // exponentialRampToValueAt cannot ever ramp from or to 0
	        // More info: https://bugzilla.mozilla.org/show_bug.cgi?id=1125600#c2
	        if (currentVal === 0) {
	            currentVal = this._minOutput;
	        }
	        this._param.setValueAtTime(currentVal, now);
	        return this;
	    };
	    /**
		 *  Schedules a linear continuous change in parameter value from the
		 *  previous scheduled parameter value to the given value.
		 *
		 *  @param  {number} value
		 *  @param  {Time} endTime
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.linearRampToValueAtTime = function (value, endTime) {
	        value = this._fromUnits(value);
	        this._param.linearRampToValueAtTime(value, this.toSeconds(endTime));
	        return this;
	    };
	    /**
		 *  Schedules an exponential continuous change in parameter value from
		 *  the previous scheduled parameter value to the given value.
		 *
		 *  @param  {number} value
		 *  @param  {Time} endTime
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.exponentialRampToValueAtTime = function (value, endTime) {
	        value = this._fromUnits(value);
	        value = Math.max(this._minOutput, value);
	        this._param.exponentialRampToValueAtTime(value, this.toSeconds(endTime));
	        return this;
	    };
	    /**
		 *  Schedules an exponential continuous change in parameter value from
		 *  the current time and current value to the given value over the
		 *  duration of the rampTime.
		 *
		 *  @param  {number} value   The value to ramp to.
		 *  @param  {Time} rampTime the time that it takes the
		 *                               value to ramp from it's current value
		 *  @param {Time}	[startTime=now] 	When the ramp should start.
		 *  @returns {Tone.Param} this
		 *  @example
		 * //exponentially ramp to the value 2 over 4 seconds.
		 * signal.exponentialRampToValue(2, 4);
		 */
	    Tone.Param.prototype.exponentialRampToValue = function (value, rampTime, startTime) {
	        startTime = this.toSeconds(startTime);
	        this.setRampPoint(startTime);
	        this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
	        return this;
	    };
	    /**
		 *  Schedules an linear continuous change in parameter value from
		 *  the current time and current value to the given value over the
		 *  duration of the rampTime.
		 *
		 *  @param  {number} value   The value to ramp to.
		 *  @param  {Time} rampTime the time that it takes the
		 *                               value to ramp from it's current value
		 *  @param {Time}	[startTime=now] 	When the ramp should start.
		 *  @returns {Tone.Param} this
		 *  @example
		 * //linearly ramp to the value 4 over 3 seconds.
		 * signal.linearRampToValue(4, 3);
		 */
	    Tone.Param.prototype.linearRampToValue = function (value, rampTime, startTime) {
	        startTime = this.toSeconds(startTime);
	        this.setRampPoint(startTime);
	        this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
	        return this;
	    };
	    /**
		 *  Start exponentially approaching the target value at the given time with
		 *  a rate having the given time constant.
		 *  @param {number} value
		 *  @param {Time} startTime
		 *  @param {number} timeConstant
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.setTargetAtTime = function (value, startTime, timeConstant) {
	        value = this._fromUnits(value);
	        // The value will never be able to approach without timeConstant > 0.
	        // http://www.w3.org/TR/webaudio/#dfn-setTargetAtTime, where the equation
	        // is described. 0 results in a division by 0.
	        value = Math.max(this._minOutput, value);
	        timeConstant = Math.max(this._minOutput, timeConstant);
	        this._param.setTargetAtTime(value, this.toSeconds(startTime), timeConstant);
	        return this;
	    };
	    /**
		 *  Sets an array of arbitrary parameter values starting at the given time
		 *  for the given duration.
		 *
		 *  @param {Array} values
		 *  @param {Time} startTime
		 *  @param {Time} duration
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.setValueCurveAtTime = function (values, startTime, duration) {
	        duration = this.toSeconds(duration);
	        startTime = this.toSeconds(startTime);
	        this.setValueAtTime(values[0], startTime);
	        var segTime = duration / (values.length - 1);
	        for (var i = 1; i < values.length; i++) {
	            this._param.linearRampToValueAtTime(this._fromUnits(values[i]), startTime + i * segTime);
	        }
	        return this;
	    };
	    /**
		 *  Cancels all scheduled parameter changes with times greater than or
		 *  equal to startTime.
		 *
		 *  @param  {Time} startTime
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.cancelScheduledValues = function (startTime) {
	        this._param.cancelScheduledValues(this.toSeconds(startTime));
	        return this;
	    };
	    /**
		 *  Ramps to the given value over the duration of the rampTime.
		 *  Automatically selects the best ramp type (exponential or linear)
		 *  depending on the `units` of the signal
		 *
		 *  @param  {number} value
		 *  @param  {Time} rampTime 	The time that it takes the
		 *                              value to ramp from it's current value
		 *  @param {Time}	[startTime=now] 	When the ramp should start.
		 *  @returns {Tone.Param} this
		 *  @example
		 * //ramp to the value either linearly or exponentially
		 * //depending on the "units" value of the signal
		 * signal.rampTo(0, 10);
		 *  @example
		 * //schedule it to ramp starting at a specific time
		 * signal.rampTo(0, 10, 5)
		 */
	    Tone.Param.prototype.rampTo = function (value, rampTime, startTime) {
	        rampTime = Tone.defaultArg(rampTime, 0);
	        if (this.units === Tone.Type.Frequency || this.units === Tone.Type.BPM || this.units === Tone.Type.Decibels) {
	            this.exponentialRampToValue(value, rampTime, startTime);
	        } else {
	            this.linearRampToValue(value, rampTime, startTime);
	        }
	        return this;
	    };
	    /**
		 *  The LFO created by the signal instance. If none
		 *  was created, this is null.
		 *  @type {Tone.LFO}
		 *  @readOnly
		 *  @memberOf Tone.Param#
		 *  @name lfo
		 */
	    Object.defineProperty(Tone.Param.prototype, 'lfo', {
	        get: function () {
	            return this._lfo;
	        }
	    });
	    /**
		 *  Clean up
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._param = null;
	        if (this._lfo) {
	            this._lfo.dispose();
	            this._lfo = null;
	        }
	        return this;
	    };
	    return Tone.Param;
	});
	Module(function (Tone) {
	    
	    /**
		 *  createGain shim
		 *  @private
		 */
	    if (window.GainNode && !AudioContext.prototype.createGain) {
	        AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
	    }
	    /**
		 *  @class A thin wrapper around the Native Web Audio GainNode.
		 *         The GainNode is a basic building block of the Web Audio
		 *         API and is useful for routing audio and adjusting gains.
		 *  @extends {Tone}
		 *  @param  {Number=}  gain  The initial gain of the GainNode
		 *  @param {Tone.Type=} units The units of the gain parameter.
		 */
	    Tone.Gain = function () {
	        var options = Tone.defaults(arguments, [
	            'gain',
	            'units'
	        ], Tone.Gain);
	        Tone.AudioNode.call(this);
	        /**
			 *  The GainNode
			 *  @type  {GainNode}
			 *  @private
			 */
	        this.input = this.output = this._gainNode = this.context.createGain();
	        /**
			 *  The gain parameter of the gain node.
			 *  @type {Gain}
			 *  @signal
			 */
	        this.gain = new Tone.Param({
	            'param': this._gainNode.gain,
	            'units': options.units,
	            'value': options.gain,
	            'convert': options.convert
	        });
	        this._readOnly('gain');
	    };
	    Tone.extend(Tone.Gain, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Gain.defaults = {
	        'gain': 1,
	        'convert': true
	    };
	    /**
		 *  Clean up.
		 *  @return  {Tone.Gain}  this
		 */
	    Tone.Gain.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._gainNode.disconnect();
	        this._gainNode = null;
	        this._writable('gain');
	        this.gain.dispose();
	        this.gain = null;
	    };
	    return Tone.Gain;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A signal is an audio-rate value. Tone.Signal is a core component of the library.
		 *          Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal
		 *          has all of the methods available to native Web Audio 
		 *          [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)
		 *          as well as additional conveniences. Read more about working with signals 
		 *          [here](https://github.com/Tonejs/Tone.js/wiki/Signals).
		 *
		 *  @constructor
		 *  @extends {Tone.Param}
		 *  @param {Number|AudioParam} [value] Initial value of the signal. If an AudioParam
		 *                                     is passed in, that parameter will be wrapped
		 *                                     and controlled by the Signal. 
		 *  @param {string} [units=Number] unit The units the signal is in. 
		 *  @example
		 * var signal = new Tone.Signal(10);
		 */
	    Tone.Signal = function () {
	        var options = Tone.defaults(arguments, [
	            'value',
	            'units'
	        ], Tone.Signal);
	        var gainNode = Tone.context.createGain();
	        options.param = gainNode.gain;
	        Tone.Param.call(this, options);
	        /**
			 * The node where the constant signal value is scaled.
			 * @type {GainNode}
			 * @private
			 */
	        this.output = gainNode;
	        /**
			 * The node where the value is set.
			 * @type {Tone.Param}
			 * @private
			 */
	        this.input = this._param = this.output.gain;
	        //connect the const output to the node output
	        this.context.getConstant(1).connect(this.output);
	    };
	    Tone.extend(Tone.Signal, Tone.Param);
	    /**
		 *  The default values
		 *  @type  {Object}
		 *  @static
		 *  @const
		 */
	    Tone.Signal.defaults = {
	        'value': 0,
	        'units': Tone.Type.Default,
	        'convert': true
	    };
	    /**
		 *  When signals connect to other signals or AudioParams, 
		 *  they take over the output value of that signal or AudioParam. 
		 *  For all other nodes, the behavior is the same as a default <code>connect</code>. 
		 *
		 *  @override
		 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node 
		 *  @param {number} [outputNumber=0] The output number to connect from.
		 *  @param {number} [inputNumber=0] The input number to connect to.
		 *  @returns {Tone.SignalBase} this
		 *  @method
		 */
	    Tone.Signal.prototype.connect = Tone.SignalBase.prototype.connect;
	    /**
		 *  dispose and disconnect
		 *  @returns {Tone.Signal} this
		 */
	    Tone.Signal.prototype.dispose = function () {
	        Tone.Param.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.Signal;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A signal which adds the method getValueAtTime. 
		 *         Code and inspiration from https://github.com/jsantell/web-audio-automation-timeline
		 *  @extends {Tone.Signal}
		 *  @param {Number=} value The initial value of the signal
		 *  @param {String=} units The conversion units of the signal.
		 */
	    Tone.TimelineSignal = function () {
	        var options = Tone.defaults(arguments, [
	            'value',
	            'units'
	        ], Tone.Signal);
	        Tone.Signal.call(this, options);
	        /**
			 *  The scheduled events
			 *  @type {Tone.Timeline}
			 *  @private
			 */
	        this._events = new Tone.Timeline(100);
	        /**
			 *  The initial scheduled value
			 *  @type {Number}
			 *  @private
			 */
	        this._initial = this._fromUnits(this._param.value);
	        this.value = options.value;
	        //delete the input node so that nothing can overwrite the signal value
	        delete this.input;
	    };
	    Tone.extend(Tone.TimelineSignal, Tone.Signal);
	    /**
		 *  The event types of a schedulable signal.
		 *  @enum {String}
		 *  @private
		 */
	    Tone.TimelineSignal.Type = {
	        Linear: 'linear',
	        Exponential: 'exponential',
	        Target: 'target',
	        Set: 'set'
	    };
	    /**
		 * The current value of the signal. 
		 * @memberOf Tone.TimelineSignal#
		 * @type {Number}
		 * @name value
		 */
	    Object.defineProperty(Tone.TimelineSignal.prototype, 'value', {
	        get: function () {
	            var now = this.now();
	            var val = this.getValueAtTime(now);
	            return this._toUnits(val);
	        },
	        set: function (value) {
	            if (this._events) {
	                var convertedVal = this._fromUnits(value);
	                this._initial = convertedVal;
	                this.cancelScheduledValues();
	                this._param.value = convertedVal;
	            }
	        }
	    });
	    ///////////////////////////////////////////////////////////////////////////
	    //	SCHEDULING
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Schedules a parameter value change at the given time.
		 *  @param {*}	value The value to set the signal.
		 *  @param {Time}  time The time when the change should occur.
		 *  @returns {Tone.TimelineSignal} this
		 *  @example
		 * //set the frequency to "G4" in exactly 1 second from now. 
		 * freq.setValueAtTime("G4", "+1");
		 */
	    Tone.TimelineSignal.prototype.setValueAtTime = function (value, startTime) {
	        value = this._fromUnits(value);
	        startTime = this.toSeconds(startTime);
	        this._events.add({
	            'type': Tone.TimelineSignal.Type.Set,
	            'value': value,
	            'time': startTime
	        });
	        //invoke the original event
	        this._param.setValueAtTime(value, startTime);
	        return this;
	    };
	    /**
		 *  Schedules a linear continuous change in parameter value from the 
		 *  previous scheduled parameter value to the given value.
		 *  
		 *  @param  {number} value   
		 *  @param  {Time} endTime 
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.linearRampToValueAtTime = function (value, endTime) {
	        value = this._fromUnits(value);
	        endTime = this.toSeconds(endTime);
	        this._events.add({
	            'type': Tone.TimelineSignal.Type.Linear,
	            'value': value,
	            'time': endTime
	        });
	        this._param.linearRampToValueAtTime(value, endTime);
	        return this;
	    };
	    /**
		 *  Schedules an exponential continuous change in parameter value from 
		 *  the previous scheduled parameter value to the given value.
		 *  
		 *  @param  {number} value   
		 *  @param  {Time} endTime 
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.exponentialRampToValueAtTime = function (value, endTime) {
	        //get the previous event and make sure it's not starting from 0
	        endTime = this.toSeconds(endTime);
	        var beforeEvent = this._searchBefore(endTime);
	        if (beforeEvent && beforeEvent.value === 0) {
	            //reschedule that event
	            this.setValueAtTime(this._minOutput, beforeEvent.time);
	        }
	        value = this._fromUnits(value);
	        var setValue = Math.max(value, this._minOutput);
	        this._events.add({
	            'type': Tone.TimelineSignal.Type.Exponential,
	            'value': setValue,
	            'time': endTime
	        });
	        //if the ramped to value is 0, make it go to the min output, and then set to 0.
	        if (value < this._minOutput) {
	            this._param.exponentialRampToValueAtTime(this._minOutput, endTime - this.sampleTime);
	            this.setValueAtTime(0, endTime);
	        } else {
	            this._param.exponentialRampToValueAtTime(value, endTime);
	        }
	        return this;
	    };
	    /**
		 *  Start exponentially approaching the target value at the given time with
		 *  a rate having the given time constant.
		 *  @param {number} value        
		 *  @param {Time} startTime    
		 *  @param {number} timeConstant 
		 *  @returns {Tone.TimelineSignal} this 
		 */
	    Tone.TimelineSignal.prototype.setTargetAtTime = function (value, startTime, timeConstant) {
	        value = this._fromUnits(value);
	        value = Math.max(this._minOutput, value);
	        timeConstant = Math.max(this._minOutput, timeConstant);
	        startTime = this.toSeconds(startTime);
	        this._events.add({
	            'type': Tone.TimelineSignal.Type.Target,
	            'value': value,
	            'time': startTime,
	            'constant': timeConstant
	        });
	        this._param.setTargetAtTime(value, startTime, timeConstant);
	        return this;
	    };
	    /**
		 *  Set an array of arbitrary values starting at the given time for the given duration.
		 *  @param {Float32Array} values        
		 *  @param {Time} startTime    
		 *  @param {Time} duration
		 *  @param {NormalRange} [scaling=1] If the values in the curve should be scaled by some value
		 *  @returns {Tone.TimelineSignal} this 
		 */
	    Tone.TimelineSignal.prototype.setValueCurveAtTime = function (values, startTime, duration, scaling) {
	        scaling = Tone.defaultArg(scaling, 1);
	        duration = this.toSeconds(duration);
	        startTime = this.toSeconds(startTime);
	        var segTime = duration / (values.length - 1);
	        this.setValueAtTime(values[0] * scaling, startTime);
	        for (var i = 1; i < values.length; i++) {
	            this.linearRampToValueAtTime(values[i] * scaling, startTime + i * segTime);
	        }
	        return this;
	    };
	    /**
		 *  Cancels all scheduled parameter changes with times greater than or 
		 *  equal to startTime.
		 *  
		 *  @param  {Time} startTime
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.cancelScheduledValues = function (after) {
	        after = this.toSeconds(after);
	        this._events.cancel(after);
	        this._param.cancelScheduledValues(after);
	        return this;
	    };
	    /**
		 *  Sets the computed value at the given time. This provides
		 *  a point from which a linear or exponential curve
		 *  can be scheduled after. Will cancel events after 
		 *  the given time and shorten the currently scheduled
		 *  linear or exponential ramp so that it ends at `time` .
		 *  This is to avoid discontinuities and clicks in envelopes. 
		 *  @param {Time} time When to set the ramp point
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.setRampPoint = function (time) {
	        time = this.toSeconds(time);
	        //get the value at the given time
	        var val = this._toUnits(this.getValueAtTime(time));
	        //if there is an event at the given time
	        //and that even is not a "set"
	        var before = this._searchBefore(time);
	        if (before && before.time === time) {
	            //remove everything after
	            this.cancelScheduledValues(time + this.sampleTime);
	        } else {
	            //reschedule the next event to end at the given time
	            var after = this._searchAfter(time);
	            if (after) {
	                //cancel the next event(s)
	                this.cancelScheduledValues(time);
	                if (after.type === Tone.TimelineSignal.Type.Linear) {
	                    this.linearRampToValueAtTime(val, time);
	                } else if (after.type === Tone.TimelineSignal.Type.Exponential) {
	                    this.exponentialRampToValueAtTime(val, time);
	                }
	            }
	            this.setValueAtTime(val, time);
	        }
	        return this;
	    };
	    /**
		 *  Do a linear ramp to the given value between the start and finish times.
		 *  @param {Number} value The value to ramp to.
		 *  @param {Time} start The beginning anchor point to do the linear ramp
		 *  @param {Time} finish The ending anchor point by which the value of
		 *                       the signal will equal the given value.
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.linearRampToValueBetween = function (value, start, finish) {
	        this.setRampPoint(start);
	        this.linearRampToValueAtTime(value, finish);
	        return this;
	    };
	    /**
		 *  Do a exponential ramp to the given value between the start and finish times.
		 *  @param {Number} value The value to ramp to.
		 *  @param {Time} start The beginning anchor point to do the exponential ramp
		 *  @param {Time} finish The ending anchor point by which the value of
		 *                       the signal will equal the given value.
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.exponentialRampToValueBetween = function (value, start, finish) {
	        this.setRampPoint(start);
	        this.exponentialRampToValueAtTime(value, finish);
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	GETTING SCHEDULED VALUES
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Returns the value before or equal to the given time
		 *  @param  {Number}  time  The time to query
		 *  @return  {Object}  The event at or before the given time.
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._searchBefore = function (time) {
	        return this._events.get(time);
	    };
	    /**
		 *  The event after the given time
		 *  @param  {Number}  time  The time to query.
		 *  @return  {Object}  The next event after the given time
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._searchAfter = function (time) {
	        return this._events.getAfter(time);
	    };
	    /**
		 *  Get the scheduled value at the given time. This will
		 *  return the unconverted (raw) value.
		 *  @param  {Number}  time  The time in seconds.
		 *  @return  {Number}  The scheduled value at the given time.
		 */
	    Tone.TimelineSignal.prototype.getValueAtTime = function (time) {
	        time = this.toSeconds(time);
	        var after = this._searchAfter(time);
	        var before = this._searchBefore(time);
	        var value = this._initial;
	        //if it was set by
	        if (before === null) {
	            value = this._initial;
	        } else if (before.type === Tone.TimelineSignal.Type.Target) {
	            var previous = this._events.getBefore(before.time);
	            var previouVal;
	            if (previous === null) {
	                previouVal = this._initial;
	            } else {
	                previouVal = previous.value;
	            }
	            value = this._exponentialApproach(before.time, previouVal, before.value, before.constant, time);
	        } else if (after === null) {
	            value = before.value;
	        } else if (after.type === Tone.TimelineSignal.Type.Linear) {
	            value = this._linearInterpolate(before.time, before.value, after.time, after.value, time);
	        } else if (after.type === Tone.TimelineSignal.Type.Exponential) {
	            value = this._exponentialInterpolate(before.time, before.value, after.time, after.value, time);
	        } else {
	            value = before.value;
	        }
	        return value;
	    };
	    /**
		 *  When signals connect to other signals or AudioParams, 
		 *  they take over the output value of that signal or AudioParam. 
		 *  For all other nodes, the behavior is the same as a default <code>connect</code>. 
		 *
		 *  @override
		 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node 
		 *  @param {number} [outputNumber=0] The output number to connect from.
		 *  @param {number} [inputNumber=0] The input number to connect to.
		 *  @returns {Tone.TimelineSignal} this
		 *  @method
		 */
	    Tone.TimelineSignal.prototype.connect = Tone.SignalBase.prototype.connect;
	    ///////////////////////////////////////////////////////////////////////////
	    //	AUTOMATION CURVE CALCULATIONS
	    //	MIT License, copyright (c) 2014 Jordan Santell
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Calculates the the value along the curve produced by setTargetAtTime
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._exponentialApproach = function (t0, v0, v1, timeConstant, t) {
	        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);
	    };
	    /**
		 *  Calculates the the value along the curve produced by linearRampToValueAtTime
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._linearInterpolate = function (t0, v0, t1, v1, t) {
	        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));
	    };
	    /**
		 *  Calculates the the value along the curve produced by exponentialRampToValueAtTime
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._exponentialInterpolate = function (t0, v0, t1, v1, t) {
	        v0 = Math.max(this._minOutput, v0);
	        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));
	    };
	    /**
		 *  Clean up.
		 *  @return {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._events.dispose();
	        this._events = null;
	    };
	    return Tone.TimelineSignal;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Pow applies an exponent to the incoming signal. The incoming signal
		 *         must be AudioRange.
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @param {Positive} exp The exponent to apply to the incoming signal, must be at least 2. 
		 *  @example
		 * var pow = new Tone.Pow(2);
		 * var sig = new Tone.Signal(0.5).connect(pow);
		 * //output of pow is 0.25. 
		 */
	    Tone.Pow = function (exp) {
	        Tone.SignalBase.call(this);
	        /**
			 * the exponent
			 * @private
			 * @type {number}
			 */
	        this._exp = Tone.defaultArg(exp, 1);
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._expScaler = this.input = this.output = new Tone.WaveShaper(this._expFunc(this._exp), 8192);
	    };
	    Tone.extend(Tone.Pow, Tone.SignalBase);
	    /**
		 * The value of the exponent.
		 * @memberOf Tone.Pow#
		 * @type {number}
		 * @name value
		 */
	    Object.defineProperty(Tone.Pow.prototype, 'value', {
	        get: function () {
	            return this._exp;
	        },
	        set: function (exp) {
	            this._exp = exp;
	            this._expScaler.setMap(this._expFunc(this._exp));
	        }
	    });
	    /**
		 *  the function which maps the waveshaper
		 *  @param   {number} exp
		 *  @return {function}
		 *  @private
		 */
	    Tone.Pow.prototype._expFunc = function (exp) {
	        return function (val) {
	            return Math.pow(Math.abs(val), exp);
	        };
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Pow} this
		 */
	    Tone.Pow.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._expScaler.dispose();
	        this._expScaler = null;
	        return this;
	    };
	    return Tone.Pow;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)
		 *          envelope generator. Tone.Envelope outputs a signal which
		 *          can be connected to an AudioParam or Tone.Signal.
		 *          <img src="https://upload.wikimedia.org/wikipedia/commons/e/ea/ADSR_parameter.svg">
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Time} [attack] The amount of time it takes for the envelope to go from
		 *                         0 to it's maximum value.
		 *  @param {Time} [decay]	The period of time after the attack that it takes for the envelope
		 *                       	to fall to the sustain value.
		 *  @param {NormalRange} [sustain]	The percent of the maximum value that the envelope rests at until
		 *                                	the release is triggered.
		 *  @param {Time} [release]	The amount of time after the release is triggered it takes to reach 0.
		 *  @example
		 * //an amplitude envelope
		 * var gainNode = Tone.context.createGain();
		 * var env = new Tone.Envelope({
		 * 	"attack" : 0.1,
		 * 	"decay" : 0.2,
		 * 	"sustain" : 1,
		 * 	"release" : 0.8,
		 * });
		 * env.connect(gainNode.gain);
		 */
	    Tone.Envelope = function () {
	        //get all of the defaults
	        var options = Tone.defaults(arguments, [
	            'attack',
	            'decay',
	            'sustain',
	            'release'
	        ], Tone.Envelope);
	        Tone.AudioNode.call(this);
	        /**
			 *  When triggerAttack is called, the attack time is the amount of
			 *  time it takes for the envelope to reach it's maximum value.
			 *  @type {Time}
			 */
	        this.attack = options.attack;
	        /**
			 *  After the attack portion of the envelope, the value will fall
			 *  over the duration of the decay time to it's sustain value.
			 *  @type {Time}
			 */
	        this.decay = options.decay;
	        /**
			 * 	The sustain value is the value
			 * 	which the envelope rests at after triggerAttack is
			 * 	called, but before triggerRelease is invoked.
			 *  @type {NormalRange}
			 */
	        this.sustain = options.sustain;
	        /**
			 *  After triggerRelease is called, the envelope's
			 *  value will fall to it's miminum value over the
			 *  duration of the release time.
			 *  @type {Time}
			 */
	        this.release = options.release;
	        /**
			 *  the next time the envelope is at standby
			 *  @type {number}
			 *  @private
			 */
	        this._attackCurve = 'linear';
	        /**
			 *  the next time the envelope is at standby
			 *  @type {number}
			 *  @private
			 */
	        this._releaseCurve = 'exponential';
	        /**
			 *  the signal
			 *  @type {Tone.TimelineSignal}
			 *  @private
			 */
	        this._sig = this.output = new Tone.TimelineSignal();
	        this._sig.setValueAtTime(0, 0);
	        //set the attackCurve initially
	        this.attackCurve = options.attackCurve;
	        this.releaseCurve = options.releaseCurve;
	    };
	    Tone.extend(Tone.Envelope, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 */
	    Tone.Envelope.defaults = {
	        'attack': 0.01,
	        'decay': 0.1,
	        'sustain': 0.5,
	        'release': 1,
	        'attackCurve': 'linear',
	        'releaseCurve': 'exponential'
	    };
	    /**
		 * Read the current value of the envelope. Useful for
		 * syncronizing visual output to the envelope.
		 * @memberOf Tone.Envelope#
		 * @type {Number}
		 * @name value
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Envelope.prototype, 'value', {
	        get: function () {
	            return this.getValueAtTime(this.now());
	        }
	    });
	    /**
		 * The shape of the attack.
		 * Can be any of these strings:
		 * <ul>
		 *   <li>linear</li>
		 *   <li>exponential</li>
		 *   <li>sine</li>
		 *   <li>cosine</li>
		 *   <li>bounce</li>
		 *   <li>ripple</li>
		 *   <li>step</li>
		 * </ul>
		 * Can also be an array which describes the curve. Values
		 * in the array are evenly subdivided and linearly
		 * interpolated over the duration of the attack.
		 * @memberOf Tone.Envelope#
		 * @type {String|Array}
		 * @name attackCurve
		 * @example
		 * env.attackCurve = "linear";
		 * @example
		 * //can also be an array
		 * env.attackCurve = [0, 0.2, 0.3, 0.4, 1]
		 */
	    Object.defineProperty(Tone.Envelope.prototype, 'attackCurve', {
	        get: function () {
	            if (Tone.isString(this._attackCurve)) {
	                return this._attackCurve;
	            } else if (Tone.isArray(this._attackCurve)) {
	                //look up the name in the curves array
	                for (var type in Tone.Envelope.Type) {
	                    if (Tone.Envelope.Type[type].In === this._attackCurve) {
	                        return type;
	                    }
	                }
	                //otherwise just return the array
	                return this._attackCurve;
	            }
	        },
	        set: function (curve) {
	            //check if it's a valid type
	            if (Tone.Envelope.Type.hasOwnProperty(curve)) {
	                var curveDef = Tone.Envelope.Type[curve];
	                if (Tone.isObject(curveDef)) {
	                    this._attackCurve = curveDef.In;
	                } else {
	                    this._attackCurve = curveDef;
	                }
	            } else if (Tone.isArray(curve)) {
	                this._attackCurve = curve;
	            } else {
	                throw new Error('Tone.Envelope: invalid curve: ' + curve);
	            }
	        }
	    });
	    /**
		 * The shape of the release. See the attack curve types.
		 * @memberOf Tone.Envelope#
		 * @type {String|Array}
		 * @name releaseCurve
		 * @example
		 * env.releaseCurve = "linear";
		 */
	    Object.defineProperty(Tone.Envelope.prototype, 'releaseCurve', {
	        get: function () {
	            if (Tone.isString(this._releaseCurve)) {
	                return this._releaseCurve;
	            } else if (Tone.isArray(this._releaseCurve)) {
	                //look up the name in the curves array
	                for (var type in Tone.Envelope.Type) {
	                    if (Tone.Envelope.Type[type].Out === this._releaseCurve) {
	                        return type;
	                    }
	                }
	                //otherwise just return the array
	                return this._releaseCurve;
	            }
	        },
	        set: function (curve) {
	            //check if it's a valid type
	            if (Tone.Envelope.Type.hasOwnProperty(curve)) {
	                var curveDef = Tone.Envelope.Type[curve];
	                if (Tone.isObject(curveDef)) {
	                    this._releaseCurve = curveDef.Out;
	                } else {
	                    this._releaseCurve = curveDef;
	                }
	            } else if (Tone.isArray(curve)) {
	                this._releaseCurve = curve;
	            } else {
	                throw new Error('Tone.Envelope: invalid curve: ' + curve);
	            }
	        }
	    });
	    /**
		 *  Trigger the attack/decay portion of the ADSR envelope.
		 *  @param  {Time} [time=now] When the attack should start.
		 *  @param {NormalRange} [velocity=1] The velocity of the envelope scales the vales.
		 *                               number between 0-1
		 *  @returns {Tone.Envelope} this
		 *  @example
		 *  //trigger the attack 0.5 seconds from now with a velocity of 0.2
		 *  env.triggerAttack("+0.5", 0.2);
		 */
	    Tone.Envelope.prototype.triggerAttack = function (time, velocity) {
	        time = this.toSeconds(time);
	        var originalAttack = this.toSeconds(this.attack);
	        var attack = originalAttack;
	        var decay = this.toSeconds(this.decay);
	        velocity = Tone.defaultArg(velocity, 1);
	        //check if it's not a complete attack
	        var currentValue = this.getValueAtTime(time);
	        if (currentValue > 0) {
	            //subtract the current value from the attack time
	            var attackRate = 1 / attack;
	            var remainingDistance = 1 - currentValue;
	            //the attack is now the remaining time
	            attack = remainingDistance / attackRate;
	        }
	        //attack
	        if (this._attackCurve === 'linear') {
	            this._sig.linearRampToValue(velocity, attack, time);
	        } else if (this._attackCurve === 'exponential') {
	            this._sig.exponentialRampToValue(velocity, attack, time);
	        } else if (attack > 0) {
	            this._sig.setRampPoint(time);
	            var curve = this._attackCurve;
	            //take only a portion of the curve
	            if (attack < originalAttack) {
	                var percentComplete = 1 - attack / originalAttack;
	                var sliceIndex = Math.floor(percentComplete * this._attackCurve.length);
	                curve = this._attackCurve.slice(sliceIndex);
	                //the first index is the current value
	                curve[0] = currentValue;
	            }
	            this._sig.setValueCurveAtTime(curve, time, attack, velocity);
	        }
	        //decay
	        this._sig.exponentialRampToValue(velocity * this.sustain, decay, attack + time);
	        return this;
	    };
	    /**
		 *  Triggers the release of the envelope.
		 *  @param  {Time} [time=now] When the release portion of the envelope should start.
		 *  @returns {Tone.Envelope} this
		 *  @example
		 *  //trigger release immediately
		 *  env.triggerRelease();
		 */
	    Tone.Envelope.prototype.triggerRelease = function (time) {
	        time = this.toSeconds(time);
	        var currentValue = this.getValueAtTime(time);
	        if (currentValue > 0) {
	            var release = this.toSeconds(this.release);
	            if (this._releaseCurve === 'linear') {
	                this._sig.linearRampToValue(0, release, time);
	            } else if (this._releaseCurve === 'exponential') {
	                this._sig.exponentialRampToValue(0, release, time);
	            } else {
	                var curve = this._releaseCurve;
	                if (Tone.isArray(curve)) {
	                    this._sig.setRampPoint(time);
	                    this._sig.setValueCurveAtTime(curve, time, release, currentValue);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Get the scheduled value at the given time. This will
		 *  return the unconverted (raw) value.
		 *  @param  {Number}  time  The time in seconds.
		 *  @return  {Number}  The scheduled value at the given time.
		 */
	    Tone.Envelope.prototype.getValueAtTime = function (time) {
	        return this._sig.getValueAtTime(time);
	    };
	    /**
		 *  triggerAttackRelease is shorthand for triggerAttack, then waiting
		 *  some duration, then triggerRelease.
		 *  @param {Time} duration The duration of the sustain.
		 *  @param {Time} [time=now] When the attack should be triggered.
		 *  @param {number} [velocity=1] The velocity of the envelope.
		 *  @returns {Tone.Envelope} this
		 *  @example
		 * //trigger the attack and then the release after 0.6 seconds.
		 * env.triggerAttackRelease(0.6);
		 */
	    Tone.Envelope.prototype.triggerAttackRelease = function (duration, time, velocity) {
	        time = this.toSeconds(time);
	        this.triggerAttack(time, velocity);
	        this.triggerRelease(time + this.toSeconds(duration));
	        return this;
	    };
	    /**
		 *  Cancels all scheduled envelope changes after the given time.
		 *  @param  {Time} after
		 *  @returns {Tone.Envelope} this
		 */
	    Tone.Envelope.prototype.cancel = function (after) {
	        this._sig.cancelScheduledValues(after);
	        return this;
	    };
	    /**
		 *  Borrows the connect method from Tone.Signal.
		 *  @function
		 *  @private
		 */
	    Tone.Envelope.prototype.connect = Tone.Signal.prototype.connect;
	    /**
	 	 *  Generate some complex envelope curves.
	 	 */
	    (function _createCurves() {
	        var curveLen = 128;
	        var i, k;
	        //cosine curve
	        var cosineCurve = [];
	        for (i = 0; i < curveLen; i++) {
	            cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));
	        }
	        //ripple curve
	        var rippleCurve = [];
	        var rippleCurveFreq = 6.4;
	        for (i = 0; i < curveLen - 1; i++) {
	            k = i / (curveLen - 1);
	            var sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;
	            rippleCurve[i] = sineWave / 10 + k * 0.83;
	        }
	        rippleCurve[curveLen - 1] = 1;
	        //stairs curve
	        var stairsCurve = [];
	        var steps = 5;
	        for (i = 0; i < curveLen; i++) {
	            stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;
	        }
	        //in-out easing curve
	        var sineCurve = [];
	        for (i = 0; i < curveLen; i++) {
	            k = i / (curveLen - 1);
	            sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));
	        }
	        //a bounce curve
	        var bounceCurve = [];
	        for (i = 0; i < curveLen; i++) {
	            k = i / (curveLen - 1);
	            var freq = Math.pow(k, 3) * 4 + 0.2;
	            var val = Math.cos(freq * Math.PI * 2 * k);
	            bounceCurve[i] = Math.abs(val * (1 - k));
	        }
	        /**
			 *  Invert a value curve to make it work for the release
			 *  @private
			 */
	        function invertCurve(curve) {
	            var out = new Array(curve.length);
	            for (var j = 0; j < curve.length; j++) {
	                out[j] = 1 - curve[j];
	            }
	            return out;
	        }
	        /**
			 *  reverse the curve
			 *  @private
			 */
	        function reverseCurve(curve) {
	            return curve.slice(0).reverse();
	        }
	        /**
			 *  attack and release curve arrays
			 *  @type  {Object}
			 *  @private
			 */
	        Tone.Envelope.Type = {
	            'linear': 'linear',
	            'exponential': 'exponential',
	            'bounce': {
	                In: invertCurve(bounceCurve),
	                Out: bounceCurve
	            },
	            'cosine': {
	                In: cosineCurve,
	                Out: reverseCurve(cosineCurve)
	            },
	            'step': {
	                In: stairsCurve,
	                Out: invertCurve(stairsCurve)
	            },
	            'ripple': {
	                In: rippleCurve,
	                Out: invertCurve(rippleCurve)
	            },
	            'sine': {
	                In: sineCurve,
	                Out: invertCurve(sineCurve)
	            }
	        };
	    }());
	    /**
		 *  Disconnect and dispose.
		 *  @returns {Tone.Envelope} this
		 */
	    Tone.Envelope.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._sig.dispose();
	        this._sig = null;
	        this._attackCurve = null;
	        this._releaseCurve = null;
	        return this;
	    };
	    return Tone.Envelope;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.AmplitudeEnvelope is a Tone.Envelope connected to a gain node.
		 *          Unlike Tone.Envelope, which outputs the envelope's value, Tone.AmplitudeEnvelope accepts
		 *          an audio signal as the input and will apply the envelope to the amplitude
		 *          of the signal. Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).
		 *
		 *  @constructor
		 *  @extends {Tone.Envelope}
		 *  @param {Time|Object} [attack] The amount of time it takes for the envelope to go from
		 *                               0 to it's maximum value.
		 *  @param {Time} [decay]	The period of time after the attack that it takes for the envelope
		 *                       	to fall to the sustain value.
		 *  @param {NormalRange} [sustain]	The percent of the maximum value that the envelope rests at until
		 *                                	the release is triggered.
		 *  @param {Time} [release]	The amount of time after the release is triggered it takes to reach 0.
		 *  @example
		 * var ampEnv = new Tone.AmplitudeEnvelope({
		 * 	"attack": 0.1,
		 * 	"decay": 0.2,
		 * 	"sustain": 1.0,
		 * 	"release": 0.8
		 * }).toMaster();
		 * //create an oscillator and connect it
		 * var osc = new Tone.Oscillator().connect(ampEnv).start();
		 * //trigger the envelopes attack and release "8t" apart
		 * ampEnv.triggerAttackRelease("8t");
		 */
	    Tone.AmplitudeEnvelope = function () {
	        Tone.Envelope.apply(this, arguments);
	        /**
			 *  the input node
			 *  @type {GainNode}
			 *  @private
			 */
	        this.input = this.output = new Tone.Gain();
	        this._sig.connect(this.output.gain);
	    };
	    Tone.extend(Tone.AmplitudeEnvelope, Tone.Envelope);
	    /**
		 *  Clean up
		 *  @return  {Tone.AmplitudeEnvelope}  this
		 */
	    Tone.AmplitudeEnvelope.prototype.dispose = function () {
	        Tone.Envelope.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.AmplitudeEnvelope;
	});
	Module(function (Tone) {
	    
	    /**
		 *  AnalyserNode.getFloatTimeDomainData polyfill
		 *  @private
		 */
	    if (window.AnalyserNode && !AnalyserNode.prototype.getFloatTimeDomainData) {
	        //referenced https://github.com/mohayonao/get-float-time-domain-data
	        AnalyserNode.prototype.getFloatTimeDomainData = function (array) {
	            var uint8 = new Uint8Array(array.length);
	            this.getByteTimeDomainData(uint8);
	            for (var i = 0; i < uint8.length; i++) {
	                array[i] = (uint8[i] - 128) / 128;
	            }
	        };
	    }
	    /**
		 *  @class  Wrapper around the native Web Audio's
		 *          [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).
		 *          Extracts FFT or Waveform data from the incoming signal.
		 *  @extends {Tone.AudioNode}
		 *  @param {String=} type The return type of the analysis, either "fft", or "waveform".
		 *  @param {Number=} size The size of the FFT. Value must be a power of
		 *                       two in the range 32 to 32768.
		 */
	    Tone.Analyser = function () {
	        var options = Tone.defaults(arguments, [
	            'type',
	            'size'
	        ], Tone.Analyser);
	        Tone.AudioNode.call(this);
	        /**
			 *  The analyser node.
			 *  @private
			 *  @type {AnalyserNode}
			 */
	        this._analyser = this.input = this.output = this.context.createAnalyser();
	        /**
			 *  The analysis type
			 *  @type {String}
			 *  @private
			 */
	        this._type = options.type;
	        /**
			 *  The buffer that the FFT data is written to
			 *  @type {TypedArray}
			 *  @private
			 */
	        this._buffer = null;
	        //set the values initially
	        this.size = options.size;
	        this.type = options.type;
	    };
	    Tone.extend(Tone.Analyser, Tone.AudioNode);
	    /**
		 *  The default values.
		 *  @type {Object}
		 *  @const
		 */
	    Tone.Analyser.defaults = {
	        'size': 1024,
	        'type': 'fft',
	        'smoothing': 0.8
	    };
	    /**
		 *  Possible return types of Tone.Analyser.analyse()
		 *  @enum {String}
		 */
	    Tone.Analyser.Type = {
	        Waveform: 'waveform',
	        FFT: 'fft'
	    };
	    /**
		 *  Run the analysis given the current settings and return the
		 *  result as a TypedArray.
		 *  @returns {TypedArray}
		 */
	    Tone.Analyser.prototype.analyse = function () {
	        if (this._type === Tone.Analyser.Type.FFT) {
	            this._analyser.getFloatFrequencyData(this._buffer);
	        } else if (this._type === Tone.Analyser.Type.Waveform) {
	            this._analyser.getFloatTimeDomainData(this._buffer);
	        }
	        return this._buffer;
	    };
	    /**
		 *  The size of analysis. This must be a power of two in the range 32 to 32768.
		 *  @memberOf Tone.Analyser#
		 *  @type {Number}
		 *  @name size
		 */
	    Object.defineProperty(Tone.Analyser.prototype, 'size', {
	        get: function () {
	            return this._analyser.frequencyBinCount;
	        },
	        set: function (size) {
	            this._analyser.fftSize = size * 2;
	            this._buffer = new Float32Array(size);
	        }
	    });
	    /**
		 *  The analysis function returned by Tone.Analyser.analyse(), either "fft" or "waveform".
		 *  @memberOf Tone.Analyser#
		 *  @type {String}
		 *  @name type
		 */
	    Object.defineProperty(Tone.Analyser.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            if (type !== Tone.Analyser.Type.Waveform && type !== Tone.Analyser.Type.FFT) {
	                throw new TypeError('Tone.Analyser: invalid type: ' + type);
	            }
	            this._type = type;
	        }
	    });
	    /**
		 *  0 represents no time averaging with the last analysis frame.
		 *  @memberOf Tone.Analyser#
		 *  @type {NormalRange}
		 *  @name smoothing
		 */
	    Object.defineProperty(Tone.Analyser.prototype, 'smoothing', {
	        get: function () {
	            return this._analyser.smoothingTimeConstant;
	        },
	        set: function (val) {
	            this._analyser.smoothingTimeConstant = val;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return  {Tone.Analyser}  this
		 */
	    Tone.Analyser.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._analyser.disconnect();
	        this._analyser = null;
	        this._buffer = null;
	    };
	    return Tone.Analyser;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Compressor is a thin wrapper around the Web Audio
		 *         [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).
		 *         Compression reduces the volume of loud sounds or amplifies quiet sounds
		 *         by narrowing or "compressing" an audio signal's dynamic range.
		 *         Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Decibels|Object} [threshold] The value above which the compression starts to be applied.
		 *  @param {Positive} [ratio] The gain reduction ratio.
		 *  @example
		 * var comp = new Tone.Compressor(-30, 3);
		 */
	    Tone.Compressor = function () {
	        var options = Tone.defaults(arguments, [
	            'threshold',
	            'ratio'
	        ], Tone.Compressor);
	        Tone.AudioNode.call(this);
	        /**
			 *  the compressor node
			 *  @type {DynamicsCompressorNode}
			 *  @private
			 */
	        this._compressor = this.input = this.output = this.context.createDynamicsCompressor();
	        /**
			 *  the threshold vaue
			 *  @type {Decibels}
			 *  @signal
			 */
	        this.threshold = new Tone.Param({
	            'param': this._compressor.threshold,
	            'units': Tone.Type.Decibels,
	            'convert': false
	        });
	        /**
			 *  The attack parameter
			 *  @type {Time}
			 *  @signal
			 */
	        this.attack = new Tone.Param(this._compressor.attack, Tone.Type.Time);
	        /**
			 *  The release parameter
			 *  @type {Time}
			 *  @signal
			 */
	        this.release = new Tone.Param(this._compressor.release, Tone.Type.Time);
	        /**
			 *  The knee parameter
			 *  @type {Decibels}
			 *  @signal
			 */
	        this.knee = new Tone.Param({
	            'param': this._compressor.knee,
	            'units': Tone.Type.Decibels,
	            'convert': false
	        });
	        /**
			 *  The ratio value
			 *  @type {Number}
			 *  @signal
			 */
	        this.ratio = new Tone.Param({
	            'param': this._compressor.ratio,
	            'convert': false
	        });
	        //set the defaults
	        this._readOnly([
	            'knee',
	            'release',
	            'attack',
	            'ratio',
	            'threshold'
	        ]);
	        this.set(options);
	    };
	    Tone.extend(Tone.Compressor, Tone.AudioNode);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Compressor.defaults = {
	        'ratio': 12,
	        'threshold': -24,
	        'release': 0.25,
	        'attack': 0.003,
	        'knee': 30
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.Compressor} this
		 */
	    Tone.Compressor.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'knee',
	            'release',
	            'attack',
	            'ratio',
	            'threshold'
	        ]);
	        this._compressor.disconnect();
	        this._compressor = null;
	        this.attack.dispose();
	        this.attack = null;
	        this.release.dispose();
	        this.release = null;
	        this.threshold.dispose();
	        this.threshold = null;
	        this.ratio.dispose();
	        this.ratio = null;
	        this.knee.dispose();
	        this.knee = null;
	        return this;
	    };
	    return Tone.Compressor;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Add a signal and a number or two signals. When no value is
		 *         passed into the constructor, Tone.Add will sum <code>input[0]</code>
		 *         and <code>input[1]</code>. If a value is passed into the constructor, 
		 *         the it will be added to the input.
		 *  
		 *  @constructor
		 *  @extends {Tone.Signal}
		 *  @param {number=} value If no value is provided, Tone.Add will sum the first
		 *                         and second inputs. 
		 *  @example
		 * var signal = new Tone.Signal(2);
		 * var add = new Tone.Add(2);
		 * signal.connect(add);
		 * //the output of add equals 4
		 *  @example
		 * //if constructed with no arguments
		 * //it will add the first and second inputs
		 * var add = new Tone.Add();
		 * var sig0 = new Tone.Signal(3).connect(add, 0, 0);
		 * var sig1 = new Tone.Signal(4).connect(add, 0, 1);
		 * //the output of add equals 7. 
		 */
	    Tone.Add = function (value) {
	        Tone.Signal.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  the summing node
			 *  @type {GainNode}
			 *  @private
			 */
	        this._sum = this.input[0] = this.input[1] = this.output = new Tone.Gain();
	        /**
			 *  @private
			 *  @type {Tone.Signal}
			 */
	        this._param = this.input[1] = new Tone.Signal(value);
	        this._param.connect(this._sum);
	    };
	    Tone.extend(Tone.Add, Tone.Signal);
	    /**
		 *  Clean up.
		 *  @returns {Tone.Add} this
		 */
	    Tone.Add.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._sum.dispose();
	        this._sum = null;
	        return this;
	    };
	    return Tone.Add;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Multiply two incoming signals. Or, if a number is given in the constructor, 
		 *          multiplies the incoming signal by that value. 
		 *
		 *  @constructor
		 *  @extends {Tone.Signal}
		 *  @param {number=} value Constant value to multiple. If no value is provided,
		 *                         it will return the product of the first and second inputs
		 *  @example
		 * var mult = new Tone.Multiply();
		 * var sigA = new Tone.Signal(3);
		 * var sigB = new Tone.Signal(4);
		 * sigA.connect(mult, 0, 0);
		 * sigB.connect(mult, 0, 1);
		 * //output of mult is 12.
		 *  @example
		 * var mult = new Tone.Multiply(10);
		 * var sig = new Tone.Signal(2).connect(mult);
		 * //the output of mult is 20. 
		 */
	    Tone.Multiply = function (value) {
	        Tone.Signal.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  the input node is the same as the output node
			 *  it is also the GainNode which handles the scaling of incoming signal
			 *  
			 *  @type {GainNode}
			 *  @private
			 */
	        this._mult = this.input[0] = this.output = new Tone.Gain();
	        /**
			 *  the scaling parameter
			 *  @type {AudioParam}
			 *  @private
			 */
	        this._param = this.input[1] = this.output.gain;
	        this._param.value = Tone.defaultArg(value, 0);
	    };
	    Tone.extend(Tone.Multiply, Tone.Signal);
	    /**
		 *  clean up
		 *  @returns {Tone.Multiply} this
		 */
	    Tone.Multiply.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._mult.dispose();
	        this._mult = null;
	        this._param = null;
	        return this;
	    };
	    return Tone.Multiply;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Negate the incoming signal. i.e. an input signal of 10 will output -10
		 *
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @example
		 * var neg = new Tone.Negate();
		 * var sig = new Tone.Signal(-2).connect(neg);
		 * //output of neg is positive 2. 
		 */
	    Tone.Negate = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  negation is done by multiplying by -1
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._multiply = this.input = this.output = new Tone.Multiply(-1);
	    };
	    Tone.extend(Tone.Negate, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @returns {Tone.Negate} this
		 */
	    Tone.Negate.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._multiply.dispose();
	        this._multiply = null;
	        return this;
	    };
	    return Tone.Negate;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Subtract the signal connected to <code>input[1]</code> from the signal connected 
		 *         to <code>input[0]</code>. If an argument is provided in the constructor, the 
		 *         signals <code>.value</code> will be subtracted from the incoming signal.
		 *
		 *  @extends {Tone.Signal}
		 *  @constructor
		 *  @param {number=} value The value to subtract from the incoming signal. If the value
		 *                         is omitted, it will subtract the second signal from the first.
		 *  @example
		 * var sub = new Tone.Subtract(1);
		 * var sig = new Tone.Signal(4).connect(sub);
		 * //the output of sub is 3. 
		 *  @example
		 * var sub = new Tone.Subtract();
		 * var sigA = new Tone.Signal(10);
		 * var sigB = new Tone.Signal(2.5);
		 * sigA.connect(sub, 0, 0);
		 * sigB.connect(sub, 0, 1);
		 * //output of sub is 7.5
		 */
	    Tone.Subtract = function (value) {
	        Tone.Signal.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  the summing node
			 *  @type {GainNode}
			 *  @private
			 */
	        this._sum = this.input[0] = this.output = new Tone.Gain();
	        /**
			 *  negate the input of the second input before connecting it
			 *  to the summing node.
			 *  @type {Tone.Negate}
			 *  @private
			 */
	        this._neg = new Tone.Negate();
	        /**
			 *  the node where the value is set
			 *  @private
			 *  @type {Tone.Signal}
			 */
	        this._param = this.input[1] = new Tone.Signal(value);
	        this._param.chain(this._neg, this._sum);
	    };
	    Tone.extend(Tone.Subtract, Tone.Signal);
	    /**
		 *  Clean up.
		 *  @returns {Tone.SignalBase} this
		 */
	    Tone.Subtract.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._neg.dispose();
	        this._neg = null;
	        this._sum.disconnect();
	        this._sum = null;
	        return this;
	    };
	    return Tone.Subtract;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  GreaterThanZero outputs 1 when the input is strictly greater than zero
		 *  
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @example
		 * var gt0 = new Tone.GreaterThanZero();
		 * var sig = new Tone.Signal(0.01).connect(gt0);
		 * //the output of gt0 is 1. 
		 * sig.value = 0;
		 * //the output of gt0 is 0. 
		 */
	    Tone.GreaterThanZero = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {Tone.WaveShaper}
			 *  @private
			 */
	        this._thresh = this.output = new Tone.WaveShaper(function (val) {
	            if (val <= 0) {
	                return 0;
	            } else {
	                return 1;
	            }
	        }, 127);
	        /**
			 *  scale the first thresholded signal by a large value.
			 *  this will help with values which are very close to 0
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._scale = this.input = new Tone.Multiply(10000);
	        //connections
	        this._scale.connect(this._thresh);
	    };
	    Tone.extend(Tone.GreaterThanZero, Tone.SignalBase);
	    /**
		 *  dispose method
		 *  @returns {Tone.GreaterThanZero} this
		 */
	    Tone.GreaterThanZero.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._scale.dispose();
	        this._scale = null;
	        this._thresh.dispose();
	        this._thresh = null;
	        return this;
	    };
	    return Tone.GreaterThanZero;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Output 1 if the signal is greater than the value, otherwise outputs 0.
		 *          can compare two signals or a signal and a number. 
		 *  
		 *  @constructor
		 *  @extends {Tone.Signal}
		 *  @param {number} [value=0] the value to compare to the incoming signal
		 *  @example
		 * var gt = new Tone.GreaterThan(2);
		 * var sig = new Tone.Signal(4).connect(gt);
		 * //output of gt is equal 1. 
		 */
	    Tone.GreaterThan = function (value) {
	        Tone.Signal.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  subtract the amount from the incoming signal
			 *  @type {Tone.Subtract}
			 *  @private
			 */
	        this._param = this.input[0] = new Tone.Subtract(value);
	        this.input[1] = this._param.input[1];
	        /**
			 *  compare that amount to zero
			 *  @type {Tone.GreaterThanZero}
			 *  @private
			 */
	        this._gtz = this.output = new Tone.GreaterThanZero();
	        //connect
	        this._param.connect(this._gtz);
	    };
	    Tone.extend(Tone.GreaterThan, Tone.Signal);
	    /**
		 *  dispose method
		 *  @returns {Tone.GreaterThan} this
		 */
	    Tone.GreaterThan.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._gtz.dispose();
	        this._gtz = null;
	        return this;
	    };
	    return Tone.GreaterThan;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Return the absolute value of an incoming signal. 
		 *  
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @example
		 * var signal = new Tone.Signal(-1);
		 * var abs = new Tone.Abs();
		 * signal.connect(abs);
		 * //the output of abs is 1. 
		 */
	    Tone.Abs = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {Tone.LessThan}
			 *  @private
			 */
	        this._abs = this.input = this.output = new Tone.WaveShaper(function (val) {
	            if (val === 0) {
	                return 0;
	            } else {
	                return Math.abs(val);
	            }
	        }, 127);
	    };
	    Tone.extend(Tone.Abs, Tone.SignalBase);
	    /**
		 *  dispose method
		 *  @returns {Tone.Abs} this
		 */
	    Tone.Abs.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._abs.dispose();
	        this._abs = null;
	        return this;
	    };
	    return Tone.Abs;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Signal-rate modulo operator. Only works in AudioRange [-1, 1] and for modulus
		 *         values in the NormalRange. 
		 *
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @param {NormalRange} modulus The modulus to apply.
		 *  @example
		 * var mod = new Tone.Modulo(0.2)
		 * var sig = new Tone.Signal(0.5).connect(mod);
		 * //mod outputs 0.1
		 */
	    Tone.Modulo = function (modulus) {
	        Tone.SignalBase.call(this);
	        this.createInsOuts(1, 0);
	        /**
			 *  A waveshaper gets the integer multiple of 
			 *  the input signal and the modulus.
			 *  @private
			 *  @type {Tone.WaveShaper}
			 */
	        this._shaper = new Tone.WaveShaper(Math.pow(2, 16));
	        /**
			 *  the integer multiple is multiplied by the modulus
			 *  @type  {Tone.Multiply}
			 *  @private
			 */
	        this._multiply = new Tone.Multiply();
	        /**
			 *  and subtracted from the input signal
			 *  @type  {Tone.Subtract}
			 *  @private
			 */
	        this._subtract = this.output = new Tone.Subtract();
	        /**
			 *  the modulus signal
			 *  @type  {Tone.Signal}
			 *  @private
			 */
	        this._modSignal = new Tone.Signal(modulus);
	        //connections
	        this.input.fan(this._shaper, this._subtract);
	        this._modSignal.connect(this._multiply, 0, 0);
	        this._shaper.connect(this._multiply, 0, 1);
	        this._multiply.connect(this._subtract, 0, 1);
	        this._setWaveShaper(modulus);
	    };
	    Tone.extend(Tone.Modulo, Tone.SignalBase);
	    /**
		 *  @param  {number}  mod  the modulus to apply
		 *  @private
		 */
	    Tone.Modulo.prototype._setWaveShaper = function (mod) {
	        this._shaper.setMap(function (val) {
	            var multiple = Math.floor((val + 0.0001) / mod);
	            return multiple;
	        });
	    };
	    /**
		 * The modulus value.
		 * @memberOf Tone.Modulo#
		 * @type {NormalRange}
		 * @name value
		 */
	    Object.defineProperty(Tone.Modulo.prototype, 'value', {
	        get: function () {
	            return this._modSignal.value;
	        },
	        set: function (mod) {
	            this._modSignal.value = mod;
	            this._setWaveShaper(mod);
	        }
	    });
	    /**
		 * clean up
		 *  @returns {Tone.Modulo} this
		 */
	    Tone.Modulo.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._shaper.dispose();
	        this._shaper = null;
	        this._multiply.dispose();
	        this._multiply = null;
	        this._subtract.dispose();
	        this._subtract = null;
	        this._modSignal.dispose();
	        this._modSignal = null;
	        return this;
	    };
	    return Tone.Modulo;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1]. 
		 *         See Tone.GainToAudio.
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @example
		 *  var a2g = new Tone.AudioToGain();
		 */
	    Tone.AudioToGain = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {
	            return (x + 1) / 2;
	        });
	    };
	    Tone.extend(Tone.AudioToGain, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @returns {Tone.AudioToGain} this
		 */
	    Tone.AudioToGain.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._norm.dispose();
	        this._norm = null;
	        return this;
	    };
	    return Tone.AudioToGain;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Evaluate an expression at audio rate. <br><br>
		 *         Parsing code modified from https://code.google.com/p/tapdigit/
		 *         Copyright 2011 2012 Ariya Hidayat, New BSD License
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @param {string} expr the expression to generate
		 *  @example
		 * //adds the signals from input[0] and input[1].
		 * var expr = new Tone.Expr("$0 + $1");
		 */
	    Tone.Expr = function () {
	        Tone.SignalBase.call(this);
	        var expr = this._replacements(Array.prototype.slice.call(arguments));
	        var inputCount = this._parseInputs(expr);
	        /**
			 *  hold onto all of the nodes for disposal
			 *  @type {Array}
			 *  @private
			 */
	        this._nodes = [];
	        /**
			 *  The inputs. The length is determined by the expression. 
			 *  @type {Array}
			 */
	        this.input = new Array(inputCount);
	        //create a gain for each input
	        for (var i = 0; i < inputCount; i++) {
	            this.input[i] = this.context.createGain();
	        }
	        //parse the syntax tree
	        var tree = this._parseTree(expr);
	        //evaluate the results
	        var result;
	        try {
	            result = this._eval(tree);
	        } catch (e) {
	            this._disposeNodes();
	            throw new Error('Tone.Expr: Could evaluate expression: ' + expr);
	        }
	        /**
			 *  The output node is the result of the expression
			 *  @type {Tone}
			 */
	        this.output = result;
	    };
	    Tone.extend(Tone.Expr, Tone.SignalBase);
	    //some helpers to cut down the amount of code
	    function applyBinary(Constructor, args, self) {
	        var op = new Constructor();
	        self._eval(args[0]).connect(op, 0, 0);
	        self._eval(args[1]).connect(op, 0, 1);
	        return op;
	    }
	    function applyUnary(Constructor, args, self) {
	        var op = new Constructor();
	        self._eval(args[0]).connect(op, 0, 0);
	        return op;
	    }
	    function getNumber(arg) {
	        return arg ? parseFloat(arg) : undefined;
	    }
	    function literalNumber(arg) {
	        return arg && arg.args ? parseFloat(arg.args) : undefined;
	    }
	    /*
		 *  the Expressions that Tone.Expr can parse.
		 *
		 *  each expression belongs to a group and contains a regexp 
		 *  for selecting the operator as well as that operators method
		 *  
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Expr._Expressions = {
	        //values
	        'value': {
	            'signal': {
	                regexp: /^\d+\.\d+|^\d+/,
	                method: function (arg) {
	                    var sig = new Tone.Signal(getNumber(arg));
	                    return sig;
	                }
	            },
	            'input': {
	                regexp: /^\$\d/,
	                method: function (arg, self) {
	                    return self.input[getNumber(arg.substr(1))];
	                }
	            }
	        },
	        //syntactic glue
	        'glue': {
	            '(': { regexp: /^\(/ },
	            ')': { regexp: /^\)/ },
	            ',': { regexp: /^,/ }
	        },
	        //functions
	        'func': {
	            'abs': {
	                regexp: /^abs/,
	                method: applyUnary.bind(this, Tone.Abs)
	            },
	            'mod': {
	                regexp: /^mod/,
	                method: function (args, self) {
	                    var modulus = literalNumber(args[1]);
	                    var op = new Tone.Modulo(modulus);
	                    self._eval(args[0]).connect(op);
	                    return op;
	                }
	            },
	            'pow': {
	                regexp: /^pow/,
	                method: function (args, self) {
	                    var exp = literalNumber(args[1]);
	                    var op = new Tone.Pow(exp);
	                    self._eval(args[0]).connect(op);
	                    return op;
	                }
	            },
	            'a2g': {
	                regexp: /^a2g/,
	                method: function (args, self) {
	                    var op = new Tone.AudioToGain();
	                    self._eval(args[0]).connect(op);
	                    return op;
	                }
	            }
	        },
	        //binary expressions
	        'binary': {
	            '+': {
	                regexp: /^\+/,
	                precedence: 1,
	                method: applyBinary.bind(this, Tone.Add)
	            },
	            '-': {
	                regexp: /^\-/,
	                precedence: 1,
	                method: function (args, self) {
	                    //both unary and binary op
	                    if (args.length === 1) {
	                        return applyUnary(Tone.Negate, args, self);
	                    } else {
	                        return applyBinary(Tone.Subtract, args, self);
	                    }
	                }
	            },
	            '*': {
	                regexp: /^\*/,
	                precedence: 0,
	                method: applyBinary.bind(this, Tone.Multiply)
	            }
	        },
	        //unary expressions
	        'unary': {
	            '-': {
	                regexp: /^\-/,
	                method: applyUnary.bind(this, Tone.Negate)
	            },
	            '!': {
	                regexp: /^\!/,
	                method: applyUnary.bind(this, Tone.NOT)
	            }
	        }
	    };
	    /**
		 *  @param   {string} expr the expression string
		 *  @return  {number}      the input count
		 *  @private
		 */
	    Tone.Expr.prototype._parseInputs = function (expr) {
	        var inputArray = expr.match(/\$\d/g);
	        var inputMax = 0;
	        if (inputArray !== null) {
	            for (var i = 0; i < inputArray.length; i++) {
	                var inputNum = parseInt(inputArray[i].substr(1)) + 1;
	                inputMax = Math.max(inputMax, inputNum);
	            }
	        }
	        return inputMax;
	    };
	    /**
		 *  @param   {Array} args 	an array of arguments
		 *  @return  {string} the results of the replacements being replaced
		 *  @private
		 */
	    Tone.Expr.prototype._replacements = function (args) {
	        var expr = args.shift();
	        for (var i = 0; i < args.length; i++) {
	            expr = expr.replace(/\%/i, args[i]);
	        }
	        return expr;
	    };
	    /**
		 *  tokenize the expression based on the Expressions object
		 *  @param   {string} expr 
		 *  @return  {Object}      returns two methods on the tokenized list, next and peek
		 *  @private
		 */
	    Tone.Expr.prototype._tokenize = function (expr) {
	        var position = -1;
	        var tokens = [];
	        while (expr.length > 0) {
	            expr = expr.trim();
	            var token = getNextToken(expr);
	            tokens.push(token);
	            expr = expr.substr(token.value.length);
	        }
	        function getNextToken(expr) {
	            for (var type in Tone.Expr._Expressions) {
	                var group = Tone.Expr._Expressions[type];
	                for (var opName in group) {
	                    var op = group[opName];
	                    var reg = op.regexp;
	                    var match = expr.match(reg);
	                    if (match !== null) {
	                        return {
	                            type: type,
	                            value: match[0],
	                            method: op.method
	                        };
	                    }
	                }
	            }
	            throw new SyntaxError('Tone.Expr: Unexpected token ' + expr);
	        }
	        return {
	            next: function () {
	                return tokens[++position];
	            },
	            peek: function () {
	                return tokens[position + 1];
	            }
	        };
	    };
	    /**
		 *  recursively parse the string expression into a syntax tree
		 *  
		 *  @param   {string} expr 
		 *  @return  {Object}
		 *  @private
		 */
	    Tone.Expr.prototype._parseTree = function (expr) {
	        var lexer = this._tokenize(expr);
	        var isUndef = Tone.isUndef.bind(this);
	        function matchSyntax(token, syn) {
	            return !isUndef(token) && token.type === 'glue' && token.value === syn;
	        }
	        function matchGroup(token, groupName, prec) {
	            var ret = false;
	            var group = Tone.Expr._Expressions[groupName];
	            if (!isUndef(token)) {
	                for (var opName in group) {
	                    var op = group[opName];
	                    if (op.regexp.test(token.value)) {
	                        if (!isUndef(prec)) {
	                            if (op.precedence === prec) {
	                                return true;
	                            }
	                        } else {
	                            return true;
	                        }
	                    }
	                }
	            }
	            return ret;
	        }
	        function parseExpression(precedence) {
	            if (isUndef(precedence)) {
	                precedence = 5;
	            }
	            var expr;
	            if (precedence < 0) {
	                expr = parseUnary();
	            } else {
	                expr = parseExpression(precedence - 1);
	            }
	            var token = lexer.peek();
	            while (matchGroup(token, 'binary', precedence)) {
	                token = lexer.next();
	                expr = {
	                    operator: token.value,
	                    method: token.method,
	                    args: [
	                        expr,
	                        parseExpression(precedence - 1)
	                    ]
	                };
	                token = lexer.peek();
	            }
	            return expr;
	        }
	        function parseUnary() {
	            var token, expr;
	            token = lexer.peek();
	            if (matchGroup(token, 'unary')) {
	                token = lexer.next();
	                expr = parseUnary();
	                return {
	                    operator: token.value,
	                    method: token.method,
	                    args: [expr]
	                };
	            }
	            return parsePrimary();
	        }
	        function parsePrimary() {
	            var token, expr;
	            token = lexer.peek();
	            if (isUndef(token)) {
	                throw new SyntaxError('Tone.Expr: Unexpected termination of expression');
	            }
	            if (token.type === 'func') {
	                token = lexer.next();
	                return parseFunctionCall(token);
	            }
	            if (token.type === 'value') {
	                token = lexer.next();
	                return {
	                    method: token.method,
	                    args: token.value
	                };
	            }
	            if (matchSyntax(token, '(')) {
	                lexer.next();
	                expr = parseExpression();
	                token = lexer.next();
	                if (!matchSyntax(token, ')')) {
	                    throw new SyntaxError('Expected )');
	                }
	                return expr;
	            }
	            throw new SyntaxError('Tone.Expr: Parse error, cannot process token ' + token.value);
	        }
	        function parseFunctionCall(func) {
	            var token, args = [];
	            token = lexer.next();
	            if (!matchSyntax(token, '(')) {
	                throw new SyntaxError('Tone.Expr: Expected ( in a function call "' + func.value + '"');
	            }
	            token = lexer.peek();
	            if (!matchSyntax(token, ')')) {
	                args = parseArgumentList();
	            }
	            token = lexer.next();
	            if (!matchSyntax(token, ')')) {
	                throw new SyntaxError('Tone.Expr: Expected ) in a function call "' + func.value + '"');
	            }
	            return {
	                method: func.method,
	                args: args,
	                name: name
	            };
	        }
	        function parseArgumentList() {
	            var token, expr, args = [];
	            while (true) {
	                expr = parseExpression();
	                if (isUndef(expr)) {
	                    // TODO maybe throw exception?
	                    break;
	                }
	                args.push(expr);
	                token = lexer.peek();
	                if (!matchSyntax(token, ',')) {
	                    break;
	                }
	                lexer.next();
	            }
	            return args;
	        }
	        return parseExpression();
	    };
	    /**
		 *  recursively evaluate the expression tree
		 *  @param   {Object} tree 
		 *  @return  {AudioNode}      the resulting audio node from the expression
		 *  @private
		 */
	    Tone.Expr.prototype._eval = function (tree) {
	        if (!Tone.isUndef(tree)) {
	            var node = tree.method(tree.args, this);
	            this._nodes.push(node);
	            return node;
	        }
	    };
	    /**
		 *  dispose all the nodes
		 *  @private
		 */
	    Tone.Expr.prototype._disposeNodes = function () {
	        for (var i = 0; i < this._nodes.length; i++) {
	            var node = this._nodes[i];
	            if (Tone.isFunction(node.dispose)) {
	                node.dispose();
	            } else if (Tone.isFunction(node.disconnect)) {
	                node.disconnect();
	            }
	            node = null;
	            this._nodes[i] = null;
	        }
	        this._nodes = null;
	    };
	    /**
		 *  clean up
		 */
	    Tone.Expr.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._disposeNodes();
	    };
	    return Tone.Expr;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Convert an incoming signal between 0, 1 to an equal power gain scale.
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @example
		 * var eqPowGain = new Tone.EqualPowerGain();
		 */
	    Tone.EqualPowerGain = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {Tone.WaveShaper}
			 *  @private
			 */
	        this._eqPower = this.input = this.output = new Tone.WaveShaper(function (val) {
	            if (Math.abs(val) < 0.001) {
	                //should output 0 when input is 0
	                return 0;
	            } else {
	                return Tone.equalPowerScale(val);
	            }
	        }.bind(this), 4096);
	    };
	    Tone.extend(Tone.EqualPowerGain, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @returns {Tone.EqualPowerGain} this
		 */
	    Tone.EqualPowerGain.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._eqPower.dispose();
	        this._eqPower = null;
	        return this;
	    };
	    return Tone.EqualPowerGain;
	});
	Module(function (Tone) {
	    
	    /**
		 * @class  Tone.Crossfade provides equal power fading between two inputs.
		 *         More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).
		 *
		 * @constructor
		 * @extends {Tone.AudioNode}
		 * @param {NormalRange} [initialFade=0.5]
		 * @example
		 * var crossFade = new Tone.CrossFade(0.5);
		 * //connect effect A to crossfade from
		 * //effect output 0 to crossfade input 0
		 * effectA.connect(crossFade, 0, 0);
		 * //connect effect B to crossfade from
		 * //effect output 0 to crossfade input 1
		 * effectB.connect(crossFade, 0, 1);
		 * crossFade.fade.value = 0;
		 * // ^ only effectA is output
		 * crossFade.fade.value = 1;
		 * // ^ only effectB is output
		 * crossFade.fade.value = 0.5;
		 * // ^ the two signals are mixed equally.
		 */
	    Tone.CrossFade = function (initialFade) {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(2, 1);
	        /**
			 *  Alias for <code>input[0]</code>.
			 *  @type {Tone.Gain}
			 */
	        this.a = this.input[0] = new Tone.Gain();
	        /**
			 *  Alias for <code>input[1]</code>.
			 *  @type {Tone.Gain}
			 */
	        this.b = this.input[1] = new Tone.Gain();
	        /**
			 * 	The mix between the two inputs. A fade value of 0
			 * 	will output 100% <code>input[0]</code> and
			 * 	a value of 1 will output 100% <code>input[1]</code>.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.fade = new Tone.Signal(Tone.defaultArg(initialFade, 0.5), Tone.Type.NormalRange);
	        /**
			 *  equal power gain cross fade
			 *  @private
			 *  @type {Tone.EqualPowerGain}
			 */
	        this._equalPowerA = new Tone.EqualPowerGain();
	        /**
			 *  equal power gain cross fade
			 *  @private
			 *  @type {Tone.EqualPowerGain}
			 */
	        this._equalPowerB = new Tone.EqualPowerGain();
	        /**
			 *  invert the incoming signal
			 *  @private
			 *  @type {Tone}
			 */
	        this._invert = new Tone.Expr('1 - $0');
	        //connections
	        this.a.connect(this.output);
	        this.b.connect(this.output);
	        this.fade.chain(this._equalPowerB, this.b.gain);
	        this.fade.chain(this._invert, this._equalPowerA, this.a.gain);
	        this._readOnly('fade');
	    };
	    Tone.extend(Tone.CrossFade, Tone.AudioNode);
	    /**
		 *  clean up
		 *  @returns {Tone.CrossFade} this
		 */
	    Tone.CrossFade.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable('fade');
	        this._equalPowerA.dispose();
	        this._equalPowerA = null;
	        this._equalPowerB.dispose();
	        this._equalPowerB = null;
	        this.fade.dispose();
	        this.fade = null;
	        this._invert.dispose();
	        this._invert = null;
	        this.a.dispose();
	        this.a = null;
	        this.b.dispose();
	        this.b = null;
	        return this;
	    };
	    return Tone.CrossFade;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Filter is a filter which allows for all of the same native methods
		 *          as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface).
		 *          Tone.Filter has the added ability to set the filter rolloff at -12
		 *          (default), -24 and -48.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Frequency|Object} [frequency] The cutoff frequency of the filter.
		 *  @param {string=} type The type of filter.
		 *  @param {number=} rolloff The drop in decibels per octave after the cutoff frequency.
		 *                            3 choices: -12, -24, and -48
		 *  @example
		 *  var filter = new Tone.Filter(200, "highpass");
		 */
	    Tone.Filter = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type',
	            'rolloff'
	        ], Tone.Filter);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  the filter(s)
			 *  @type {Array}
			 *  @private
			 */
	        this._filters = [];
	        /**
			 *  The cutoff frequency of the filter.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune parameter
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(0, Tone.Type.Cents);
	        /**
			 *  The gain of the filter, only used in certain filter types
			 *  @type {Number}
			 *  @signal
			 */
	        this.gain = new Tone.Signal({
	            'value': options.gain,
	            'convert': false
	        });
	        /**
			 *  The Q or Quality of the filter
			 *  @type {Positive}
			 *  @signal
			 */
	        this.Q = new Tone.Signal(options.Q);
	        /**
			 *  the type of the filter
			 *  @type {string}
			 *  @private
			 */
	        this._type = options.type;
	        /**
			 *  the rolloff value of the filter
			 *  @type {number}
			 *  @private
			 */
	        this._rolloff = options.rolloff;
	        //set the rolloff;
	        this.rolloff = options.rolloff;
	        this._readOnly([
	            'detune',
	            'frequency',
	            'gain',
	            'Q'
	        ]);
	    };
	    Tone.extend(Tone.Filter, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Filter.defaults = {
	        'type': 'lowpass',
	        'frequency': 350,
	        'rolloff': -12,
	        'Q': 1,
	        'gain': 0
	    };
	    /**
		 * The type of the filter. Types: "lowpass", "highpass",
		 * "bandpass", "lowshelf", "highshelf", "notch", "allpass", or "peaking".
		 * @memberOf Tone.Filter#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.Filter.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            var types = [
	                'lowpass',
	                'highpass',
	                'bandpass',
	                'lowshelf',
	                'highshelf',
	                'notch',
	                'allpass',
	                'peaking'
	            ];
	            if (types.indexOf(type) === -1) {
	                throw new TypeError('Tone.Filter: invalid type ' + type);
	            }
	            this._type = type;
	            for (var i = 0; i < this._filters.length; i++) {
	                this._filters[i].type = type;
	            }
	        }
	    });
	    /**
		 * The rolloff of the filter which is the drop in db
		 * per octave. Implemented internally by cascading filters.
		 * Only accepts the values -12, -24, -48 and -96.
		 * @memberOf Tone.Filter#
		 * @type {number}
		 * @name rolloff
		 */
	    Object.defineProperty(Tone.Filter.prototype, 'rolloff', {
	        get: function () {
	            return this._rolloff;
	        },
	        set: function (rolloff) {
	            rolloff = parseInt(rolloff, 10);
	            var possibilities = [
	                -12,
	                -24,
	                -48,
	                -96
	            ];
	            var cascadingCount = possibilities.indexOf(rolloff);
	            //check the rolloff is valid
	            if (cascadingCount === -1) {
	                throw new RangeError('Tone.Filter: rolloff can only be -12, -24, -48 or -96');
	            }
	            cascadingCount += 1;
	            this._rolloff = rolloff;
	            //first disconnect the filters and throw them away
	            this.input.disconnect();
	            for (var i = 0; i < this._filters.length; i++) {
	                this._filters[i].disconnect();
	                this._filters[i] = null;
	            }
	            this._filters = new Array(cascadingCount);
	            for (var count = 0; count < cascadingCount; count++) {
	                var filter = this.context.createBiquadFilter();
	                filter.type = this._type;
	                this.frequency.connect(filter.frequency);
	                this.detune.connect(filter.detune);
	                this.Q.connect(filter.Q);
	                this.gain.connect(filter.gain);
	                this._filters[count] = filter;
	            }
	            //connect them up
	            var connectionChain = [this.input].concat(this._filters).concat([this.output]);
	            Tone.connectSeries.apply(Tone, connectionChain);
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.Filter} this
		 */
	    Tone.Filter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        for (var i = 0; i < this._filters.length; i++) {
	            this._filters[i].disconnect();
	            this._filters[i] = null;
	        }
	        this._filters = null;
	        this._writable([
	            'detune',
	            'frequency',
	            'gain',
	            'Q'
	        ]);
	        this.frequency.dispose();
	        this.Q.dispose();
	        this.frequency = null;
	        this.Q = null;
	        this.detune.dispose();
	        this.detune = null;
	        this.gain.dispose();
	        this.gain = null;
	        return this;
	    };
	    return Tone.Filter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Split the incoming signal into three bands (low, mid, high)
		 *         with two crossover frequency controls.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Frequency|Object} [lowFrequency] the low/mid crossover frequency
		 *  @param {Frequency} [highFrequency] the mid/high crossover frequency
		 */
	    Tone.MultibandSplit = function () {
	        var options = Tone.defaults(arguments, [
	            'lowFrequency',
	            'highFrequency'
	        ], Tone.MultibandSplit);
	        Tone.AudioNode.call(this);
	        /**
			 *  the input
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this.input = new Tone.Gain();
	        /**
			 *  the outputs
			 *  @type {Array}
			 *  @private
			 */
	        this.output = new Array(3);
	        /**
			 *  The low band. Alias for <code>output[0]</code>
			 *  @type {Tone.Filter}
			 */
	        this.low = this.output[0] = new Tone.Filter(0, 'lowpass');
	        /**
			 *  the lower filter of the mid band
			 *  @type {Tone.Filter}
			 *  @private
			 */
	        this._lowMidFilter = new Tone.Filter(0, 'highpass');
	        /**
			 *  The mid band output. Alias for <code>output[1]</code>
			 *  @type {Tone.Filter}
			 */
	        this.mid = this.output[1] = new Tone.Filter(0, 'lowpass');
	        /**
			 *  The high band output. Alias for <code>output[2]</code>
			 *  @type {Tone.Filter}
			 */
	        this.high = this.output[2] = new Tone.Filter(0, 'highpass');
	        /**
			 *  The low/mid crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.lowFrequency = new Tone.Signal(options.lowFrequency, Tone.Type.Frequency);
	        /**
			 *  The mid/high crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.highFrequency = new Tone.Signal(options.highFrequency, Tone.Type.Frequency);
	        /**
			 *  The quality of all the filters
			 *  @type {Number}
			 *  @signal
			 */
	        this.Q = new Tone.Signal(options.Q);
	        this.input.fan(this.low, this.high);
	        this.input.chain(this._lowMidFilter, this.mid);
	        //the frequency control signal
	        this.lowFrequency.connect(this.low.frequency);
	        this.lowFrequency.connect(this._lowMidFilter.frequency);
	        this.highFrequency.connect(this.mid.frequency);
	        this.highFrequency.connect(this.high.frequency);
	        //the Q value
	        this.Q.connect(this.low.Q);
	        this.Q.connect(this._lowMidFilter.Q);
	        this.Q.connect(this.mid.Q);
	        this.Q.connect(this.high.Q);
	        this._readOnly([
	            'high',
	            'mid',
	            'low',
	            'highFrequency',
	            'lowFrequency'
	        ]);
	    };
	    Tone.extend(Tone.MultibandSplit, Tone.AudioNode);
	    /**
		 *  @private
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MultibandSplit.defaults = {
	        'lowFrequency': 400,
	        'highFrequency': 2500,
	        'Q': 1
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.MultibandSplit} this
		 */
	    Tone.MultibandSplit.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'high',
	            'mid',
	            'low',
	            'highFrequency',
	            'lowFrequency'
	        ]);
	        this.low.dispose();
	        this.low = null;
	        this._lowMidFilter.dispose();
	        this._lowMidFilter = null;
	        this.mid.dispose();
	        this.mid = null;
	        this.high.dispose();
	        this.high = null;
	        this.lowFrequency.dispose();
	        this.lowFrequency = null;
	        this.highFrequency.dispose();
	        this.highFrequency = null;
	        this.Q.dispose();
	        this.Q = null;
	        return this;
	    };
	    return Tone.MultibandSplit;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.EQ3 is a three band EQ with control over low, mid, and high gain as
		 *         well as the low and high crossover frequencies.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *
		 *  @param {Decibels|Object} [lowLevel] The gain applied to the lows.
		 *  @param {Decibels} [midLevel] The gain applied to the mid.
		 *  @param {Decibels} [highLevel] The gain applied to the high.
		 *  @example
		 * var eq = new Tone.EQ3(-10, 3, -20);
		 */
	    Tone.EQ3 = function () {
	        var options = Tone.defaults(arguments, [
	            'low',
	            'mid',
	            'high'
	        ], Tone.EQ3);
	        Tone.AudioNode.call(this);
	        /**
			 *  the output node
			 *  @type {GainNode}
			 *  @private
			 */
	        this.output = new Tone.Gain();
	        /**
			 *  the multiband split
			 *  @type {Tone.MultibandSplit}
			 *  @private
			 */
	        this._multibandSplit = this.input = new Tone.MultibandSplit({
	            'lowFrequency': options.lowFrequency,
	            'highFrequency': options.highFrequency
	        });
	        /**
			 *  The gain for the lower signals
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._lowGain = new Tone.Gain(options.low, Tone.Type.Decibels);
	        /**
			 *  The gain for the mid signals
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._midGain = new Tone.Gain(options.mid, Tone.Type.Decibels);
	        /**
			 * The gain in decibels of the high part
			 * @type {Tone.Gain}
			 * @private
			 */
	        this._highGain = new Tone.Gain(options.high, Tone.Type.Decibels);
	        /**
			 * The gain in decibels of the low part
			 * @type {Decibels}
			 * @signal
			 */
	        this.low = this._lowGain.gain;
	        /**
			 * The gain in decibels of the mid part
			 * @type {Decibels}
			 * @signal
			 */
	        this.mid = this._midGain.gain;
	        /**
			 * The gain in decibels of the high part
			 * @type {Decibels}
			 * @signal
			 */
	        this.high = this._highGain.gain;
	        /**
			 *  The Q value for all of the filters.
			 *  @type {Positive}
			 *  @signal
			 */
	        this.Q = this._multibandSplit.Q;
	        /**
			 *  The low/mid crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.lowFrequency = this._multibandSplit.lowFrequency;
	        /**
			 *  The mid/high crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.highFrequency = this._multibandSplit.highFrequency;
	        //the frequency bands
	        this._multibandSplit.low.chain(this._lowGain, this.output);
	        this._multibandSplit.mid.chain(this._midGain, this.output);
	        this._multibandSplit.high.chain(this._highGain, this.output);
	        this._readOnly([
	            'low',
	            'mid',
	            'high',
	            'lowFrequency',
	            'highFrequency'
	        ]);
	    };
	    Tone.extend(Tone.EQ3, Tone.AudioNode);
	    /**
		 *  the default values
		 */
	    Tone.EQ3.defaults = {
	        'low': 0,
	        'mid': 0,
	        'high': 0,
	        'lowFrequency': 400,
	        'highFrequency': 2500
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.EQ3} this
		 */
	    Tone.EQ3.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'low',
	            'mid',
	            'high',
	            'lowFrequency',
	            'highFrequency'
	        ]);
	        this._multibandSplit.dispose();
	        this._multibandSplit = null;
	        this.lowFrequency = null;
	        this.highFrequency = null;
	        this._lowGain.dispose();
	        this._lowGain = null;
	        this._midGain.dispose();
	        this._midGain = null;
	        this._highGain.dispose();
	        this._highGain = null;
	        this.low = null;
	        this.mid = null;
	        this.high = null;
	        this.Q = null;
	        return this;
	    };
	    return Tone.EQ3;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Performs a linear scaling on an input signal.
		 *          Scales a NormalRange input to between
		 *          outputMin and outputMax.
		 *
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @param {number} [outputMin=0] The output value when the input is 0. 
		 *  @param {number} [outputMax=1]	The output value when the input is 1. 
		 *  @example
		 * var scale = new Tone.Scale(50, 100);
		 * var signal = new Tone.Signal(0.5).connect(scale);
		 * //the output of scale equals 75
		 */
	    Tone.Scale = function (outputMin, outputMax) {
	        Tone.SignalBase.call(this);
	        /** 
			 *  @private
			 *  @type {number}
			 */
	        this._outputMin = Tone.defaultArg(outputMin, 0);
	        /** 
			 *  @private
			 *  @type {number}
			 */
	        this._outputMax = Tone.defaultArg(outputMax, 1);
	        /** 
			 *  @private
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._scale = this.input = new Tone.Multiply(1);
	        /** 
			 *  @private
			 *  @type {Tone.Add}
			 *  @private
			 */
	        this._add = this.output = new Tone.Add(0);
	        this._scale.connect(this._add);
	        this._setRange();
	    };
	    Tone.extend(Tone.Scale, Tone.SignalBase);
	    /**
		 * The minimum output value. This number is output when 
		 * the value input value is 0. 
		 * @memberOf Tone.Scale#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.Scale.prototype, 'min', {
	        get: function () {
	            return this._outputMin;
	        },
	        set: function (min) {
	            this._outputMin = min;
	            this._setRange();
	        }
	    });
	    /**
		 * The maximum output value. This number is output when 
		 * the value input value is 1. 
		 * @memberOf Tone.Scale#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.Scale.prototype, 'max', {
	        get: function () {
	            return this._outputMax;
	        },
	        set: function (max) {
	            this._outputMax = max;
	            this._setRange();
	        }
	    });
	    /**
		 *  set the values
		 *  @private
		 */
	    Tone.Scale.prototype._setRange = function () {
	        this._add.value = this._outputMin;
	        this._scale.value = this._outputMax - this._outputMin;
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Scale} this
		 */
	    Tone.Scale.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._add.dispose();
	        this._add = null;
	        this._scale.dispose();
	        this._scale = null;
	        return this;
	    };
	    return Tone.Scale;
	});
	Module(function (Tone) {
	    /**
		 *  @class  Performs an exponential scaling on an input signal.
		 *          Scales a NormalRange value [0,1] exponentially
		 *          to the output range of outputMin to outputMax.
		 *
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @param {number} [outputMin=0] The output value when the input is 0. 
		 *  @param {number} [outputMax=1]	The output value when the input is 1. 
		 *  @param {number} [exponent=2] The exponent which scales the incoming signal.
		 *  @example
		 * var scaleExp = new Tone.ScaleExp(0, 100, 2);
		 * var signal = new Tone.Signal(0.5).connect(scaleExp);
		 */
	    Tone.ScaleExp = function (outputMin, outputMax, exponent) {
	        Tone.SignalBase.call(this);
	        /**
			 *  scale the input to the output range
			 *  @type {Tone.Scale}
			 *  @private
			 */
	        this._scale = this.output = new Tone.Scale(outputMin, outputMax);
	        /**
			 *  @private
			 *  @type {Tone.Pow}
			 *  @private
			 */
	        this._exp = this.input = new Tone.Pow(Tone.defaultArg(exponent, 2));
	        this._exp.connect(this._scale);
	    };
	    Tone.extend(Tone.ScaleExp, Tone.SignalBase);
	    /**
		 * Instead of interpolating linearly between the <code>min</code> and 
		 * <code>max</code> values, setting the exponent will interpolate between
		 * the two values with an exponential curve. 
		 * @memberOf Tone.ScaleExp#
		 * @type {number}
		 * @name exponent
		 */
	    Object.defineProperty(Tone.ScaleExp.prototype, 'exponent', {
	        get: function () {
	            return this._exp.value;
	        },
	        set: function (exp) {
	            this._exp.value = exp;
	        }
	    });
	    /**
		 * The minimum output value. This number is output when 
		 * the value input value is 0. 
		 * @memberOf Tone.ScaleExp#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.ScaleExp.prototype, 'min', {
	        get: function () {
	            return this._scale.min;
	        },
	        set: function (min) {
	            this._scale.min = min;
	        }
	    });
	    /**
		 * The maximum output value. This number is output when 
		 * the value input value is 1. 
		 * @memberOf Tone.ScaleExp#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.ScaleExp.prototype, 'max', {
	        get: function () {
	            return this._scale.max;
	        },
	        set: function (max) {
	            this._scale.max = max;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.ScaleExp} this
		 */
	    Tone.ScaleExp.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._scale.dispose();
	        this._scale = null;
	        this._exp.dispose();
	        this._exp = null;
	        return this;
	    };
	    return Tone.ScaleExp;
	});
	Module(function (Tone) {
	    
	    /**
		 *  createDelay shim
		 *  @private
		 */
	    if (window.DelayNode && !AudioContext.prototype.createDelay) {
	        AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
	    }
	    /**
		 *  @class Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).
		 *  @extends {Tone}
		 *  @param {Time=} delayTime The delay applied to the incoming signal.
		 *  @param {Time=} maxDelay The maximum delay time.
		 */
	    Tone.Delay = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'maxDelay'
	        ], Tone.Delay);
	        Tone.AudioNode.call(this);
	        /**
			 *  The native delay node
			 *  @type {DelayNode}
			 *  @private
			 */
	        this._delayNode = this.input = this.output = this.context.createDelay(this.toSeconds(options.maxDelay));
	        /**
			 *  The amount of time the incoming signal is
			 *  delayed.
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = new Tone.Param({
	            'param': this._delayNode.delayTime,
	            'units': Tone.Type.Time,
	            'value': options.delayTime
	        });
	        this._readOnly('delayTime');
	    };
	    Tone.extend(Tone.Delay, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Delay.defaults = {
	        'maxDelay': 1,
	        'delayTime': 0
	    };
	    /**
		 *  Clean up.
		 *  @return  {Tone.Delay}  this
		 */
	    Tone.Delay.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._delayNode.disconnect();
	        this._delayNode = null;
	        this._writable('delayTime');
	        this.delayTime = null;
	        return this;
	    };
	    return Tone.Delay;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Comb filters are basic building blocks for physical modeling. Read more
		 *         about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Time|Object} [delayTime] The delay time of the filter.
		 *  @param {NormalRange=} resonance The amount of feedback the filter has.
		 */
	    Tone.FeedbackCombFilter = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'resonance'
	        ], Tone.FeedbackCombFilter);
	        Tone.AudioNode.call(this);
	        /**
			 *  the delay node
			 *  @type {DelayNode}
			 *  @private
			 */
	        this._delay = this.input = this.output = new Tone.Delay(options.delayTime);
	        /**
			 *  The amount of delay of the comb filter.
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = this._delay.delayTime;
	        /**
			 *  the feedback node
			 *  @type {GainNode}
			 *  @private
			 */
	        this._feedback = new Tone.Gain(options.resonance, Tone.Type.NormalRange);
	        /**
			 *  The amount of feedback of the delayed signal.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.resonance = this._feedback.gain;
	        this._delay.chain(this._feedback, this._delay);
	        this._readOnly([
	            'resonance',
	            'delayTime'
	        ]);
	    };
	    Tone.extend(Tone.FeedbackCombFilter, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.FeedbackCombFilter.defaults = {
	        'delayTime': 0.1,
	        'resonance': 0.5
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.FeedbackCombFilter} this
		 */
	    Tone.FeedbackCombFilter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'resonance',
	            'delayTime'
	        ]);
	        this._delay.dispose();
	        this._delay = null;
	        this.delayTime = null;
	        this._feedback.dispose();
	        this._feedback = null;
	        this.resonance = null;
	        return this;
	    };
	    return Tone.FeedbackCombFilter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Follower is a  crude envelope follower which will follow
		 *          the amplitude of an incoming signal.
		 *          Take care with small (< 0.02) attack or decay values
		 *          as follower has some ripple which is exaggerated
		 *          at these values. Read more about envelope followers (also known
		 *          as envelope detectors) on [Wikipedia](https://en.wikipedia.org/wiki/Envelope_detector).
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Time|Object} [attack] The rate at which the follower rises.
		 *  @param {Time=} release The rate at which the folower falls.
		 *  @example
		 * var follower = new Tone.Follower(0.2, 0.4);
		 */
	    Tone.Follower = function () {
	        var options = Tone.defaults(arguments, [
	            'attack',
	            'release'
	        ], Tone.Follower);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  @type {Tone.Abs}
			 *  @private
			 */
	        this._abs = new Tone.Abs();
	        /**
			 *  the lowpass filter which smooths the input
			 *  @type {BiquadFilterNode}
			 *  @private
			 */
	        this._filter = this.context.createBiquadFilter();
	        this._filter.type = 'lowpass';
	        this._filter.frequency.value = 0;
	        this._filter.Q.value = -100;
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._frequencyValues = new Tone.WaveShaper();
	        /**
			 *  @type {Tone.Subtract}
			 *  @private
			 */
	        this._sub = new Tone.Subtract();
	        /**
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delay = new Tone.Delay(this.blockTime);
	        /**
			 *  this keeps it far from 0, even for very small differences
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._mult = new Tone.Multiply(10000);
	        /**
			 *  @private
			 *  @type {number}
			 */
	        this._attack = options.attack;
	        /**
			 *  @private
			 *  @type {number}
			 */
	        this._release = options.release;
	        //the smoothed signal to get the values
	        this.input.chain(this._abs, this._filter, this.output);
	        //the difference path
	        this._abs.connect(this._sub, 0, 1);
	        this._filter.chain(this._delay, this._sub);
	        //threshold the difference and use the thresh to set the frequency
	        this._sub.chain(this._mult, this._frequencyValues, this._filter.frequency);
	        //set the attack and release values in the table
	        this._setAttackRelease(this._attack, this._release);
	    };
	    Tone.extend(Tone.Follower, Tone.AudioNode);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Follower.defaults = {
	        'attack': 0.05,
	        'release': 0.5
	    };
	    /**
		 *  sets the attack and release times in the wave shaper
		 *  @param   {Time} attack
		 *  @param   {Time} release
		 *  @private
		 */
	    Tone.Follower.prototype._setAttackRelease = function (attack, release) {
	        var minTime = this.blockTime;
	        attack = Tone.Time(attack).toFrequency();
	        release = Tone.Time(release).toFrequency();
	        attack = Math.max(attack, minTime);
	        release = Math.max(release, minTime);
	        this._frequencyValues.setMap(function (val) {
	            if (val <= 0) {
	                return attack;
	            } else {
	                return release;
	            }
	        });
	    };
	    /**
		 * The attack time.
		 * @memberOf Tone.Follower#
		 * @type {Time}
		 * @name attack
		 */
	    Object.defineProperty(Tone.Follower.prototype, 'attack', {
	        get: function () {
	            return this._attack;
	        },
	        set: function (attack) {
	            this._attack = attack;
	            this._setAttackRelease(this._attack, this._release);
	        }
	    });
	    /**
		 * The release time.
		 * @memberOf Tone.Follower#
		 * @type {Time}
		 * @name release
		 */
	    Object.defineProperty(Tone.Follower.prototype, 'release', {
	        get: function () {
	            return this._release;
	        },
	        set: function (release) {
	            this._release = release;
	            this._setAttackRelease(this._attack, this._release);
	        }
	    });
	    /**
		 *  Borrows the connect method from Signal so that the output can be used
		 *  as a Tone.Signal control signal.
		 *  @function
		 */
	    Tone.Follower.prototype.connect = Tone.Signal.prototype.connect;
	    /**
		 *  dispose
		 *  @returns {Tone.Follower} this
		 */
	    Tone.Follower.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._filter.disconnect();
	        this._filter = null;
	        this._frequencyValues.disconnect();
	        this._frequencyValues = null;
	        this._delay.dispose();
	        this._delay = null;
	        this._sub.disconnect();
	        this._sub = null;
	        this._abs.dispose();
	        this._abs = null;
	        this._mult.dispose();
	        this._mult = null;
	        this._curve = null;
	        return this;
	    };
	    return Tone.Follower;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.ScaledEnvelop is an envelope which can be scaled 
		 *         to any range. It's useful for applying an envelope 
		 *         to a frequency or any other non-NormalRange signal 
		 *         parameter. 
		 *
		 *  @extends {Tone.Envelope}
		 *  @constructor
		 *  @param {Time|Object} [attack]	the attack time in seconds
		 *  @param {Time} [decay]	the decay time in seconds
		 *  @param {number} [sustain] 	a percentage (0-1) of the full amplitude
		 *  @param {Time} [release]	the release time in seconds
		 *  @example
		 *  var scaledEnv = new Tone.ScaledEnvelope({
		 *  	"attack" : 0.2,
		 *  	"min" : 200,
		 *  	"max" : 2000
		 *  });
		 *  scaledEnv.connect(oscillator.frequency);
		 */
	    Tone.ScaledEnvelope = function () {
	        //get all of the defaults
	        var options = Tone.defaults(arguments, [
	            'attack',
	            'decay',
	            'sustain',
	            'release'
	        ], Tone.Envelope);
	        Tone.Envelope.call(this, options);
	        options = Tone.defaultArg(options, Tone.ScaledEnvelope.defaults);
	        /** 
			 *  scale the incoming signal by an exponent
			 *  @type {Tone.Pow}
			 *  @private
			 */
	        this._exp = this.output = new Tone.Pow(options.exponent);
	        /**
			 *  scale the signal to the desired range
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._scale = this.output = new Tone.Scale(options.min, options.max);
	        this._sig.chain(this._exp, this._scale);
	    };
	    Tone.extend(Tone.ScaledEnvelope, Tone.Envelope);
	    /**
		 *  the default parameters
		 *  @static
		 */
	    Tone.ScaledEnvelope.defaults = {
	        'min': 0,
	        'max': 1,
	        'exponent': 1
	    };
	    /**
		 * The envelope's min output value. This is the value which it
		 * starts at. 
		 * @memberOf Tone.ScaledEnvelope#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'min', {
	        get: function () {
	            return this._scale.min;
	        },
	        set: function (min) {
	            this._scale.min = min;
	        }
	    });
	    /**
		 * The envelope's max output value. In other words, the value
		 * at the peak of the attack portion of the envelope. 
		 * @memberOf Tone.ScaledEnvelope#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'max', {
	        get: function () {
	            return this._scale.max;
	        },
	        set: function (max) {
	            this._scale.max = max;
	        }
	    });
	    /**
		 * The envelope's exponent value. 
		 * @memberOf Tone.ScaledEnvelope#
		 * @type {number}
		 * @name exponent
		 */
	    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'exponent', {
	        get: function () {
	            return this._exp.value;
	        },
	        set: function (exp) {
	            this._exp.value = exp;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.ScaledEnvelope} this
		 */
	    Tone.ScaledEnvelope.prototype.dispose = function () {
	        Tone.Envelope.prototype.dispose.call(this);
	        this._scale.dispose();
	        this._scale = null;
	        this._exp.dispose();
	        this._exp = null;
	        return this;
	    };
	    return Tone.ScaledEnvelope;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.FrequencyEnvelope is a Tone.ScaledEnvelope, but instead of `min` and `max`
		 *         it's got a `baseFrequency` and `octaves` parameter. 
		 *
		 *  @extends {Tone.Envelope}
		 *  @constructor
		 *  @param {Time|Object} [attack]	the attack time in seconds
		 *  @param {Time} [decay]	the decay time in seconds
		 *  @param {number} [sustain] 	a percentage (0-1) of the full amplitude
		 *  @param {Time} [release]	the release time in seconds
		 *  @example
		 *  var env = new Tone.FrequencyEnvelope({
		 *  	"attack" : 0.2,
		 *  	"baseFrequency" : "C2",
		 *  	"octaves" : 4
		 *  });
		 *  scaledEnv.connect(oscillator.frequency);
		 */
	    Tone.FrequencyEnvelope = function () {
	        var options = Tone.defaults(arguments, [
	            'attack',
	            'decay',
	            'sustain',
	            'release'
	        ], Tone.Envelope);
	        Tone.ScaledEnvelope.call(this, options);
	        //merge it with the frequency envelope defaults
	        options = Tone.defaultArg(options, Tone.FrequencyEnvelope.defaults);
	        /**
			 *  Stores the octave value
			 *  @type {Positive}
			 *  @private
			 */
	        this._octaves = options.octaves;
	        //setup
	        this.baseFrequency = options.baseFrequency;
	        this.octaves = options.octaves;
	    };
	    Tone.extend(Tone.FrequencyEnvelope, Tone.Envelope);
	    /**
		 *  the default parameters
		 *  @static
		 */
	    Tone.FrequencyEnvelope.defaults = {
	        'baseFrequency': 200,
	        'octaves': 4,
	        'exponent': 2
	    };
	    /**
		 * The envelope's mininum output value. This is the value which it
		 * starts at. 
		 * @memberOf Tone.FrequencyEnvelope#
		 * @type {Frequency}
		 * @name baseFrequency
		 */
	    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'baseFrequency', {
	        get: function () {
	            return this._scale.min;
	        },
	        set: function (min) {
	            this._scale.min = this.toFrequency(min);
	            //also update the octaves
	            this.octaves = this._octaves;
	        }
	    });
	    /**
		 * The number of octaves above the baseFrequency that the
		 * envelope will scale to.
		 * @memberOf Tone.FrequencyEnvelope#
		 * @type {Positive}
		 * @name octaves
		 */
	    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (octaves) {
	            this._octaves = octaves;
	            this._scale.max = this.baseFrequency * Math.pow(2, octaves);
	        }
	    });
	    /**
		 * The envelope's exponent value. 
		 * @memberOf Tone.FrequencyEnvelope#
		 * @type {number}
		 * @name exponent
		 */
	    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'exponent', {
	        get: function () {
	            return this._exp.value;
	        },
	        set: function (exp) {
	            this._exp.value = exp;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.FrequencyEnvelope} this
		 */
	    Tone.FrequencyEnvelope.prototype.dispose = function () {
	        Tone.ScaledEnvelope.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.FrequencyEnvelope;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Gate only passes a signal through when the incoming
		 *          signal exceeds a specified threshold. To do this, Gate uses
		 *          a Tone.Follower to follow the amplitude of the incoming signal.
		 *          A common implementation of this class is a [Noise Gate](https://en.wikipedia.org/wiki/Noise_gate).
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Decibels|Object} [threshold] The threshold above which the gate will open.
		 *  @param {Time=} attack The follower's attack time
		 *  @param {Time=} release The follower's release time
		 *  @example
		 * var gate = new Tone.Gate(-30, 0.2, 0.3).toMaster();
		 * var mic = new Tone.UserMedia().connect(gate);
		 * //the gate will only pass through the incoming
		 * //signal when it's louder than -30db
		 */
	    Tone.Gate = function () {
	        var options = Tone.defaults(arguments, [
	            'threshold',
	            'attack',
	            'release'
	        ], Tone.Gate);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  @type {Tone.Follower}
			 *  @private
			 */
	        this._follower = new Tone.Follower(options.attack, options.release);
	        /**
			 *  @type {Tone.GreaterThan}
			 *  @private
			 */
	        this._gt = new Tone.GreaterThan(Tone.dbToGain(options.threshold));
	        //the connections
	        this.input.connect(this.output);
	        //the control signal
	        this.input.chain(this._gt, this._follower, this.output.gain);
	    };
	    Tone.extend(Tone.Gate, Tone.AudioNode);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Gate.defaults = {
	        'attack': 0.1,
	        'release': 0.1,
	        'threshold': -40
	    };
	    /**
		 * The threshold of the gate in decibels
		 * @memberOf Tone.Gate#
		 * @type {Decibels}
		 * @name threshold
		 */
	    Object.defineProperty(Tone.Gate.prototype, 'threshold', {
	        get: function () {
	            return Tone.gainToDb(this._gt.value);
	        },
	        set: function (thresh) {
	            this._gt.value = Tone.dbToGain(thresh);
	        }
	    });
	    /**
		 * The attack speed of the gate
		 * @memberOf Tone.Gate#
		 * @type {Time}
		 * @name attack
		 */
	    Object.defineProperty(Tone.Gate.prototype, 'attack', {
	        get: function () {
	            return this._follower.attack;
	        },
	        set: function (attackTime) {
	            this._follower.attack = attackTime;
	        }
	    });
	    /**
		 * The release speed of the gate
		 * @memberOf Tone.Gate#
		 * @type {Time}
		 * @name release
		 */
	    Object.defineProperty(Tone.Gate.prototype, 'release', {
	        get: function () {
	            return this._follower.release;
	        },
	        set: function (releaseTime) {
	            this._follower.release = releaseTime;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.Gate} this
		 */
	    Tone.Gate.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._follower.dispose();
	        this._gt.dispose();
	        this._follower = null;
	        this._gt = null;
	        return this;
	    };
	    return Tone.Gate;
	});
	Module(function (Tone) {
	    /**
		 * @class Tone.TickSignal extends Tone.TimelineSignal, but adds the capability
		 *        to calculate the number of elapsed ticks. exponential and target curves
		 *        are approximated with multiple linear ramps.
		 *
		 *        Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos, for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)
		 *        describing integrating timing functions for tempo calculations.
		 *
		 * @param {Number} value The initial value of the signal
		 * @extends {Tone.TimelineSignal}
		 */
	    Tone.TickSignal = function (value) {
	        value = Tone.defaultArg(value, 1);
	        Tone.TimelineSignal.call(this, {
	            'units': Tone.Type.Ticks,
	            'value': value
	        });
	        //extend the memory
	        this._events.memory = Infinity;
	    };
	    Tone.extend(Tone.TickSignal, Tone.TimelineSignal);
	    /**
		 * Wraps Tone.TimelineSignal methods so that they also
		 * record the ticks.
		 * @param  {Function} method
		 * @return {Function}
		 * @private
		 */
	    function _wrapScheduleMethods(method) {
	        return function (value, time) {
	            time = this.toSeconds(time);
	            method.apply(this, arguments);
	            var event = this._events.get(time);
	            var previousEvent = this._events.previousEvent(event);
	            var ticksUntilTime = this._getTickUntilEvent(previousEvent, time - this.sampleTime);
	            event.ticks = Math.max(ticksUntilTime, 0);
	            return this;
	        };
	    }
	    Tone.TickSignal.prototype.setValueAtTime = _wrapScheduleMethods(Tone.TimelineSignal.prototype.setValueAtTime);
	    Tone.TickSignal.prototype.linearRampToValueAtTime = _wrapScheduleMethods(Tone.TimelineSignal.prototype.linearRampToValueAtTime);
	    /**
		 *  Start exponentially approaching the target value at the given time with
		 *  a rate having the given time constant.
		 *  @param {number} value
		 *  @param {Time} startTime
		 *  @param {number} timeConstant
		 *  @returns {Tone.TickSignal} this
		 */
	    Tone.TickSignal.prototype.setTargetAtTime = function (value, time, constant) {
	        //aproximate it with multiple linear ramps
	        time = this.toSeconds(time);
	        this.setRampPoint(time);
	        value = this._fromUnits(value);
	        //start from previously scheduled value
	        var prevEvent = this._events.get(time);
	        var segments = 5;
	        for (var i = 0; i <= segments; i++) {
	            var segTime = constant * i + time;
	            var rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, value, constant, segTime);
	            this.linearRampToValueAtTime(this._toUnits(rampVal), segTime);
	        }
	        return this;
	    };
	    /**
		 *  Schedules an exponential continuous change in parameter value from
		 *  the previous scheduled parameter value to the given value.
		 *  @param  {number} value
		 *  @param  {Time} endTime
		 *  @returns {Tone.TickSignal} this
		 */
	    Tone.TickSignal.prototype.exponentialRampToValueAtTime = function (value, time) {
	        //aproximate it with multiple linear ramps
	        time = this.toSeconds(time);
	        value = this._fromUnits(value);
	        //start from previously scheduled value
	        var prevEvent = this._events.get(time);
	        if (prevEvent === null) {
	            prevEvent = {
	                'value': this._initial,
	                'time': 0
	            };
	        }
	        var segments = 5;
	        var segmentDur = (time - prevEvent.time) / segments;
	        for (var i = 0; i <= segments; i++) {
	            var segTime = segmentDur * i + prevEvent.time;
	            var rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, value, segTime);
	            this.linearRampToValueAtTime(this._toUnits(rampVal), segTime);
	        }
	        return this;
	    };
	    /**
		 * Returns the tick value at the time. Takes into account
		 * any automation curves scheduled on the signal.
		 * @private
		 * @param  {Time} time The time to get the tick count at
		 * @return {Ticks}      The number of ticks which have elapsed at the time
		 *                          given any automations.
		 */
	    Tone.TickSignal.prototype._getTickUntilEvent = function (event, time) {
	        if (event === null) {
	            event = {
	                'ticks': 0,
	                'time': 0
	            };
	        }
	        var val0 = this.getValueAtTime(event.time);
	        var val1 = this.getValueAtTime(time);
	        return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;
	    };
	    /**
		 * Returns the tick value at the time. Takes into account
		 * any automation curves scheduled on the signal.
		 * @param  {Time} time The time to get the tick count at
		 * @return {Ticks}      The number of ticks which have elapsed at the time
		 *                          given any automations.
		 */
	    Tone.TickSignal.prototype.getTickAtTime = function (time) {
	        time = this.toSeconds(time);
	        var event = this._events.get(time);
	        return this._getTickUntilEvent(event, time);
	    };
	    /**
		 * Return the elapsed time of the number of ticks from the given time
		 * @param {Ticks} ticks The number of ticks to calculate
		 * @param  {Time} time The time to get the next tick from
		 * @return {Seconds} The duration of the number of ticks from the given time in seconds
		 */
	    Tone.TickSignal.prototype.getDurationOfTicks = function (ticks, time) {
	        time = this.toSeconds(time);
	        var currentTick = this.getTickAtTime(time);
	        return this.getTimeOfTick(currentTick + ticks) - time;
	    };
	    /**
		 * Given a tick, returns the time that tick occurs at.
		 * @param  {Ticks} tick
		 * @return {Time}      The time that the tick occurs.
		 */
	    Tone.TickSignal.prototype.getTimeOfTick = function (tick) {
	        var before = this._events.get(tick, 'ticks');
	        var after = this._events.getAfter(tick, 'ticks');
	        if (before && before.ticks === tick) {
	            return before.time;
	        } else if (before && after && after.type === Tone.TimelineSignal.Type.Linear && before.value !== after.value) {
	            var val0 = this.getValueAtTime(before.time);
	            var val1 = this.getValueAtTime(after.time);
	            var delta = (val1 - val0) / (after.time - before.time);
	            var k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));
	            var sol1 = (-val0 + k) / delta;
	            var sol2 = (-val0 - k) / delta;
	            return (sol1 > 0 ? sol1 : sol2) + before.time;
	        } else if (before) {
	            if (before.value === 0) {
	                return Infinity;
	            } else {
	                return before.time + (tick - before.ticks) / before.value;
	            }
	        } else {
	            return tick / this._initial;
	        }
	    };
	    return Tone.TickSignal;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A Timeline State. Provides the methods: <code>setStateAtTime("state", time)</code>
		 *          and <code>getValueAtTime(time)</code>.
		 *
		 *  @extends {Tone.Timeline}
		 *  @param {String} initial The initial state of the TimelineState. 
		 *                          Defaults to <code>undefined</code>
		 */
	    Tone.TimelineState = function (initial) {
	        Tone.Timeline.call(this);
	        /**
			 *  The initial state
			 *  @private
			 *  @type {String}
			 */
	        this._initial = initial;
	    };
	    Tone.extend(Tone.TimelineState, Tone.Timeline);
	    /**
		 *  Returns the scheduled state scheduled before or at
		 *  the given time.
		 *  @param  {Number}  time  The time to query.
		 *  @return  {String}  The name of the state input in setStateAtTime.
		 */
	    Tone.TimelineState.prototype.getValueAtTime = function (time) {
	        var event = this.get(time);
	        if (event !== null) {
	            return event.state;
	        } else {
	            return this._initial;
	        }
	    };
	    /**
		 *  Add a state to the timeline.
		 *  @param  {String}  state The name of the state to set.
		 *  @param  {Number}  time  The time to query.
		 *  @returns {Tone.TimelineState} this
		 */
	    Tone.TimelineState.prototype.setStateAtTime = function (state, time) {
	        this.add({
	            'state': state,
	            'time': time
	        });
	        return this;
	    };
	    return Tone.TimelineState;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A sample accurate clock which provides a callback at the given rate. 
		 *          While the callback is not sample-accurate (it is still susceptible to
		 *          loose JS timing), the time passed in as the argument to the callback
		 *          is precise. For most applications, it is better to use Tone.Transport
		 *          instead of the Clock by itself since you can synchronize multiple callbacks.
		 *
		 * 	@constructor
		 *  @extends {Tone.Emitter}
		 * 	@param {function} callback The callback to be invoked with the time of the audio event
		 * 	@param {Frequency} frequency The rate of the callback
		 * 	@example
		 * //the callback will be invoked approximately once a second
		 * //and will print the time exactly once a second apart.
		 * var clock = new Tone.Clock(function(time){
		 * 	console.log(time);
		 * }, 1);
		 */
	    Tone.Clock = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'frequency'
	        ], Tone.Clock);
	        Tone.Emitter.call(this);
	        /**
			 *  The callback function to invoke at the scheduled tick.
			 *  @type  {Function}
			 */
	        this.callback = options.callback;
	        /**
			 *  The next time the callback is scheduled.
			 *  @type {Number}
			 *  @private
			 */
	        this._nextTick = 0;
	        /**
			 *  The last state of the clock.
			 *  @type  {State}
			 *  @private
			 */
	        this._lastState = Tone.State.Stopped;
	        /**
			 *  The rate the callback function should be invoked. 
			 *  @type  {BPM}
			 *  @signal
			 */
	        this.frequency = new Tone.TickSignal(options.frequency, Tone.Type.Frequency);
	        this._readOnly('frequency');
	        /**
			 *  The number of times the callback was invoked. Starts counting at 0
			 *  and increments after the callback was invoked. 
			 *  @type {Ticks}
			 *  @readOnly
			 */
	        this.ticks = 0;
	        /**
			 *  The state timeline
			 *  @type {Tone.TimelineState}
			 *  @private
			 */
	        this._state = new Tone.TimelineState(Tone.State.Stopped);
	        /**
			 *  The loop function bound to its context. 
			 *  This is necessary to remove the event in the end.
			 *  @type {Function}
			 *  @private
			 */
	        this._boundLoop = this._loop.bind(this);
	        //bind a callback to the worker thread
	        this.context.on('tick', this._boundLoop);
	    };
	    Tone.extend(Tone.Clock, Tone.Emitter);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Clock.defaults = {
	        'callback': Tone.noOp,
	        'frequency': 1
	    };
	    /**
		 *  Returns the playback state of the source, either "started", "stopped" or "paused".
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.Clock#
		 *  @name state
		 */
	    Object.defineProperty(Tone.Clock.prototype, 'state', {
	        get: function () {
	            return this._state.getValueAtTime(this.now());
	        }
	    });
	    /**
		 *  Start the clock at the given time. Optionally pass in an offset
		 *  of where to start the tick counter from.
		 *  @param  {Time=}  time    The time the clock should start
		 *  @param  {Ticks=}  offset  Where the tick counter starts counting from.
		 *  @return  {Tone.Clock}  this
		 */
	    Tone.Clock.prototype.start = function (time, offset) {
	        time = this.toSeconds(time);
	        if (this._state.getValueAtTime(time) !== Tone.State.Started) {
	            this._state.setStateAtTime(Tone.State.Started, time);
	            this._state.get(time).offset = offset;
	        }
	        return this;
	    };
	    /**
		 *  Stop the clock. Stopping the clock resets the tick counter to 0.
		 *  @param {Time} [time=now] The time when the clock should stop.
		 *  @returns {Tone.Clock} this
		 *  @example
		 * clock.stop();
		 */
	    Tone.Clock.prototype.stop = function (time) {
	        time = this.toSeconds(time);
	        this._state.cancel(time);
	        this._state.setStateAtTime(Tone.State.Stopped, time);
	        return this;
	    };
	    /**
		 *  Pause the clock. Pausing does not reset the tick counter.
		 *  @param {Time} [time=now] The time when the clock should stop.
		 *  @returns {Tone.Clock} this
		 */
	    Tone.Clock.prototype.pause = function (time) {
	        time = this.toSeconds(time);
	        if (this._state.getValueAtTime(time) === Tone.State.Started) {
	            this._state.setStateAtTime(Tone.State.Paused, time);
	        }
	        return this;
	    };
	    /**
		 *  The scheduling loop.
		 *  @private
		 */
	    Tone.Clock.prototype._loop = function () {
	        //the end of the update interval
	        var endTime = this.now() + this.context.updateInterval;
	        //the current event at the time of the loop
	        var event = this._state.get(endTime);
	        if (event) {
	            //state change events
	            if (event.state !== this._lastState) {
	                this._lastState = event.state;
	                switch (event.state) {
	                case Tone.State.Started:
	                    if (!Tone.isUndef(event.offset)) {
	                        this.ticks = event.offset;
	                    }
	                    this._nextTick = event.time;
	                    this.emit('start', event.time, this.ticks);
	                    break;
	                case Tone.State.Stopped:
	                    this.ticks = 0;
	                    this.emit('stop', event.time);
	                    break;
	                case Tone.State.Paused:
	                    this.emit('pause', event.time);
	                    break;
	                }
	            }
	            //all the tick events
	            while (endTime > this._nextTick && this._state) {
	                var tickTime = this._nextTick;
	                if (this.frequency) {
	                    this._nextTick += this.frequency.getDurationOfTicks(1, this._nextTick);
	                    if (event.state === Tone.State.Started) {
	                        try {
	                            this.callback(tickTime);
	                            this.ticks++;
	                        } catch (e) {
	                            this.ticks++;
	                            throw e;
	                        }
	                    }
	                }
	            }
	        }
	    };
	    /**
		 *  Returns the scheduled state at the given time.
		 *  @param  {Time}  time  The time to query.
		 *  @return  {String}  The name of the state input in setStateAtTime.
		 *  @example
		 * clock.start("+0.1");
		 * clock.getStateAtTime("+0.1"); //returns "started"
		 */
	    Tone.Clock.prototype.getStateAtTime = function (time) {
	        time = this.toSeconds(time);
	        return this._state.getValueAtTime(time);
	    };
	    /**
		 *  Clean up
		 *  @returns {Tone.Clock} this
		 */
	    Tone.Clock.prototype.dispose = function () {
	        Tone.Emitter.prototype.dispose.call(this);
	        this.context.off('tick', this._boundLoop);
	        this._writable('frequency');
	        this.frequency.dispose();
	        this.frequency = null;
	        this._boundLoop = null;
	        this._nextTick = Infinity;
	        this.callback = null;
	        this._state.dispose();
	        this._state = null;
	    };
	    return Tone.Clock;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Similar to Tone.Timeline, but all events represent
		 *         intervals with both "time" and "duration" times. The 
		 *         events are placed in a tree structure optimized
		 *         for querying an intersection point with the timeline
		 *         events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)
		 *         to represent the data.
		 *  @extends {Tone}
		 */
	    Tone.IntervalTimeline = function () {
	        Tone.call(this);
	        /**
			 *  The root node of the inteval tree
			 *  @type  {IntervalNode}
			 *  @private
			 */
	        this._root = null;
	        /**
			 *  Keep track of the length of the timeline.
			 *  @type  {Number}
			 *  @private
			 */
	        this._length = 0;
	    };
	    Tone.extend(Tone.IntervalTimeline);
	    /**
		 *  The event to add to the timeline. All events must 
		 *  have a time and duration value
		 *  @param  {Object}  event  The event to add to the timeline
		 *  @return  {Tone.IntervalTimeline}  this
		 */
	    Tone.IntervalTimeline.prototype.add = function (event) {
	        if (Tone.isUndef(event.time) || Tone.isUndef(event.duration)) {
	            throw new Error('Tone.IntervalTimeline: events must have time and duration parameters');
	        }
	        var node = new IntervalNode(event.time, event.time + event.duration, event);
	        if (this._root === null) {
	            this._root = node;
	        } else {
	            this._root.insert(node);
	        }
	        this._length++;
	        // Restructure tree to be balanced
	        while (node !== null) {
	            node.updateHeight();
	            node.updateMax();
	            this._rebalance(node);
	            node = node.parent;
	        }
	        return this;
	    };
	    /**
		 *  Remove an event from the timeline.
		 *  @param  {Object}  event  The event to remove from the timeline
		 *  @return  {Tone.IntervalTimeline}  this
		 */
	    Tone.IntervalTimeline.prototype.remove = function (event) {
	        if (this._root !== null) {
	            var results = [];
	            this._root.search(event.time, results);
	            for (var i = 0; i < results.length; i++) {
	                var node = results[i];
	                if (node.event === event) {
	                    this._removeNode(node);
	                    this._length--;
	                    break;
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  The number of items in the timeline.
		 *  @type {Number}
		 *  @memberOf Tone.IntervalTimeline#
		 *  @name length
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.IntervalTimeline.prototype, 'length', {
	        get: function () {
	            return this._length;
	        }
	    });
	    /**
		 *  Remove events whose time time is after the given time
		 *  @param  {Number}  time  The time to query.
		 *  @returns {Tone.IntervalTimeline} this
		 */
	    Tone.IntervalTimeline.prototype.cancel = function (after) {
	        this.forEachAfter(after, function (event) {
	            this.remove(event);
	        }.bind(this));
	        return this;
	    };
	    /**
		 *  Set the root node as the given node
		 *  @param {IntervalNode} node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._setRoot = function (node) {
	        this._root = node;
	        if (this._root !== null) {
	            this._root.parent = null;
	        }
	    };
	    /**
		 *  Replace the references to the node in the node's parent
		 *  with the replacement node.
		 *  @param  {IntervalNode}  node        
		 *  @param  {IntervalNode}  replacement 
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._replaceNodeInParent = function (node, replacement) {
	        if (node.parent !== null) {
	            if (node.isLeftChild()) {
	                node.parent.left = replacement;
	            } else {
	                node.parent.right = replacement;
	            }
	            this._rebalance(node.parent);
	        } else {
	            this._setRoot(replacement);
	        }
	    };
	    /**
		 *  Remove the node from the tree and replace it with 
		 *  a successor which follows the schema.
		 *  @param  {IntervalNode}  node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._removeNode = function (node) {
	        if (node.left === null && node.right === null) {
	            this._replaceNodeInParent(node, null);
	        } else if (node.right === null) {
	            this._replaceNodeInParent(node, node.left);
	        } else if (node.left === null) {
	            this._replaceNodeInParent(node, node.right);
	        } else {
	            var balance = node.getBalance();
	            var replacement, temp;
	            if (balance > 0) {
	                if (node.left.right === null) {
	                    replacement = node.left;
	                    replacement.right = node.right;
	                    temp = replacement;
	                } else {
	                    replacement = node.left.right;
	                    while (replacement.right !== null) {
	                        replacement = replacement.right;
	                    }
	                    replacement.parent.right = replacement.left;
	                    temp = replacement.parent;
	                    replacement.left = node.left;
	                    replacement.right = node.right;
	                }
	            } else {
	                if (node.right.left === null) {
	                    replacement = node.right;
	                    replacement.left = node.left;
	                    temp = replacement;
	                } else {
	                    replacement = node.right.left;
	                    while (replacement.left !== null) {
	                        replacement = replacement.left;
	                    }
	                    replacement.parent = replacement.parent;
	                    replacement.parent.left = replacement.right;
	                    temp = replacement.parent;
	                    replacement.left = node.left;
	                    replacement.right = node.right;
	                }
	            }
	            if (node.parent !== null) {
	                if (node.isLeftChild()) {
	                    node.parent.left = replacement;
	                } else {
	                    node.parent.right = replacement;
	                }
	            } else {
	                this._setRoot(replacement);
	            }
	            // this._replaceNodeInParent(node, replacement);
	            this._rebalance(temp);
	        }
	        node.dispose();
	    };
	    /**
		 *  Rotate the tree to the left
		 *  @param  {IntervalNode}  node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._rotateLeft = function (node) {
	        var parent = node.parent;
	        var isLeftChild = node.isLeftChild();
	        // Make node.right the new root of this sub tree (instead of node)
	        var pivotNode = node.right;
	        node.right = pivotNode.left;
	        pivotNode.left = node;
	        if (parent !== null) {
	            if (isLeftChild) {
	                parent.left = pivotNode;
	            } else {
	                parent.right = pivotNode;
	            }
	        } else {
	            this._setRoot(pivotNode);
	        }
	    };
	    /**
		 *  Rotate the tree to the right
		 *  @param  {IntervalNode}  node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._rotateRight = function (node) {
	        var parent = node.parent;
	        var isLeftChild = node.isLeftChild();
	        // Make node.left the new root of this sub tree (instead of node)
	        var pivotNode = node.left;
	        node.left = pivotNode.right;
	        pivotNode.right = node;
	        if (parent !== null) {
	            if (isLeftChild) {
	                parent.left = pivotNode;
	            } else {
	                parent.right = pivotNode;
	            }
	        } else {
	            this._setRoot(pivotNode);
	        }
	    };
	    /**
		 *  Balance the BST
		 *  @param  {IntervalNode}  node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._rebalance = function (node) {
	        var balance = node.getBalance();
	        if (balance > 1) {
	            if (node.left.getBalance() < 0) {
	                this._rotateLeft(node.left);
	            } else {
	                this._rotateRight(node);
	            }
	        } else if (balance < -1) {
	            if (node.right.getBalance() > 0) {
	                this._rotateRight(node.right);
	            } else {
	                this._rotateLeft(node);
	            }
	        }
	    };
	    /**
		 *  Get an event whose time and duration span the give time. Will
		 *  return the match whose "time" value is closest to the given time.
		 *  @param  {Object}  event  The event to add to the timeline
		 *  @return  {Object}  The event which spans the desired time
		 */
	    Tone.IntervalTimeline.prototype.get = function (time) {
	        if (this._root !== null) {
	            var results = [];
	            this._root.search(time, results);
	            if (results.length > 0) {
	                var max = results[0];
	                for (var i = 1; i < results.length; i++) {
	                    if (results[i].low > max.low) {
	                        max = results[i];
	                    }
	                }
	                return max.event;
	            }
	        }
	        return null;
	    };
	    /**
		 *  Iterate over everything in the timeline.
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.IntervalTimeline} this
		 */
	    Tone.IntervalTimeline.prototype.forEach = function (callback) {
	        if (this._root !== null) {
	            var allNodes = [];
	            this._root.traverse(function (node) {
	                allNodes.push(node);
	            });
	            for (var i = 0; i < allNodes.length; i++) {
	                var ev = allNodes[i].event;
	                if (ev) {
	                    callback(ev);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array in which the given time
		 *  overlaps with the time and duration time of the event.
		 *  @param  {Number}  time The time to check if items are overlapping
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.IntervalTimeline} this
		 */
	    Tone.IntervalTimeline.prototype.forEachAtTime = function (time, callback) {
	        if (this._root !== null) {
	            var results = [];
	            this._root.search(time, results);
	            for (var i = results.length - 1; i >= 0; i--) {
	                var ev = results[i].event;
	                if (ev) {
	                    callback(ev);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array in which the time is greater
		 *  than the given time.
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.IntervalTimeline} this
		 */
	    Tone.IntervalTimeline.prototype.forEachAfter = function (time, callback) {
	        if (this._root !== null) {
	            var results = [];
	            this._root.searchAfter(time, results);
	            for (var i = results.length - 1; i >= 0; i--) {
	                var ev = results[i].event;
	                callback(ev);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.IntervalTimeline}  this
		 */
	    Tone.IntervalTimeline.prototype.dispose = function () {
	        var allNodes = [];
	        if (this._root !== null) {
	            this._root.traverse(function (node) {
	                allNodes.push(node);
	            });
	        }
	        for (var i = 0; i < allNodes.length; i++) {
	            allNodes[i].dispose();
	        }
	        allNodes = null;
	        this._root = null;
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	INTERVAL NODE HELPER
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Represents a node in the binary search tree, with the addition
		 *  of a "high" value which keeps track of the highest value of
		 *  its children. 
		 *  References: 
		 *  https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/
		 *  http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf
		 *  @param {Number} low
		 *  @param {Number} high
		 *  @private
		 */
	    var IntervalNode = function (low, high, event) {
	        //the event container
	        this.event = event;
	        //the low value
	        this.low = low;
	        //the high value
	        this.high = high;
	        //the high value for this and all child nodes
	        this.max = this.high;
	        //the nodes to the left
	        this._left = null;
	        //the nodes to the right
	        this._right = null;
	        //the parent node
	        this.parent = null;
	        //the number of child nodes
	        this.height = 0;
	    };
	    /** 
		 *  Insert a node into the correct spot in the tree
		 *  @param  {IntervalNode}  node
		 */
	    IntervalNode.prototype.insert = function (node) {
	        if (node.low <= this.low) {
	            if (this.left === null) {
	                this.left = node;
	            } else {
	                this.left.insert(node);
	            }
	        } else {
	            if (this.right === null) {
	                this.right = node;
	            } else {
	                this.right.insert(node);
	            }
	        }
	    };
	    /**
		 *  Search the tree for nodes which overlap 
		 *  with the given point
		 *  @param  {Number}  point  The point to query
		 *  @param  {Array}  results  The array to put the results
		 */
	    IntervalNode.prototype.search = function (point, results) {
	        // If p is to the right of the rightmost point of any interval
	        // in this node and all children, there won't be any matches.
	        if (point > this.max) {
	            return;
	        }
	        // Search left children
	        if (this.left !== null) {
	            this.left.search(point, results);
	        }
	        // Check this node
	        if (this.low <= point && this.high > point) {
	            results.push(this);
	        }
	        // If p is to the left of the time of this interval,
	        // then it can't be in any child to the right.
	        if (this.low > point) {
	            return;
	        }
	        // Search right children
	        if (this.right !== null) {
	            this.right.search(point, results);
	        }
	    };
	    /**
		 *  Search the tree for nodes which are less 
		 *  than the given point
		 *  @param  {Number}  point  The point to query
		 *  @param  {Array}  results  The array to put the results
		 */
	    IntervalNode.prototype.searchAfter = function (point, results) {
	        // Check this node
	        if (this.low >= point) {
	            results.push(this);
	            if (this.left !== null) {
	                this.left.searchAfter(point, results);
	            }
	        }
	        // search the right side
	        if (this.right !== null) {
	            this.right.searchAfter(point, results);
	        }
	    };
	    /**
		 *  Invoke the callback on this element and both it's branches
		 *  @param  {Function}  callback
		 */
	    IntervalNode.prototype.traverse = function (callback) {
	        callback(this);
	        if (this.left !== null) {
	            this.left.traverse(callback);
	        }
	        if (this.right !== null) {
	            this.right.traverse(callback);
	        }
	    };
	    /**
		 *  Update the height of the node
		 */
	    IntervalNode.prototype.updateHeight = function () {
	        if (this.left !== null && this.right !== null) {
	            this.height = Math.max(this.left.height, this.right.height) + 1;
	        } else if (this.right !== null) {
	            this.height = this.right.height + 1;
	        } else if (this.left !== null) {
	            this.height = this.left.height + 1;
	        } else {
	            this.height = 0;
	        }
	    };
	    /**
		 *  Update the height of the node
		 */
	    IntervalNode.prototype.updateMax = function () {
	        this.max = this.high;
	        if (this.left !== null) {
	            this.max = Math.max(this.max, this.left.max);
	        }
	        if (this.right !== null) {
	            this.max = Math.max(this.max, this.right.max);
	        }
	    };
	    /**
		 *  The balance is how the leafs are distributed on the node
		 *  @return  {Number}  Negative numbers are balanced to the right
		 */
	    IntervalNode.prototype.getBalance = function () {
	        var balance = 0;
	        if (this.left !== null && this.right !== null) {
	            balance = this.left.height - this.right.height;
	        } else if (this.left !== null) {
	            balance = this.left.height + 1;
	        } else if (this.right !== null) {
	            balance = -(this.right.height + 1);
	        }
	        return balance;
	    };
	    /**
		 *  @returns {Boolean} true if this node is the left child
		 *  of its parent
		 */
	    IntervalNode.prototype.isLeftChild = function () {
	        return this.parent !== null && this.parent.left === this;
	    };
	    /**
		 *  get/set the left node
		 *  @type {IntervalNode}
		 */
	    Object.defineProperty(IntervalNode.prototype, 'left', {
	        get: function () {
	            return this._left;
	        },
	        set: function (node) {
	            this._left = node;
	            if (node !== null) {
	                node.parent = this;
	            }
	            this.updateHeight();
	            this.updateMax();
	        }
	    });
	    /**
		 *  get/set the right node
		 *  @type {IntervalNode}
		 */
	    Object.defineProperty(IntervalNode.prototype, 'right', {
	        get: function () {
	            return this._right;
	        },
	        set: function (node) {
	            this._right = node;
	            if (node !== null) {
	                node.parent = this;
	            }
	            this.updateHeight();
	            this.updateMax();
	        }
	    });
	    /**
		 *  null out references.
		 */
	    IntervalNode.prototype.dispose = function () {
	        this.parent = null;
	        this._left = null;
	        this._right = null;
	        this.event = null;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	END INTERVAL NODE HELPER
	    ///////////////////////////////////////////////////////////////////////////
	    return Tone.IntervalTimeline;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Transport for timing musical events.
		 *          Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)
		 *          Tone.Transport timing events pass in the exact time of the scheduled event
		 *          in the argument of the callback function. Pass that time value to the object
		 *          you're scheduling. <br><br>
		 *          A single transport is created for you when the library is initialized. 
		 *          <br><br>
		 *          The transport emits the events: "start", "stop", "pause", and "loop" which are
		 *          called with the time of that event as the argument. 
		 *
		 *  @extends {Tone.Emitter}
		 *  @singleton
		 *  @example
		 * //repeated event every 8th note
		 * Tone.Transport.scheduleRepeat(function(time){
		 * 	//do something with the time
		 * }, "8n");
		 *  @example
		 * //schedule an event on the 16th measure
		 * Tone.Transport.schedule(function(time){
		 * 	//do something with the time
		 * }, "16:0:0");
		 */
	    Tone.Transport = function () {
	        Tone.Emitter.call(this);
	        Tone.getContext(function () {
	            ///////////////////////////////////////////////////////////////////////
	            //	LOOPING
	            //////////////////////////////////////////////////////////////////////
	            /** 
				 * 	If the transport loops or not.
				 *  @type {boolean}
				 */
	            this.loop = false;
	            /** 
				 * 	The loop start position in ticks
				 *  @type {Ticks}
				 *  @private
				 */
	            this._loopStart = 0;
	            /** 
				 * 	The loop end position in ticks
				 *  @type {Ticks}
				 *  @private
				 */
	            this._loopEnd = 0;
	            ///////////////////////////////////////////////////////////////////////
	            //	CLOCK/TEMPO
	            //////////////////////////////////////////////////////////////////////
	            /**
				 *  Pulses per quarter is the number of ticks per quarter note.
				 *  @private
				 *  @type  {Number}
				 */
	            this._ppq = TransportConstructor.defaults.PPQ;
	            /**
				 *  watches the main oscillator for timing ticks
				 *  initially starts at 120bpm
				 *  @private
				 *  @type {Tone.Clock}
				 */
	            this._clock = new Tone.Clock({
	                'callback': this._processTick.bind(this),
	                'frequency': 0
	            });
	            this._bindClockEvents();
	            /**
				 *  The Beats Per Minute of the Transport. 
				 *  @type {BPM}
				 *  @signal
				 *  @example
				 * Tone.Transport.bpm.value = 80;
				 * //ramp the bpm to 120 over 10 seconds
				 * Tone.Transport.bpm.rampTo(120, 10);
				 */
	            this.bpm = this._clock.frequency;
	            this.bpm._toUnits = this._toUnits.bind(this);
	            this.bpm._fromUnits = this._fromUnits.bind(this);
	            this.bpm.units = Tone.Type.BPM;
	            this.bpm.value = TransportConstructor.defaults.bpm;
	            this._readOnly('bpm');
	            /**
				 *  The time signature, or more accurately the numerator
				 *  of the time signature over a denominator of 4. 
				 *  @type {Number}
				 *  @private
				 */
	            this._timeSignature = TransportConstructor.defaults.timeSignature;
	            ///////////////////////////////////////////////////////////////////////
	            //	TIMELINE EVENTS
	            //////////////////////////////////////////////////////////////////////
	            /**
				 *  All the events in an object to keep track by ID
				 *  @type {Object}
				 *  @private
				 */
	            this._scheduledEvents = {};
	            /**
				 *  The event ID counter
				 *  @type {Number}
				 *  @private
				 */
	            this._eventID = 0;
	            /**
				 * 	The scheduled events.
				 *  @type {Tone.Timeline}
				 *  @private
				 */
	            this._timeline = new Tone.Timeline();
	            /**
				 *  Repeated events
				 *  @type {Array}
				 *  @private
				 */
	            this._repeatedEvents = new Tone.IntervalTimeline();
	            /**
				 *  Events that occur once
				 *  @type {Array}
				 *  @private
				 */
	            this._onceEvents = new Tone.Timeline();
	            /** 
				 *  All of the synced Signals
				 *  @private 
				 *  @type {Array}
				 */
	            this._syncedSignals = [];
	            ///////////////////////////////////////////////////////////////////////
	            //	SWING
	            //////////////////////////////////////////////////////////////////////
	            /**
				 *  The subdivision of the swing
				 *  @type  {Ticks}
				 *  @private
				 */
	            this._swingTicks = TransportConstructor.defaults.PPQ / 2;
	            //8n
	            /**
				 *  The swing amount
				 *  @type {NormalRange}
				 *  @private
				 */
	            this._swingAmount = 0;
	        }.bind(this));
	    };
	    Tone.extend(Tone.Transport, Tone.Emitter);
	    /**
		 *  the defaults
		 *  @type {Object}
		 *  @const
		 *  @static
		 */
	    Tone.Transport.defaults = {
	        'bpm': 120,
	        'swing': 0,
	        'swingSubdivision': '8n',
	        'timeSignature': 4,
	        'loopStart': 0,
	        'loopEnd': '4m',
	        'PPQ': 192
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	TICKS
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  called on every tick
		 *  @param   {number} tickTime clock relative tick time
		 *  @private
		 */
	    Tone.Transport.prototype._processTick = function (tickTime) {
	        var ticks = this._clock.ticks;
	        //handle swing
	        if (this._swingAmount > 0 && ticks % this._ppq !== 0 && //not on a downbeat
	            ticks % (this._swingTicks * 2) !== 0) {
	            //add some swing
	            var progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);
	            var amount = Math.sin(progress * Math.PI) * this._swingAmount;
	            tickTime += Tone.Time(this._swingTicks * 2 / 3, 'i') * amount;
	        }
	        //do the loop test
	        if (this.loop) {
	            if (ticks >= this._loopEnd) {
	                this.emit('loopEnd', tickTime);
	                this._clock.ticks = this._loopStart;
	                ticks = this._loopStart;
	                this.emit('loopStart', tickTime, this.seconds);
	                this.emit('loop', tickTime);
	            }
	        }
	        //process the single occurrence events
	        this._onceEvents.forEachBefore(ticks, function (event) {
	            event.callback(tickTime);
	            //remove the event
	            delete this._scheduledEvents[event.id.toString()];
	        }.bind(this));
	        //and clear the single occurrence timeline
	        this._onceEvents.cancelBefore(ticks);
	        //fire the next tick events if their time has come
	        this._timeline.forEachAtTime(ticks, function (event) {
	            event.callback(tickTime);
	        });
	        //process the repeated events
	        this._repeatedEvents.forEachAtTime(ticks, function (event) {
	            if ((ticks - event.time) % event.interval === 0) {
	                event.callback(tickTime);
	            }
	        });
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	SCHEDULABLE EVENTS
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  Schedule an event along the timeline.
		 *  @param {Function} callback The callback to be invoked at the time.
		 *  @param {TransportTime}  time The time to invoke the callback at.
		 *  @return {Number} The id of the event which can be used for canceling the event. 
		 *  @example
		 * //trigger the callback when the Transport reaches the desired time
		 * Tone.Transport.schedule(function(time){
		 * 	envelope.triggerAttack(time);
		 * }, "128i");
		 */
	    Tone.Transport.prototype.schedule = function (callback, time) {
	        var event = {
	            'time': this.toTicks(time),
	            'callback': callback
	        };
	        var id = this._eventID++;
	        this._scheduledEvents[id.toString()] = {
	            'event': event,
	            'timeline': this._timeline
	        };
	        this._timeline.add(event);
	        return id;
	    };
	    /**
		 *  Schedule a repeated event along the timeline. The event will fire
		 *  at the `interval` starting at the `startTime` and for the specified
		 *  `duration`. 
		 *  @param  {Function}  callback   The callback to invoke.
		 *  @param  {Time}    interval   The duration between successive
		 *                               callbacks.
		 *  @param  {TimelinePosition=}    startTime  When along the timeline the events should
		 *                               start being invoked.
		 *  @param {Time} [duration=Infinity] How long the event should repeat. 
		 *  @return  {Number}    The ID of the scheduled event. Use this to cancel
		 *                           the event. 
		 *  @example
		 * //a callback invoked every eighth note after the first measure
		 * Tone.Transport.scheduleRepeat(callback, "8n", "1m");
		 */
	    Tone.Transport.prototype.scheduleRepeat = function (callback, interval, startTime, duration) {
	        if (interval <= 0) {
	            throw new Error('Tone.Transport: repeat events must have an interval larger than 0');
	        }
	        var event = {
	            'time': this.toTicks(startTime),
	            'duration': this.toTicks(Tone.defaultArg(duration, Infinity)),
	            'interval': this.toTicks(interval),
	            'callback': callback
	        };
	        var id = this._eventID++;
	        this._scheduledEvents[id.toString()] = {
	            'event': event,
	            'timeline': this._repeatedEvents
	        };
	        this._repeatedEvents.add(event);
	        return id;
	    };
	    /**
		 *  Schedule an event that will be removed after it is invoked. 
		 *  Note that if the given time is less than the current transport time, 
		 *  the event will be invoked immediately. 
		 *  @param {Function} callback The callback to invoke once.
		 *  @param {TransportTime} time The time the callback should be invoked.
		 *  @returns {Number} The ID of the scheduled event. 
		 */
	    Tone.Transport.prototype.scheduleOnce = function (callback, time) {
	        var id = this._eventID++;
	        var event = {
	            'time': this.toTicks(time),
	            'callback': callback,
	            'id': id
	        };
	        this._scheduledEvents[id.toString()] = {
	            'event': event,
	            'timeline': this._onceEvents
	        };
	        this._onceEvents.add(event);
	        return id;
	    };
	    /**
		 *  Clear the passed in event id from the timeline
		 *  @param {Number} eventId The id of the event.
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.clear = function (eventId) {
	        if (this._scheduledEvents.hasOwnProperty(eventId)) {
	            var item = this._scheduledEvents[eventId.toString()];
	            item.timeline.remove(item.event);
	            delete this._scheduledEvents[eventId.toString()];
	        }
	        return this;
	    };
	    /**
		 *  Remove scheduled events from the timeline after
		 *  the given time. Repeated events will be removed
		 *  if their startTime is after the given time
		 *  @param {TransportTime} [after=0] Clear all events after
		 *                          this time. 
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.cancel = function (after) {
	        after = Tone.defaultArg(after, 0);
	        after = this.toTicks(after);
	        this._timeline.cancel(after);
	        this._onceEvents.cancel(after);
	        this._repeatedEvents.cancel(after);
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	START/STOP/PAUSE
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  Bind start/stop/pause events from the clock and emit them.
		 *  @private
		 */
	    Tone.Transport.prototype._bindClockEvents = function () {
	        this._clock.on('start', function (time, offset) {
	            offset = Tone.Time(this._clock.ticks, 'i').toSeconds();
	            this.emit('start', time, offset);
	        }.bind(this));
	        this._clock.on('stop', function (time) {
	            this.emit('stop', time);
	        }.bind(this));
	        this._clock.on('pause', function (time) {
	            this.emit('pause', time);
	        }.bind(this));
	    };
	    /**
		 *  Returns the playback state of the source, either "started", "stopped", or "paused"
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.Transport#
		 *  @name state
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'state', {
	        get: function () {
	            return this._clock.getStateAtTime(this.now());
	        }
	    });
	    /**
		 *  Start the transport and all sources synced to the transport.
		 *  @param  {Time} [time=now] The time when the transport should start.
		 *  @param  {TransportTime=} offset The timeline offset to start the transport.
		 *  @returns {Tone.Transport} this
		 *  @example
		 * //start the transport in one second starting at beginning of the 5th measure. 
		 * Tone.Transport.start("+1", "4:0:0");
		 */
	    Tone.Transport.prototype.start = function (time, offset) {
	        //start the clock
	        if (!Tone.isUndef(offset)) {
	            offset = this.toTicks(offset);
	        }
	        this._clock.start(time, offset);
	        return this;
	    };
	    /**
		 *  Stop the transport and all sources synced to the transport.
		 *  @param  {Time} [time=now] The time when the transport should stop. 
		 *  @returns {Tone.Transport} this
		 *  @example
		 * Tone.Transport.stop();
		 */
	    Tone.Transport.prototype.stop = function (time) {
	        this._clock.stop(time);
	        return this;
	    };
	    /**
		 *  Pause the transport and all sources synced to the transport.
		 *  @param  {Time} [time=now]
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.pause = function (time) {
	        this._clock.pause(time);
	        return this;
	    };
	    /**
		 * Toggle the current state of the transport. If it is
		 * started, it will stop it, otherwise it will start the Transport.
		 * @param  {Time=} time The time of the event
		 * @return {Tone.Transport}      this
		 */
	    Tone.Transport.prototype.toggle = function (time) {
	        time = this.toSeconds(time);
	        if (this._clock.getStateAtTime(time) !== Tone.State.Started) {
	            this.start(time);
	        } else {
	            this.stop(time);
	        }
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	SETTERS/GETTERS
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  The time signature as just the numerator over 4. 
		 *  For example 4/4 would be just 4 and 6/8 would be 3.
		 *  @memberOf Tone.Transport#
		 *  @type {Number|Array}
		 *  @name timeSignature
		 *  @example
		 * //common time
		 * Tone.Transport.timeSignature = 4;
		 * // 7/8
		 * Tone.Transport.timeSignature = [7, 8];
		 * //this will be reduced to a single number
		 * Tone.Transport.timeSignature; //returns 3.5
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'timeSignature', {
	        get: function () {
	            return this._timeSignature;
	        },
	        set: function (timeSig) {
	            if (Tone.isArray(timeSig)) {
	                timeSig = timeSig[0] / timeSig[1] * 4;
	            }
	            this._timeSignature = timeSig;
	        }
	    });
	    /**
		 * When the Tone.Transport.loop = true, this is the starting position of the loop.
		 * @memberOf Tone.Transport#
		 * @type {TransportTime}
		 * @name loopStart
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'loopStart', {
	        get: function () {
	            return Tone.TransportTime(this._loopStart, 'i').toSeconds();
	        },
	        set: function (startPosition) {
	            this._loopStart = this.toTicks(startPosition);
	        }
	    });
	    /**
		 * When the Tone.Transport.loop = true, this is the ending position of the loop.
		 * @memberOf Tone.Transport#
		 * @type {TransportTime}
		 * @name loopEnd
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'loopEnd', {
	        get: function () {
	            return Tone.TransportTime(this._loopEnd, 'i').toSeconds();
	        },
	        set: function (endPosition) {
	            this._loopEnd = this.toTicks(endPosition);
	        }
	    });
	    /**
		 *  Set the loop start and stop at the same time. 
		 *  @param {TransportTime} startPosition 
		 *  @param {TransportTime} endPosition   
		 *  @returns {Tone.Transport} this
		 *  @example
		 * //loop over the first measure
		 * Tone.Transport.setLoopPoints(0, "1m");
		 * Tone.Transport.loop = true;
		 */
	    Tone.Transport.prototype.setLoopPoints = function (startPosition, endPosition) {
	        this.loopStart = startPosition;
	        this.loopEnd = endPosition;
	        return this;
	    };
	    /**
		 *  The swing value. Between 0-1 where 1 equal to 
		 *  the note + half the subdivision.
		 *  @memberOf Tone.Transport#
		 *  @type {NormalRange}
		 *  @name swing
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'swing', {
	        get: function () {
	            return this._swingAmount;
	        },
	        set: function (amount) {
	            //scale the values to a normal range
	            this._swingAmount = amount;
	        }
	    });
	    /**
		 *  Set the subdivision which the swing will be applied to. 
		 *  The default value is an 8th note. Value must be less 
		 *  than a quarter note.
		 *  
		 *  @memberOf Tone.Transport#
		 *  @type {Time}
		 *  @name swingSubdivision
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'swingSubdivision', {
	        get: function () {
	            return Tone.Time(this._swingTicks, 'i').toNotation();
	        },
	        set: function (subdivision) {
	            this._swingTicks = this.toTicks(subdivision);
	        }
	    });
	    /**
		 *  The Transport's position in Bars:Beats:Sixteenths.
		 *  Setting the value will jump to that position right away. 
		 *  @memberOf Tone.Transport#
		 *  @type {BarsBeatsSixteenths}
		 *  @name position
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'position', {
	        get: function () {
	            return Tone.TransportTime(this.ticks, 'i').toBarsBeatsSixteenths();
	        },
	        set: function (progress) {
	            var ticks = this.toTicks(progress);
	            this.ticks = ticks;
	        }
	    });
	    /**
		 *  The Transport's position in seconds
		 *  Setting the value will jump to that position right away. 
		 *  @memberOf Tone.Transport#
		 *  @type {Seconds}
		 *  @name seconds
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'seconds', {
	        get: function () {
	            return Tone.TransportTime(this.ticks, 'i').toSeconds();
	        },
	        set: function (progress) {
	            var ticks = this.toTicks(progress);
	            this.ticks = ticks;
	        }
	    });
	    /**
		 *  The Transport's loop position as a normalized value. Always
		 *  returns 0 if the transport if loop is not true. 
		 *  @memberOf Tone.Transport#
		 *  @name progress
		 *  @type {NormalRange}
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'progress', {
	        get: function () {
	            if (this.loop) {
	                return (this.ticks - this._loopStart) / (this._loopEnd - this._loopStart);
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  The transports current tick position.
		 *  
		 *  @memberOf Tone.Transport#
		 *  @type {Ticks}
		 *  @name ticks
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'ticks', {
	        get: function () {
	            return this._clock.ticks;
	        },
	        set: function (t) {
	            if (this._clock.ticks !== t) {
	                var now = this.now();
	                //stop everything synced to the transport
	                if (this.state === Tone.State.Started) {
	                    this.emit('stop', now);
	                    this._clock.ticks = t;
	                    //restart it with the new time
	                    this.emit('start', now, this.seconds);
	                } else {
	                    this._clock.ticks = t;
	                }
	            }
	        }
	    });
	    /**
		 *  Pulses Per Quarter note. This is the smallest resolution
		 *  the Transport timing supports. This should be set once
		 *  on initialization and not set again. Changing this value 
		 *  after other objects have been created can cause problems. 
		 *  
		 *  @memberOf Tone.Transport#
		 *  @type {Number}
		 *  @name PPQ
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'PPQ', {
	        get: function () {
	            return this._ppq;
	        },
	        set: function (ppq) {
	            var bpm = this.bpm.value;
	            this._ppq = ppq;
	            this.bpm.value = bpm;
	        }
	    });
	    /**
		 *  Convert from BPM to frequency (factoring in PPQ)
		 *  @param  {BPM}  bpm The BPM value to convert to frequency
		 *  @return  {Frequency}  The BPM as a frequency with PPQ factored in.
		 *  @private
		 */
	    Tone.Transport.prototype._fromUnits = function (bpm) {
	        return 1 / (60 / bpm / this.PPQ);
	    };
	    /**
		 *  Convert from frequency (with PPQ) into BPM
		 *  @param  {Frequency}  freq The clocks frequency to convert to BPM
		 *  @return  {BPM}  The frequency value as BPM.
		 *  @private
		 */
	    Tone.Transport.prototype._toUnits = function (freq) {
	        return freq / this.PPQ * 60;
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	SYNCING
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  Returns the time aligned to the next subdivision
		 *  of the Transport. If the Transport is not started,
		 *  it will return 0.
		 *  Note: this will not work precisely during tempo ramps.
		 *  @param  {Time}  subdivision  The subdivision to quantize to
		 *  @return  {Number}  The context time of the next subdivision.
		 *  @example
		 * Tone.Transport.start(); //the transport must be started
		 * Tone.Transport.nextSubdivision("4n");
		 */
	    Tone.Transport.prototype.nextSubdivision = function (subdivision) {
	        subdivision = this.toSeconds(subdivision);
	        //if the transport's not started, return 0
	        var now;
	        if (this.state === Tone.State.Started) {
	            now = this._clock._nextTick;
	        } else {
	            return 0;
	        }
	        var transportPos = Tone.Time(this.ticks, 'i');
	        var remainingTime = subdivision - transportPos % subdivision;
	        if (remainingTime === 0) {
	            remainingTime = subdivision;
	        }
	        return now + remainingTime;
	    };
	    /**
		 *  Attaches the signal to the tempo control signal so that 
		 *  any changes in the tempo will change the signal in the same
		 *  ratio. 
		 *  
		 *  @param  {Tone.Signal} signal 
		 *  @param {number=} ratio Optionally pass in the ratio between
		 *                         the two signals. Otherwise it will be computed
		 *                         based on their current values. 
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.syncSignal = function (signal, ratio) {
	        if (!ratio) {
	            //get the sync ratio
	            if (signal._param.value !== 0) {
	                ratio = signal._param.value / this.bpm._param.value;
	            } else {
	                ratio = 0;
	            }
	        }
	        var ratioSignal = new Tone.Gain(ratio);
	        this.bpm.chain(ratioSignal, signal._param);
	        this._syncedSignals.push({
	            'ratio': ratioSignal,
	            'signal': signal,
	            'initial': signal._param.value
	        });
	        signal._param.value = 0;
	        return this;
	    };
	    /**
		 *  Unsyncs a previously synced signal from the transport's control. 
		 *  See Tone.Transport.syncSignal.
		 *  @param  {Tone.Signal} signal 
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.unsyncSignal = function (signal) {
	        for (var i = this._syncedSignals.length - 1; i >= 0; i--) {
	            var syncedSignal = this._syncedSignals[i];
	            if (syncedSignal.signal === signal) {
	                syncedSignal.ratio.dispose();
	                syncedSignal.signal._param.value = syncedSignal.initial;
	                this._syncedSignals.splice(i, 1);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Transport} this
		 *  @private
		 */
	    Tone.Transport.prototype.dispose = function () {
	        Tone.Emitter.prototype.dispose.call(this);
	        this._clock.dispose();
	        this._clock = null;
	        this._writable('bpm');
	        this.bpm = null;
	        this._timeline.dispose();
	        this._timeline = null;
	        this._onceEvents.dispose();
	        this._onceEvents = null;
	        this._repeatedEvents.dispose();
	        this._repeatedEvents = null;
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	INITIALIZATION
	    ///////////////////////////////////////////////////////////////////////////////
	    var TransportConstructor = Tone.Transport;
	    Tone.Transport = new TransportConstructor();
	    Tone.Context.on('init', function (context) {
	        if (context.Transport instanceof TransportConstructor) {
	            Tone.Transport = context.Transport;
	        } else {
	            Tone.Transport = new TransportConstructor();
	        }
	        //store the Transport on the context so it can be retrieved later
	        context.Transport = Tone.Transport;
	    });
	    Tone.Context.on('close', function (context) {
	        if (context.Transport instanceof TransportConstructor) {
	            context.Transport.dispose();
	        }
	    });
	    return Tone.Transport;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Volume is a simple volume node, useful for creating a volume fader.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Decibels} [volume=0] the initial volume
		 *  @example
		 * var vol = new Tone.Volume(-12);
		 * instrument.chain(vol, Tone.Master);
		 */
	    Tone.Volume = function () {
	        var options = Tone.defaults(arguments, ['volume'], Tone.Volume);
	        Tone.AudioNode.call(this);
	        /**
			 * the output node
			 * @type {GainNode}
			 * @private
			 */
	        this.output = this.input = new Tone.Gain(options.volume, Tone.Type.Decibels);
	        /**
			 * The unmuted volume
			 * @type {Decibels}
			 * @private
			 */
	        this._unmutedVolume = options.volume;
	        /**
			 *  The volume control in decibels.
			 *  @type {Decibels}
			 *  @signal
			 */
	        this.volume = this.output.gain;
	        this._readOnly('volume');
	        //set the mute initially
	        this.mute = options.mute;
	    };
	    Tone.extend(Tone.Volume, Tone.AudioNode);
	    /**
		 *  Defaults
		 *  @type  {Object}
		 *  @const
		 *  @static
		 */
	    Tone.Volume.defaults = {
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 * Mute the output.
		 * @memberOf Tone.Volume#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * volume.mute = true;
		 */
	    Object.defineProperty(Tone.Volume.prototype, 'mute', {
	        get: function () {
	            return this.volume.value === -Infinity;
	        },
	        set: function (mute) {
	            if (!this.mute && mute) {
	                this._unmutedVolume = this.volume.value;
	                //maybe it should ramp here?
	                this.volume.value = -Infinity;
	            } else if (this.mute && !mute) {
	                this.volume.value = this._unmutedVolume;
	            }
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.Volume} this
		 */
	    Tone.Volume.prototype.dispose = function () {
	        this.input.dispose();
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable('volume');
	        this.volume.dispose();
	        this.volume = null;
	        return this;
	    };
	    return Tone.Volume;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A single master output which is connected to the
		 *          AudioDestinationNode (aka your speakers).
		 *          It provides useful conveniences such as the ability
		 *          to set the volume and mute the entire application.
		 *          It also gives you the ability to apply master effects to your application.
		 *          <br><br>
		 *          Like Tone.Transport, A single Tone.Master is created
		 *          on initialization and you do not need to explicitly construct one.
		 *
		 *  @constructor
		 *  @extends {Tone}
		 *  @singleton
		 *  @example
		 * //the audio will go from the oscillator to the speakers
		 * oscillator.connect(Tone.Master);
		 * //a convenience for connecting to the master output is also provided:
		 * oscillator.toMaster();
		 * //the above two examples are equivalent.
		 */
	    Tone.Master = function () {
	        Tone.AudioNode.call(this);
	        Tone.getContext(function () {
	            this.createInsOuts(1, 0);
	            /**
				 *  The private volume node
				 *  @type  {Tone.Volume}
				 *  @private
				 */
	            this._volume = this.output = new Tone.Volume();
	            /**
				 * The volume of the master output.
				 * @type {Decibels}
				 * @signal
				 */
	            this.volume = this._volume.volume;
	            this._readOnly('volume');
	            //connections
	            this.input.chain(this.output, this.context.destination);
	        }.bind(this));
	    };
	    Tone.extend(Tone.Master, Tone.AudioNode);
	    /**
		 *  @type {Object}
		 *  @const
		 */
	    Tone.Master.defaults = {
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 * Mute the output.
		 * @memberOf Tone.Master#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * Tone.Master.mute = true;
		 */
	    Object.defineProperty(Tone.Master.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously
		 *  chained in the master effects chain.
		 *  @param {AudioNode|Tone} args... All arguments will be connected in a row
		 *                                  and the Master will be routed through it.
		 *  @return  {Tone.Master}  this
		 *  @example
		 * //some overall compression to keep the levels in check
		 * var masterCompressor = new Tone.Compressor({
		 * 	"threshold" : -6,
		 * 	"ratio" : 3,
		 * 	"attack" : 0.5,
		 * 	"release" : 0.1
		 * });
		 * //give a little boost to the lows
		 * var lowBump = new Tone.Filter(200, "lowshelf");
		 * //route everything through the filter
		 * //and compressor before going to the speakers
		 * Tone.Master.chain(lowBump, masterCompressor);
		 */
	    Tone.Master.prototype.chain = function () {
	        this.input.disconnect();
	        this.input.chain.apply(this.input, arguments);
	        arguments[arguments.length - 1].connect(this.output);
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.Master}  this
		 */
	    Tone.Master.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable('volume');
	        this._volume.dispose();
	        this._volume = null;
	        this.volume = null;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	AUGMENT TONE's PROTOTYPE
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Connect 'this' to the master output. Shorthand for this.connect(Tone.Master)
		 *  @returns {Tone.AudioNode} this
		 *  @example
		 * //connect an oscillator to the master output
		 * var osc = new Tone.Oscillator().toMaster();
		 */
	    Tone.AudioNode.prototype.toMaster = function () {
	        this.connect(Tone.Master);
	        return this;
	    };
	    if (window.AudioNode) {
	        // Also augment AudioNode's prototype to include toMaster as a convenience
	        AudioNode.prototype.toMaster = function () {
	            this.connect(Tone.Master);
	            return this;
	        };
	    }
	    /**
		 *  initialize the module and listen for new audio contexts
		 */
	    var MasterConstructor = Tone.Master;
	    Tone.Master = new MasterConstructor();
	    Tone.Context.on('init', function (context) {
	        // if it already exists, just restore it
	        if (context.Master instanceof MasterConstructor) {
	            Tone.Master = context.Master;
	        } else {
	            Tone.Master = new MasterConstructor();
	        }
	        context.Master = Tone.Master;
	    });
	    Tone.Context.on('close', function (context) {
	        if (context.Master instanceof MasterConstructor) {
	            context.Master.dispose();
	        }
	    });
	    return Tone.Master;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Base class for sources. Sources have start/stop methods
		 *          and the ability to be synced to the
		 *          start/stop of Tone.Transport.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @example
		 * //Multiple state change events can be chained together,
		 * //but must be set in the correct order and with ascending times
		 *
		 * // OK
		 * state.start().stop("+0.2");
		 * // AND
		 * state.start().stop("+0.2").start("+0.4").stop("+0.7")
		 *
		 * // BAD
		 * state.stop("+0.2").start();
		 * // OR
		 * state.start("+0.3").stop("+0.2");
		 *
		 */
	    Tone.Source = function (options) {
	        options = Tone.defaultArg(options, Tone.Source.defaults);
	        Tone.AudioNode.call(this);
	        /**
			 *  The output volume node
			 *  @type  {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 * The volume of the output in decibels.
			 * @type {Decibels}
			 * @signal
			 * @example
			 * source.volume.value = -6;
			 */
	        this.volume = this._volume.volume;
	        this._readOnly('volume');
	        /**
			 * 	Keep track of the scheduled state.
			 *  @type {Tone.TimelineState}
			 *  @private
			 */
	        this._state = new Tone.TimelineState(Tone.State.Stopped);
	        this._state.memory = 10;
	        /**
			 *  The synced `start` callback function from the transport
			 *  @type {Function}
			 *  @private
			 */
	        this._synced = false;
	        /**
			 *  Keep track of all of the scheduled event ids
			 *  @type  {Array}
			 *  @private
			 */
	        this._scheduled = [];
	        //make the output explicitly stereo
	        this._volume.output.output.channelCount = 2;
	        this._volume.output.output.channelCountMode = 'explicit';
	        //mute initially
	        this.mute = options.mute;
	    };
	    Tone.extend(Tone.Source, Tone.AudioNode);
	    /**
		 *  The default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Source.defaults = {
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 *  Returns the playback state of the source, either "started" or "stopped".
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.Source#
		 *  @name state
		 */
	    Object.defineProperty(Tone.Source.prototype, 'state', {
	        get: function () {
	            if (this._synced) {
	                if (Tone.Transport.state === Tone.State.Started) {
	                    return this._state.getValueAtTime(Tone.Transport.seconds);
	                } else {
	                    return Tone.State.Stopped;
	                }
	            } else {
	                return this._state.getValueAtTime(this.now());
	            }
	        }
	    });
	    /**
		 * Mute the output.
		 * @memberOf Tone.Source#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * source.mute = true;
		 */
	    Object.defineProperty(Tone.Source.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    //overwrite these functions
	    Tone.Source.prototype._start = Tone.noOp;
	    Tone.Source.prototype._stop = Tone.noOp;
	    /**
		 *  Start the source at the specified time. If no time is given,
		 *  start the source now.
		 *  @param  {Time} [time=now] When the source should be started.
		 *  @returns {Tone.Source} this
		 *  @example
		 * source.start("+0.5"); //starts the source 0.5 seconds from now
		 */
	    Tone.Source.prototype.start = function (time, offset, duration) {
	        if (Tone.isUndef(time) && this._synced) {
	            time = Tone.Transport.seconds;
	        } else {
	            time = this.toSeconds(time);
	        }
	        //if it's started, stop it and restart it
	        if (!this.retrigger && this._state.getValueAtTime(time) === Tone.State.Started) {
	            this.stop(time);
	        }
	        this._state.setStateAtTime(Tone.State.Started, time);
	        if (this._synced) {
	            // add the offset time to the event
	            var event = this._state.get(time);
	            event.offset = Tone.defaultArg(offset, 0);
	            event.duration = duration;
	            var sched = Tone.Transport.schedule(function (t) {
	                this._start(t, offset, duration);
	            }.bind(this), time);
	            this._scheduled.push(sched);
	        } else {
	            this._start.apply(this, arguments);
	        }
	        return this;
	    };
	    /**
		 *  Stop the source at the specified time. If no time is given,
		 *  stop the source now.
		 *  @param  {Time} [time=now] When the source should be stopped.
		 *  @returns {Tone.Source} this
		 *  @example
		 * source.stop(); // stops the source immediately
		 */
	    Tone.Source.prototype.stop = function (time) {
	        if (Tone.isUndef(time) && this._synced) {
	            time = Tone.Transport.seconds;
	        } else {
	            time = this.toSeconds(time);
	        }
	        this._state.cancel(time);
	        this._state.setStateAtTime(Tone.State.Stopped, time);
	        if (!this._synced) {
	            this._stop.apply(this, arguments);
	        } else {
	            var sched = Tone.Transport.schedule(this._stop.bind(this), time);
	            this._scheduled.push(sched);
	        }
	        return this;
	    };
	    /**
		 *  Sync the source to the Transport so that all subsequent
		 *  calls to `start` and `stop` are synced to the TransportTime
		 *  instead of the AudioContext time.
		 *
		 *  @returns {Tone.Source} this
		 *  @example
		 * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline
		 * source.sync().start(0).stop(0.3);
		 * //start the transport.
		 * Tone.Transport.start();
		 *
		 *  @example
		 * //start the transport with an offset and the sync'ed sources
		 * //will start in the correct position
		 * source.sync().start(0.1);
		 * //the source will be invoked with an offset of 0.4
		 * Tone.Transport.start("+0.5", 0.5);
		 */
	    Tone.Source.prototype.sync = function () {
	        this._synced = true;
	        this._syncedStart = function (time, offset) {
	            if (offset > 0) {
	                // get the playback state at that time
	                var stateEvent = this._state.get(offset);
	                // listen for start events which may occur in the middle of the sync'ed time
	                if (stateEvent && stateEvent.state === Tone.State.Started && stateEvent.time !== offset) {
	                    // get the offset
	                    var startOffset = offset - this.toSeconds(stateEvent.time);
	                    var duration;
	                    if (stateEvent.duration) {
	                        duration = this.toSeconds(stateEvent.duration) - startOffset;
	                    }
	                    this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);
	                }
	            }
	        }.bind(this);
	        this._syncedStop = function (time) {
	            if (this._state.getValueAtTime(Tone.Transport.seconds) === Tone.State.Started) {
	                this._stop(time);
	            }
	        }.bind(this);
	        Tone.Transport.on('start loopStart', this._syncedStart);
	        Tone.Transport.on('stop pause loopEnd', this._syncedStop);
	        return this;
	    };
	    /**
		 *  Unsync the source to the Transport. See Tone.Source.sync
		 *  @returns {Tone.Source} this
		 */
	    Tone.Source.prototype.unsync = function () {
	        if (this._synced) {
	            Tone.Transport.off('stop pause loopEnd', this._syncedStop);
	            Tone.Transport.off('start loopStart', this._syncedStart);
	        }
	        this._synced = false;
	        // clear all of the scheduled ids
	        for (var i = 0; i < this._scheduled.length; i++) {
	            var id = this._scheduled[i];
	            Tone.Transport.clear(id);
	        }
	        this._scheduled = [];
	        this._state.cancel(0);
	        return this;
	    };
	    /**
		 *	Clean up.
		 *  @return {Tone.Source} this
		 */
	    Tone.Source.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.unsync();
	        this._scheduled = null;
	        this._writable('volume');
	        this._volume.dispose();
	        this._volume = null;
	        this.volume = null;
	        this._state.dispose();
	        this._state = null;
	    };
	    return Tone.Source;
	});
	Module(function (Tone) {
	    
	    /**
		 *  OscillatorNode shim
		 *  @private
		 */
	    if (window.OscillatorNode && !OscillatorNode.prototype.start) {
	        OscillatorNode.prototype.start = OscillatorNode.prototype.noteOn;
	        OscillatorNode.prototype.stop = OscillatorNode.prototype.noteOff;
	        if (!OscillatorNode.prototype.setPeriodicWave) {
	            OscillatorNode.prototype.setPeriodicWave = OscillatorNode.prototype.setWaveTable;
	        }
	        if (!AudioContext.prototype.createPeriodicWave) {
	            AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;
	        }
	    }
	    /**
		 *  @class Tone.Oscillator supports a number of features including
		 *         phase rotation, multiple oscillator types (see Tone.Oscillator.type), 
		 *         and Transport syncing (see Tone.Oscillator.syncFrequency).
		 *
		 *  @constructor
		 *  @extends {Tone.Source}
		 *  @param {Frequency} [frequency] Starting frequency
		 *  @param {string} [type] The oscillator type. Read more about type below.
		 *  @example
		 * //make and start a 440hz sine tone
		 * var osc = new Tone.Oscillator(440, "sine").toMaster().start();
		 */
	    Tone.Oscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type'
	        ], Tone.Oscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  the main oscillator
			 *  @type {OscillatorNode}
			 *  @private
			 */
	        this._oscillator = null;
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune control signal.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  the periodic wave
			 *  @type {PeriodicWave}
			 *  @private
			 */
	        this._wave = null;
	        /**
			 *  The partials of the oscillator
			 *  @type {Array}
			 *  @private
			 */
	        this._partials = Tone.defaultArg(options.partials, [1]);
	        /**
			 *  the phase of the oscillator
			 *  between 0 - 360
			 *  @type {number}
			 *  @private
			 */
	        this._phase = options.phase;
	        /**
			 *  the type of the oscillator
			 *  @type {string}
			 *  @private
			 */
	        this._type = null;
	        //setup
	        this.type = options.type;
	        this.phase = this._phase;
	        this._readOnly([
	            'frequency',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.Oscillator, Tone.Source);
	    /**
		 *  the default parameters
		 *  @type {Object}
		 */
	    Tone.Oscillator.defaults = {
	        'type': 'sine',
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'partials': []
	    };
	    /**
		 *  The Oscillator types
		 *  @enum {String}
		 */
	    Tone.Oscillator.Type = {
	        Sine: 'sine',
	        Triangle: 'triangle',
	        Sawtooth: 'sawtooth',
	        Square: 'square',
	        Custom: 'custom'
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now] 
		 *  @private
		 */
	    Tone.Oscillator.prototype._start = function (time) {
	        //new oscillator with previous values
	        this._oscillator = this.context.createOscillator();
	        this._oscillator.setPeriodicWave(this._wave);
	        //connect the control signal to the oscillator frequency & detune
	        this._oscillator.connect(this.output);
	        this.frequency.connect(this._oscillator.frequency);
	        this.detune.connect(this._oscillator.detune);
	        //start the oscillator
	        this._oscillator.start(this.toSeconds(time));
	    };
	    /**
		 *  stop the oscillator
		 *  @private
		 *  @param  {Time} [time=now] (optional) timing parameter
		 *  @returns {Tone.Oscillator} this
		 */
	    Tone.Oscillator.prototype._stop = function (time) {
	        if (this._oscillator) {
	            this._oscillator.stop(this.toSeconds(time));
	            this._oscillator = null;
	        }
	        return this;
	    };
	    /**
		 *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,
		 *  will also affect the oscillators frequency. 
		 *  @returns {Tone.Oscillator} this
		 *  @example
		 * Tone.Transport.bpm.value = 120;
		 * osc.frequency.value = 440;
		 * //the ration between the bpm and the frequency will be maintained
		 * osc.syncFrequency();
		 * Tone.Transport.bpm.value = 240; 
		 * // the frequency of the oscillator is doubled to 880
		 */
	    Tone.Oscillator.prototype.syncFrequency = function () {
	        Tone.Transport.syncSignal(this.frequency);
	        return this;
	    };
	    /**
		 *  Unsync the oscillator's frequency from the Transport. 
		 *  See Tone.Oscillator.syncFrequency
		 *  @returns {Tone.Oscillator} this
		 */
	    Tone.Oscillator.prototype.unsyncFrequency = function () {
	        Tone.Transport.unsyncSignal(this.frequency);
	        return this;
	    };
	    /**
		 * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of
		 * setting the first x number of partials of the oscillator. For example: "sine4" would
		 * set be the first 4 partials of the sine wave and "triangle8" would set the first
		 * 8 partials of the triangle wave.
		 * <br><br> 
		 * Uses PeriodicWave internally even for native types so that it can set the phase. 
		 * PeriodicWave equations are from the 
		 * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).
		 *  
		 * @memberOf Tone.Oscillator#
		 * @type {string}
		 * @name type
		 * @example
		 * //set it to a square wave
		 * osc.type = "square";
		 * @example
		 * //set the first 6 partials of a sawtooth wave
		 * osc.type = "sawtooth6";
		 */
	    Object.defineProperty(Tone.Oscillator.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            var coefs = this._getRealImaginary(type, this._phase);
	            var periodicWave = this.context.createPeriodicWave(coefs[0], coefs[1]);
	            this._wave = periodicWave;
	            if (this._oscillator !== null) {
	                this._oscillator.setPeriodicWave(this._wave);
	            }
	            this._type = type;
	        }
	    });
	    /**
		 *  Returns the real and imaginary components based 
		 *  on the oscillator type.
		 *  @returns {Array} [real, imaginary]
		 *  @private
		 */
	    Tone.Oscillator.prototype._getRealImaginary = function (type, phase) {
	        var fftSize = 4096;
	        var periodicWaveSize = fftSize / 2;
	        var real = new Float32Array(periodicWaveSize);
	        var imag = new Float32Array(periodicWaveSize);
	        var partialCount = 1;
	        if (type === Tone.Oscillator.Type.Custom) {
	            partialCount = this._partials.length + 1;
	            periodicWaveSize = partialCount;
	        } else {
	            var partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(type);
	            if (partial) {
	                partialCount = parseInt(partial[2]) + 1;
	                type = partial[1];
	                partialCount = Math.max(partialCount, 2);
	                periodicWaveSize = partialCount;
	            }
	        }
	        for (var n = 1; n < periodicWaveSize; ++n) {
	            var piFactor = 2 / (n * Math.PI);
	            var b;
	            switch (type) {
	            case Tone.Oscillator.Type.Sine:
	                b = n <= partialCount ? 1 : 0;
	                break;
	            case Tone.Oscillator.Type.Square:
	                b = n & 1 ? 2 * piFactor : 0;
	                break;
	            case Tone.Oscillator.Type.Sawtooth:
	                b = piFactor * (n & 1 ? 1 : -1);
	                break;
	            case Tone.Oscillator.Type.Triangle:
	                if (n & 1) {
	                    b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);
	                } else {
	                    b = 0;
	                }
	                break;
	            case Tone.Oscillator.Type.Custom:
	                b = this._partials[n - 1];
	                break;
	            default:
	                throw new TypeError('Tone.Oscillator: invalid type: ' + type);
	            }
	            if (b !== 0) {
	                real[n] = -b * Math.sin(phase * n);
	                imag[n] = b * Math.cos(phase * n);
	            } else {
	                real[n] = 0;
	                imag[n] = 0;
	            }
	        }
	        return [
	            real,
	            imag
	        ];
	    };
	    /**
		 *  Compute the inverse FFT for a given phase.	
		 *  @param  {Float32Array}  real
		 *  @param  {Float32Array}  imag 
		 *  @param  {NormalRange}  phase 
		 *  @return  {AudioRange}
		 *  @private
		 */
	    Tone.Oscillator.prototype._inverseFFT = function (real, imag, phase) {
	        var sum = 0;
	        var len = real.length;
	        for (var i = 0; i < len; i++) {
	            sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);
	        }
	        return sum;
	    };
	    /**
		 *  Returns the initial value of the oscillator.
		 *  @return  {AudioRange}
		 *  @private
		 */
	    Tone.Oscillator.prototype._getInitialValue = function () {
	        var coefs = this._getRealImaginary(this._type, 0);
	        var real = coefs[0];
	        var imag = coefs[1];
	        var maxValue = 0;
	        var twoPi = Math.PI * 2;
	        //check for peaks in 8 places
	        for (var i = 0; i < 8; i++) {
	            maxValue = Math.max(this._inverseFFT(real, imag, i / 8 * twoPi), maxValue);
	        }
	        return -this._inverseFFT(real, imag, this._phase) / maxValue;
	    };
	    /**
		 * The partials of the waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * @memberOf Tone.Oscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.Oscillator.prototype, 'partials', {
	        get: function () {
	            if (this._type !== Tone.Oscillator.Type.Custom) {
	                return [];
	            } else {
	                return this._partials;
	            }
	        },
	        set: function (partials) {
	            this._partials = partials;
	            this.type = Tone.Oscillator.Type.Custom;
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees. 
		 * @memberOf Tone.Oscillator#
		 * @type {Degrees}
		 * @name phase
		 * @example
		 * osc.phase = 180; //flips the phase of the oscillator
		 */
	    Object.defineProperty(Tone.Oscillator.prototype, 'phase', {
	        get: function () {
	            return this._phase * (180 / Math.PI);
	        },
	        set: function (phase) {
	            this._phase = phase * Math.PI / 180;
	            //reset the type
	            this.type = this._type;
	        }
	    });
	    /**
		 *  Dispose and disconnect.
		 *  @return {Tone.Oscillator} this
		 */
	    Tone.Oscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        if (this._oscillator !== null) {
	            this._oscillator.disconnect();
	            this._oscillator = null;
	        }
	        this._wave = null;
	        this._writable([
	            'frequency',
	            'detune'
	        ]);
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune.dispose();
	        this.detune = null;
	        this._partials = null;
	        return this;
	    };
	    return Tone.Oscillator;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Zero outputs 0's at audio-rate. The reason this has to be
		 *         it's own class is that many browsers optimize out Tone.Signal
		 *         with a value of 0 and will not process nodes further down the graph.
		 *  @extends {Tone.SignalBase}
		 */
	    Tone.Zero = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  The gain node
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._gain = this.input = this.output = new Tone.Gain();
	        this.context.getConstant(0).connect(this._gain);
	    };
	    Tone.extend(Tone.Zero, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @return  {Tone.Zero}  this
		 */
	    Tone.Zero.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._gain.dispose();
	        this._gain = null;
	        return this;
	    };
	    return Tone.Zero;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  LFO stands for low frequency oscillator. Tone.LFO produces an output signal
		 *          which can be attached to an AudioParam or Tone.Signal
		 *          in order to modulate that parameter with an oscillator. The LFO can
		 *          also be synced to the transport to start/stop and change when the tempo changes.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Frequency|Object} [frequency] The frequency of the oscillation. Typically, LFOs will be
		 *                               in the frequency range of 0.1 to 10 hertz.
		 *  @param {number=} min The minimum output value of the LFO.
		 *  @param {number=} max The maximum value of the LFO.
		 *  @example
		 * var lfo = new Tone.LFO("4n", 400, 4000);
		 * lfo.connect(filter.frequency);
		 */
	    Tone.LFO = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'min',
	            'max'
	        ], Tone.LFO);
	        Tone.AudioNode.call(this);
	        /**
			 *  The oscillator.
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._oscillator = new Tone.Oscillator({
	            'frequency': options.frequency,
	            'type': options.type
	        });
	        /**
			 *  the lfo's frequency
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._oscillator.frequency;
	        /**
			 * The amplitude of the LFO, which controls the output range between
			 * the min and max output. For example if the min is -10 and the max
			 * is 10, setting the amplitude to 0.5 would make the LFO modulate
			 * between -5 and 5.
			 * @type {Number}
			 * @signal
			 */
	        this.amplitude = this._oscillator.volume;
	        this.amplitude.units = Tone.Type.NormalRange;
	        this.amplitude.value = options.amplitude;
	        /**
			 *  The signal which is output when the LFO is stopped
			 *  @type  {Tone.Signal}
			 *  @private
			 */
	        this._stoppedSignal = new Tone.Signal(0, Tone.Type.AudioRange);
	        /**
			 *  Just outputs zeros.
			 *  @type {Tone.Zero}
			 *  @private
			 */
	        this._zeros = new Tone.Zero();
	        /**
			 *  The value that the LFO outputs when it's stopped
			 *  @type {AudioRange}
			 *  @private
			 */
	        this._stoppedValue = 0;
	        /**
			 *  @type {Tone.AudioToGain}
			 *  @private
			 */
	        this._a2g = new Tone.AudioToGain();
	        /**
			 *  @type {Tone.Scale}
			 *  @private
			 */
	        this._scaler = this.output = new Tone.Scale(options.min, options.max);
	        /**
			 *  the units of the LFO (used for converting)
			 *  @type {Tone.Type}
			 *  @private
			 */
	        this._units = Tone.Type.Default;
	        this.units = options.units;
	        //connect it up
	        this._oscillator.chain(this._a2g, this._scaler);
	        this._zeros.connect(this._a2g);
	        this._stoppedSignal.connect(this._a2g);
	        this._readOnly([
	            'amplitude',
	            'frequency'
	        ]);
	        this.phase = options.phase;
	    };
	    Tone.extend(Tone.LFO, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.LFO.defaults = {
	        'type': 'sine',
	        'min': 0,
	        'max': 1,
	        'phase': 0,
	        'frequency': '4n',
	        'amplitude': 1,
	        'units': Tone.Type.Default
	    };
	    /**
		 *  Start the LFO.
		 *  @param  {Time} [time=now] the time the LFO will start
		 *  @returns {Tone.LFO} this
		 */
	    Tone.LFO.prototype.start = function (time) {
	        time = this.toSeconds(time);
	        this._stoppedSignal.setValueAtTime(0, time);
	        this._oscillator.start(time);
	        return this;
	    };
	    /**
		 *  Stop the LFO.
		 *  @param  {Time} [time=now] the time the LFO will stop
		 *  @returns {Tone.LFO} this
		 */
	    Tone.LFO.prototype.stop = function (time) {
	        time = this.toSeconds(time);
	        this._stoppedSignal.setValueAtTime(this._stoppedValue, time);
	        this._oscillator.stop(time);
	        return this;
	    };
	    /**
		 *  Sync the start/stop/pause to the transport
		 *  and the frequency to the bpm of the transport
		 *  @returns {Tone.LFO} this
		 *  @example
		 *  lfo.frequency.value = "8n";
		 *  lfo.sync().start(0)
		 *  //the rate of the LFO will always be an eighth note,
		 *  //even as the tempo changes
		 */
	    Tone.LFO.prototype.sync = function () {
	        this._oscillator.sync();
	        this._oscillator.syncFrequency();
	        return this;
	    };
	    /**
		 *  unsync the LFO from transport control
		 *  @returns {Tone.LFO} this
		 */
	    Tone.LFO.prototype.unsync = function () {
	        this._oscillator.unsync();
	        this._oscillator.unsyncFrequency();
	        return this;
	    };
	    /**
		 * The miniumum output of the LFO.
		 * @memberOf Tone.LFO#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'min', {
	        get: function () {
	            return this._toUnits(this._scaler.min);
	        },
	        set: function (min) {
	            min = this._fromUnits(min);
	            this._scaler.min = min;
	        }
	    });
	    /**
		 * The maximum output of the LFO.
		 * @memberOf Tone.LFO#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'max', {
	        get: function () {
	            return this._toUnits(this._scaler.max);
	        },
	        set: function (max) {
	            max = this._fromUnits(max);
	            this._scaler.max = max;
	        }
	    });
	    /**
		 * The type of the oscillator: sine, square, sawtooth, triangle.
		 * @memberOf Tone.LFO#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'type', {
	        get: function () {
	            return this._oscillator.type;
	        },
	        set: function (type) {
	            this._oscillator.type = type;
	            this._stoppedValue = this._oscillator._getInitialValue();
	            this._stoppedSignal.value = this._stoppedValue;
	        }
	    });
	    /**
		 * The phase of the LFO.
		 * @memberOf Tone.LFO#
		 * @type {number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'phase', {
	        get: function () {
	            return this._oscillator.phase;
	        },
	        set: function (phase) {
	            this._oscillator.phase = phase;
	            this._stoppedValue = this._oscillator._getInitialValue();
	            this._stoppedSignal.value = this._stoppedValue;
	        }
	    });
	    /**
		 * The output units of the LFO.
		 * @memberOf Tone.LFO#
		 * @type {Tone.Type}
		 * @name units
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'units', {
	        get: function () {
	            return this._units;
	        },
	        set: function (val) {
	            var currentMin = this.min;
	            var currentMax = this.max;
	            //convert the min and the max
	            this._units = val;
	            this.min = currentMin;
	            this.max = currentMax;
	        }
	    });
	    /**
		 * Mute the output.
		 * @memberOf Tone.LFO#
		 * @type {Boolean}
		 * @name mute
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'mute', {
	        get: function () {
	            return this._oscillator.mute;
	        },
	        set: function (mute) {
	            this._oscillator.mute = mute;
	        }
	    });
	    /**
		 *  Returns the playback state of the source, either "started" or "stopped".
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.LFO#
		 *  @name state
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'state', {
	        get: function () {
	            return this._oscillator.state;
	        }
	    });
	    /**
		 *  Connect the output of the LFO to an AudioParam, AudioNode, or Tone Node.
		 *  Tone.LFO will automatically convert to the destination units of the
		 *  will get the units from the connected node.
		 *  @param  {Tone | AudioParam | AudioNode} node
		 *  @param {number} [outputNum=0] optionally which output to connect from
		 *  @param {number} [inputNum=0] optionally which input to connect to
		 *  @returns {Tone.LFO} this
		 *  @private
		 */
	    Tone.LFO.prototype.connect = function (node) {
	        if (node.constructor === Tone.Signal || node.constructor === Tone.Param || node.constructor === Tone.TimelineSignal) {
	            this.convert = node.convert;
	            this.units = node.units;
	        }
	        Tone.Signal.prototype.connect.apply(this, arguments);
	        return this;
	    };
	    /**
		 *  private method borrowed from Param converts
		 *  units from their destination value
		 *  @function
		 *  @private
		 */
	    Tone.LFO.prototype._fromUnits = Tone.Param.prototype._fromUnits;
	    /**
		 *  private method borrowed from Param converts
		 *  units to their destination value
		 *  @function
		 *  @private
		 */
	    Tone.LFO.prototype._toUnits = Tone.Param.prototype._toUnits;
	    /**
		 *  disconnect and dispose
		 *  @returns {Tone.LFO} this
		 */
	    Tone.LFO.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'amplitude',
	            'frequency'
	        ]);
	        this._oscillator.dispose();
	        this._oscillator = null;
	        this._stoppedSignal.dispose();
	        this._stoppedSignal = null;
	        this._zeros.dispose();
	        this._zeros = null;
	        this._scaler.dispose();
	        this._scaler = null;
	        this._a2g.dispose();
	        this._a2g = null;
	        this.frequency = null;
	        this.amplitude = null;
	        return this;
	    };
	    return Tone.LFO;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Limiter will limit the loudness of an incoming signal.
		 *         It is composed of a Tone.Compressor with a fast attack
		 *         and release. Limiters are commonly used to safeguard against
		 *         signal clipping. Unlike a compressor, limiters do not provide
		 *         smooth gain reduction and almost completely prevent
		 *         additional gain above the threshold.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {number} threshold The theshold above which the limiting is applied.
		 *  @example
		 *  var limiter = new Tone.Limiter(-6);
		 */
	    Tone.Limiter = function () {
	        var options = Tone.defaults(arguments, ['threshold'], Tone.Limiter);
	        Tone.AudioNode.call(this);
	        /**
			 *  the compressor
			 *  @private
			 *  @type {Tone.Compressor}
			 */
	        this._compressor = this.input = this.output = new Tone.Compressor({
	            'attack': 0.001,
	            'decay': 0.001,
	            'threshold': options.threshold
	        });
	        /**
			 * The threshold of of the limiter
			 * @type {Decibel}
			 * @signal
			 */
	        this.threshold = this._compressor.threshold;
	        this._readOnly('threshold');
	    };
	    Tone.extend(Tone.Limiter, Tone.AudioNode);
	    /**
		 *  The default value
		 *  @type {Object}
		 *  @const
		 *  @static
		 */
	    Tone.Limiter.defaults = { 'threshold': -12 };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Limiter} this
		 */
	    Tone.Limiter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._compressor.dispose();
	        this._compressor = null;
	        this._writable('threshold');
	        this.threshold = null;
	        return this;
	    };
	    return Tone.Limiter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Lowpass is a lowpass feedback comb filter. It is similar to
		 *         Tone.FeedbackCombFilter, but includes a lowpass filter.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Time|Object} [delayTime] The delay time of the comb filter
		 *  @param {NormalRange=} resonance The resonance (feedback) of the comb filter
		 *  @param {Frequency=} dampening The cutoff of the lowpass filter dampens the
		 *                                signal as it is fedback.
		 */
	    Tone.LowpassCombFilter = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'resonance',
	            'dampening'
	        ], Tone.LowpassCombFilter);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  the delay node
			 *  @type {DelayNode}
			 *  @private
			 */
	        this._delay = this.input = new Tone.Delay(options.delayTime);
	        /**
			 *  The delayTime of the comb filter.
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = this._delay.delayTime;
	        /**
			 *  the lowpass filter
			 *  @type  {BiquadFilterNode}
			 *  @private
			 */
	        this._lowpass = this.output = this.context.createBiquadFilter();
	        this._lowpass.Q.value = -3.0102999566398125;
	        this._lowpass.type = 'lowpass';
	        /**
			 *  The dampening control of the feedback
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.dampening = new Tone.Param({
	            'param': this._lowpass.frequency,
	            'units': Tone.Type.Frequency,
	            'value': options.dampening
	        });
	        /**
			 *  the feedback gain
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedback = new Tone.Gain(options.resonance, Tone.Type.NormalRange);
	        /**
			 *  The amount of feedback of the delayed signal.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.resonance = this._feedback.gain;
	        //connections
	        this._delay.chain(this._lowpass, this._feedback, this._delay);
	        this._readOnly([
	            'dampening',
	            'resonance',
	            'delayTime'
	        ]);
	    };
	    Tone.extend(Tone.LowpassCombFilter, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.LowpassCombFilter.defaults = {
	        'delayTime': 0.1,
	        'resonance': 0.5,
	        'dampening': 3000
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.LowpassCombFilter} this
		 */
	    Tone.LowpassCombFilter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'dampening',
	            'resonance',
	            'delayTime'
	        ]);
	        this.dampening.dispose();
	        this.dampening = null;
	        this.resonance.dispose();
	        this.resonance = null;
	        this._delay.dispose();
	        this._delay = null;
	        this.delayTime = null;
	        this._lowpass.disconnect();
	        this._lowpass = null;
	        this._feedback.disconnect();
	        this._feedback = null;
	        return this;
	    };
	    return Tone.LowpassCombFilter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Merge brings two signals into the left and right
		 *          channels of a single stereo channel.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @example
		 * var merge = new Tone.Merge().toMaster();
		 * //routing a sine tone in the left channel
		 * //and noise in the right channel
		 * var osc = new Tone.Oscillator().connect(merge.left);
		 * var noise = new Tone.Noise().connect(merge.right);
		 * //starting our oscillators
		 * noise.start();
		 * osc.start();
		 */
	    Tone.Merge = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  The left input channel.
			 *  Alias for <code>input[0]</code>
			 *  @type {GainNode}
			 */
	        this.left = this.input[0] = new Tone.Gain();
	        /**
			 *  The right input channel.
			 *  Alias for <code>input[1]</code>.
			 *  @type {GainNode}
			 */
	        this.right = this.input[1] = new Tone.Gain();
	        /**
			 *  the merger node for the two channels
			 *  @type {ChannelMergerNode}
			 *  @private
			 */
	        this._merger = this.output = this.context.createChannelMerger(2);
	        //connections
	        this.left.connect(this._merger, 0, 0);
	        this.right.connect(this._merger, 0, 1);
	        this.left.channelCount = 1;
	        this.right.channelCount = 1;
	        this.left.channelCountMode = 'explicit';
	        this.right.channelCountMode = 'explicit';
	    };
	    Tone.extend(Tone.Merge, Tone.AudioNode);
	    /**
		 *  Clean up.
		 *  @returns {Tone.Merge} this
		 */
	    Tone.Merge.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.left.dispose();
	        this.left = null;
	        this.right.dispose();
	        this.right = null;
	        this._merger.disconnect();
	        this._merger = null;
	        return this;
	    };
	    return Tone.Merge;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)
		 *          of an input signal with some averaging applied. It can also get the raw
		 *          value of the input signal.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {String} type Either "level" or "signal".
		 *  @param {Number} smoothing The amount of smoothing applied between frames.
		 *  @example
		 * var meter = new Tone.Meter();
		 * var mic = new Tone.UserMedia().open();
		 * //connect mic to the meter
		 * mic.connect(meter);
		 * //the current level of the mic input
		 * var level = meter.value;
		 */
	    Tone.Meter = function () {
	        var options = Tone.defaults(arguments, [
	            'type',
	            'smoothing'
	        ], Tone.Meter);
	        Tone.AudioNode.call(this);
	        /**
			 *  The type of the meter, either "level" or "signal".
			 *  A "level" meter will return the volume level (rms) of the
			 *  input signal and a "signal" meter will return
			 *  the signal value of the input.
			 *  @type  {String}
			 */
	        this.type = options.type;
	        /**
			 *  The analyser node which computes the levels.
			 *  @private
			 *  @type  {Tone.Analyser}
			 */
	        this.input = this.output = this._analyser = new Tone.Analyser('waveform', 512);
	        /**
			 *  The amount of carryover between the current and last frame.
			 *  Only applied meter for "level" type.
			 *  @type  {Number}
			 */
	        this.smoothing = options.smoothing;
	        /**
			 *  The last computed value
			 *  @type {Number}
			 *  @private
			 */
	        this._lastValue = 0;
	    };
	    Tone.extend(Tone.Meter, Tone.AudioNode);
	    /**
		 *  @private
		 *  @enum {String}
		 */
	    Tone.Meter.Type = {
	        Level: 'level',
	        Signal: 'signal'
	    };
	    /**
		 *  The defaults
		 *  @type {Object}
		 *  @static
		 *  @const
		 */
	    Tone.Meter.defaults = {
	        'smoothing': 0.8,
	        'type': Tone.Meter.Type.Level
	    };
	    /**
		 * The current value of the meter. A value of 1 is
		 * "unity".
		 * @memberOf Tone.Meter#
		 * @type {Number}
		 * @name value
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Meter.prototype, 'value', {
	        get: function () {
	            var signal = this._analyser.analyse();
	            if (this.type === Tone.Meter.Type.Level) {
	                //rms
	                var sum = 0;
	                for (var i = 0; i < signal.length; i++) {
	                    sum += Math.pow(signal[i], 2);
	                }
	                var rms = Math.sqrt(sum / signal.length);
	                //smooth it
	                rms = Math.max(rms, this._lastValue * this.smoothing);
	                this._lastValue = rms;
	                //scale it
	                var unity = 0.35;
	                var val = rms / unity;
	                //scale the output curve
	                return Math.sqrt(val);
	            } else {
	                return signal[0];
	            }
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.Meter} this
		 */
	    Tone.Meter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._analyser.dispose();
	        this._analyser = null;
	        return this;
	    };
	    return Tone.Meter;
	});
	Module(function (Tone) {
	    
	    /**
		 *	@class  Tone.Split splits an incoming signal into left and right channels.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @example
		 * var split = new Tone.Split();
		 * stereoSignal.connect(split);
		 */
	    Tone.Split = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(0, 2);
	        /**
			 *  @type {ChannelSplitterNode}
			 *  @private
			 */
	        this._splitter = this.input = this.context.createChannelSplitter(2);
	        this._splitter.channelCount = 2;
	        this._splitter.channelCountMode = 'explicit';
	        /**
			 *  Left channel output.
			 *  Alias for <code>output[0]</code>
			 *  @type {Tone.Gain}
			 */
	        this.left = this.output[0] = new Tone.Gain();
	        /**
			 *  Right channel output.
			 *  Alias for <code>output[1]</code>
			 *  @type {Tone.Gain}
			 */
	        this.right = this.output[1] = new Tone.Gain();
	        //connections
	        this._splitter.connect(this.left, 0, 0);
	        this._splitter.connect(this.right, 1, 0);
	    };
	    Tone.extend(Tone.Split, Tone.AudioNode);
	    /**
		 *  Clean up.
		 *  @returns {Tone.Split} this
		 */
	    Tone.Split.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._splitter.disconnect();
	        this.left.dispose();
	        this.left = null;
	        this.right.dispose();
	        this.right = null;
	        this._splitter = null;
	        return this;
	    };
	    return Tone.Split;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Mid/Side processing separates the the 'mid' signal
		 *         (which comes out of both the left and the right channel)
		 *         and the 'side' (which only comes out of the the side channels). <br><br>
		 *         <code>
		 *         Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right<br>
		 *         Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and righ<br>
		 *         </code>
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 */
	    Tone.MidSideSplit = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(0, 2);
	        /**
			 *  split the incoming signal into left and right channels
			 *  @type  {Tone.Split}
			 *  @private
			 */
	        this._split = this.input = new Tone.Split();
	        /**
			 *  The mid send. Connect to mid processing. Alias for
			 *  <code>output[0]</code>
			 *  @type {Tone.Expr}
			 */
	        this.mid = this.output[0] = new Tone.Expr('($0 + $1) * $2');
	        /**
			 *  The side output. Connect to side processing. Alias for
			 *  <code>output[1]</code>
			 *  @type {Tone.Expr}
			 */
	        this.side = this.output[1] = new Tone.Expr('($0 - $1) * $2');
	        this._split.connect(this.mid, 0, 0);
	        this._split.connect(this.mid, 1, 1);
	        this._split.connect(this.side, 0, 0);
	        this._split.connect(this.side, 1, 1);
	        this.context.getConstant(Math.SQRT1_2).connect(this.mid, 0, 2);
	        this.context.getConstant(Math.SQRT1_2).connect(this.side, 0, 2);
	    };
	    Tone.extend(Tone.MidSideSplit, Tone.AudioNode);
	    /**
		 *  clean up
		 *  @returns {Tone.MidSideSplit} this
		 */
	    Tone.MidSideSplit.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.mid.dispose();
	        this.mid = null;
	        this.side.dispose();
	        this.side = null;
	        this._split.dispose();
	        this._split = null;
	        return this;
	    };
	    return Tone.MidSideSplit;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Mid/Side processing separates the the 'mid' signal
		 *         (which comes out of both the left and the right channel)
		 *         and the 'side' (which only comes out of the the side channels).
		 *         MidSideMerge merges the mid and side signal after they've been seperated
		 *         by Tone.MidSideSplit.<br><br>
		 *         <code>
		 *         Left = (Mid+Side)/sqrt(2);   // obtain left signal from mid and side<br>
		 *         Right = (Mid-Side)/sqrt(2);   // obtain right signal from mid and side<br>
		 *         </code>
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 */
	    Tone.MidSideMerge = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  The mid signal input. Alias for
			 *  <code>input[0]</code>
			 *  @type  {Tone.Gain}
			 */
	        this.mid = this.input[0] = new Tone.Gain();
	        /**
			 *  recombine the mid/side into Left
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this._left = new Tone.Expr('($0 + $1) * $2');
	        /**
			 *  The side signal input. Alias for
			 *  <code>input[1]</code>
			 *  @type  {Tone.Gain}
			 */
	        this.side = this.input[1] = new Tone.Gain();
	        /**
			 *  recombine the mid/side into Right
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this._right = new Tone.Expr('($0 - $1) * $2');
	        /**
			 *  Merge the left/right signal back into a stereo signal.
			 *  @type {Tone.Merge}
			 *  @private
			 */
	        this._merge = this.output = new Tone.Merge();
	        this.mid.connect(this._left, 0, 0);
	        this.side.connect(this._left, 0, 1);
	        this.mid.connect(this._right, 0, 0);
	        this.side.connect(this._right, 0, 1);
	        this._left.connect(this._merge, 0, 0);
	        this._right.connect(this._merge, 0, 1);
	        this.context.getConstant(Math.SQRT1_2).connect(this._left, 0, 2);
	        this.context.getConstant(Math.SQRT1_2).connect(this._right, 0, 2);
	    };
	    Tone.extend(Tone.MidSideMerge, Tone.AudioNode);
	    /**
		 *  clean up
		 *  @returns {Tone.MidSideMerge} this
		 */
	    Tone.MidSideMerge.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.mid.dispose();
	        this.mid = null;
	        this.side.dispose();
	        this.side = null;
	        this._left.dispose();
	        this._left = null;
	        this._right.dispose();
	        this._right = null;
	        this._merge.dispose();
	        this._merge = null;
	        return this;
	    };
	    return Tone.MidSideMerge;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.MidSideCompressor applies two different compressors to the mid
		 *         and side signal components. See Tone.MidSideSplit.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @param {Object} options The options that are passed to the mid and side
		 *                          compressors.
		 *  @constructor
		 */
	    Tone.MidSideCompressor = function (options) {
	        Tone.AudioNode.call(this);
	        options = Tone.defaultArg(options, Tone.MidSideCompressor.defaults);
	        /**
			 *  the mid/side split
			 *  @type  {Tone.MidSideSplit}
			 *  @private
			 */
	        this._midSideSplit = this.input = new Tone.MidSideSplit();
	        /**
			 *  the mid/side recombination
			 *  @type  {Tone.MidSideMerge}
			 *  @private
			 */
	        this._midSideMerge = this.output = new Tone.MidSideMerge();
	        /**
			 *  The compressor applied to the mid signal
			 *  @type  {Tone.Compressor}
			 */
	        this.mid = new Tone.Compressor(options.mid);
	        /**
			 *  The compressor applied to the side signal
			 *  @type  {Tone.Compressor}
			 */
	        this.side = new Tone.Compressor(options.side);
	        this._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);
	        this._midSideSplit.side.chain(this.side, this._midSideMerge.side);
	        this._readOnly([
	            'mid',
	            'side'
	        ]);
	    };
	    Tone.extend(Tone.MidSideCompressor, Tone.AudioNode);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MidSideCompressor.defaults = {
	        'mid': {
	            'ratio': 3,
	            'threshold': -24,
	            'release': 0.03,
	            'attack': 0.02,
	            'knee': 16
	        },
	        'side': {
	            'ratio': 6,
	            'threshold': -30,
	            'release': 0.25,
	            'attack': 0.03,
	            'knee': 10
	        }
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.MidSideCompressor} this
		 */
	    Tone.MidSideCompressor.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'mid',
	            'side'
	        ]);
	        this.mid.dispose();
	        this.mid = null;
	        this.side.dispose();
	        this.side = null;
	        this._midSideSplit.dispose();
	        this._midSideSplit = null;
	        this._midSideMerge.dispose();
	        this._midSideMerge = null;
	        return this;
	    };
	    return Tone.MidSideCompressor;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Mono coerces the incoming mono or stereo signal into a mono signal
		 *         where both left and right channels have the same value. This can be useful
		 *         for [stereo imaging](https://en.wikipedia.org/wiki/Stereo_imaging).
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 */
	    Tone.Mono = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 0);
	        /**
			 *  merge the signal
			 *  @type {Tone.Merge}
			 *  @private
			 */
	        this._merge = this.output = new Tone.Merge();
	        this.input.connect(this._merge, 0, 0);
	        this.input.connect(this._merge, 0, 1);
	        this.input.gain.value = Tone.dbToGain(-10);
	    };
	    Tone.extend(Tone.Mono);
	    /**
		 *  clean up
		 *  @returns {Tone.Mono} this
		 */
	    Tone.Mono.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._merge.dispose();
	        this._merge = null;
	        return this;
	    };
	    return Tone.Mono;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A compressor with seperate controls over low/mid/high dynamics
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Object} options The low/mid/high compressor settings.
		 *  @example
		 *  var multiband = new Tone.MultibandCompressor({
		 *  	"lowFrequency" : 200,
		 *  	"highFrequency" : 1300
		 *  	"low" : {
		 *  		"threshold" : -12
		 *  	}
		 *  })
		 */
	    Tone.MultibandCompressor = function (options) {
	        Tone.AudioNode.call(this);
	        options = Tone.defaultArg(arguments, Tone.MultibandCompressor.defaults);
	        /**
			 *  split the incoming signal into high/mid/low
			 *  @type {Tone.MultibandSplit}
			 *  @private
			 */
	        this._splitter = this.input = new Tone.MultibandSplit({
	            'lowFrequency': options.lowFrequency,
	            'highFrequency': options.highFrequency
	        });
	        /**
			 *  low/mid crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.lowFrequency = this._splitter.lowFrequency;
	        /**
			 *  mid/high crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.highFrequency = this._splitter.highFrequency;
	        /**
			 *  the output
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this.output = new Tone.Gain();
	        /**
			 *  The compressor applied to the low frequencies.
			 *  @type {Tone.Compressor}
			 */
	        this.low = new Tone.Compressor(options.low);
	        /**
			 *  The compressor applied to the mid frequencies.
			 *  @type {Tone.Compressor}
			 */
	        this.mid = new Tone.Compressor(options.mid);
	        /**
			 *  The compressor applied to the high frequencies.
			 *  @type {Tone.Compressor}
			 */
	        this.high = new Tone.Compressor(options.high);
	        //connect the compressor
	        this._splitter.low.chain(this.low, this.output);
	        this._splitter.mid.chain(this.mid, this.output);
	        this._splitter.high.chain(this.high, this.output);
	        this._readOnly([
	            'high',
	            'mid',
	            'low',
	            'highFrequency',
	            'lowFrequency'
	        ]);
	    };
	    Tone.extend(Tone.MultibandCompressor, Tone.AudioNode);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MultibandCompressor.defaults = {
	        'low': Tone.Compressor.defaults,
	        'mid': Tone.Compressor.defaults,
	        'high': Tone.Compressor.defaults,
	        'lowFrequency': 250,
	        'highFrequency': 2000
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.MultibandCompressor} this
		 */
	    Tone.MultibandCompressor.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._splitter.dispose();
	        this._writable([
	            'high',
	            'mid',
	            'low',
	            'highFrequency',
	            'lowFrequency'
	        ]);
	        this.low.dispose();
	        this.mid.dispose();
	        this.high.dispose();
	        this._splitter = null;
	        this.low = null;
	        this.mid = null;
	        this.high = null;
	        this.lowFrequency = null;
	        this.highFrequency = null;
	        return this;
	    };
	    return Tone.MultibandCompressor;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Panner is an equal power Left/Right Panner and does not
		 *          support 3D. Panner uses the StereoPannerNode when available.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {NormalRange} [initialPan=0] The initail panner value (center).
		 *  @example
		 *  //pan the input signal hard right.
		 *  var panner = new Tone.Panner(1);
		 */
	    Tone.Panner = function (initialPan) {
	        Tone.AudioNode.call(this);
	        if (Tone.Panner.hasStereoPanner) {
	            /**
				 *  the panner node
				 *  @type {StereoPannerNode}
				 *  @private
				 */
	            this._panner = this.input = this.output = this.context.createStereoPanner();
	            /**
				 *  The pan control. -1 = hard left, 1 = hard right.
				 *  @type {NormalRange}
				 *  @signal
				 */
	            this.pan = this._panner.pan;
	        } else {
	            /**
				 *  the dry/wet knob
				 *  @type {Tone.CrossFade}
				 *  @private
				 */
	            this._crossFade = new Tone.CrossFade();
	            /**
				 *  @type {Tone.Merge}
				 *  @private
				 */
	            this._merger = this.output = new Tone.Merge();
	            /**
				 *  @type {Tone.Split}
				 *  @private
				 */
	            this._splitter = this.input = new Tone.Split();
	            /**
				 *  The pan control. -1 = hard left, 1 = hard right.
				 *  @type {AudioRange}
				 *  @signal
				 */
	            this.pan = new Tone.Signal(0, Tone.Type.AudioRange);
	            /**
				 *  always sends 0
				 *  @type {Tone.Zero}
				 *  @private
				 */
	            this._zero = new Tone.Zero();
	            /**
				 *  The analog to gain conversion
				 *  @type  {Tone.AudioToGain}
				 *  @private
				 */
	            this._a2g = new Tone.AudioToGain();
	            //CONNECTIONS:
	            this._zero.connect(this._a2g);
	            this.pan.chain(this._a2g, this._crossFade.fade);
	            //left channel is a, right channel is b
	            this._splitter.connect(this._crossFade, 0, 0);
	            this._splitter.connect(this._crossFade, 1, 1);
	            //merge it back together
	            this._crossFade.a.connect(this._merger, 0, 0);
	            this._crossFade.b.connect(this._merger, 0, 1);
	        }
	        //initial value
	        this.pan.value = Tone.defaultArg(initialPan, 0);
	        this._readOnly('pan');
	    };
	    Tone.extend(Tone.Panner, Tone.AudioNode);
	    /**
		 *  Indicates if the panner is using the new StereoPannerNode internally
		 *  @type  {Boolean}
		 *  @static
		 *  @private
		 *  @readOnly
		 */
	    Tone.Panner.hasStereoPanner = Tone.context && Tone.isFunction(Tone.context.createStereoPanner);
	    /**
		 *  Clean up.
		 *  @returns {Tone.Panner} this
		 */
	    Tone.Panner.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable('pan');
	        if (Tone.Panner.hasStereoPanner) {
	            this._panner.disconnect();
	            this._panner = null;
	            this.pan = null;
	        } else {
	            this._zero.dispose();
	            this._zero = null;
	            this._crossFade.dispose();
	            this._crossFade = null;
	            this._splitter.dispose();
	            this._splitter = null;
	            this._merger.dispose();
	            this._merger = null;
	            this.pan.dispose();
	            this.pan = null;
	            this._a2g.dispose();
	            this._a2g = null;
	        }
	        return this;
	    };
	    return Tone.Panner;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A spatialized panner node which supports equalpower or HRTF panning.
		 *          Tries to normalize the API across various browsers. See Tone.Listener
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Number} positionX The initial x position.
		 *  @param {Number} positionY The initial y position.
		 *  @param {Number} positionZ The initial z position.
		 */
	    Tone.Panner3D = function () {
	        var options = Tone.defaults(arguments, [
	            'positionX',
	            'positionY',
	            'positionZ'
	        ], Tone.Panner3D);
	        Tone.AudioNode.call(this);
	        /**
			 *  The panner node
			 *  @type {PannerNode}
			 *  @private
			 */
	        this._panner = this.input = this.output = this.context.createPanner();
	        //set some values
	        this._panner.panningModel = options.panningModel;
	        this._panner.maxDistance = options.maxDistance;
	        this._panner.distanceModel = options.distanceModel;
	        this._panner.coneOuterGain = options.coneOuterGain;
	        this._panner.coneOuterAngle = options.coneOuterAngle;
	        this._panner.coneInnerAngle = options.coneInnerAngle;
	        this._panner.refDistance = options.refDistance;
	        this._panner.rolloffFactor = options.rolloffFactor;
	        /**
			 *  Holds the current orientation
			 *  @type  {Array}
			 *  @private
			 */
	        this._orientation = [
	            options.orientationX,
	            options.orientationY,
	            options.orientationZ
	        ];
	        /**
			 *  Holds the current position
			 *  @type  {Array}
			 *  @private
			 */
	        this._position = [
	            options.positionX,
	            options.positionY,
	            options.positionZ
	        ];
	        // set the default position/orientation
	        this.orientationX = options.orientationX;
	        this.orientationY = options.orientationY;
	        this.orientationZ = options.orientationZ;
	        this.positionX = options.positionX;
	        this.positionY = options.positionY;
	        this.positionZ = options.positionZ;
	    };
	    Tone.extend(Tone.Panner3D, Tone.AudioNode);
	    /**
		 *  Defaults according to the specification
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Panner3D.defaults = {
	        'positionX': 0,
	        'positionY': 0,
	        'positionZ': 0,
	        'orientationX': 0,
	        'orientationY': 0,
	        'orientationZ': 0,
	        'panningModel': 'equalpower',
	        'maxDistance': 10000,
	        'distanceModel': 'inverse',
	        'coneOuterGain': 0,
	        'coneOuterAngle': 360,
	        'coneInnerAngle': 360,
	        'refDistance': 1,
	        'rolloffFactor': 1
	    };
	    /**
		 * The ramp time which is applied to the setTargetAtTime
		 * @type {Number}
		 * @private
		 */
	    Tone.Panner3D.prototype._rampTimeConstant = 0.01;
	    /**
		 *  Sets the position of the source in 3d space.
		 *  @param  {Number}  x
		 *  @param  {Number}  y
		 *  @param  {Number}  z
		 *  @return {Tone.Panner3D} this
		 */
	    Tone.Panner3D.prototype.setPosition = function (x, y, z) {
	        if (this._panner.positionX) {
	            var now = this.now();
	            this._panner.positionX.setTargetAtTime(x, now, this._rampTimeConstant);
	            this._panner.positionY.setTargetAtTime(y, now, this._rampTimeConstant);
	            this._panner.positionZ.setTargetAtTime(z, now, this._rampTimeConstant);
	        } else {
	            this._panner.setPosition(x, y, z);
	        }
	        this._position = Array.prototype.slice.call(arguments);
	        return this;
	    };
	    /**
		 *  Sets the orientation of the source in 3d space.
		 *  @param  {Number}  x
		 *  @param  {Number}  y
		 *  @param  {Number}  z
		 *  @return {Tone.Panner3D} this
		 */
	    Tone.Panner3D.prototype.setOrientation = function (x, y, z) {
	        if (this._panner.orientationX) {
	            var now = this.now();
	            this._panner.orientationX.setTargetAtTime(x, now, this._rampTimeConstant);
	            this._panner.orientationY.setTargetAtTime(y, now, this._rampTimeConstant);
	            this._panner.orientationZ.setTargetAtTime(z, now, this._rampTimeConstant);
	        } else {
	            this._panner.setOrientation(x, y, z);
	        }
	        this._orientation = Array.prototype.slice.call(arguments);
	        return this;
	    };
	    /**
		 *  The x position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name positionX
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'positionX', {
	        set: function (pos) {
	            this._position[0] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[0];
	        }
	    });
	    /**
		 *  The y position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name positionY
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'positionY', {
	        set: function (pos) {
	            this._position[1] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[1];
	        }
	    });
	    /**
		 *  The z position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name positionZ
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'positionZ', {
	        set: function (pos) {
	            this._position[2] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[2];
	        }
	    });
	    /**
		 *  The x orientation of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name orientationX
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'orientationX', {
	        set: function (pos) {
	            this._orientation[0] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[0];
	        }
	    });
	    /**
		 *  The y orientation of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name orientationY
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'orientationY', {
	        set: function (pos) {
	            this._orientation[1] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[1];
	        }
	    });
	    /**
		 *  The z orientation of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name orientationZ
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'orientationZ', {
	        set: function (pos) {
	            this._orientation[2] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[2];
	        }
	    });
	    /**
		 *  Proxy a property on the panner to an exposed public propery
		 *  @param  {String}  prop
		 *  @private
		 */
	    Tone.Panner3D._aliasProperty = function (prop) {
	        Object.defineProperty(Tone.Panner3D.prototype, prop, {
	            set: function (val) {
	                this._panner[prop] = val;
	            },
	            get: function () {
	                return this._panner[prop];
	            }
	        });
	    };
	    /**
		 *  The panning model. Either "equalpower" or "HRTF".
		 *  @type {String}
		 *  @memberOf Tone.Panner3D#
		 *  @name panningModel
		 */
	    Tone.Panner3D._aliasProperty('panningModel');
	    /**
		 *  A reference distance for reducing volume as source move further from the listener
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name refDistance
		 */
	    Tone.Panner3D._aliasProperty('refDistance');
	    /**
		 *  Describes how quickly the volume is reduced as source moves away from listener.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name rolloffFactor
		 */
	    Tone.Panner3D._aliasProperty('rolloffFactor');
	    /**
		 *  The distance model used by,  "linear", "inverse", or "exponential".
		 *  @type {String}
		 *  @memberOf Tone.Panner3D#
		 *  @name distanceModel
		 */
	    Tone.Panner3D._aliasProperty('distanceModel');
	    /**
		 *  The angle, in degrees, inside of which there will be no volume reduction
		 *  @type {Degrees}
		 *  @memberOf Tone.Panner3D#
		 *  @name coneInnerAngle
		 */
	    Tone.Panner3D._aliasProperty('coneInnerAngle');
	    /**
		 *  The angle, in degrees, outside of which the volume will be reduced
		 *  to a constant value of coneOuterGain
		 *  @type {Degrees}
		 *  @memberOf Tone.Panner3D#
		 *  @name coneOuterAngle
		 */
	    Tone.Panner3D._aliasProperty('coneOuterAngle');
	    /**
		 *  The gain outside of the coneOuterAngle
		 *  @type {Gain}
		 *  @memberOf Tone.Panner3D#
		 *  @name coneOuterGain
		 */
	    Tone.Panner3D._aliasProperty('coneOuterGain');
	    /**
		 *  The maximum distance between source and listener,
		 *  after which the volume will not be reduced any further.
		 *  @type {Positive}
		 *  @memberOf Tone.Panner3D#
		 *  @name maxDistance
		 */
	    Tone.Panner3D._aliasProperty('maxDistance');
	    /**
		 *  Clean up.
		 *  @returns {Tone.Panner3D} this
		 */
	    Tone.Panner3D.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._panner.disconnect();
	        this._panner = null;
	        this._orientation = null;
	        this._position = null;
	        return this;
	    };
	    return Tone.Panner3D;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.PanVol is a Tone.Panner and Tone.Volume in one.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {AudioRange} pan the initial pan
		 *  @param {number} volume The output volume.
		 *  @example
		 * //pan the incoming signal left and drop the volume
		 * var panVol = new Tone.PanVol(-0.25, -12);
		 */
	    Tone.PanVol = function () {
	        var options = Tone.defaults(arguments, [
	            'pan',
	            'volume'
	        ], Tone.PanVol);
	        Tone.AudioNode.call(this);
	        /**
			 *  The panning node
			 *  @type {Tone.Panner}
			 *  @private
			 */
	        this._panner = this.input = new Tone.Panner(options.pan);
	        /**
			 *  The L/R panning control.
			 *  @type {AudioRange}
			 *  @signal
			 */
	        this.pan = this._panner.pan;
	        /**
			 *  The volume node
			 *  @type {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 *  The volume control in decibels.
			 *  @type {Decibels}
			 *  @signal
			 */
	        this.volume = this._volume.volume;
	        //connections
	        this._panner.connect(this._volume);
	        this.mute = options.mute;
	        this._readOnly([
	            'pan',
	            'volume'
	        ]);
	    };
	    Tone.extend(Tone.PanVol, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @type  {Object}
		 *  @const
		 *  @static
		 */
	    Tone.PanVol.defaults = {
	        'pan': 0,
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 * Mute/unmute the volume
		 * @memberOf Tone.PanVol#
		 * @name mute
		 * @type {Boolean}
		 */
	    Object.defineProperty(Tone.PanVol.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.PanVol} this
		 */
	    Tone.PanVol.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'pan',
	            'volume'
	        ]);
	        this._panner.dispose();
	        this._panner = null;
	        this.pan = null;
	        this._volume.dispose();
	        this._volume = null;
	        this.volume = null;
	        return this;
	    };
	    return Tone.PanVol;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Solo lets you isolate a specific audio stream. When
		 *         an instance is set to `solo=true`, it will mute all other instances.
		 *  @extends {Tone.AudioNode}
		 *  @example
		 * var soloA = new Tone.Solo()
		 * var soloB = new Tone.Solo()
		 * soloA.solo = true
		 * //no audio will pass through soloB
		 */
	    Tone.Solo = function () {
	        var options = Tone.defaults(arguments, ['solo'], Tone.Solo);
	        Tone.AudioNode.call(this);
	        /**
			 *  The input and output node
			 *  @type  {Tone.Gain}
			 */
	        this.input = this.output = new Tone.Gain();
	        /**
			 *  A bound _soloed method
			 *  @type  {Function}
			 *  @private
			 */
	        this._soloBind = this._soloed.bind(this);
	        //listen for solo events class-wide.
	        this.context.on('solo', this._soloBind);
	        //set initially
	        this.solo = options.solo;
	    };
	    Tone.extend(Tone.Solo, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @type  {Object}
		 *  @static
		 */
	    Tone.Solo.defaults = { solo: false };
	    /**
		 *  Isolates this instance and mutes all other instances of Tone.Solo.
		 *  Only one instance can be soloed at a time. A soloed
		 *  instance will report `solo=false` when another instance is soloed.
		 *  @memberOf Tone.Solo#
		 *  @type {Boolean}
		 *  @name solo
		 */
	    Object.defineProperty(Tone.Solo.prototype, 'solo', {
	        get: function () {
	            return this._isSoloed();
	        },
	        set: function (solo) {
	            if (solo) {
	                this._addSolo();
	            } else {
	                this._removeSolo();
	            }
	            this.context.emit('solo', this);
	        }
	    });
	    /**
		 *  If the current instance is muted, i.e. another instance is soloed
		 *  @memberOf Tone.Solo#
		 *  @type {Boolean}
		 *  @name muted
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Solo.prototype, 'muted', {
	        get: function () {
	            return this.input.gain.value === 0;
	        }
	    });
	    /**
		 * Add this to the soloed array
		 * @private
		 */
	    Tone.Solo.prototype._addSolo = function () {
	        if (!Tone.isArray(this.context._currentSolo)) {
	            this.context._currentSolo = [];
	        }
	        if (!this._isSoloed()) {
	            this.context._currentSolo.push(this);
	        }
	    };
	    /**
		 * Remove this from the soloed array
		 * @private
		 */
	    Tone.Solo.prototype._removeSolo = function () {
	        if (this._isSoloed()) {
	            var index = this.context._currentSolo.indexOf(this);
	            this.context._currentSolo.splice(index, 1);
	        }
	    };
	    /**
		 * @return {Boolean} Is this on the soloed array
		 * @private
		 */
	    Tone.Solo.prototype._isSoloed = function () {
	        if (Tone.isArray(this.context._currentSolo)) {
	            return this.context._currentSolo.length !== 0 && this.context._currentSolo.indexOf(this) !== -1;
	        } else {
	            return false;
	        }
	    };
	    /**
		 * @return {Boolean} Returns true if no one is soloed
		 * @private
		 */
	    Tone.Solo.prototype._noSolos = function () {
	        return !Tone.isArray(this.context._currentSolo) || this.context._currentSolo.length === 0;
	    };
	    /**
		 *  Solo the current instance and unsolo all other instances.
		 *  @param  {Tone.Solo}  instance  The instance which is being soloed/unsoloed.
		 *  @private
		 */
	    Tone.Solo.prototype._soloed = function () {
	        if (this._isSoloed()) {
	            this.input.gain.value = 1;
	        } else if (this._noSolos()) {
	            //no one is soloed
	            this.input.gain.value = 1;
	        } else {
	            this.input.gain.value = 0;
	        }
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.Solo}  this
		 */
	    Tone.Solo.prototype.dispose = function () {
	        this.context.off('solo', this._soloBind);
	        this._removeSolo();
	        this._soloBind = null;
	        Tone.AudioNode.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.Solo;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.CtrlInterpolate will interpolate between given values based
		 *         on the "index" property. Passing in an array or object literal
		 *         will interpolate each of the parameters. Note (i.e. "C3")
		 *         and Time (i.e. "4n + 2") can be interpolated. All other values are
		 *         assumed to be numbers. 
		 *  @example
		 * var interp = new Tone.CtrlInterpolate([0, 2, 9, 4]);
		 * interp.index = 0.75;
		 * interp.value; //returns 1.5
		 *
		 *  @example
		 * var interp = new Tone.CtrlInterpolate([
		 * 	[2, 4, 5],
		 * 	[9, 3, 2],
		 * ]);
		 * @param {Array} values The array of values to interpolate over
		 * @param {Positive} index The initial interpolation index.
		 * @extends {Tone}
		 */
	    Tone.CtrlInterpolate = function () {
	        var options = Tone.defaults(arguments, [
	            'values',
	            'index'
	        ], Tone.CtrlInterpolate);
	        Tone.call(this);
	        /**
			 *  The values to interpolate between
			 *  @type  {Array}
			 */
	        this.values = options.values;
	        /**
			 *  The interpolated index between values. For example: a value of 1.5
			 *  would interpolate equally between the value at index 1
			 *  and the value at index 2. 
			 *  @example
			 * interp.index = 0; 
			 * interp.value; //returns the value at 0
			 * interp.index = 0.5;
			 * interp.value; //returns the value between indices 0 and 1. 
			 *  @type  {Positive}
			 */
	        this.index = options.index;
	    };
	    Tone.extend(Tone.CtrlInterpolate);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.CtrlInterpolate.defaults = {
	        'index': 0,
	        'values': []
	    };
	    /**
		 *  The current interpolated value based on the index
		 *  @readOnly
		 *  @memberOf Tone.CtrlInterpolate#
		 *  @type {*}
		 *  @name value
		 */
	    Object.defineProperty(Tone.CtrlInterpolate.prototype, 'value', {
	        get: function () {
	            var index = this.index;
	            index = Math.min(index, this.values.length - 1);
	            var lowerPosition = Math.floor(index);
	            var lower = this.values[lowerPosition];
	            var upper = this.values[Math.ceil(index)];
	            return this._interpolate(index - lowerPosition, lower, upper);
	        }
	    });
	    /**
		 *  Internal interpolation routine
		 *  @param  {NormalRange}  index  The index between the lower and upper
		 *  @param  {*}  lower 
		 *  @param  {*}  upper 
		 *  @return  {*}  The interpolated value
		 *  @private
		 */
	    Tone.CtrlInterpolate.prototype._interpolate = function (index, lower, upper) {
	        if (Tone.isArray(lower)) {
	            var retArray = [];
	            for (var i = 0; i < lower.length; i++) {
	                retArray[i] = this._interpolate(index, lower[i], upper[i]);
	            }
	            return retArray;
	        } else if (Tone.isObject(lower)) {
	            var retObj = {};
	            for (var attr in lower) {
	                retObj[attr] = this._interpolate(index, lower[attr], upper[attr]);
	            }
	            return retObj;
	        } else {
	            lower = this._toNumber(lower);
	            upper = this._toNumber(upper);
	            return (1 - index) * lower + index * upper;
	        }
	    };
	    /**
		 *  Convert from the given type into a number
		 *  @param  {Number|String}  value
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.CtrlInterpolate.prototype._toNumber = function (val) {
	        if (Tone.isNumber(val)) {
	            return val;
	        } else {
	            //otherwise assume that it's Time...
	            return this.toSeconds(val);
	        }
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.CtrlInterpolate}  this
		 */
	    Tone.CtrlInterpolate.prototype.dispose = function () {
	        this.values = null;
	    };
	    return Tone.CtrlInterpolate;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.CtrlMarkov represents a Markov Chain where each call
		 *         to Tone.CtrlMarkov.next will move to the next state. If the next
		 *         state choice is an array, the next state is chosen randomly with
		 *         even probability for all of the choices. For a weighted probability
		 *         of the next choices, pass in an object with "state" and "probability" attributes. 
		 *         The probabilities will be normalized and then chosen. If no next options
		 *         are given for the current state, the state will stay there. 
		 *  @extends {Tone}
		 *  @example
		 * var chain = new Tone.CtrlMarkov({
		 * 	"beginning" : ["end", "middle"],
		 * 	"middle" : "end"
		 * });
		 * chain.value = "beginning";
		 * chain.next(); //returns "end" or "middle" with 50% probability
		 *
		 *  @example
		 * var chain = new Tone.CtrlMarkov({
		 * 	"beginning" : [{"value" : "end", "probability" : 0.8}, 
		 * 					{"value" : "middle", "probability" : 0.2}],
		 * 	"middle" : "end"
		 * });
		 * chain.value = "beginning";
		 * chain.next(); //returns "end" with 80% probability or "middle" with 20%.
		 *  @param {Object} values An object with the state names as the keys
		 *                         and the next state(s) as the values. 
		 */
	    Tone.CtrlMarkov = function (values, initial) {
	        Tone.call(this);
	        /**
			 *  The Markov values with states as the keys
			 *  and next state(s) as the values. 
			 *  @type {Object}
			 */
	        this.values = Tone.defaultArg(values, {});
	        /**
			 *  The current state of the Markov values. The next
			 *  state will be evaluated and returned when Tone.CtrlMarkov.next
			 *  is invoked.
			 *  @type {String}
			 */
	        this.value = Tone.defaultArg(initial, Object.keys(this.values)[0]);
	    };
	    Tone.extend(Tone.CtrlMarkov);
	    /**
		 *  Returns the next state of the Markov values. 
		 *  @return  {String}
		 */
	    Tone.CtrlMarkov.prototype.next = function () {
	        if (this.values.hasOwnProperty(this.value)) {
	            var next = this.values[this.value];
	            if (Tone.isArray(next)) {
	                var distribution = this._getProbDistribution(next);
	                var rand = Math.random();
	                var total = 0;
	                for (var i = 0; i < distribution.length; i++) {
	                    var dist = distribution[i];
	                    if (rand > total && rand < total + dist) {
	                        var chosen = next[i];
	                        if (Tone.isObject(chosen)) {
	                            this.value = chosen.value;
	                        } else {
	                            this.value = chosen;
	                        }
	                    }
	                    total += dist;
	                }
	            } else {
	                this.value = next;
	            }
	        }
	        return this.value;
	    };
	    /**
		 *  Choose randomly from an array weighted options in the form 
		 *  {"state" : string, "probability" : number} or an array of values
		 *  @param  {Array}  options 
		 *  @return  {Array}  The randomly selected choice
		 *  @private
		 */
	    Tone.CtrlMarkov.prototype._getProbDistribution = function (options) {
	        var distribution = [];
	        var total = 0;
	        var needsNormalizing = false;
	        for (var i = 0; i < options.length; i++) {
	            var option = options[i];
	            if (Tone.isObject(option)) {
	                needsNormalizing = true;
	                distribution[i] = option.probability;
	            } else {
	                distribution[i] = 1 / options.length;
	            }
	            total += distribution[i];
	        }
	        if (needsNormalizing) {
	            //normalize the values
	            for (var j = 0; j < distribution.length; j++) {
	                distribution[j] = distribution[j] / total;
	            }
	        }
	        return distribution;
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.CtrlMarkov}  this
		 */
	    Tone.CtrlMarkov.prototype.dispose = function () {
	        this.values = null;
	    };
	    return Tone.CtrlMarkov;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Generate patterns from an array of values.
		 *         Has a number of arpeggiation and randomized
		 *         selection patterns. 
		 *           <ul>
		 *  	        <li>"up" - cycles upward</li>
		 *  			<li>"down" - cycles downward</li>
		 *  			<li>"upDown" - up then and down</li>
		 *  			<li>"downUp" - cycles down then and up</li>
		 *  			<li>"alternateUp" - jump up two and down one</li>
		 *  			<li>"alternateDown" - jump down two and up one</li>
		 *  			<li>"random" - randomly select an index</li>
		 *  			<li>"randomWalk" - randomly moves one index away from the current position</li>
		 *  			<li>"randomOnce" - randomly select an index without repeating until all values have been chosen.</li>
		 *     		</ul>
		 *  @param  {Array}  values   An array of options to choose from.
		 *  @param  {Tone.CtrlPattern.Type=}  type  The name of the pattern.
		 *  @extends {Tone}
		 */
	    Tone.CtrlPattern = function () {
	        var options = Tone.defaults(arguments, [
	            'values',
	            'type'
	        ], Tone.CtrlPattern);
	        Tone.call(this);
	        /**
			 *  The array of values to arpeggiate over
			 *  @type {Array}
			 */
	        this.values = options.values;
	        /**
			 *  The current position in the values array
			 *  @type  {Number}
			 */
	        this.index = 0;
	        /**
			 *  The type placeholder
			 *  @type {Tone.CtrlPattern.Type}
			 *  @private
			 */
	        this._type = null;
	        /**
			 *  Shuffled values for the RandomOnce type
			 *  @type {Array}
			 *  @private
			 */
	        this._shuffled = null;
	        /**
			 *  The direction of the movement
			 *  @type {String}
			 *  @private
			 */
	        this._direction = null;
	        this.type = options.type;
	    };
	    Tone.extend(Tone.CtrlPattern);
	    /**
		 *  The Control Patterns
		 *  @type  {Object}
		 *  @static
		 */
	    Tone.CtrlPattern.Type = {
	        Up: 'up',
	        Down: 'down',
	        UpDown: 'upDown',
	        DownUp: 'downUp',
	        AlternateUp: 'alternateUp',
	        AlternateDown: 'alternateDown',
	        Random: 'random',
	        RandomWalk: 'randomWalk',
	        RandomOnce: 'randomOnce'
	    };
	    /**
		 *  The default values. 
		 *  @type  {Object}
		 */
	    Tone.CtrlPattern.defaults = {
	        'type': Tone.CtrlPattern.Type.Up,
	        'values': []
	    };
	    /**
		 *  The value at the current index of the pattern.
		 *  @readOnly
		 *  @memberOf Tone.CtrlPattern#
		 *  @type {*}
		 *  @name value
		 */
	    Object.defineProperty(Tone.CtrlPattern.prototype, 'value', {
	        get: function () {
	            //some safeguards
	            if (this.values.length === 0) {
	                return;
	            } else if (this.values.length === 1) {
	                return this.values[0];
	            }
	            this.index = Math.min(this.index, this.values.length - 1);
	            var val = this.values[this.index];
	            if (this.type === Tone.CtrlPattern.Type.RandomOnce) {
	                if (this.values.length !== this._shuffled.length) {
	                    this._shuffleValues();
	                }
	                val = this.values[this._shuffled[this.index]];
	            }
	            return val;
	        }
	    });
	    /**
		 *  The pattern used to select the next
		 *  item from the values array
		 *  @memberOf Tone.CtrlPattern#
		 *  @type {Tone.CtrlPattern.Type}
		 *  @name type
		 */
	    Object.defineProperty(Tone.CtrlPattern.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            this._type = type;
	            this._shuffled = null;
	            //the first index
	            if (this._type === Tone.CtrlPattern.Type.Up || this._type === Tone.CtrlPattern.Type.UpDown || this._type === Tone.CtrlPattern.Type.RandomOnce || this._type === Tone.CtrlPattern.Type.AlternateUp) {
	                this.index = 0;
	            } else if (this._type === Tone.CtrlPattern.Type.Down || this._type === Tone.CtrlPattern.Type.DownUp || this._type === Tone.CtrlPattern.Type.AlternateDown) {
	                this.index = this.values.length - 1;
	            }
	            //the direction
	            if (this._type === Tone.CtrlPattern.Type.UpDown || this._type === Tone.CtrlPattern.Type.AlternateUp) {
	                this._direction = Tone.CtrlPattern.Type.Up;
	            } else if (this._type === Tone.CtrlPattern.Type.DownUp || this._type === Tone.CtrlPattern.Type.AlternateDown) {
	                this._direction = Tone.CtrlPattern.Type.Down;
	            }
	            //randoms
	            if (this._type === Tone.CtrlPattern.Type.RandomOnce) {
	                this._shuffleValues();
	            } else if (this._type === Tone.CtrlPattern.Random) {
	                this.index = Math.floor(Math.random() * this.values.length);
	            }
	        }
	    });
	    /**
		 *  Return the next value given the current position
		 *  and pattern.
		 *  @return {*} The next value
		 */
	    Tone.CtrlPattern.prototype.next = function () {
	        var type = this.type;
	        //choose the next index
	        if (type === Tone.CtrlPattern.Type.Up) {
	            this.index++;
	            if (this.index >= this.values.length) {
	                this.index = 0;
	            }
	        } else if (type === Tone.CtrlPattern.Type.Down) {
	            this.index--;
	            if (this.index < 0) {
	                this.index = this.values.length - 1;
	            }
	        } else if (type === Tone.CtrlPattern.Type.UpDown || type === Tone.CtrlPattern.Type.DownUp) {
	            if (this._direction === Tone.CtrlPattern.Type.Up) {
	                this.index++;
	            } else {
	                this.index--;
	            }
	            if (this.index < 0) {
	                this.index = 1;
	                this._direction = Tone.CtrlPattern.Type.Up;
	            } else if (this.index >= this.values.length) {
	                this.index = this.values.length - 2;
	                this._direction = Tone.CtrlPattern.Type.Down;
	            }
	        } else if (type === Tone.CtrlPattern.Type.Random) {
	            this.index = Math.floor(Math.random() * this.values.length);
	        } else if (type === Tone.CtrlPattern.Type.RandomWalk) {
	            if (Math.random() < 0.5) {
	                this.index--;
	                this.index = Math.max(this.index, 0);
	            } else {
	                this.index++;
	                this.index = Math.min(this.index, this.values.length - 1);
	            }
	        } else if (type === Tone.CtrlPattern.Type.RandomOnce) {
	            this.index++;
	            if (this.index >= this.values.length) {
	                this.index = 0;
	                //reshuffle the values for next time
	                this._shuffleValues();
	            }
	        } else if (type === Tone.CtrlPattern.Type.AlternateUp) {
	            if (this._direction === Tone.CtrlPattern.Type.Up) {
	                this.index += 2;
	                this._direction = Tone.CtrlPattern.Type.Down;
	            } else {
	                this.index -= 1;
	                this._direction = Tone.CtrlPattern.Type.Up;
	            }
	            if (this.index >= this.values.length) {
	                this.index = 0;
	                this._direction = Tone.CtrlPattern.Type.Up;
	            }
	        } else if (type === Tone.CtrlPattern.Type.AlternateDown) {
	            if (this._direction === Tone.CtrlPattern.Type.Up) {
	                this.index += 1;
	                this._direction = Tone.CtrlPattern.Type.Down;
	            } else {
	                this.index -= 2;
	                this._direction = Tone.CtrlPattern.Type.Up;
	            }
	            if (this.index < 0) {
	                this.index = this.values.length - 1;
	                this._direction = Tone.CtrlPattern.Type.Down;
	            }
	        }
	        return this.value;
	    };
	    /**
		 *  Shuffles the values and places the results into the _shuffled
		 *  @private
		 */
	    Tone.CtrlPattern.prototype._shuffleValues = function () {
	        var copy = [];
	        this._shuffled = [];
	        for (var i = 0; i < this.values.length; i++) {
	            copy[i] = i;
	        }
	        while (copy.length > 0) {
	            var randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);
	            this._shuffled.push(randVal[0]);
	        }
	    };
	    /**
		 *  Clean up
		 *  @returns {Tone.CtrlPattern} this
		 */
	    Tone.CtrlPattern.prototype.dispose = function () {
	        this._shuffled = null;
	        this.values = null;
	    };
	    return Tone.CtrlPattern;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Choose a random value.
		 *  @extends {Tone}
		 *  @example
		 * var randomWalk = new Tone.CtrlRandom({
		 * 	"min" : 0,
		 * 	"max" : 10,
		 * 	"integer" : true
		 * });
		 * randomWalk.eval();
		 *
		 *  @param {Number|Time=} min The minimum return value.
		 *  @param {Number|Time=} max The maximum return value.
		 */
	    Tone.CtrlRandom = function () {
	        var options = Tone.defaults(arguments, [
	            'min',
	            'max'
	        ], Tone.CtrlRandom);
	        Tone.call(this);
	        /**
			 *  The minimum return value
			 *  @type  {Number|Time}
			 */
	        this.min = options.min;
	        /**
			 *  The maximum return value
			 *  @type  {Number|Time}
			 */
	        this.max = options.max;
	        /**
			 *  If the return value should be an integer
			 *  @type  {Boolean}
			 */
	        this.integer = options.integer;
	    };
	    Tone.extend(Tone.CtrlRandom);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.CtrlRandom.defaults = {
	        'min': 0,
	        'max': 1,
	        'integer': false
	    };
	    /**
		 *  Return a random value between min and max. 
		 *  @readOnly
		 *  @memberOf Tone.CtrlRandom#
		 *  @type {*}
		 *  @name value
		 */
	    Object.defineProperty(Tone.CtrlRandom.prototype, 'value', {
	        get: function () {
	            var min = this.toSeconds(this.min);
	            var max = this.toSeconds(this.max);
	            var rand = Math.random();
	            var val = rand * min + (1 - rand) * max;
	            if (this.integer) {
	                val = Math.floor(val);
	            }
	            return val;
	        }
	    });
	    return Tone.CtrlRandom;
	});
	Module(function (Tone) {
	    
	    /**
		 *  AudioBuffer.copyToChannel polyfill
		 *  @private
		 */
	    if (window.AudioBuffer && !AudioBuffer.prototype.copyToChannel) {
	        AudioBuffer.prototype.copyToChannel = function (src, chanNum, start) {
	            var channel = this.getChannelData(chanNum);
	            start = start || 0;
	            for (var i = 0; i < channel.length; i++) {
	                channel[i + start] = src[i];
	            }
	        };
	        AudioBuffer.prototype.copyFromChannel = function (dest, chanNum, start) {
	            var channel = this.getChannelData(chanNum);
	            start = start || 0;
	            for (var i = 0; i < dest.length; i++) {
	                dest[i] = channel[i + start];
	            }
	        };
	    }
	    /**
		 *  @class  Buffer loading and storage. Tone.Buffer is used internally by all 
		 *          classes that make requests for audio files such as Tone.Player,
		 *          Tone.Sampler and Tone.Convolver.
		 *          
		 *          Aside from load callbacks from individual buffers, Tone.Buffer 
		 *  		provides events which keep track of the loading progress 
		 *  		of _all_ of the buffers. These are Tone.Buffer.on("load" / "progress" / "error")
		 *
		 *  @constructor 
		 *  @extends {Tone}
		 *  @param {AudioBuffer|String} url The url to load, or the audio buffer to set. 
		 *  @param {Function=} onload A callback which is invoked after the buffer is loaded. 
		 *                            It's recommended to use `Tone.Buffer.on('load', callback)` instead 
		 *                            since it will give you a callback when _all_ buffers are loaded.
		 *  @param {Function=} onerror The callback to invoke if there is an error
		 *  @example
		 * var buffer = new Tone.Buffer("path/to/sound.mp3", function(){
		 * 	//the buffer is now available.
		 * 	var buff = buffer.get();
		 * });
		 *  @example
		 * //can load provide fallback extension types if the first type is not supported.
		 * var buffer = new Tone.Buffer("path/to/sound.[mp3|ogg|wav]");
		 */
	    Tone.Buffer = function () {
	        var options = Tone.defaults(arguments, [
	            'url',
	            'onload',
	            'onerror'
	        ], Tone.Buffer);
	        Tone.call(this);
	        /**
			 *  stores the loaded AudioBuffer
			 *  @type {AudioBuffer}
			 *  @private
			 */
	        this._buffer = null;
	        /**
			 *  indicates if the buffer should be reversed or not
			 *  @type {Boolean}
			 *  @private
			 */
	        this._reversed = options.reverse;
	        /**
			 *  The XHR
			 *  @type  {XMLHttpRequest}
			 *  @private
			 */
	        this._xhr = null;
	        if (options.url instanceof AudioBuffer || options.url instanceof Tone.Buffer) {
	            this.set(options.url);
	            // invoke the onload callback
	            if (options.onload) {
	                options.onload(this);
	            }
	        } else if (Tone.isString(options.url)) {
	            this.load(options.url, options.onload, options.onerror);
	        }
	    };
	    Tone.extend(Tone.Buffer);
	    /**
		 *  the default parameters
		 *  @type {Object}
		 */
	    Tone.Buffer.defaults = {
	        'url': undefined,
	        'reverse': false
	    };
	    /**
		 *  Pass in an AudioBuffer or Tone.Buffer to set the value
		 *  of this buffer.
		 *  @param {AudioBuffer|Tone.Buffer} buffer the buffer
		 *  @returns {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype.set = function (buffer) {
	        if (buffer instanceof Tone.Buffer) {
	            this._buffer = buffer.get();
	        } else {
	            this._buffer = buffer;
	        }
	        return this;
	    };
	    /**
		 *  @return {AudioBuffer} The audio buffer stored in the object.
		 */
	    Tone.Buffer.prototype.get = function () {
	        return this._buffer;
	    };
	    /**
		 *  Makes an xhr reqest for the selected url then decodes
		 *  the file as an audio buffer. Invokes
		 *  the callback once the audio buffer loads.
		 *  @param {String} url The url of the buffer to load.
		 *                      filetype support depends on the
		 *                      browser.
		 *  @returns {Promise} returns a Promise which resolves with the Tone.Buffer
		 */
	    Tone.Buffer.prototype.load = function (url, onload, onerror) {
	        var promise = new Promise(function (load, error) {
	            this._xhr = Tone.Buffer.load(url, //success
	            function (buff) {
	                this._xhr = null;
	                this.set(buff);
	                load(this);
	                if (onload) {
	                    onload(this);
	                }
	            }.bind(this), //error
	            function (err) {
	                this._xhr = null;
	                error(err);
	                if (onerror) {
	                    onerror(err);
	                }
	            }.bind(this));
	        }.bind(this));
	        return promise;
	    };
	    /**
		 *  dispose and disconnect
		 *  @returns {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype.dispose = function () {
	        Tone.prototype.dispose.call(this);
	        this._buffer = null;
	        if (this._xhr) {
	            Tone.Buffer._removeFromDownloadQueue(this._xhr);
	            this._xhr.abort();
	            this._xhr = null;
	        }
	        return this;
	    };
	    /**
		 * If the buffer is loaded or not
		 * @memberOf Tone.Buffer#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'loaded', {
	        get: function () {
	            return this.length > 0;
	        }
	    });
	    /**
		 * The duration of the buffer. 
		 * @memberOf Tone.Buffer#
		 * @type {Number}
		 * @name duration
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'duration', {
	        get: function () {
	            if (this._buffer) {
	                return this._buffer.duration;
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 * The length of the buffer in samples
		 * @memberOf Tone.Buffer#
		 * @type {Number}
		 * @name length
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'length', {
	        get: function () {
	            if (this._buffer) {
	                return this._buffer.length;
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 * The number of discrete audio channels. Returns 0 if no buffer
		 * is loaded.
		 * @memberOf Tone.Buffer#
		 * @type {Number}
		 * @name numberOfChannels
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'numberOfChannels', {
	        get: function () {
	            if (this._buffer) {
	                return this._buffer.numberOfChannels;
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  Set the audio buffer from the array. To create a multichannel AudioBuffer,
		 *  pass in a multidimensional array. 
		 *  @param {Float32Array} array The array to fill the audio buffer
		 *  @return {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype.fromArray = function (array) {
	        var isMultidimensional = array[0].length > 0;
	        var channels = isMultidimensional ? array.length : 1;
	        var len = isMultidimensional ? array[0].length : array.length;
	        var buffer = this.context.createBuffer(channels, len, this.context.sampleRate);
	        if (!isMultidimensional && channels === 1) {
	            array = [array];
	        }
	        for (var c = 0; c < channels; c++) {
	            buffer.copyToChannel(array[c], c);
	        }
	        this._buffer = buffer;
	        return this;
	    };
	    /**
		 * 	Sums muliple channels into 1 channel
		 *  @param {Number=} channel Optionally only copy a single channel from the array.
		 *  @return {Array}
		 */
	    Tone.Buffer.prototype.toMono = function (chanNum) {
	        if (Tone.isNumber(chanNum)) {
	            this.fromArray(this.toArray(chanNum));
	        } else {
	            var outputArray = new Float32Array(this.length);
	            var numChannels = this.numberOfChannels;
	            for (var channel = 0; channel < numChannels; channel++) {
	                var channelArray = this.toArray(channel);
	                for (var i = 0; i < channelArray.length; i++) {
	                    outputArray[i] += channelArray[i];
	                }
	            }
	            //divide by the number of channels
	            outputArray = outputArray.map(function (sample) {
	                return sample / numChannels;
	            });
	            this.fromArray(outputArray);
	        }
	        return this;
	    };
	    /**
		 * 	Get the buffer as an array. Single channel buffers will return a 1-dimensional 
		 * 	Float32Array, and multichannel buffers will return multidimensional arrays.
		 *  @param {Number=} channel Optionally only copy a single channel from the array.
		 *  @return {Array}
		 */
	    Tone.Buffer.prototype.toArray = function (channel) {
	        if (Tone.isNumber(channel)) {
	            return this.getChannelData(channel);
	        } else if (this.numberOfChannels === 1) {
	            return this.toArray(0);
	        } else {
	            var ret = [];
	            for (var c = 0; c < this.numberOfChannels; c++) {
	                ret[c] = this.getChannelData(c);
	            }
	            return ret;
	        }
	    };
	    /**
		 *  Returns the Float32Array representing the PCM audio data for the specific channel.
		 *  @param  {Number}  channel  The channel number to return
		 *  @return  {Float32Array}  The audio as a TypedArray
		 */
	    Tone.Buffer.prototype.getChannelData = function (channel) {
	        return this._buffer.getChannelData(channel);
	    };
	    /**
		 *  Cut a subsection of the array and return a buffer of the
		 *  subsection. Does not modify the original buffer
		 *  @param {Time} start The time to start the slice
		 *  @param {Time=} end The end time to slice. If none is given
		 *                     will default to the end of the buffer
		 *  @return {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype.slice = function (start, end) {
	        end = Tone.defaultArg(end, this.duration);
	        var startSamples = Math.floor(this.context.sampleRate * this.toSeconds(start));
	        var endSamples = Math.floor(this.context.sampleRate * this.toSeconds(end));
	        var replacement = [];
	        for (var i = 0; i < this.numberOfChannels; i++) {
	            replacement[i] = this.toArray(i).slice(startSamples, endSamples);
	        }
	        var retBuffer = new Tone.Buffer().fromArray(replacement);
	        return retBuffer;
	    };
	    /**
		 *  Reverse the buffer.
		 *  @private
		 *  @return {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype._reverse = function () {
	        if (this.loaded) {
	            for (var i = 0; i < this.numberOfChannels; i++) {
	                Array.prototype.reverse.call(this.getChannelData(i));
	            }
	        }
	        return this;
	    };
	    /**
		 * Reverse the buffer.
		 * @memberOf Tone.Buffer#
		 * @type {Boolean}
		 * @name reverse
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'reverse', {
	        get: function () {
	            return this._reversed;
	        },
	        set: function (rev) {
	            if (this._reversed !== rev) {
	                this._reversed = rev;
	                this._reverse();
	            }
	        }
	    });
	    ///////////////////////////////////////////////////////////////////////////
	    // STATIC METHODS
	    ///////////////////////////////////////////////////////////////////////////
	    //statically inherits Emitter methods
	    Tone.Emitter.mixin(Tone.Buffer);
	    /**
		 *  the static queue for all of the xhr requests
		 *  @type {Array}
		 *  @private
		 */
	    Tone.Buffer._downloadQueue = [];
	    /**
		 *  A path which is prefixed before every url.
		 *  @type  {String}
		 *  @static
		 */
	    Tone.Buffer.baseUrl = '';
	    /**
		 *  Create a Tone.Buffer from the array. To create a multichannel AudioBuffer,
		 *  pass in a multidimensional array. 
		 *  @param {Float32Array} array The array to fill the audio buffer
		 *  @return {Tone.Buffer} A Tone.Buffer created from the array
		 */
	    Tone.Buffer.fromArray = function (array) {
	        return new Tone.Buffer().fromArray(array);
	    };
	    /**
		 * Remove an xhr request from the download queue
		 * @private
		 */
	    Tone.Buffer._removeFromDownloadQueue = function (request) {
	        var index = Tone.Buffer._downloadQueue.indexOf(request);
	        if (index !== -1) {
	            Tone.Buffer._downloadQueue.splice(index, 1);
	        }
	    };
	    /**
		 *  Loads a url using XMLHttpRequest.
		 *  @param {String} url
		 *  @param {Function} onload
		 *  @param {Function} onerror
		 *  @param {Function} onprogress
		 *  @return {XMLHttpRequest}
		 */
	    Tone.Buffer.load = function (url, onload, onerror) {
	        //default
	        onload = Tone.defaultArg(onload, Tone.noOp);
	        // test if the url contains multiple extensions
	        var matches = url.match(/\[(.+\|?)+\]$/);
	        if (matches) {
	            var extensions = matches[1].split('|');
	            var extension = extensions[0];
	            for (var i = 0; i < extensions.length; i++) {
	                if (Tone.Buffer.supportsType(extensions[i])) {
	                    extension = extensions[i];
	                    break;
	                }
	            }
	            url = url.replace(matches[0], extension);
	        }
	        function onError(e) {
	            Tone.Buffer._removeFromDownloadQueue(request);
	            Tone.Buffer.emit('error', e);
	            if (onerror) {
	                onerror(e);
	            } else {
	                throw e;
	            }
	        }
	        function onProgress() {
	            //calculate the progress
	            var totalProgress = 0;
	            for (var i = 0; i < Tone.Buffer._downloadQueue.length; i++) {
	                totalProgress += Tone.Buffer._downloadQueue[i].progress;
	            }
	            Tone.Buffer.emit('progress', totalProgress / Tone.Buffer._downloadQueue.length);
	        }
	        var request = new XMLHttpRequest();
	        request.open('GET', Tone.Buffer.baseUrl + url, true);
	        request.responseType = 'arraybuffer';
	        //start out as 0
	        request.progress = 0;
	        Tone.Buffer._downloadQueue.push(request);
	        request.addEventListener('load', function () {
	            if (request.status === 200) {
	                Tone.context.decodeAudioData(request.response, function (buff) {
	                    request.progress = 1;
	                    onProgress();
	                    onload(buff);
	                    Tone.Buffer._removeFromDownloadQueue(request);
	                    if (Tone.Buffer._downloadQueue.length === 0) {
	                        //emit the event at the end
	                        Tone.Buffer.emit('load');
	                    }
	                }, function () {
	                    Tone.Buffer._removeFromDownloadQueue(request);
	                    onError('Tone.Buffer: could not decode audio data: ' + url);
	                });
	            } else {
	                onError('Tone.Buffer: could not locate file: ' + url);
	            }
	        });
	        request.addEventListener('error', onError);
	        request.addEventListener('progress', function (event) {
	            if (event.lengthComputable) {
	                //only go to 95%, the last 5% is when the audio is decoded
	                request.progress = event.loaded / event.total * 0.95;
	                onProgress();
	            }
	        });
	        request.send();
	        return request;
	    };
	    /**
		 *  Stop all of the downloads in progress
		 *  @return {Tone.Buffer}
		 *  @static
		 */
	    Tone.Buffer.cancelDownloads = function () {
	        Tone.Buffer._downloadQueue.slice().forEach(function (request) {
	            Tone.Buffer._removeFromDownloadQueue(request);
	            request.abort();
	        });
	        return Tone.Buffer;
	    };
	    /**
		 *  Checks a url's extension to see if the current browser can play that file type.
		 *  @param {String} url The url/extension to test
		 *  @return {Boolean} If the file extension can be played
		 *  @static
		 *  @example
		 * Tone.Buffer.supportsType("wav"); //returns true
		 * Tone.Buffer.supportsType("path/to/file.wav"); //returns true
		 */
	    Tone.Buffer.supportsType = function (url) {
	        var extension = url.split('.');
	        extension = extension[extension.length - 1];
	        var response = document.createElement('audio').canPlayType('audio/' + extension);
	        return response !== '';
	    };
	    /**
		 *  Returns a Promise which resolves when all of the buffers have loaded
		 *  @return {Promise}
		 */
	    Tone.loaded = function () {
	        var onload, onerror;
	        function removeEvents() {
	            //remove the events when it's resolved
	            Tone.Buffer.off('load', onload);
	            Tone.Buffer.off('error', onerror);
	        }
	        return new Promise(function (success, fail) {
	            onload = function () {
	                success();
	            };
	            onerror = function () {
	                fail();
	            };
	            //add the event listeners
	            Tone.Buffer.on('load', onload);
	            Tone.Buffer.on('error', onerror);
	        }).then(removeEvents).catch(function (e) {
	            removeEvents();
	            throw new Error(e);
	        });
	    };
	    return Tone.Buffer;
	});
	Module(function (Tone) {
	    /**
		 *  @class A data structure for holding multiple buffers.
		 *  
		 *  @param  {Object|Array}    urls      An object literal or array
		 *                                      of urls to load.
		 *  @param  {Function=}  callback  The callback to invoke when
		 *                                 the buffers are loaded. 
		 *  @extends {Tone}
		 *  @example
		 * //load a whole bank of piano samples
		 * var pianoSamples = new Tone.Buffers({
		 * 	"C4" : "path/to/C4.mp3"
		 * 	"C#4" : "path/to/C#4.mp3"
		 * 	"D4" : "path/to/D4.mp3"
		 * 	"D#4" : "path/to/D#4.mp3"
		 * 	...
		 * }, function(){
		 * 	//play one of the samples when they all load
		 * 	player.buffer = pianoSamples.get("C4");
		 * 	player.start();
		 * });
		 * 	@example
		 * //To pass in additional parameters in the second parameter
		 * var buffers = new Tone.Buffers(urls, {
		 * 	"onload" : callback,
		 * 	"baseUrl" : "../path/to/audio/"
		 * })
		 */
	    Tone.Buffers = function (urls) {
	        //remove the urls from the options
	        var args = Array.prototype.slice.call(arguments);
	        args.shift();
	        var options = Tone.defaults(args, [
	            'onload',
	            'baseUrl'
	        ], Tone.Buffers);
	        Tone.call(this);
	        /**
			 *  All of the buffers
			 *  @type  {Object}
			 *  @private
			 */
	        this._buffers = {};
	        /**
			 *  A path which is prefixed before every url.
			 *  @type  {String}
			 */
	        this.baseUrl = options.baseUrl;
	        this._loadingCount = 0;
	        //add each one
	        for (var key in urls) {
	            this._loadingCount++;
	            this.add(key, urls[key], this._bufferLoaded.bind(this, options.onload));
	        }
	    };
	    Tone.extend(Tone.Buffers);
	    /**
		 *  Defaults
		 *  @type  {Object}
		 */
	    Tone.Buffers.defaults = {
	        'onload': Tone.noOp,
	        'baseUrl': ''
	    };
	    /**
		 *  True if the buffers object has a buffer by that name.
		 *  @param  {String|Number}  name  The key or index of the 
		 *                                 buffer.
		 *  @return  {Boolean}
		 */
	    Tone.Buffers.prototype.has = function (name) {
	        return this._buffers.hasOwnProperty(name);
	    };
	    /**
		 *  Get a buffer by name. If an array was loaded, 
		 *  then use the array index.
		 *  @param  {String|Number}  name  The key or index of the 
		 *                                 buffer.
		 *  @return  {Tone.Buffer}
		 */
	    Tone.Buffers.prototype.get = function (name) {
	        if (this.has(name)) {
	            return this._buffers[name];
	        } else {
	            throw new Error('Tone.Buffers: no buffer named ' + name);
	        }
	    };
	    /**
		 *  A buffer was loaded. decrement the counter.
		 *  @param  {Function}  callback 
		 *  @private
		 */
	    Tone.Buffers.prototype._bufferLoaded = function (callback) {
	        this._loadingCount--;
	        if (this._loadingCount === 0 && callback) {
	            callback(this);
	        }
	    };
	    /**
		 * If the buffers are loaded or not
		 * @memberOf Tone.Buffers#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffers.prototype, 'loaded', {
	        get: function () {
	            var isLoaded = true;
	            for (var buffName in this._buffers) {
	                var buff = this.get(buffName);
	                isLoaded = isLoaded && buff.loaded;
	            }
	            return isLoaded;
	        }
	    });
	    /**
		 *  Add a buffer by name and url to the Buffers
		 *  @param  {String}    name      A unique name to give
		 *                                the buffer
		 *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer, 
		 *                                                 or a buffer which will be added
		 *                                                 with the given name.
		 *  @param  {Function=}  callback  The callback to invoke 
		 *                                 when the url is loaded.
		 */
	    Tone.Buffers.prototype.add = function (name, url, callback) {
	        callback = Tone.defaultArg(callback, Tone.noOp);
	        if (url instanceof Tone.Buffer) {
	            this._buffers[name] = url;
	            callback(this);
	        } else if (url instanceof AudioBuffer) {
	            this._buffers[name] = new Tone.Buffer(url);
	            callback(this);
	        } else if (Tone.isString(url)) {
	            this._buffers[name] = new Tone.Buffer(this.baseUrl + url, callback);
	        }
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @return  {Tone.Buffers} this
		 */
	    Tone.Buffers.prototype.dispose = function () {
	        Tone.prototype.dispose.call(this);
	        for (var name in this._buffers) {
	            this._buffers[name].dispose();
	        }
	        this._buffers = null;
	        return this;
	    };
	    return Tone.Buffers;
	});
	Module(function (Tone) {
	    
	    /**
		 *  buses are another way of routing audio
		 *
		 *  augments Tone.prototype to include send and recieve
		 */
	    /**
		  *  All of the routes
		  *  
		  *  @type {Object}
		  *  @static
		  *  @private
		  */
	    var Buses = {};
	    /**
		 *  Send this signal to the channel name. 
		 *  @param  {String} channelName A named channel to send the signal to.
		 *  @param  {Decibels} amount The amount of the source to send to the bus. 
		 *  @return {GainNode} The gain node which connects this node to the desired channel. 
		 *                     Can be used to adjust the levels of the send.
		 *  @example
		 * source.send("reverb", -12);
		 */
	    Tone.prototype.send = function (channelName, amount) {
	        if (!Buses.hasOwnProperty(channelName)) {
	            Buses[channelName] = this.context.createGain();
	        }
	        amount = Tone.defaultArg(amount, 0);
	        var sendKnob = new Tone.Gain(amount, Tone.Type.Decibels);
	        this.output.chain(sendKnob, Buses[channelName]);
	        return sendKnob;
	    };
	    /**
		 *  Recieve the input from the desired channelName to the input
		 *
		 *  @param  {String} channelName A named channel to send the signal to.
		 *  @param  {Number=} channelNumber The channel to connect to
		 *  @returns {Tone} this
		 *  @example
		 * reverbEffect.receive("reverb");
		 */
	    Tone.prototype.receive = function (channelName, inputNum) {
	        if (!Buses.hasOwnProperty(channelName)) {
	            Buses[channelName] = this.context.createGain();
	        }
	        Buses[channelName].connect(this, 0, inputNum);
	        return this;
	    };
	    //remove all the send/receives when a new audio context is passed in
	    Tone.Context.on('init', function (context) {
	        if (context.Buses) {
	            Buses = context.Buses;
	        } else {
	            Buses = {};
	            context.Buses = Buses;
	        }
	    });
	    return Tone;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Draw is useful for synchronizing visuals and audio events.
		 *         Callbacks from Tone.Transport or any of the Tone.Event classes
		 *         always happen _before_ the scheduled time and are not synchronized
		 *         to the animation frame so they are not good for triggering tightly
		 *         synchronized visuals and sound. Tone.Draw makes it easy to schedule
		 *         callbacks using the AudioContext time and uses requestAnimationFrame.
		 *         
		 *  @singleton
		 *  @extends {Tone}
		 *  @example
		 * Tone.Transport.schedule(function(time){
		 * 	//use the time argument to schedule a callback with Tone.Draw
		 * 	Tone.Draw.schedule(function(){
		 * 		//do drawing or DOM manipulation here
		 * 	}, time)
		 * }, "+0.5")
		 */
	    Tone.Draw = function () {
	        Tone.call(this);
	        /**
			 *  All of the events.
			 *  @type  {Tone.Timeline}
			 *  @private
			 */
	        this._events = new Tone.Timeline();
	        /**
			 *  The duration after which events are not invoked.
			 *  @type  {Number}
			 *  @default 0.25
			 */
	        this.expiration = 0.25;
	        /**
			 *  The amount of time before the scheduled time 
			 *  that the callback can be invoked. Default is
			 *  half the time of an animation frame (0.008 seconds).
			 *  @type  {Number}
			 *  @default 0.008
			 */
	        this.anticipation = 0.008;
	        /**
			 *  The draw loop
			 *  @type  {Function}
			 *  @private
			 */
	        this._boundDrawLoop = this._drawLoop.bind(this);
	    };
	    Tone.extend(Tone.Draw);
	    /**
		 *  Schedule a function at the given time to be invoked
		 *  on the nearest animation frame.
		 *  @param  {Function}  callback  Callback is invoked at the given time.
		 *  @param  {Time}    time      The time relative to the AudioContext time
		 *                              to invoke the callback.
		 *  @return  {Tone.Draw}    this
		 */
	    Tone.Draw.prototype.schedule = function (callback, time) {
	        this._events.add({
	            callback: callback,
	            time: this.toSeconds(time)
	        });
	        //start the draw loop on the first event
	        if (this._events.length === 1) {
	            requestAnimationFrame(this._boundDrawLoop);
	        }
	        return this;
	    };
	    /**
		 *  Cancel events scheduled after the given time
		 *  @param  {Time=}  after  Time after which scheduled events will 
		 *                          be removed from the scheduling timeline.
		 *  @return  {Tone.Draw}  this
		 */
	    Tone.Draw.prototype.cancel = function (after) {
	        this._events.cancel(this.toSeconds(after));
	        return this;
	    };
	    /**
		 *  The draw loop
		 *  @private
		 */
	    Tone.Draw.prototype._drawLoop = function () {
	        var now = Tone.now();
	        while (this._events.length && this._events.peek().time - this.anticipation <= now) {
	            var event = this._events.shift();
	            if (now - event.time <= this.expiration) {
	                event.callback();
	            }
	        }
	        if (this._events.length > 0) {
	            requestAnimationFrame(this._boundDrawLoop);
	        }
	    };
	    //make a singleton
	    Tone.Draw = new Tone.Draw();
	    return Tone.Draw;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Both Tone.Panner3D and Tone.Listener have a position in 3D space 
		 *          using a right-handed cartesian coordinate system. 
		 *          The units used in the coordinate system are not defined; 
		 *          these coordinates are independent/invariant of any particular 
		 *          units such as meters or feet. Tone.Panner3D objects have an forward 
		 *          vector representing the direction the sound is projecting. Additionally, 
		 *          they have a sound cone representing how directional the sound is. 
		 *          For example, the sound could be omnidirectional, in which case it would 
		 *          be heard anywhere regardless of its forward, or it can be more directional 
		 *          and heard only if it is facing the listener. Tone.Listener objects 
		 *          (representing a person's ears) have an forward and up vector 
		 *          representing in which direction the person is facing. Because both the 
		 *          source stream and the listener can be moving, they both have a velocity 
		 *          vector representing both the speed and direction of movement. Taken together, 
		 *          these two velocities can be used to generate a doppler shift effect which changes the pitch.
		 *          <br><br>
		 *          Note: the position of the Listener will have no effect on nodes not connected to a Tone.Panner3D
		 *  
		 *  @constructor
		 *  @extends {Tone}
		 *  @singleton
		 */
	    Tone.Listener = function () {
	        Tone.call(this);
	        /**
			 *  Holds the current forward orientation
			 *  @type  {Array}
			 *  @private
			 */
	        this._orientation = [
	            0,
	            0,
	            0,
	            0,
	            0,
	            0
	        ];
	        /**
			 *  Holds the current position
			 *  @type  {Array}
			 *  @private
			 */
	        this._position = [
	            0,
	            0,
	            0
	        ];
	        Tone.getContext(function () {
	            // set the default position/forward
	            this.set(ListenerConstructor.defaults);
	        }.bind(this));
	    };
	    Tone.extend(Tone.Listener);
	    /**
		 *  Defaults according to the specification
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Listener.defaults = {
	        'positionX': 0,
	        'positionY': 0,
	        'positionZ': 0,
	        'forwardX': 0,
	        'forwardY': 0,
	        'forwardZ': 1,
	        'upX': 0,
	        'upY': 1,
	        'upZ': 0
	    };
	    /**
		 * The ramp time which is applied to the setTargetAtTime
		 * @type {Number}
		 * @private
		 */
	    Tone.Listener.prototype._rampTimeConstant = 0.01;
	    /**
		 *  Sets the position of the listener in 3d space.	
		 *  @param  {Number}  x
		 *  @param  {Number}  y
		 *  @param  {Number}  z
		 *  @return {Tone.Listener} this
		 */
	    Tone.Listener.prototype.setPosition = function (x, y, z) {
	        if (this.context.listener.positionX) {
	            var now = this.now();
	            this.context.listener.positionX.setTargetAtTime(x, now, this._rampTimeConstant);
	            this.context.listener.positionY.setTargetAtTime(y, now, this._rampTimeConstant);
	            this.context.listener.positionZ.setTargetAtTime(z, now, this._rampTimeConstant);
	        } else {
	            this.context.listener.setPosition(x, y, z);
	        }
	        this._position = Array.prototype.slice.call(arguments);
	        return this;
	    };
	    /**
		 *  Sets the orientation of the listener using two vectors, the forward
		 *  vector (which direction the listener is facing) and the up vector 
		 *  (which the up direction of the listener). An up vector
		 *  of 0, 0, 1 is equivalent to the listener standing up in the Z direction. 
		 *  @param  {Number}  x
		 *  @param  {Number}  y
		 *  @param  {Number}  z
		 *  @param  {Number}  upX
		 *  @param  {Number}  upY
		 *  @param  {Number}  upZ
		 *  @return {Tone.Listener} this
		 */
	    Tone.Listener.prototype.setOrientation = function (x, y, z, upX, upY, upZ) {
	        if (this.context.listener.forwardX) {
	            var now = this.now();
	            this.context.listener.forwardX.setTargetAtTime(x, now, this._rampTimeConstant);
	            this.context.listener.forwardY.setTargetAtTime(y, now, this._rampTimeConstant);
	            this.context.listener.forwardZ.setTargetAtTime(z, now, this._rampTimeConstant);
	            this.context.listener.upX.setTargetAtTime(upX, now, this._rampTimeConstant);
	            this.context.listener.upY.setTargetAtTime(upY, now, this._rampTimeConstant);
	            this.context.listener.upZ.setTargetAtTime(upZ, now, this._rampTimeConstant);
	        } else {
	            this.context.listener.setOrientation(x, y, z, upX, upY, upZ);
	        }
	        this._orientation = Array.prototype.slice.call(arguments);
	        return this;
	    };
	    /**
		 *  The x position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name positionX
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'positionX', {
	        set: function (pos) {
	            this._position[0] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[0];
	        }
	    });
	    /**
		 *  The y position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name positionY
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'positionY', {
	        set: function (pos) {
	            this._position[1] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[1];
	        }
	    });
	    /**
		 *  The z position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name positionZ
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'positionZ', {
	        set: function (pos) {
	            this._position[2] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[2];
	        }
	    });
	    /**
		 *  The x coordinate of the listeners front direction. i.e. 
		 *  which way they are facing.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name forwardX
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'forwardX', {
	        set: function (pos) {
	            this._orientation[0] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[0];
	        }
	    });
	    /**
		 *  The y coordinate of the listeners front direction. i.e. 
		 *  which way they are facing.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name forwardY
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'forwardY', {
	        set: function (pos) {
	            this._orientation[1] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[1];
	        }
	    });
	    /**
		 *  The z coordinate of the listeners front direction. i.e. 
		 *  which way they are facing.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name forwardZ
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'forwardZ', {
	        set: function (pos) {
	            this._orientation[2] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[2];
	        }
	    });
	    /**
		 *  The x coordinate of the listener's up direction. i.e.
		 *  the direction the listener is standing in.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name upX
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'upX', {
	        set: function (pos) {
	            this._orientation[3] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[3];
	        }
	    });
	    /**
		 *  The y coordinate of the listener's up direction. i.e.
		 *  the direction the listener is standing in.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name upY
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'upY', {
	        set: function (pos) {
	            this._orientation[4] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[4];
	        }
	    });
	    /**
		 *  The z coordinate of the listener's up direction. i.e.
		 *  the direction the listener is standing in.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name upZ
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'upZ', {
	        set: function (pos) {
	            this._orientation[5] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[5];
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.Listener} this
		 */
	    Tone.Listener.prototype.dispose = function () {
	        this._orientation = null;
	        this._position = null;
	        return this;
	    };
	    //SINGLETON SETUP
	    var ListenerConstructor = Tone.Listener;
	    Tone.Listener = new ListenerConstructor();
	    Tone.Context.on('init', function (context) {
	        if (context.Listener instanceof ListenerConstructor) {
	            //a single listener object
	            Tone.Listener = context.Listener;
	        } else {
	            //make new Listener insides
	            Tone.Listener = new ListenerConstructor();
	        }
	        context.Listener = Tone.Listener;
	    });
	    //END SINGLETON SETUP
	    return Tone.Listener;
	});
	Module(function (Tone) {
	    /**
		 *  shim
		 *  @private
		 */
	    if (!window.hasOwnProperty('OfflineAudioContext') && window.hasOwnProperty('webkitOfflineAudioContext')) {
	        window.OfflineAudioContext = window.webkitOfflineAudioContext;
	    }
	    /**
		 *  @class Wrapper around the OfflineAudioContext
		 *  @extends {Tone.Context}
		 *  @param  {Number}  channels  The number of channels to render
		 *  @param  {Number}  duration  The duration to render in samples
		 *  @param {Number} sampleRate the sample rate to render at
		 */
	    Tone.OfflineContext = function (channels, duration, sampleRate) {
	        /**
			 *  The offline context
			 *  @private
			 *  @type  {OfflineAudioContext}
			 */
	        var offlineContext = new OfflineAudioContext(channels, duration * sampleRate, sampleRate);
	        //wrap the methods/members
	        Tone.Context.call(this, {
	            'context': offlineContext,
	            'clockSource': 'offline',
	            'lookAhead': 0,
	            'updateInterval': 128 / sampleRate
	        });
	        /**
			 *  A private reference to the duration
			 *  @private
			 *  @type  {Number}
			 */
	        this._duration = duration;
	        /**
			 *  An artificial clock source
			 *  @type  {Number}
			 *  @private
			 */
	        this._currentTime = 0;
	    };
	    Tone.extend(Tone.OfflineContext, Tone.Context);
	    /**
		 *  Override the now method to point to the internal clock time
		 *  @return  {Number}
		 */
	    Tone.OfflineContext.prototype.now = function () {
	        return this._currentTime;
	    };
	    /**
		 *  Render the output of the OfflineContext
		 *  @return  {Promise}
		 */
	    Tone.OfflineContext.prototype.render = function () {
	        while (this._duration - this._currentTime >= 0) {
	            //invoke all the callbacks on that time
	            this.emit('tick');
	            //increment the clock
	            this._currentTime += this.blockTime;
	        }
	        //promise returned is not yet implemented in all browsers
	        return new Promise(function (done) {
	            this._context.oncomplete = function (e) {
	                done(e.renderedBuffer);
	            };
	            this._context.startRendering();
	        }.bind(this));
	    };
	    /**
		 *  Close the context
		 *  @return  {Number}
		 */
	    Tone.OfflineContext.prototype.close = function () {
	        this._context = null;
	    };
	    return Tone.OfflineContext;
	});
	Module(function (Tone) {
	    /**
		 *  Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext. 
		 *  The OfflineAudioContext is capable of rendering much faster than real time in many cases. 
		 *  The callback function also passes in an offline instance of Tone.Transport which can be used
		 *  to schedule events along the Transport. 
		 *  @param  {Function}  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.
		 *  @param  {Time}  duration     the amount of time to record for.
		 *  @return  {Promise}  The promise which is invoked with the Tone.Buffer of the recorded output.
		 *  @example
		 * //render 2 seconds of the oscillator
		 * Tone.Offline(function(){
		 * 	//only nodes created in this callback will be recorded
		 * 	var oscillator = new Tone.Oscillator().toMaster().start(0)
		 * 	//schedule their events
		 * }, 2).then(function(buffer){
		 * 	//do something with the output buffer
		 * })
		 * @example
		 * //can also schedule events along the Transport
		 * //using the passed in Offline Transport
		 * Tone.Offline(function(Transport){
		 * 	var osc = new Tone.Oscillator().toMaster()
		 * 	Transport.schedule(function(time){
		 * 		osc.start(time).stop(time + 0.1)
		 * 	}, 1)
		 * 	Transport.start(0.2)
		 * }, 4).then(function(buffer){
		 * 	//do something with the output buffer
		 * })
		 */
	    Tone.Offline = function (callback, duration) {
	        //set the OfflineAudioContext
	        var sampleRate = Tone.context.sampleRate;
	        var originalContext = Tone.context;
	        var context = new Tone.OfflineContext(2, duration, sampleRate);
	        Tone.context = context;
	        //invoke the callback/scheduling
	        callback(Tone.Transport);
	        //process the audio
	        var rendered = context.render();
	        //return the original AudioContext
	        Tone.context = originalContext;
	        //return the audio
	        return rendered.then(function (buffer) {
	            //wrap it in a Tone.Buffer
	            return new Tone.Buffer(buffer);
	        });
	    };
	    return Tone.Offline;
	});
	Module(function (Tone) {
	    
	    /**
		 * 	@class  Tone.Effect is the base class for effects. Connect the effect between
		 * 	        the effectSend and effectReturn GainNodes, then control the amount of
		 * 	        effect which goes to the output using the wet control.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {NormalRange|Object} [wet] The starting wet value.
		 */
	    Tone.Effect = function () {
	        var options = Tone.defaults(arguments, ['wet'], Tone.Effect);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  the drywet knob to control the amount of effect
			 *  @type {Tone.CrossFade}
			 *  @private
			 */
	        this._dryWet = new Tone.CrossFade(options.wet);
	        /**
			 *  The wet control is how much of the effected
			 *  will pass through to the output. 1 = 100% effected
			 *  signal, 0 = 100% dry signal.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.wet = this._dryWet.fade;
	        /**
			 *  connect the effectSend to the input of hte effect
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this.effectSend = new Tone.Gain();
	        /**
			 *  connect the output of the effect to the effectReturn
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this.effectReturn = new Tone.Gain();
	        //connections
	        this.input.connect(this._dryWet.a);
	        this.input.connect(this.effectSend);
	        this.effectReturn.connect(this._dryWet.b);
	        this._dryWet.connect(this.output);
	        this._readOnly(['wet']);
	    };
	    Tone.extend(Tone.Effect, Tone.AudioNode);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Effect.defaults = { 'wet': 1 };
	    /**
		 *  chains the effect in between the effectSend and effectReturn
		 *  @param  {Tone} effect
		 *  @private
		 *  @returns {Tone.Effect} this
		 */
	    Tone.Effect.prototype.connectEffect = function (effect) {
	        this.effectSend.chain(effect, this.effectReturn);
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Effect} this
		 */
	    Tone.Effect.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._dryWet.dispose();
	        this._dryWet = null;
	        this.effectSend.dispose();
	        this.effectSend = null;
	        this.effectReturn.dispose();
	        this.effectReturn = null;
	        this._writable(['wet']);
	        this.wet = null;
	        return this;
	    };
	    return Tone.Effect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.
		 *         Setting the LFO rate and depth allows for control over the filter modulation rate 
		 *         and depth.
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {Time|Object} [frequency] The rate of the LFO.
		 *  @param {Frequency=} baseFrequency The lower value of the LFOs oscillation
	 	 *  @param {Frequency=} octaves The number of octaves above the baseFrequency
		 *  @example
		 * //create an autofilter and start it's LFO
		 * var autoFilter = new Tone.AutoFilter("4n").toMaster().start();
		 * //route an oscillator through the filter and start it
		 * var oscillator = new Tone.Oscillator().connect(autoFilter).start();
		 */
	    Tone.AutoFilter = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'baseFrequency',
	            'octaves'
	        ], Tone.AutoFilter);
	        Tone.Effect.call(this, options);
	        /**
			 *  the lfo which drives the filter cutoff
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfo = new Tone.LFO({
	            'frequency': options.frequency,
	            'amplitude': options.depth
	        });
	        /**
			 * The range of the filter modulating between the min and max frequency. 
			 * 0 = no modulation. 1 = full modulation.
			 * @type {NormalRange}
			 * @signal
			 */
	        this.depth = this._lfo.amplitude;
	        /**
			 * How fast the filter modulates between min and max. 
			 * @type {Frequency}
			 * @signal
			 */
	        this.frequency = this._lfo.frequency;
	        /**
			 *  The filter node
			 *  @type {Tone.Filter}
			 */
	        this.filter = new Tone.Filter(options.filter);
	        /**
			 *  The octaves placeholder
			 *  @type {Positive}
			 *  @private
			 */
	        this._octaves = 0;
	        //connections
	        this.connectEffect(this.filter);
	        this._lfo.connect(this.filter.frequency);
	        this.type = options.type;
	        this._readOnly([
	            'frequency',
	            'depth'
	        ]);
	        this.octaves = options.octaves;
	        this.baseFrequency = options.baseFrequency;
	    };
	    //extend Effect
	    Tone.extend(Tone.AutoFilter, Tone.Effect);
	    /**
		 *  defaults
		 *  @static
		 *  @type {Object}
		 */
	    Tone.AutoFilter.defaults = {
	        'frequency': 1,
	        'type': 'sine',
	        'depth': 1,
	        'baseFrequency': 200,
	        'octaves': 2.6,
	        'filter': {
	            'type': 'lowpass',
	            'rolloff': -12,
	            'Q': 1
	        }
	    };
	    /**
		 * Start the effect.
		 * @param {Time} [time=now] When the LFO will start. 
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.start = function (time) {
	        this._lfo.start(time);
	        return this;
	    };
	    /**
		 * Stop the effect.
		 * @param {Time} [time=now] When the LFO will stop. 
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.stop = function (time) {
	        this._lfo.stop(time);
	        return this;
	    };
	    /**
		 * Sync the filter to the transport.
		 * @param {Time} [delay=0] Delay time before starting the effect after the
		 *                               Transport has started. 
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.sync = function (delay) {
	        this._lfo.sync(delay);
	        return this;
	    };
	    /**
		 * Unsync the filter from the transport.
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.unsync = function () {
	        this._lfo.unsync();
	        return this;
	    };
	    /**
		 * Type of oscillator attached to the AutoFilter. 
		 * Possible values: "sine", "square", "triangle", "sawtooth".
		 * @memberOf Tone.AutoFilter#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.AutoFilter.prototype, 'type', {
	        get: function () {
	            return this._lfo.type;
	        },
	        set: function (type) {
	            this._lfo.type = type;
	        }
	    });
	    /**
		 * The minimum value of the filter's cutoff frequency.
		 * @memberOf Tone.AutoFilter#
		 * @type {Frequency}
		 * @name min
		 */
	    Object.defineProperty(Tone.AutoFilter.prototype, 'baseFrequency', {
	        get: function () {
	            return this._lfo.min;
	        },
	        set: function (freq) {
	            this._lfo.min = this.toFrequency(freq);
	            //and set the max
	            this.octaves = this._octaves;
	        }
	    });
	    /**
		 * The maximum value of the filter's cutoff frequency. 
		 * @memberOf Tone.AutoFilter#
		 * @type {Positive}
		 * @name octaves
		 */
	    Object.defineProperty(Tone.AutoFilter.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (oct) {
	            this._octaves = oct;
	            this._lfo.max = this.baseFrequency * Math.pow(2, oct);
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._lfo.dispose();
	        this._lfo = null;
	        this.filter.dispose();
	        this.filter = null;
	        this._writable([
	            'frequency',
	            'depth'
	        ]);
	        this.frequency = null;
	        this.depth = null;
	        return this;
	    };
	    return Tone.AutoFilter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.AutoPanner is a Tone.Panner with an LFO connected to the pan amount. 
		 *         More on using autopanners [here](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {Frequency|Object} [frequency] Rate of left-right oscillation. 
		 *  @example
		 * //create an autopanner and start it's LFO
		 * var autoPanner = new Tone.AutoPanner("4n").toMaster().start();
		 * //route an oscillator through the panner and start it
		 * var oscillator = new Tone.Oscillator().connect(autoPanner).start();
		 */
	    Tone.AutoPanner = function () {
	        var options = Tone.defaults(arguments, ['frequency'], Tone.AutoPanner);
	        Tone.Effect.call(this, options);
	        /**
			 *  the lfo which drives the panning
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfo = new Tone.LFO({
	            'frequency': options.frequency,
	            'amplitude': options.depth,
	            'min': -1,
	            'max': 1
	        });
	        /**
			 * The amount of panning between left and right. 
			 * 0 = always center. 1 = full range between left and right. 
			 * @type {NormalRange}
			 * @signal
			 */
	        this.depth = this._lfo.amplitude;
	        /**
			 *  the panner node which does the panning
			 *  @type {Tone.Panner}
			 *  @private
			 */
	        this._panner = new Tone.Panner();
	        /**
			 * How fast the panner modulates between left and right. 
			 * @type {Frequency}
			 * @signal
			 */
	        this.frequency = this._lfo.frequency;
	        //connections
	        this.connectEffect(this._panner);
	        this._lfo.connect(this._panner.pan);
	        this.type = options.type;
	        this._readOnly([
	            'depth',
	            'frequency'
	        ]);
	    };
	    //extend Effect
	    Tone.extend(Tone.AutoPanner, Tone.Effect);
	    /**
		 *  defaults
		 *  @static
		 *  @type {Object}
		 */
	    Tone.AutoPanner.defaults = {
	        'frequency': 1,
	        'type': 'sine',
	        'depth': 1
	    };
	    /**
		 * Start the effect.
		 * @param {Time} [time=now] When the LFO will start. 
		 * @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.start = function (time) {
	        this._lfo.start(time);
	        return this;
	    };
	    /**
		 * Stop the effect.
		 * @param {Time} [time=now] When the LFO will stop. 
		 * @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.stop = function (time) {
	        this._lfo.stop(time);
	        return this;
	    };
	    /**
		 * Sync the panner to the transport.
		 * @param {Time} [delay=0] Delay time before starting the effect after the
		 *                               Transport has started. 
		 * @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.sync = function (delay) {
	        this._lfo.sync(delay);
	        return this;
	    };
	    /**
		 * Unsync the panner from the transport
		 * @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.unsync = function () {
	        this._lfo.unsync();
	        return this;
	    };
	    /**
		 * Type of oscillator attached to the AutoFilter. 
		 * Possible values: "sine", "square", "triangle", "sawtooth".
		 * @memberOf Tone.AutoFilter#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.AutoPanner.prototype, 'type', {
	        get: function () {
	            return this._lfo.type;
	        },
	        set: function (type) {
	            this._lfo.type = type;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._lfo.dispose();
	        this._lfo = null;
	        this._panner.dispose();
	        this._panner = null;
	        this._writable([
	            'depth',
	            'frequency'
	        ]);
	        this.frequency = null;
	        this.depth = null;
	        return this;
	    };
	    return Tone.AutoPanner;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.AutoWah connects a Tone.Follower to a bandpass filter (Tone.Filter).
		 *          The frequency of the filter is adjusted proportionally to the 
		 *          incoming signal's amplitude. Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {Frequency|Object} [baseFrequency] The frequency the filter is set 
		 *                                            to at the low point of the wah
		 *  @param {Positive} [octaves] The number of octaves above the baseFrequency
		 *                                the filter will sweep to when fully open
		 *  @param {Decibels} [sensitivity] The decibel threshold sensitivity for 
		 *                                   the incoming signal. Normal range of -40 to 0. 
		 *  @example
		 * var autoWah = new Tone.AutoWah(50, 6, -30).toMaster();
		 * //initialize the synth and connect to autowah
		 * var synth = new Synth.connect(autoWah);
		 * //Q value influences the effect of the wah - default is 2
		 * autoWah.Q.value = 6;
		 * //more audible on higher notes
		 * synth.triggerAttackRelease("C4", "8n")
		 */
	    Tone.AutoWah = function () {
	        var options = Tone.defaults(arguments, [
	            'baseFrequency',
	            'octaves',
	            'sensitivity'
	        ], Tone.AutoWah);
	        Tone.Effect.call(this, options);
	        /**
			 *  The envelope follower. Set the attack/release
			 *  timing to adjust how the envelope is followed. 
			 *  @type {Tone.Follower}
			 *  @private
			 */
	        this.follower = new Tone.Follower(options.follower);
	        /**
			 *  scales the follower value to the frequency domain
			 *  @type {Tone}
			 *  @private
			 */
	        this._sweepRange = new Tone.ScaleExp(0, 1, 0.5);
	        /**
			 *  @type {number}
			 *  @private
			 */
	        this._baseFrequency = options.baseFrequency;
	        /**
			 *  @type {number}
			 *  @private
			 */
	        this._octaves = options.octaves;
	        /**
			 *  the input gain to adjust the sensitivity
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._inputBoost = new Tone.Gain();
	        /**
			 *  @type {BiquadFilterNode}
			 *  @private
			 */
	        this._bandpass = new Tone.Filter({
	            'rolloff': -48,
	            'frequency': 0,
	            'Q': options.Q
	        });
	        /**
			 *  @type {Tone.Filter}
			 *  @private
			 */
	        this._peaking = new Tone.Filter(0, 'peaking');
	        this._peaking.gain.value = options.gain;
	        /**
			 * The gain of the filter.
			 * @type {Number}
			 * @signal
			 */
	        this.gain = this._peaking.gain;
	        /**
			 * The quality of the filter.
			 * @type {Positive}
			 * @signal
			 */
	        this.Q = this._bandpass.Q;
	        //the control signal path
	        this.effectSend.chain(this._inputBoost, this.follower, this._sweepRange);
	        this._sweepRange.connect(this._bandpass.frequency);
	        this._sweepRange.connect(this._peaking.frequency);
	        //the filtered path
	        this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn);
	        //set the initial value
	        this._setSweepRange();
	        this.sensitivity = options.sensitivity;
	        this._readOnly([
	            'gain',
	            'Q'
	        ]);
	    };
	    Tone.extend(Tone.AutoWah, Tone.Effect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.AutoWah.defaults = {
	        'baseFrequency': 100,
	        'octaves': 6,
	        'sensitivity': 0,
	        'Q': 2,
	        'gain': 2,
	        'follower': {
	            'attack': 0.3,
	            'release': 0.5
	        }
	    };
	    /**
		 * The number of octaves that the filter will sweep above the 
		 * baseFrequency. 
		 * @memberOf Tone.AutoWah#
		 * @type {Number}
		 * @name octaves
		 */
	    Object.defineProperty(Tone.AutoWah.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (octaves) {
	            this._octaves = octaves;
	            this._setSweepRange();
	        }
	    });
	    /**
		 * The base frequency from which the sweep will start from.
		 * @memberOf Tone.AutoWah#
		 * @type {Frequency}
		 * @name baseFrequency
		 */
	    Object.defineProperty(Tone.AutoWah.prototype, 'baseFrequency', {
	        get: function () {
	            return this._baseFrequency;
	        },
	        set: function (baseFreq) {
	            this._baseFrequency = baseFreq;
	            this._setSweepRange();
	        }
	    });
	    /**
		 * The sensitivity to control how responsive to the input signal the filter is. 
		 * @memberOf Tone.AutoWah#
		 * @type {Decibels}
		 * @name sensitivity
		 */
	    Object.defineProperty(Tone.AutoWah.prototype, 'sensitivity', {
	        get: function () {
	            return Tone.gainToDb(1 / this._inputBoost.gain.value);
	        },
	        set: function (sensitivy) {
	            this._inputBoost.gain.value = 1 / Tone.dbToGain(sensitivy);
	        }
	    });
	    /**
		 *  sets the sweep range of the scaler
		 *  @private
		 */
	    Tone.AutoWah.prototype._setSweepRange = function () {
	        this._sweepRange.min = this._baseFrequency;
	        this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.AutoWah} this
		 */
	    Tone.AutoWah.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this.follower.dispose();
	        this.follower = null;
	        this._sweepRange.dispose();
	        this._sweepRange = null;
	        this._bandpass.dispose();
	        this._bandpass = null;
	        this._peaking.dispose();
	        this._peaking = null;
	        this._inputBoost.dispose();
	        this._inputBoost = null;
	        this._writable([
	            'gain',
	            'Q'
	        ]);
	        this.gain = null;
	        this.Q = null;
	        return this;
	    };
	    return Tone.AutoWah;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Bitcrusher downsamples the incoming signal to a different bitdepth. 
		 *         Lowering the bitdepth of the signal creates distortion. Read more about Bitcrushing
		 *         on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {Number} bits The number of bits to downsample the signal. Nominal range
		 *                       of 1 to 8. 
		 *  @example
		 * //initialize crusher and route a synth through it
		 * var crusher = new Tone.BitCrusher(4).toMaster();
		 * var synth = new Tone.MonoSynth().connect(crusher);
		 */
	    Tone.BitCrusher = function () {
	        var options = Tone.defaults(arguments, ['bits'], Tone.BitCrusher);
	        Tone.Effect.call(this, options);
	        var invStepSize = 1 / Math.pow(2, options.bits - 1);
	        /**
			 *  Subtract the input signal and the modulus of the input signal
			 *  @type {Tone.Subtract}
			 *  @private
			 */
	        this._subtract = new Tone.Subtract();
	        /**
			 *  The mod function
			 *  @type  {Tone.Modulo}
			 *  @private
			 */
	        this._modulo = new Tone.Modulo(invStepSize);
	        /**
			 *  keeps track of the bits
			 *  @type {number}
			 *  @private
			 */
	        this._bits = options.bits;
	        //connect it up
	        this.effectSend.fan(this._subtract, this._modulo);
	        this._modulo.connect(this._subtract, 0, 1);
	        this._subtract.connect(this.effectReturn);
	    };
	    Tone.extend(Tone.BitCrusher, Tone.Effect);
	    /**
		 *  the default values
		 *  @static
		 *  @type {Object}
		 */
	    Tone.BitCrusher.defaults = { 'bits': 4 };
	    /**
		 * The bit depth of the effect. Nominal range of 1-8. 
		 * @memberOf Tone.BitCrusher#
		 * @type {number}
		 * @name bits
		 */
	    Object.defineProperty(Tone.BitCrusher.prototype, 'bits', {
	        get: function () {
	            return this._bits;
	        },
	        set: function (bits) {
	            this._bits = bits;
	            var invStepSize = 1 / Math.pow(2, bits - 1);
	            this._modulo.value = invStepSize;
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.BitCrusher} this
		 */
	    Tone.BitCrusher.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._subtract.dispose();
	        this._subtract = null;
	        this._modulo.dispose();
	        this._modulo = null;
	        return this;
	    };
	    return Tone.BitCrusher;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.ChebyShev is a Chebyshev waveshaper, an effect which is good 
		 *         for making different types of distortion sounds.
		 *         Note that odd orders sound very different from even ones, 
		 *         and order = 1 is no change. 
		 *         Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 *  @param {Positive|Object} [order] The order of the chebyshev polynomial. Normal range between 1-100. 
		 *  @example
		 * //create a new cheby
		 * var cheby = new Tone.Chebyshev(50);
		 * //create a monosynth connected to our cheby
		 * synth = new Tone.MonoSynth().connect(cheby);
		 */
	    Tone.Chebyshev = function () {
	        var options = Tone.defaults(arguments, ['order'], Tone.Chebyshev);
	        Tone.Effect.call(this, options);
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._shaper = new Tone.WaveShaper(4096);
	        /**
			 * holds onto the order of the filter
			 * @type {number}
			 * @private
			 */
	        this._order = options.order;
	        this.connectEffect(this._shaper);
	        this.order = options.order;
	        this.oversample = options.oversample;
	    };
	    Tone.extend(Tone.Chebyshev, Tone.Effect);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Chebyshev.defaults = {
	        'order': 1,
	        'oversample': 'none'
	    };
	    /**
		 *  get the coefficient for that degree
		 *  @param {number} x the x value
		 *  @param   {number} degree 
		 *  @param {Object} memo memoize the computed value. 
		 *                       this speeds up computation greatly. 
		 *  @return  {number}       the coefficient 
		 *  @private
		 */
	    Tone.Chebyshev.prototype._getCoefficient = function (x, degree, memo) {
	        if (memo.hasOwnProperty(degree)) {
	            return memo[degree];
	        } else if (degree === 0) {
	            memo[degree] = 0;
	        } else if (degree === 1) {
	            memo[degree] = x;
	        } else {
	            memo[degree] = 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo);
	        }
	        return memo[degree];
	    };
	    /**
		 * The order of the Chebyshev polynomial which creates
		 * the equation which is applied to the incoming 
		 * signal through a Tone.WaveShaper. The equations
		 * are in the form:<br>
		 * order 2: 2x^2 + 1<br>
		 * order 3: 4x^3 + 3x <br>
		 * @memberOf Tone.Chebyshev#
		 * @type {Positive}
		 * @name order
		 */
	    Object.defineProperty(Tone.Chebyshev.prototype, 'order', {
	        get: function () {
	            return this._order;
	        },
	        set: function (order) {
	            this._order = order;
	            var curve = new Array(4096);
	            var len = curve.length;
	            for (var i = 0; i < len; ++i) {
	                var x = i * 2 / len - 1;
	                if (x === 0) {
	                    //should output 0 when input is 0
	                    curve[i] = 0;
	                } else {
	                    curve[i] = this._getCoefficient(x, order, {});
	                }
	            }
	            this._shaper.curve = curve;
	        }
	    });
	    /**
		 * The oversampling of the effect. Can either be "none", "2x" or "4x".
		 * @memberOf Tone.Chebyshev#
		 * @type {string}
		 * @name oversample
		 */
	    Object.defineProperty(Tone.Chebyshev.prototype, 'oversample', {
	        get: function () {
	            return this._shaper.oversample;
	        },
	        set: function (oversampling) {
	            this._shaper.oversample = oversampling;
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Chebyshev} this
		 */
	    Tone.Chebyshev.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._shaper.dispose();
	        this._shaper = null;
	        return this;
	    };
	    return Tone.Chebyshev;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Base class for Stereo effects. Provides effectSendL/R and effectReturnL/R.
		 *
		 *	@constructor
		 *	@extends {Tone.Effect}
		 */
	    Tone.StereoEffect = function () {
	        //get the defaults
	        Tone.AudioNode.call(this);
	        var options = Tone.defaults(arguments, ['wet'], Tone.Effect);
	        this.createInsOuts(1, 1);
	        /**
			 *  the drywet knob to control the amount of effect
			 *  @type {Tone.CrossFade}
			 *  @private
			 */
	        this._dryWet = new Tone.CrossFade(options.wet);
	        /**
			 *  The wet control, i.e. how much of the effected
			 *  will pass through to the output.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.wet = this._dryWet.fade;
	        /**
			 *  then split it
			 *  @type {Tone.Split}
			 *  @private
			 */
	        this._split = new Tone.Split();
	        /**
			 *  the effects send LEFT
			 *  @type {GainNode}
			 *  @private
			 */
	        this.effectSendL = this._split.left;
	        /**
			 *  the effects send RIGHT
			 *  @type {GainNode}
			 *  @private
			 */
	        this.effectSendR = this._split.right;
	        /**
			 *  the stereo effect merger
			 *  @type {Tone.Merge}
			 *  @private
			 */
	        this._merge = new Tone.Merge();
	        /**
			 *  the effect return LEFT
			 *  @type {GainNode}
			 *  @private
			 */
	        this.effectReturnL = this._merge.left;
	        /**
			 *  the effect return RIGHT
			 *  @type {GainNode}
			 *  @private
			 */
	        this.effectReturnR = this._merge.right;
	        //connections
	        this.input.connect(this._split);
	        //dry wet connections
	        this.input.connect(this._dryWet, 0, 0);
	        this._merge.connect(this._dryWet, 0, 1);
	        this._dryWet.connect(this.output);
	        this._readOnly(['wet']);
	    };
	    Tone.extend(Tone.StereoEffect, Tone.Effect);
	    /**
		 *  Clean up.
		 *  @returns {Tone.StereoEffect} this
		 */
	    Tone.StereoEffect.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._dryWet.dispose();
	        this._dryWet = null;
	        this._split.dispose();
	        this._split = null;
	        this._merge.dispose();
	        this._merge = null;
	        this.effectSendL = null;
	        this.effectSendR = null;
	        this.effectReturnL = null;
	        this.effectReturnR = null;
	        this._writable(['wet']);
	        this.wet = null;
	        return this;
	    };
	    return Tone.StereoEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 * 	@class  Tone.FeedbackEffect provides a loop between an 
		 * 	        audio source and its own output. This is a base-class
		 * 	        for feedback effects. 
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {NormalRange|Object} [feedback] The initial feedback value.
		 */
	    Tone.FeedbackEffect = function () {
	        var options = Tone.defaults(arguments, ['feedback'], Tone.FeedbackEffect);
	        Tone.Effect.call(this, options);
	        /**
			 *  the gain which controls the feedback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackGain = new Tone.Gain(options.feedback, Tone.Type.NormalRange);
	        /**
			 *  The amount of signal which is fed back into the effect input. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.feedback = this._feedbackGain.gain;
	        //the feedback loop
	        this.effectReturn.chain(this._feedbackGain, this.effectSend);
	        this._readOnly(['feedback']);
	    };
	    Tone.extend(Tone.FeedbackEffect, Tone.Effect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.FeedbackEffect.defaults = { 'feedback': 0.125 };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.FeedbackEffect} this
		 */
	    Tone.FeedbackEffect.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._writable(['feedback']);
	        this._feedbackGain.dispose();
	        this._feedbackGain = null;
	        this.feedback = null;
	        return this;
	    };
	    return Tone.FeedbackEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Just like a stereo feedback effect, but the feedback is routed from left to right
		 *         and right to left instead of on the same channel.
		 *
		 *	@constructor
		 *	@extends {Tone.StereoEffect}
		 */
	    Tone.StereoXFeedbackEffect = function () {
	        var options = Tone.defaults(arguments, ['feedback'], Tone.FeedbackEffect);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  The amount of feedback from the output
			 *  back into the input of the effect (routed
			 *  across left and right channels).
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
	        /**
			 *  the left side feeback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackLR = new Tone.Gain();
	        /**
			 *  the right side feeback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackRL = new Tone.Gain();
	        //connect it up
	        this.effectReturnL.chain(this._feedbackLR, this.effectSendR);
	        this.effectReturnR.chain(this._feedbackRL, this.effectSendL);
	        this.feedback.fan(this._feedbackLR.gain, this._feedbackRL.gain);
	        this._readOnly(['feedback']);
	    };
	    Tone.extend(Tone.StereoXFeedbackEffect, Tone.StereoEffect);
	    /**
		 *  clean up
		 *  @returns {Tone.StereoXFeedbackEffect} this
		 */
	    Tone.StereoXFeedbackEffect.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        this._writable(['feedback']);
	        this.feedback.dispose();
	        this.feedback = null;
	        this._feedbackLR.dispose();
	        this._feedbackLR = null;
	        this._feedbackRL.dispose();
	        this._feedbackRL = null;
	        return this;
	    };
	    return Tone.StereoXFeedbackEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Chorus is a stereo chorus effect with feedback composed of 
		 *         a left and right delay with a Tone.LFO applied to the delayTime of each channel. 
		 *         Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).
		 *         Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).
		 *
		 *	@constructor
		 *	@extends {Tone.StereoXFeedbackEffect}
		 *	@param {Frequency|Object} [frequency] The frequency of the LFO.
		 *	@param {Milliseconds} [delayTime] The delay of the chorus effect in ms. 
		 *	@param {NormalRange} [depth] The depth of the chorus.
		 *	@example
		 * var chorus = new Tone.Chorus(4, 2.5, 0.5);
		 * var synth = new Tone.PolySynth(4, Tone.MonoSynth).connect(chorus);
		 * synth.triggerAttackRelease(["C3","E3","G3"], "8n");
		 */
	    Tone.Chorus = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'delayTime',
	            'depth'
	        ], Tone.Chorus);
	        Tone.StereoXFeedbackEffect.call(this, options);
	        /**
			 *  the depth of the chorus
			 *  @type {number}
			 *  @private
			 */
	        this._depth = options.depth;
	        /**
			 *  the delayTime
			 *  @type {number}
			 *  @private
			 */
	        this._delayTime = options.delayTime / 1000;
	        /**
			 *  the lfo which controls the delayTime
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfoL = new Tone.LFO({
	            'frequency': options.frequency,
	            'min': 0,
	            'max': 1
	        });
	        /**
			 *  another LFO for the right side with a 180 degree phase diff
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfoR = new Tone.LFO({
	            'frequency': options.frequency,
	            'min': 0,
	            'max': 1,
	            'phase': 180
	        });
	        /**
			 *  delay for left
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delayNodeL = new Tone.Delay();
	        /**
			 *  delay for right
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delayNodeR = new Tone.Delay();
	        /**
			 * The frequency of the LFO which modulates the delayTime. 
			 * @type {Frequency}
			 * @signal
			 */
	        this.frequency = this._lfoL.frequency;
	        //connections
	        this.effectSendL.chain(this._delayNodeL, this.effectReturnL);
	        this.effectSendR.chain(this._delayNodeR, this.effectReturnR);
	        //and pass through to make the detune apparent
	        this.effectSendL.connect(this.effectReturnL);
	        this.effectSendR.connect(this.effectReturnR);
	        //lfo setup
	        this._lfoL.connect(this._delayNodeL.delayTime);
	        this._lfoR.connect(this._delayNodeR.delayTime);
	        //start the lfo
	        this._lfoL.start();
	        this._lfoR.start();
	        //have one LFO frequency control the other
	        this._lfoL.frequency.connect(this._lfoR.frequency);
	        //set the initial values
	        this.depth = this._depth;
	        this.frequency.value = options.frequency;
	        this.type = options.type;
	        this._readOnly(['frequency']);
	        this.spread = options.spread;
	    };
	    Tone.extend(Tone.Chorus, Tone.StereoXFeedbackEffect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Chorus.defaults = {
	        'frequency': 1.5,
	        'delayTime': 3.5,
	        'depth': 0.7,
	        'feedback': 0.1,
	        'type': 'sine',
	        'spread': 180
	    };
	    /**
		 * The depth of the effect. A depth of 1 makes the delayTime
		 * modulate between 0 and 2*delayTime (centered around the delayTime). 
		 * @memberOf Tone.Chorus#
		 * @type {NormalRange}
		 * @name depth
		 */
	    Object.defineProperty(Tone.Chorus.prototype, 'depth', {
	        get: function () {
	            return this._depth;
	        },
	        set: function (depth) {
	            this._depth = depth;
	            var deviation = this._delayTime * depth;
	            this._lfoL.min = Math.max(this._delayTime - deviation, 0);
	            this._lfoL.max = this._delayTime + deviation;
	            this._lfoR.min = Math.max(this._delayTime - deviation, 0);
	            this._lfoR.max = this._delayTime + deviation;
	        }
	    });
	    /**
		 * The delayTime in milliseconds of the chorus. A larger delayTime
		 * will give a more pronounced effect. Nominal range a delayTime
		 * is between 2 and 20ms. 
		 * @memberOf Tone.Chorus#
		 * @type {Milliseconds}
		 * @name delayTime
		 */
	    Object.defineProperty(Tone.Chorus.prototype, 'delayTime', {
	        get: function () {
	            return this._delayTime * 1000;
	        },
	        set: function (delayTime) {
	            this._delayTime = delayTime / 1000;
	            this.depth = this._depth;
	        }
	    });
	    /**
		 * The oscillator type of the LFO. 
		 * @memberOf Tone.Chorus#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.Chorus.prototype, 'type', {
	        get: function () {
	            return this._lfoL.type;
	        },
	        set: function (type) {
	            this._lfoL.type = type;
	            this._lfoR.type = type;
	        }
	    });
	    /** 
		 * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.
		 * When set to 180, LFO's will be panned hard left and right respectively.
		 * @memberOf Tone.Chorus#
		 * @type {Degrees}
		 * @name spread
		 */
	    Object.defineProperty(Tone.Chorus.prototype, 'spread', {
	        get: function () {
	            return this._lfoR.phase - this._lfoL.phase;
	        },
	        set: function (spread) {
	            this._lfoL.phase = 90 - spread / 2;
	            this._lfoR.phase = spread / 2 + 90;
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Chorus} this
		 */
	    Tone.Chorus.prototype.dispose = function () {
	        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);
	        this._lfoL.dispose();
	        this._lfoL = null;
	        this._lfoR.dispose();
	        this._lfoR = null;
	        this._delayNodeL.dispose();
	        this._delayNodeL = null;
	        this._delayNodeR.dispose();
	        this._delayNodeR = null;
	        this._writable('frequency');
	        this.frequency = null;
	        return this;
	    };
	    return Tone.Chorus;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Convolver is a wrapper around the Native Web Audio 
		 *          [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).
		 *          Convolution is useful for reverb and filter emulation. Read more about convolution reverb on
		 *          [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).
		 *  
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {string|Tone.Buffer|Object} [url] The URL of the impulse response or the Tone.Buffer
		 *                                           contianing the impulse response. 
		 *  @param {Function} onload The callback to invoke when the url is loaded.
		 *  @example
		 * //initializing the convolver with an impulse response
		 * var convolver = new Tone.Convolver("./path/to/ir.wav").toMaster();
		 */
	    Tone.Convolver = function () {
	        var options = Tone.defaults(arguments, [
	            'url',
	            'onload'
	        ], Tone.Convolver);
	        Tone.Effect.call(this, options);
	        /**
			 *  convolver node
			 *  @type {ConvolverNode}
			 *  @private
			 */
	        this._convolver = this.context.createConvolver();
	        /**
			 *  the convolution buffer
			 *  @type {Tone.Buffer}
			 *  @private
			 */
	        this._buffer = new Tone.Buffer();
	        if (Tone.isString(options.url)) {
	            this._buffer.load(options.url, function (buffer) {
	                this.buffer = buffer;
	                options.onload();
	            }.bind(this));
	        } else if (options.url) {
	            this.buffer = options.url;
	            options.onload();
	        }
	        this.connectEffect(this._convolver);
	    };
	    Tone.extend(Tone.Convolver, Tone.Effect);
	    /**
		 *  @static
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Convolver.defaults = { 'onload': Tone.noOp };
	    /**
		 *  The convolver's buffer
		 *  @memberOf Tone.Convolver#
		 *  @type {AudioBuffer}
		 *  @name buffer
		 */
	    Object.defineProperty(Tone.Convolver.prototype, 'buffer', {
	        get: function () {
	            return this._buffer.get();
	        },
	        set: function (buffer) {
	            this._buffer.set(buffer);
	            this._convolver.buffer = this._buffer.get();
	        }
	    });
	    /**
		 *  Load an impulse response url as an audio buffer.
		 *  Decodes the audio asynchronously and invokes
		 *  the callback once the audio buffer loads.
		 *  @param {string} url The url of the buffer to load.
		 *                      filetype support depends on the
		 *                      browser.
		 *  @param  {function=} callback
		 *  @returns {Promise}
		 */
	    Tone.Convolver.prototype.load = function (url, callback) {
	        return this._buffer.load(url, function (buff) {
	            this.buffer = buff;
	            if (callback) {
	                callback();
	            }
	        }.bind(this));
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Convolver} this
		 */
	    Tone.Convolver.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._convolver.disconnect();
	        this._convolver = null;
	        this._buffer.dispose();
	        this._buffer = null;
	        return this;
	    };
	    return Tone.Convolver;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Distortion is a simple distortion effect using Tone.WaveShaper.
		 *         Algorithm from [a stackoverflow answer](http://stackoverflow.com/a/22313408).
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 *  @param {Number|Object} [distortion] The amount of distortion (nominal range of 0-1)
		 *  @example
		 * var dist = new Tone.Distortion(0.8).toMaster();
		 * var fm = new Tone.SimpleFM().connect(dist);
		 * //this sounds good on bass notes
		 * fm.triggerAttackRelease("A1", "8n");
		 */
	    Tone.Distortion = function () {
	        var options = Tone.defaults(arguments, ['distortion'], Tone.Distortion);
	        Tone.Effect.call(this, options);
	        /**
			 *  @type {Tone.WaveShaper}
			 *  @private
			 */
	        this._shaper = new Tone.WaveShaper(4096);
	        /**
			 * holds the distortion amount
			 * @type {number}
			 * @private
			 */
	        this._distortion = options.distortion;
	        this.connectEffect(this._shaper);
	        this.distortion = options.distortion;
	        this.oversample = options.oversample;
	    };
	    Tone.extend(Tone.Distortion, Tone.Effect);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Distortion.defaults = {
	        'distortion': 0.4,
	        'oversample': 'none'
	    };
	    /**
		 * The amount of distortion.
		 * @memberOf Tone.Distortion#
		 * @type {NormalRange}
		 * @name distortion
		 */
	    Object.defineProperty(Tone.Distortion.prototype, 'distortion', {
	        get: function () {
	            return this._distortion;
	        },
	        set: function (amount) {
	            this._distortion = amount;
	            var k = amount * 100;
	            var deg = Math.PI / 180;
	            this._shaper.setMap(function (x) {
	                if (Math.abs(x) < 0.001) {
	                    //should output 0 when input is 0
	                    return 0;
	                } else {
	                    return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
	                }
	            });
	        }
	    });
	    /**
		 * The oversampling of the effect. Can either be "none", "2x" or "4x".
		 * @memberOf Tone.Distortion#
		 * @type {string}
		 * @name oversample
		 */
	    Object.defineProperty(Tone.Distortion.prototype, 'oversample', {
	        get: function () {
	            return this._shaper.oversample;
	        },
	        set: function (oversampling) {
	            this._shaper.oversample = oversampling;
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Distortion} this
		 */
	    Tone.Distortion.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._shaper.dispose();
	        this._shaper = null;
	        return this;
	    };
	    return Tone.Distortion;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.FeedbackDelay is a DelayNode in which part of output
		 *          signal is fed back into the delay. 
		 *
		 *  @constructor
		 *  @extends {Tone.FeedbackEffect}
		 *  @param {Time|Object} [delayTime] The delay applied to the incoming signal. 
		 *  @param {NormalRange=} feedback The amount of the effected signal which 
		 *                            is fed back through the delay.
		 *  @example
		 * var feedbackDelay = new Tone.FeedbackDelay("8n", 0.5).toMaster();
		 * var tom = new Tone.DrumSynth({
		 * 	"octaves" : 4,
		 * 	"pitchDecay" : 0.1
		 * }).connect(feedbackDelay);
		 * tom.triggerAttackRelease("A2","32n");
		 */
	    Tone.FeedbackDelay = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'feedback'
	        ], Tone.FeedbackDelay);
	        Tone.FeedbackEffect.call(this, options);
	        /**
			 *  the delay node
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delayNode = new Tone.Delay(options.delayTime);
	        /**
			 *  The delayTime of the DelayNode. 
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = this._delayNode.delayTime;
	        // connect it up
	        this.connectEffect(this._delayNode);
	        this._readOnly(['delayTime']);
	    };
	    Tone.extend(Tone.FeedbackDelay, Tone.FeedbackEffect);
	    /**
		 *  The default values. 
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.FeedbackDelay.defaults = { 'delayTime': 0.25 };
	    /**
		 *  clean up
		 *  @returns {Tone.FeedbackDelay} this
		 */
	    Tone.FeedbackDelay.prototype.dispose = function () {
	        Tone.FeedbackEffect.prototype.dispose.call(this);
	        this._delayNode.dispose();
	        this._delayNode = null;
	        this._writable(['delayTime']);
	        this.delayTime = null;
	        return this;
	    };
	    return Tone.FeedbackDelay;
	});
	Module(function (Tone) {
	    
	    /**
		 *  an array of comb filter delay values from Freeverb implementation
		 *  @static
		 *  @private
		 *  @type {Array}
		 */
	    var combFilterTunings = [
	        1557 / 44100,
	        1617 / 44100,
	        1491 / 44100,
	        1422 / 44100,
	        1277 / 44100,
	        1356 / 44100,
	        1188 / 44100,
	        1116 / 44100
	    ];
	    /**
		 *  an array of allpass filter frequency values from Freeverb implementation
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var allpassFilterFrequencies = [
	        225,
	        556,
	        441,
	        341
	    ];
	    /**
		 *  @class Tone.Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).
		 *         Read more on reverb on [Sound On Sound](https://web.archive.org/web/20160404083902/http://www.soundonsound.com:80/sos/feb01/articles/synthsecrets.asp).
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 *  @param {NormalRange|Object} [roomSize] Correlated to the decay time.
		 *  @param {Frequency} [dampening] The cutoff frequency of a lowpass filter as part
		 *                                 of the reverb.
		 *  @example
		 * var freeverb = new Tone.Freeverb().toMaster();
		 * freeverb.dampening.value = 1000;
		 * //routing synth through the reverb
		 * var synth = new Tone.AMSynth().connect(freeverb);
		 */
	    Tone.Freeverb = function () {
	        var options = Tone.defaults(arguments, [
	            'roomSize',
	            'dampening'
	        ], Tone.Freeverb);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  The roomSize value between. A larger roomSize
			 *  will result in a longer decay.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);
	        /**
			 *  The amount of dampening of the reverberant signal.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.dampening = new Tone.Signal(options.dampening, Tone.Type.Frequency);
	        /**
			 *  the comb filters
			 *  @type {Array}
			 *  @private
			 */
	        this._combFilters = [];
	        /**
			 *  the allpass filters on the left
			 *  @type {Array}
			 *  @private
			 */
	        this._allpassFiltersL = [];
	        /**
			 *  the allpass filters on the right
			 *  @type {Array}
			 *  @private
			 */
	        this._allpassFiltersR = [];
	        //make the allpass filters on the right
	        for (var l = 0; l < allpassFilterFrequencies.length; l++) {
	            var allpassL = this.context.createBiquadFilter();
	            allpassL.type = 'allpass';
	            allpassL.frequency.value = allpassFilterFrequencies[l];
	            this._allpassFiltersL.push(allpassL);
	        }
	        //make the allpass filters on the left
	        for (var r = 0; r < allpassFilterFrequencies.length; r++) {
	            var allpassR = this.context.createBiquadFilter();
	            allpassR.type = 'allpass';
	            allpassR.frequency.value = allpassFilterFrequencies[r];
	            this._allpassFiltersR.push(allpassR);
	        }
	        //make the comb filters
	        for (var c = 0; c < combFilterTunings.length; c++) {
	            var lfpf = new Tone.LowpassCombFilter(combFilterTunings[c]);
	            if (c < combFilterTunings.length / 2) {
	                this.effectSendL.chain(lfpf, this._allpassFiltersL[0]);
	            } else {
	                this.effectSendR.chain(lfpf, this._allpassFiltersR[0]);
	            }
	            this.roomSize.connect(lfpf.resonance);
	            this.dampening.connect(lfpf.dampening);
	            this._combFilters.push(lfpf);
	        }
	        //chain the allpass filters togetehr
	        Tone.connectSeries.apply(Tone, this._allpassFiltersL);
	        Tone.connectSeries.apply(Tone, this._allpassFiltersR);
	        this._allpassFiltersL[this._allpassFiltersL.length - 1].connect(this.effectReturnL);
	        this._allpassFiltersR[this._allpassFiltersR.length - 1].connect(this.effectReturnR);
	        this._readOnly([
	            'roomSize',
	            'dampening'
	        ]);
	    };
	    Tone.extend(Tone.Freeverb, Tone.StereoEffect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Freeverb.defaults = {
	        'roomSize': 0.7,
	        'dampening': 3000
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Freeverb} this
		 */
	    Tone.Freeverb.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        for (var al = 0; al < this._allpassFiltersL.length; al++) {
	            this._allpassFiltersL[al].disconnect();
	            this._allpassFiltersL[al] = null;
	        }
	        this._allpassFiltersL = null;
	        for (var ar = 0; ar < this._allpassFiltersR.length; ar++) {
	            this._allpassFiltersR[ar].disconnect();
	            this._allpassFiltersR[ar] = null;
	        }
	        this._allpassFiltersR = null;
	        for (var cf = 0; cf < this._combFilters.length; cf++) {
	            this._combFilters[cf].dispose();
	            this._combFilters[cf] = null;
	        }
	        this._combFilters = null;
	        this._writable([
	            'roomSize',
	            'dampening'
	        ]);
	        this.roomSize.dispose();
	        this.roomSize = null;
	        this.dampening.dispose();
	        this.dampening = null;
	        return this;
	    };
	    return Tone.Freeverb;
	});
	Module(function (Tone) {
	    
	    /**
		 *  an array of the comb filter delay time values
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var combFilterDelayTimes = [
	        1687 / 25000,
	        1601 / 25000,
	        2053 / 25000,
	        2251 / 25000
	    ];
	    /**
		 *  the resonances of each of the comb filters
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var combFilterResonances = [
	        0.773,
	        0.802,
	        0.753,
	        0.733
	    ];
	    /**
		 *  the allpass filter frequencies
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var allpassFilterFreqs = [
	        347,
	        113,
	        37
	    ];
	    /**
		 *  @class Tone.JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)
		 *         tuned by John Chowning in 1970.
		 *         It is made up of three allpass filters and four Tone.FeedbackCombFilter. 
		 *         
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 *  @param {NormalRange|Object} [roomSize] Coorelates to the decay time.
		 *  @example
		 * var reverb = new Tone.JCReverb(0.4).connect(Tone.Master);
		 * var delay = new Tone.FeedbackDelay(0.5); 
		 * //connecting the synth to reverb through delay
		 * var synth = new Tone.DuoSynth().chain(delay, reverb);
		 * synth.triggerAttackRelease("A4","8n");
		 */
	    Tone.JCReverb = function () {
	        var options = Tone.defaults(arguments, ['roomSize'], Tone.JCReverb);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  room size control values between [0,1]
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);
	        /**
			 *  scale the room size
			 *  @type {Tone.Scale}
			 *  @private
			 */
	        this._scaleRoomSize = new Tone.Scale(-0.733, 0.197);
	        /**
			 *  a series of allpass filters
			 *  @type {Array}
			 *  @private
			 */
	        this._allpassFilters = [];
	        /**
			 *  parallel feedback comb filters
			 *  @type {Array}
			 *  @private
			 */
	        this._feedbackCombFilters = [];
	        //make the allpass filters
	        for (var af = 0; af < allpassFilterFreqs.length; af++) {
	            var allpass = this.context.createBiquadFilter();
	            allpass.type = 'allpass';
	            allpass.frequency.value = allpassFilterFreqs[af];
	            this._allpassFilters.push(allpass);
	        }
	        //and the comb filters
	        for (var cf = 0; cf < combFilterDelayTimes.length; cf++) {
	            var fbcf = new Tone.FeedbackCombFilter(combFilterDelayTimes[cf], 0.1);
	            this._scaleRoomSize.connect(fbcf.resonance);
	            fbcf.resonance.value = combFilterResonances[cf];
	            this._allpassFilters[this._allpassFilters.length - 1].connect(fbcf);
	            if (cf < combFilterDelayTimes.length / 2) {
	                fbcf.connect(this.effectReturnL);
	            } else {
	                fbcf.connect(this.effectReturnR);
	            }
	            this._feedbackCombFilters.push(fbcf);
	        }
	        //chain the allpass filters together
	        this.roomSize.connect(this._scaleRoomSize);
	        Tone.connectSeries.apply(Tone, this._allpassFilters);
	        this.effectSendL.connect(this._allpassFilters[0]);
	        this.effectSendR.connect(this._allpassFilters[0]);
	        this._readOnly(['roomSize']);
	    };
	    Tone.extend(Tone.JCReverb, Tone.StereoEffect);
	    /**
		 *  the default values
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.JCReverb.defaults = { 'roomSize': 0.5 };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.JCReverb} this
		 */
	    Tone.JCReverb.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        for (var apf = 0; apf < this._allpassFilters.length; apf++) {
	            this._allpassFilters[apf].disconnect();
	            this._allpassFilters[apf] = null;
	        }
	        this._allpassFilters = null;
	        for (var fbcf = 0; fbcf < this._feedbackCombFilters.length; fbcf++) {
	            this._feedbackCombFilters[fbcf].dispose();
	            this._feedbackCombFilters[fbcf] = null;
	        }
	        this._feedbackCombFilters = null;
	        this._writable(['roomSize']);
	        this.roomSize.dispose();
	        this.roomSize = null;
	        this._scaleRoomSize.dispose();
	        this._scaleRoomSize = null;
	        return this;
	    };
	    return Tone.JCReverb;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Mid/Side processing separates the the 'mid' signal 
		 *         (which comes out of both the left and the right channel) 
		 *         and the 'side' (which only comes out of the the side channels) 
		 *         and effects them separately before being recombined.
		 *         Applies a Mid/Side seperation and recombination.
		 *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
		 *         <br><br>
		 *         This is a base-class for Mid/Side Effects. 
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 */
	    Tone.MidSideEffect = function () {
	        Tone.Effect.apply(this, arguments);
	        /**
			 *  The mid/side split
			 *  @type  {Tone.MidSideSplit}
			 *  @private
			 */
	        this._midSideSplit = new Tone.MidSideSplit();
	        /**
			 *  The mid/side merge
			 *  @type  {Tone.MidSideMerge}
			 *  @private
			 */
	        this._midSideMerge = new Tone.MidSideMerge();
	        /**
			 *  The mid send. Connect to mid processing
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this.midSend = this._midSideSplit.mid;
	        /**
			 *  The side send. Connect to side processing
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this.sideSend = this._midSideSplit.side;
	        /**
			 *  The mid return connection
			 *  @type {GainNode}
			 *  @private
			 */
	        this.midReturn = this._midSideMerge.mid;
	        /**
			 *  The side return connection
			 *  @type {GainNode}
			 *  @private
			 */
	        this.sideReturn = this._midSideMerge.side;
	        //the connections
	        this.effectSend.connect(this._midSideSplit);
	        this._midSideMerge.connect(this.effectReturn);
	    };
	    Tone.extend(Tone.MidSideEffect, Tone.Effect);
	    /**
		 *  Clean up. 
		 *  @returns {Tone.MidSideEffect} this
		 */
	    Tone.MidSideEffect.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._midSideSplit.dispose();
	        this._midSideSplit = null;
	        this._midSideMerge.dispose();
	        this._midSideMerge = null;
	        this.midSend = null;
	        this.sideSend = null;
	        this.midReturn = null;
	        this.sideReturn = null;
	        return this;
	    };
	    return Tone.MidSideEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Phaser is a phaser effect. Phasers work by changing the phase
		 *         of different frequency components of an incoming signal. Read more on 
		 *         [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)). 
		 *         Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).
		 *
		 *	@extends {Tone.StereoEffect}
		 *	@constructor
		 *	@param {Frequency|Object} [frequency] The speed of the phasing. 
		 *	@param {number} [octaves] The octaves of the effect. 
		 *	@param {Frequency} [baseFrequency] The base frequency of the filters. 
		 *	@example
		 * var phaser = new Tone.Phaser({
		 * 	"frequency" : 15, 
		 * 	"octaves" : 5, 
		 * 	"baseFrequency" : 1000
		 * }).toMaster();
		 * var synth = new Tone.FMSynth().connect(phaser);
		 * synth.triggerAttackRelease("E3", "2n");
		 */
	    Tone.Phaser = function () {
	        //set the defaults
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'octaves',
	            'baseFrequency'
	        ], Tone.Phaser);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  the lfo which controls the frequency on the left side
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfoL = new Tone.LFO(options.frequency, 0, 1);
	        /**
			 *  the lfo which controls the frequency on the right side
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfoR = new Tone.LFO(options.frequency, 0, 1);
	        this._lfoR.phase = 180;
	        /**
			 *  the base modulation frequency
			 *  @type {number}
			 *  @private
			 */
	        this._baseFrequency = options.baseFrequency;
	        /**
			 *  the octaves of the phasing
			 *  @type {number}
			 *  @private
			 */
	        this._octaves = options.octaves;
	        /**
			 *  The quality factor of the filters
			 *  @type {Positive}
			 *  @signal
			 */
	        this.Q = new Tone.Signal(options.Q, Tone.Type.Positive);
	        /**
			 *  the array of filters for the left side
			 *  @type {Array}
			 *  @private
			 */
	        this._filtersL = this._makeFilters(options.stages, this._lfoL, this.Q);
	        /**
			 *  the array of filters for the left side
			 *  @type {Array}
			 *  @private
			 */
	        this._filtersR = this._makeFilters(options.stages, this._lfoR, this.Q);
	        /**
			 * the frequency of the effect
			 * @type {Tone.Signal}
			 */
	        this.frequency = this._lfoL.frequency;
	        this.frequency.value = options.frequency;
	        //connect them up
	        this.effectSendL.connect(this._filtersL[0]);
	        this.effectSendR.connect(this._filtersR[0]);
	        this._filtersL[options.stages - 1].connect(this.effectReturnL);
	        this._filtersR[options.stages - 1].connect(this.effectReturnR);
	        //control the frequency with one LFO
	        this._lfoL.frequency.connect(this._lfoR.frequency);
	        //set the options
	        this.baseFrequency = options.baseFrequency;
	        this.octaves = options.octaves;
	        //start the lfo
	        this._lfoL.start();
	        this._lfoR.start();
	        this._readOnly([
	            'frequency',
	            'Q'
	        ]);
	    };
	    Tone.extend(Tone.Phaser, Tone.StereoEffect);
	    /**
		 *  defaults
		 *  @static
		 *  @type {object}
		 */
	    Tone.Phaser.defaults = {
	        'frequency': 0.5,
	        'octaves': 3,
	        'stages': 10,
	        'Q': 10,
	        'baseFrequency': 350
	    };
	    /**
		 *  @param {number} stages
		 *  @returns {Array} the number of filters all connected together
		 *  @private
		 */
	    Tone.Phaser.prototype._makeFilters = function (stages, connectToFreq, Q) {
	        var filters = new Array(stages);
	        //make all the filters
	        for (var i = 0; i < stages; i++) {
	            var filter = this.context.createBiquadFilter();
	            filter.type = 'allpass';
	            Q.connect(filter.Q);
	            connectToFreq.connect(filter.frequency);
	            filters[i] = filter;
	        }
	        Tone.connectSeries.apply(Tone, filters);
	        return filters;
	    };
	    /**
		 * The number of octaves the phase goes above
		 * the baseFrequency
		 * @memberOf Tone.Phaser#
		 * @type {Positive}
		 * @name octaves
		 */
	    Object.defineProperty(Tone.Phaser.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (octaves) {
	            this._octaves = octaves;
	            var max = this._baseFrequency * Math.pow(2, octaves);
	            this._lfoL.max = max;
	            this._lfoR.max = max;
	        }
	    });
	    /**
		 * The the base frequency of the filters. 
		 * @memberOf Tone.Phaser#
		 * @type {number}
		 * @name baseFrequency
		 */
	    Object.defineProperty(Tone.Phaser.prototype, 'baseFrequency', {
	        get: function () {
	            return this._baseFrequency;
	        },
	        set: function (freq) {
	            this._baseFrequency = freq;
	            this._lfoL.min = freq;
	            this._lfoR.min = freq;
	            this.octaves = this._octaves;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.Phaser} this
		 */
	    Tone.Phaser.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'Q'
	        ]);
	        this.Q.dispose();
	        this.Q = null;
	        this._lfoL.dispose();
	        this._lfoL = null;
	        this._lfoR.dispose();
	        this._lfoR = null;
	        for (var i = 0; i < this._filtersL.length; i++) {
	            this._filtersL[i].disconnect();
	            this._filtersL[i] = null;
	        }
	        this._filtersL = null;
	        for (var j = 0; j < this._filtersR.length; j++) {
	            this._filtersR[j].disconnect();
	            this._filtersR[j] = null;
	        }
	        this._filtersR = null;
	        this.frequency = null;
	        return this;
	    };
	    return Tone.Phaser;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.PingPongDelay is a feedback delay effect where the echo is heard
		 *          first in one channel and next in the opposite channel. In a stereo
		 *          system these are the right and left channels.
		 *          PingPongDelay in more simplified terms is two Tone.FeedbackDelays 
		 *          with independent delay values. Each delay is routed to one channel
		 *          (left or right), and the channel triggered second will always 
		 *          trigger at the same interval after the first.
		 *
		 * 	@constructor
		 * 	@extends {Tone.StereoXFeedbackEffect}
		 *  @param {Time|Object} [delayTime] The delayTime between consecutive echos.
		 *  @param {NormalRange=} feedback The amount of the effected signal which 
		 *                                 is fed back through the delay.
		 *  @example
		 * var pingPong = new Tone.PingPongDelay("4n", 0.2).toMaster();
		 * var drum = new Tone.DrumSynth().connect(pingPong);
		 * drum.triggerAttackRelease("C4", "32n");
		 */
	    Tone.PingPongDelay = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'feedback'
	        ], Tone.PingPongDelay);
	        Tone.StereoXFeedbackEffect.call(this, options);
	        /**
			 *  the delay node on the left side
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._leftDelay = new Tone.Delay(0, options.maxDelayTime);
	        /**
			 *  the delay node on the right side
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._rightDelay = new Tone.Delay(0, options.maxDelayTime);
	        /**
			 *  the predelay on the right side
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._rightPreDelay = new Tone.Delay(0, options.maxDelayTime);
	        /**
			 *  the delay time signal
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);
	        //connect it up
	        this.effectSendL.chain(this._leftDelay, this.effectReturnL);
	        this.effectSendR.chain(this._rightPreDelay, this._rightDelay, this.effectReturnR);
	        this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);
	        //rearranged the feedback to be after the rightPreDelay
	        this._feedbackLR.disconnect();
	        this._feedbackLR.connect(this._rightDelay);
	        this._readOnly(['delayTime']);
	    };
	    Tone.extend(Tone.PingPongDelay, Tone.StereoXFeedbackEffect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.PingPongDelay.defaults = {
	        'delayTime': 0.25,
	        'maxDelayTime': 1
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.PingPongDelay} this
		 */
	    Tone.PingPongDelay.prototype.dispose = function () {
	        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);
	        this._leftDelay.dispose();
	        this._leftDelay = null;
	        this._rightDelay.dispose();
	        this._rightDelay = null;
	        this._rightPreDelay.dispose();
	        this._rightPreDelay = null;
	        this._writable(['delayTime']);
	        this.delayTime.dispose();
	        this.delayTime = null;
	        return this;
	    };
	    return Tone.PingPongDelay;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.PitchShift does near-realtime pitch shifting to the incoming signal. 
		 *         The effect is achieved by speeding up or slowing down the delayTime
		 *         of a DelayNode using a sawtooth wave. 
		 *         Algorithm found in [this pdf](http://dsp-book.narod.ru/soundproc.pdf).
		 *         Additional reference by [Miller Pucket](http://msp.ucsd.edu/techniques/v0.11/book-html/node115.html).
		 *         
		 *  @extends {Tone.FeedbackEffect}
		 *  @param {Interval=} pitch The interval to transpose the incoming signal by. 
		 */
	    Tone.PitchShift = function () {
	        var options = Tone.defaults(arguments, ['pitch'], Tone.PitchShift);
	        Tone.FeedbackEffect.call(this, options);
	        /**
			 *  The pitch signal
			 *  @type  {Tone.Signal}
			 *  @private
			 */
	        this._frequency = new Tone.Signal(0);
	        /**
			 *  Uses two DelayNodes to cover up the jump in
			 *  the sawtooth wave. 
			 *  @type  {DelayNode}
			 *  @private
			 */
	        this._delayA = new Tone.Delay(0, 1);
	        /**
			 *  The first LFO.
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfoA = new Tone.LFO({
	            'min': 0,
	            'max': 0.1,
	            'type': 'sawtooth'
	        }).connect(this._delayA.delayTime);
	        /**
			 *  The second DelayNode
			 *  @type  {DelayNode}
			 *  @private
			 */
	        this._delayB = new Tone.Delay(0, 1);
	        /**
			 *  The first LFO.
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfoB = new Tone.LFO({
	            'min': 0,
	            'max': 0.1,
	            'type': 'sawtooth',
	            'phase': 180
	        }).connect(this._delayB.delayTime);
	        /**
			 *  Crossfade quickly between the two delay lines
			 *  to cover up the jump in the sawtooth wave
			 *  @type  {Tone.CrossFade}
			 *  @private
			 */
	        this._crossFade = new Tone.CrossFade();
	        /**
			 *  LFO which alternates between the two
			 *  delay lines to cover up the disparity in the
			 *  sawtooth wave. 
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._crossFadeLFO = new Tone.LFO({
	            'min': 0,
	            'max': 1,
	            'type': 'triangle',
	            'phase': 90
	        }).connect(this._crossFade.fade);
	        /**
			 *  The delay node
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._feedbackDelay = new Tone.Delay(options.delayTime);
	        /**
			 *  The amount of delay on the input signal
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = this._feedbackDelay.delayTime;
	        this._readOnly('delayTime');
	        /**
			 *  Hold the current pitch
			 *  @type {Number}
			 *  @private
			 */
	        this._pitch = options.pitch;
	        /**
			 *  Hold the current windowSize
			 *  @type {Number}
			 *  @private
			 */
	        this._windowSize = options.windowSize;
	        //connect the two delay lines up
	        this._delayA.connect(this._crossFade.a);
	        this._delayB.connect(this._crossFade.b);
	        //connect the frequency
	        this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency);
	        //route the input
	        this.effectSend.fan(this._delayA, this._delayB);
	        this._crossFade.chain(this._feedbackDelay, this.effectReturn);
	        //start the LFOs at the same time
	        var now = this.now();
	        this._lfoA.start(now);
	        this._lfoB.start(now);
	        this._crossFadeLFO.start(now);
	        //set the initial value
	        this.windowSize = this._windowSize;
	    };
	    Tone.extend(Tone.PitchShift, Tone.FeedbackEffect);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.PitchShift.defaults = {
	        'pitch': 0,
	        'windowSize': 0.1,
	        'delayTime': 0,
	        'feedback': 0
	    };
	    /**
		 * Repitch the incoming signal by some interval (measured
		 * in semi-tones). 
		 * @memberOf Tone.PitchShift#
		 * @type {Interval}
		 * @name pitch
		 * @example
		 * pitchShift.pitch = -12; //down one octave
		 * pitchShift.pitch = 7; //up a fifth
		 */
	    Object.defineProperty(Tone.PitchShift.prototype, 'pitch', {
	        get: function () {
	            return this._pitch;
	        },
	        set: function (interval) {
	            this._pitch = interval;
	            var factor = 0;
	            if (interval < 0) {
	                this._lfoA.min = 0;
	                this._lfoA.max = this._windowSize;
	                this._lfoB.min = 0;
	                this._lfoB.max = this._windowSize;
	                factor = Tone.intervalToFrequencyRatio(interval - 1) + 1;
	            } else {
	                this._lfoA.min = this._windowSize;
	                this._lfoA.max = 0;
	                this._lfoB.min = this._windowSize;
	                this._lfoB.max = 0;
	                factor = Tone.intervalToFrequencyRatio(interval) - 1;
	            }
	            this._frequency.value = factor * (1.2 / this._windowSize);
	        }
	    });
	    /**
		 * The window size corresponds roughly to the sample length in a looping sampler. 
		 * Smaller values are desirable for a less noticeable delay time of the pitch shifted
		 * signal, but larger values will result in smoother pitch shifting for larger intervals. 
		 * A nominal range of 0.03 to 0.1 is recommended. 
		 * @memberOf Tone.PitchShift#
		 * @type {Time}
		 * @name windowSize
		 * @example
		 * pitchShift.windowSize = 0.1;
		 */
	    Object.defineProperty(Tone.PitchShift.prototype, 'windowSize', {
	        get: function () {
	            return this._windowSize;
	        },
	        set: function (size) {
	            this._windowSize = this.toSeconds(size);
	            this.pitch = this._pitch;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return  {Tone.PitchShift}  this
		 */
	    Tone.PitchShift.prototype.dispose = function () {
	        Tone.FeedbackEffect.prototype.dispose.call(this);
	        this._frequency.dispose();
	        this._frequency = null;
	        this._delayA.disconnect();
	        this._delayA = null;
	        this._delayB.disconnect();
	        this._delayB = null;
	        this._lfoA.dispose();
	        this._lfoA = null;
	        this._lfoB.dispose();
	        this._lfoB = null;
	        this._crossFade.dispose();
	        this._crossFade = null;
	        this._crossFadeLFO.dispose();
	        this._crossFadeLFO = null;
	        this._writable('delayTime');
	        this._feedbackDelay.dispose();
	        this._feedbackDelay = null;
	        this.delayTime = null;
	        return this;
	    };
	    return Tone.PitchShift;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Base class for stereo feedback effects where the effectReturn
		 *         is fed back into the same channel. 
		 *
		 *	@constructor
		 *	@extends {Tone.StereoEffect}
		 */
	    Tone.StereoFeedbackEffect = function () {
	        var options = Tone.defaults(arguments, ['feedback'], Tone.FeedbackEffect);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  controls the amount of feedback
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
	        /**
			 *  the left side feeback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackL = new Tone.Gain();
	        /**
			 *  the right side feeback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackR = new Tone.Gain();
	        //connect it up
	        this.effectReturnL.chain(this._feedbackL, this.effectSendL);
	        this.effectReturnR.chain(this._feedbackR, this.effectSendR);
	        this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);
	        this._readOnly(['feedback']);
	    };
	    Tone.extend(Tone.StereoFeedbackEffect, Tone.StereoEffect);
	    /**
		 *  clean up
		 *  @returns {Tone.StereoFeedbackEffect} this
		 */
	    Tone.StereoFeedbackEffect.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        this._writable(['feedback']);
	        this.feedback.dispose();
	        this.feedback = null;
	        this._feedbackL.dispose();
	        this._feedbackL = null;
	        this._feedbackR.dispose();
	        this._feedbackR = null;
	        return this;
	    };
	    return Tone.StereoFeedbackEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Applies a width factor to the mid/side seperation. 
		 *         0 is all mid and 1 is all side.
		 *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
		 *         <br><br>
		 *         <code>
		 *         Mid *= 2*(1-width)<br>
		 *         Side *= 2*width
		 *         </code>
		 *
		 *  @extends {Tone.MidSideEffect}
		 *  @constructor
		 *  @param {NormalRange|Object} [width] The stereo width. A width of 0 is mono and 1 is stereo. 0.5 is no change.
		 */
	    Tone.StereoWidener = function () {
	        var options = Tone.defaults(arguments, ['width'], Tone.StereoWidener);
	        Tone.MidSideEffect.call(this, options);
	        /**
			 *  The width control. 0 = 100% mid. 1 = 100% side. 0.5 = no change. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);
	        /**
			 *  Mid multiplier
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this._midMult = new Tone.Expr('$0 * ($1 * (1 - $2))');
	        /**
			 *  Side multiplier
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this._sideMult = new Tone.Expr('$0 * ($1 * $2)');
	        /**
			 *  constant output of 2
			 *  @type {Tone}
			 *  @private
			 */
	        this._two = new Tone.Signal(2);
	        //the mid chain
	        this._two.connect(this._midMult, 0, 1);
	        this.width.connect(this._midMult, 0, 2);
	        //the side chain
	        this._two.connect(this._sideMult, 0, 1);
	        this.width.connect(this._sideMult, 0, 2);
	        //connect it to the effect send/return
	        this.midSend.chain(this._midMult, this.midReturn);
	        this.sideSend.chain(this._sideMult, this.sideReturn);
	        this._readOnly(['width']);
	    };
	    Tone.extend(Tone.StereoWidener, Tone.MidSideEffect);
	    /**
		 *  the default values
		 *  @static
		 *  @type {Object}
		 */
	    Tone.StereoWidener.defaults = { 'width': 0.5 };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.StereoWidener} this
		 */
	    Tone.StereoWidener.prototype.dispose = function () {
	        Tone.MidSideEffect.prototype.dispose.call(this);
	        this._writable(['width']);
	        this.width.dispose();
	        this.width = null;
	        this._midMult.dispose();
	        this._midMult = null;
	        this._sideMult.dispose();
	        this._sideMult = null;
	        this._two.dispose();
	        this._two = null;
	        return this;
	    };
	    return Tone.StereoWidener;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Tremolo modulates the amplitude of an incoming signal using a Tone.LFO.
		 *         The type, frequency, and depth of the LFO is controllable.
		 *
		 *  @extends {Tone.StereoEffect}
		 *  @constructor
		 *  @param {Frequency} [frequency] The rate of the effect.
		 *  @param {NormalRange} [depth] The depth of the effect.
		 *  @example
		 * //create a tremolo and start it's LFO
		 * var tremolo = new Tone.Tremolo(9, 0.75).toMaster().start();
		 * //route an oscillator through the tremolo and start it
		 * var oscillator = new Tone.Oscillator().connect(tremolo).start();
		 */
	    Tone.Tremolo = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'depth'
	        ], Tone.Tremolo);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  The tremelo LFO in the left channel
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfoL = new Tone.LFO({
	            'phase': options.spread,
	            'min': 1,
	            'max': 0
	        });
	        /**
			 *  The tremelo LFO in the left channel
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfoR = new Tone.LFO({
	            'phase': options.spread,
	            'min': 1,
	            'max': 0
	        });
	        /**
			 *  Where the gain is multiplied
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._amplitudeL = new Tone.Gain();
	        /**
			 *  Where the gain is multiplied
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._amplitudeR = new Tone.Gain();
	        /**
			 *  The frequency of the tremolo.
			 *  @type  {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The depth of the effect. A depth of 0, has no effect
			 *  on the amplitude, and a depth of 1 makes the amplitude
			 *  modulate fully between 0 and 1.
			 *  @type  {NormalRange}
			 *  @signal
			 */
	        this.depth = new Tone.Signal(options.depth, Tone.Type.NormalRange);
	        this._readOnly([
	            'frequency',
	            'depth'
	        ]);
	        this.effectSendL.chain(this._amplitudeL, this.effectReturnL);
	        this.effectSendR.chain(this._amplitudeR, this.effectReturnR);
	        this._lfoL.connect(this._amplitudeL.gain);
	        this._lfoR.connect(this._amplitudeR.gain);
	        this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency);
	        this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude);
	        this.type = options.type;
	        this.spread = options.spread;
	    };
	    Tone.extend(Tone.Tremolo, Tone.StereoEffect);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Tremolo.defaults = {
	        'frequency': 10,
	        'type': 'sine',
	        'depth': 0.5,
	        'spread': 180
	    };
	    /**
		 * Start the tremolo.
		 * @param {Time} [time=now] When the tremolo begins.
		 * @returns {Tone.Tremolo} this
		 */
	    Tone.Tremolo.prototype.start = function (time) {
	        this._lfoL.start(time);
	        this._lfoR.start(time);
	        return this;
	    };
	    /**
		 * Stop the tremolo.
		 * @param {Time} [time=now] When the tremolo stops.
		 * @returns {Tone.Tremolo} this
		 */
	    Tone.Tremolo.prototype.stop = function (time) {
	        this._lfoL.stop(time);
	        this._lfoR.stop(time);
	        return this;
	    };
	    /**
		 * Sync the effect to the transport.
		 * @param {Time} [delay=0] Delay time before starting the effect after the
		 *                              Transport has started.
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.Tremolo.prototype.sync = function (delay) {
	        this._lfoL.sync(delay);
	        this._lfoR.sync(delay);
	        return this;
	    };
	    /**
		 * Unsync the filter from the transport
		 * @returns {Tone.Tremolo} this
		 */
	    Tone.Tremolo.prototype.unsync = function () {
	        this._lfoL.unsync();
	        this._lfoR.unsync();
	        return this;
	    };
	    /**
		 * The Tremolo's oscillator type.
		 * @memberOf Tone.Tremolo#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.Tremolo.prototype, 'type', {
	        get: function () {
	            return this._lfoL.type;
	        },
	        set: function (type) {
	            this._lfoL.type = type;
	            this._lfoR.type = type;
	        }
	    });
	    /** 
		 * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.
		 * When set to 180, LFO's will be panned hard left and right respectively.
		 * @memberOf Tone.Tremolo#
		 * @type {Degrees}
		 * @name spread
		 */
	    Object.defineProperty(Tone.Tremolo.prototype, 'spread', {
	        get: function () {
	            return this._lfoR.phase - this._lfoL.phase;    //180
	        },
	        set: function (spread) {
	            this._lfoL.phase = 90 - spread / 2;
	            this._lfoR.phase = spread / 2 + 90;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.Tremolo} this
		 */
	    Tone.Tremolo.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'depth'
	        ]);
	        this._lfoL.dispose();
	        this._lfoL = null;
	        this._lfoR.dispose();
	        this._lfoR = null;
	        this._amplitudeL.dispose();
	        this._amplitudeL = null;
	        this._amplitudeR.dispose();
	        this._amplitudeR = null;
	        this.frequency = null;
	        this.depth = null;
	        return this;
	    };
	    return Tone.Tremolo;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A Vibrato effect composed of a Tone.Delay and a Tone.LFO. The LFO
		 *         modulates the delayTime of the delay, causing the pitch to rise
		 *         and fall. 
		 *  @extends {Tone.Effect}
		 *  @param {Frequency} frequency The frequency of the vibrato.
		 *  @param {NormalRange} depth The amount the pitch is modulated.
		 */
	    Tone.Vibrato = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'depth'
	        ], Tone.Vibrato);
	        Tone.Effect.call(this, options);
	        /**
			 *  The delay node used for the vibrato effect
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delayNode = new Tone.Delay(0, options.maxDelay);
	        /**
			 *  The LFO used to control the vibrato
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfo = new Tone.LFO({
	            'type': options.type,
	            'min': 0,
	            'max': options.maxDelay,
	            'frequency': options.frequency,
	            'phase': -90    //offse the phase so the resting position is in the center
	        }).start().connect(this._delayNode.delayTime);
	        /**
			 *  The frequency of the vibrato
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._lfo.frequency;
	        /**
			 *  The depth of the vibrato. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.depth = this._lfo.amplitude;
	        this.depth.value = options.depth;
	        this._readOnly([
	            'frequency',
	            'depth'
	        ]);
	        this.effectSend.chain(this._delayNode, this.effectReturn);
	    };
	    Tone.extend(Tone.Vibrato, Tone.Effect);
	    /**
		 *  The defaults
		 *  @type  {Object}
		 *  @const
		 */
	    Tone.Vibrato.defaults = {
	        'maxDelay': 0.005,
	        'frequency': 5,
	        'depth': 0.1,
	        'type': 'sine'
	    };
	    /**
		 * Type of oscillator attached to the Vibrato.
		 * @memberOf Tone.Vibrato#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.Vibrato.prototype, 'type', {
	        get: function () {
	            return this._lfo.type;
	        },
	        set: function (type) {
	            this._lfo.type = type;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.Vibrato} this
		 */
	    Tone.Vibrato.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._delayNode.dispose();
	        this._delayNode = null;
	        this._lfo.dispose();
	        this._lfo = null;
	        this._writable([
	            'frequency',
	            'depth'
	        ]);
	        this.frequency = null;
	        this.depth = null;
	    };
	    return Tone.Vibrato;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Event abstracts away Tone.Transport.schedule and provides a schedulable
		 *          callback for a single or repeatable events along the timeline. 
		 *
		 *  @extends {Tone}
		 *  @param {function} callback The callback to invoke at the time. 
		 *  @param {*} value The value or values which should be passed to
		 *                      the callback function on invocation.  
		 *  @example
		 * var chord = new Tone.Event(function(time, chord){
		 * 	//the chord as well as the exact time of the event
		 * 	//are passed in as arguments to the callback function
		 * }, ["D4", "E4", "F4"]);
		 * //start the chord at the beginning of the transport timeline
		 * chord.start();
		 * //loop it every measure for 8 measures
		 * chord.loop = 8;
		 * chord.loopEnd = "1m";
		 */
	    Tone.Event = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'value'
	        ], Tone.Event);
	        Tone.call(this);
	        /**
			 *  Loop value
			 *  @type  {Boolean|Positive}
			 *  @private
			 */
	        this._loop = options.loop;
	        /**
			 *  The callback to invoke. 
			 *  @type  {Function}
			 */
	        this.callback = options.callback;
	        /**
			 *  The value which is passed to the
			 *  callback function.
			 *  @type  {*}
			 *  @private
			 */
	        this.value = options.value;
	        /**
			 *  When the note is scheduled to start.
			 *  @type  {Number}
			 *  @private
			 */
	        this._loopStart = this.toTicks(options.loopStart);
	        /**
			 *  When the note is scheduled to start.
			 *  @type  {Number}
			 *  @private
			 */
	        this._loopEnd = this.toTicks(options.loopEnd);
	        /**
			 *  Tracks the scheduled events
			 *  @type {Tone.TimelineState}
			 *  @private
			 */
	        this._state = new Tone.TimelineState(Tone.State.Stopped);
	        /**
			 *  The playback speed of the note. A speed of 1
			 *  is no change. 
			 *  @private
			 *  @type {Positive}
			 */
	        this._playbackRate = 1;
	        /**
			 *  A delay time from when the event is scheduled to start
			 *  @type {Ticks}
			 *  @private
			 */
	        this._startOffset = 0;
	        /**
			 *  private holder of probability value
			 *  @type {NormalRange}
			 *  @private
			 */
	        this._probability = options.probability;
	        /**
			 *  the amount of variation from the
			 *  given time. 
			 *  @type {Boolean|Time}
			 *  @private
			 */
	        this._humanize = options.humanize;
	        /**
			 *  If mute is true, the callback won't be
			 *  invoked.
			 *  @type {Boolean}
			 */
	        this.mute = options.mute;
	        //set the initial values
	        this.playbackRate = options.playbackRate;
	    };
	    Tone.extend(Tone.Event);
	    /**
		 *  The default values
		 *  @type  {Object}
		 *  @const
		 */
	    Tone.Event.defaults = {
	        'callback': Tone.noOp,
	        'loop': false,
	        'loopEnd': '1m',
	        'loopStart': 0,
	        'playbackRate': 1,
	        'value': null,
	        'probability': 1,
	        'mute': false,
	        'humanize': false
	    };
	    /**
		 *  Reschedule all of the events along the timeline
		 *  with the updated values.
		 *  @param {Time} after Only reschedules events after the given time.
		 *  @return  {Tone.Event}  this
		 *  @private
		 */
	    Tone.Event.prototype._rescheduleEvents = function (after) {
	        //if no argument is given, schedules all of the events
	        after = Tone.defaultArg(after, -1);
	        this._state.forEachFrom(after, function (event) {
	            var duration;
	            if (event.state === Tone.State.Started) {
	                if (!Tone.isUndef(event.id)) {
	                    Tone.Transport.clear(event.id);
	                }
	                var startTick = event.time + Math.round(this.startOffset / this._playbackRate);
	                if (this._loop) {
	                    duration = Infinity;
	                    if (Tone.isNumber(this._loop)) {
	                        duration = this._loop * this._getLoopDuration();
	                    }
	                    var nextEvent = this._state.getAfter(startTick);
	                    if (nextEvent !== null) {
	                        duration = Math.min(duration, nextEvent.time - startTick);
	                    }
	                    if (duration !== Infinity) {
	                        //schedule a stop since it's finite duration
	                        this._state.setStateAtTime(Tone.State.Stopped, startTick + duration + 1);
	                        duration = Tone.Time(duration, 'i');
	                    }
	                    var interval = Tone.Time(this._getLoopDuration(), 'i');
	                    event.id = Tone.Transport.scheduleRepeat(this._tick.bind(this), interval, Tone.TransportTime(startTick, 'i'), duration);
	                } else {
	                    event.id = Tone.Transport.schedule(this._tick.bind(this), startTick + 'i');
	                }
	            }
	        }.bind(this));
	        return this;
	    };
	    /**
		 *  Returns the playback state of the note, either "started" or "stopped".
		 *  @type {String}
		 *  @readOnly
		 *  @memberOf Tone.Event#
		 *  @name state
		 */
	    Object.defineProperty(Tone.Event.prototype, 'state', {
	        get: function () {
	            return this._state.getValueAtTime(Tone.Transport.ticks);
	        }
	    });
	    /**
		 *  The start from the scheduled start time
		 *  @type {Ticks}
		 *  @memberOf Tone.Event#
		 *  @name startOffset
		 *  @private
		 */
	    Object.defineProperty(Tone.Event.prototype, 'startOffset', {
	        get: function () {
	            return this._startOffset;
	        },
	        set: function (offset) {
	            this._startOffset = offset;
	        }
	    });
	    /**
		 *  The probability of the notes being triggered.
		 *  @memberOf Tone.Event#
		 *  @type {NormalRange}
		 *  @name probability
		 */
	    Object.defineProperty(Tone.Event.prototype, 'probability', {
	        get: function () {
	            return this._probability;
	        },
	        set: function (prob) {
	            this._probability = prob;
	        }
	    });
	    /**
		 *  If set to true, will apply small random variation
		 *  to the callback time. If the value is given as a time, it will randomize
		 *  by that amount.
		 *  @example
		 * event.humanize = true;
		 *  @type {Boolean|Time}
		 *  @name humanize
		 */
	    Object.defineProperty(Tone.Event.prototype, 'humanize', {
	        get: function () {
	            return this._humanize;
	        },
	        set: function (variation) {
	            this._humanize = variation;
	        }
	    });
	    /**
		 *  Start the note at the given time. 
		 *  @param  {TimelinePosition}  time  When the note should start.
		 *  @return  {Tone.Event}  this
		 */
	    Tone.Event.prototype.start = function (time) {
	        time = this.toTicks(time);
	        if (this._state.getValueAtTime(time) === Tone.State.Stopped) {
	            this._state.add({
	                'state': Tone.State.Started,
	                'time': time,
	                'id': undefined
	            });
	            this._rescheduleEvents(time);
	        }
	        return this;
	    };
	    /**
		 *  Stop the Event at the given time.
		 *  @param  {TimelinePosition}  time  When the note should stop.
		 *  @return  {Tone.Event}  this
		 */
	    Tone.Event.prototype.stop = function (time) {
	        this.cancel(time);
	        time = this.toTicks(time);
	        if (this._state.getValueAtTime(time) === Tone.State.Started) {
	            this._state.setStateAtTime(Tone.State.Stopped, time);
	            var previousEvent = this._state.getBefore(time);
	            var reschedulTime = time;
	            if (previousEvent !== null) {
	                reschedulTime = previousEvent.time;
	            }
	            this._rescheduleEvents(reschedulTime);
	        }
	        return this;
	    };
	    /**
		 *  Cancel all scheduled events greater than or equal to the given time
		 *  @param  {TimelinePosition}  [time=0]  The time after which events will be cancel.
		 *  @return  {Tone.Event}  this
		 */
	    Tone.Event.prototype.cancel = function (time) {
	        time = Tone.defaultArg(time, -Infinity);
	        time = this.toTicks(time);
	        this._state.forEachFrom(time, function (event) {
	            Tone.Transport.clear(event.id);
	        });
	        this._state.cancel(time);
	        return this;
	    };
	    /**
		 *  The callback function invoker. Also 
		 *  checks if the Event is done playing
		 *  @param  {Number}  time  The time of the event in seconds
		 *  @private
		 */
	    Tone.Event.prototype._tick = function (time) {
	        if (!this.mute && this._state.getValueAtTime(Tone.Transport.ticks) === Tone.State.Started) {
	            if (this.probability < 1 && Math.random() > this.probability) {
	                return;
	            }
	            if (this.humanize) {
	                var variation = 0.02;
	                if (!Tone.isBoolean(this.humanize)) {
	                    variation = this.toSeconds(this.humanize);
	                }
	                time += (Math.random() * 2 - 1) * variation;
	            }
	            this.callback(time, this.value);
	        }
	    };
	    /**
		 *  Get the duration of the loop.
		 *  @return  {Ticks}
		 *  @private
		 */
	    Tone.Event.prototype._getLoopDuration = function () {
	        return Math.round((this._loopEnd - this._loopStart) / this._playbackRate);
	    };
	    /**
		 *  If the note should loop or not
		 *  between Tone.Event.loopStart and 
		 *  Tone.Event.loopEnd. An integer
		 *  value corresponds to the number of
		 *  loops the Event does after it starts.
		 *  @memberOf Tone.Event#
		 *  @type {Boolean|Positive}
		 *  @name loop
		 */
	    Object.defineProperty(Tone.Event.prototype, 'loop', {
	        get: function () {
	            return this._loop;
	        },
	        set: function (loop) {
	            this._loop = loop;
	            this._rescheduleEvents();
	        }
	    });
	    /**
		 * 	The playback rate of the note. Defaults to 1.
		 *  @memberOf Tone.Event#
		 *  @type {Positive}
		 *  @name playbackRate
		 *  @example
		 * note.loop = true;
		 * //repeat the note twice as fast
		 * note.playbackRate = 2;
		 */
	    Object.defineProperty(Tone.Event.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            this._rescheduleEvents();
	        }
	    });
	    /**
		 *  The loopEnd point is the time the event will loop
		 *  if Tone.Event.loop is true.
		 *  @memberOf Tone.Event#
		 *  @type {TransportTime}
		 *  @name loopEnd
		 */
	    Object.defineProperty(Tone.Event.prototype, 'loopEnd', {
	        get: function () {
	            return Tone.TransportTime(this._loopEnd, 'i').toNotation();
	        },
	        set: function (loopEnd) {
	            this._loopEnd = this.toTicks(loopEnd);
	            if (this._loop) {
	                this._rescheduleEvents();
	            }
	        }
	    });
	    /**
		 *  The time when the loop should start. 
		 *  @memberOf Tone.Event#
		 *  @type {TransportTime}
		 *  @name loopStart
		 */
	    Object.defineProperty(Tone.Event.prototype, 'loopStart', {
	        get: function () {
	            return Tone.TransportTime(this._loopStart, 'i').toNotation();
	        },
	        set: function (loopStart) {
	            this._loopStart = this.toTicks(loopStart);
	            if (this._loop) {
	                this._rescheduleEvents();
	            }
	        }
	    });
	    /**
		 *  The current progress of the loop interval.
		 *  Returns 0 if the event is not started yet or
		 *  it is not set to loop.
		 *  @memberOf Tone.Event#
		 *  @type {NormalRange}
		 *  @name progress
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Event.prototype, 'progress', {
	        get: function () {
	            if (this._loop) {
	                var ticks = Tone.Transport.ticks;
	                var lastEvent = this._state.get(ticks);
	                if (lastEvent !== null && lastEvent.state === Tone.State.Started) {
	                    var loopDuration = this._getLoopDuration();
	                    var progress = (ticks - lastEvent.time) % loopDuration;
	                    return progress / loopDuration;
	                } else {
	                    return 0;
	                }
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  Clean up
		 *  @return  {Tone.Event}  this
		 */
	    Tone.Event.prototype.dispose = function () {
	        this.cancel();
	        this._state.dispose();
	        this._state = null;
	        this.callback = null;
	        this.value = null;
	    };
	    return Tone.Event;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Loop creates a looped callback at the 
		 *         specified interval. The callback can be 
		 *         started, stopped and scheduled along
		 *         the Transport's timeline. 
		 *  @example
		 * var loop = new Tone.Loop(function(time){
		 * 	//triggered every eighth note. 
		 * 	console.log(time);
		 * }, "8n").start(0);
		 * Tone.Transport.start();
		 *  @extends {Tone}
		 *  @param {Function} callback The callback to invoke with the event.
		 *  @param {Time} interval The time between successive callback calls. 
		 */
	    Tone.Loop = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'interval'
	        ], Tone.Loop);
	        Tone.call(this);
	        /**
			 *  The event which produces the callbacks
			 */
	        this._event = new Tone.Event({
	            'callback': this._tick.bind(this),
	            'loop': true,
	            'loopEnd': options.interval,
	            'playbackRate': options.playbackRate,
	            'probability': options.probability
	        });
	        /**
			 *  The callback to invoke with the next event in the pattern
			 *  @type {Function}
			 */
	        this.callback = options.callback;
	        //set the iterations
	        this.iterations = options.iterations;
	    };
	    Tone.extend(Tone.Loop);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Loop.defaults = {
	        'interval': '4n',
	        'callback': Tone.noOp,
	        'playbackRate': 1,
	        'iterations': Infinity,
	        'probability': true,
	        'mute': false
	    };
	    /**
		 *  Start the loop at the specified time along the Transport's
		 *  timeline.
		 *  @param  {TimelinePosition=}  time  When to start the Loop.
		 *  @return  {Tone.Loop}  this
		 */
	    Tone.Loop.prototype.start = function (time) {
	        this._event.start(time);
	        return this;
	    };
	    /**
		 *  Stop the loop at the given time.
		 *  @param  {TimelinePosition=}  time  When to stop the Arpeggio
		 *  @return  {Tone.Loop}  this
		 */
	    Tone.Loop.prototype.stop = function (time) {
	        this._event.stop(time);
	        return this;
	    };
	    /**
		 *  Cancel all scheduled events greater than or equal to the given time
		 *  @param  {TimelinePosition}  [time=0]  The time after which events will be cancel.
		 *  @return  {Tone.Loop}  this
		 */
	    Tone.Loop.prototype.cancel = function (time) {
	        this._event.cancel(time);
	        return this;
	    };
	    /**
		 *  Internal function called when the notes should be called
		 *  @param  {Number}  time  The time the event occurs
		 *  @private
		 */
	    Tone.Loop.prototype._tick = function (time) {
	        this.callback(time);
	    };
	    /**
		 *  The state of the Loop, either started or stopped.
		 *  @memberOf Tone.Loop#
		 *  @type {String}
		 *  @name state
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'state', {
	        get: function () {
	            return this._event.state;
	        }
	    });
	    /**
		 *  The progress of the loop as a value between 0-1. 0, when
		 *  the loop is stopped or done iterating. 
		 *  @memberOf Tone.Loop#
		 *  @type {NormalRange}
		 *  @name progress
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'progress', {
	        get: function () {
	            return this._event.progress;
	        }
	    });
	    /**
		 *  The time between successive callbacks. 
		 *  @example
		 * loop.interval = "8n"; //loop every 8n
		 *  @memberOf Tone.Loop#
		 *  @type {Time}
		 *  @name interval
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'interval', {
	        get: function () {
	            return this._event.loopEnd;
	        },
	        set: function (interval) {
	            this._event.loopEnd = interval;
	        }
	    });
	    /**
		 *  The playback rate of the loop. The normal playback rate is 1 (no change). 
		 *  A `playbackRate` of 2 would be twice as fast. 
		 *  @memberOf Tone.Loop#
		 *  @type {Time}
		 *  @name playbackRate
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'playbackRate', {
	        get: function () {
	            return this._event.playbackRate;
	        },
	        set: function (rate) {
	            this._event.playbackRate = rate;
	        }
	    });
	    /**
		 *  Random variation +/-0.01s to the scheduled time. 
		 *  Or give it a time value which it will randomize by.
		 *  @type {Boolean|Time}
		 *  @memberOf Tone.Loop#
		 *  @name humanize
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'humanize', {
	        get: function () {
	            return this._event.humanize;
	        },
	        set: function (variation) {
	            this._event.humanize = variation;
	        }
	    });
	    /**
		 *  The probably of the callback being invoked.
		 *  @memberOf Tone.Loop#
		 *  @type {NormalRange}
		 *  @name probability
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'probability', {
	        get: function () {
	            return this._event.probability;
	        },
	        set: function (prob) {
	            this._event.probability = prob;
	        }
	    });
	    /**
		 *  Muting the Loop means that no callbacks are invoked.
		 *  @memberOf Tone.Loop#
		 *  @type {Boolean}
		 *  @name mute
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'mute', {
	        get: function () {
	            return this._event.mute;
	        },
	        set: function (mute) {
	            this._event.mute = mute;
	        }
	    });
	    /**
		 *  The number of iterations of the loop. The default
		 *  value is Infinity (loop forever).
		 *  @memberOf Tone.Loop#
		 *  @type {Positive}
		 *  @name iterations
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'iterations', {
	        get: function () {
	            if (this._event.loop === true) {
	                return Infinity;
	            } else {
	                return this._event.loop;
	            }
	        },
	        set: function (iters) {
	            if (iters === Infinity) {
	                this._event.loop = true;
	            } else {
	                this._event.loop = iters;
	            }
	        }
	    });
	    /**
		 *  Clean up
		 *  @return  {Tone.Loop}  this
		 */
	    Tone.Loop.prototype.dispose = function () {
	        this._event.dispose();
	        this._event = null;
	        this.callback = null;
	    };
	    return Tone.Loop;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Part is a collection Tone.Events which can be
		 *         started/stopped and looped as a single unit.
		 *
		 *  @extends {Tone.Event}
		 *  @param {Function} callback The callback to invoke on each event
		 *  @param {Array} events the array of events
		 *  @example
		 * var part = new Tone.Part(function(time, note){
		 * 	//the notes given as the second element in the array
		 * 	//will be passed in as the second argument
		 * 	synth.triggerAttackRelease(note, "8n", time);
		 * }, [[0, "C2"], ["0:2", "C3"], ["0:3:2", "G2"]]);
		 *  @example
		 * //use an array of objects as long as the object has a "time" attribute
		 * var part = new Tone.Part(function(time, value){
		 * 	//the value is an object which contains both the note and the velocity
		 * 	synth.triggerAttackRelease(value.note, "8n", time, value.velocity);
		 * }, [{"time" : 0, "note" : "C3", "velocity": 0.9}, 
		 * 	   {"time" : "0:2", "note" : "C4", "velocity": 0.5}
		 * ]).start(0);
		 */
	    Tone.Part = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'events'
	        ], Tone.Part);
	        Tone.Event.call(this, options);
	        /**
			 *  An array of Objects. 
			 *  @type  {Array}
			 *  @private
			 */
	        this._events = [];
	        //add the events
	        for (var i = 0; i < options.events.length; i++) {
	            if (Array.isArray(options.events[i])) {
	                this.add(options.events[i][0], options.events[i][1]);
	            } else {
	                this.add(options.events[i]);
	            }
	        }
	    };
	    Tone.extend(Tone.Part, Tone.Event);
	    /**
		 *  The default values
		 *  @type  {Object}
		 *  @const
		 */
	    Tone.Part.defaults = {
	        'callback': Tone.noOp,
	        'loop': false,
	        'loopEnd': '1m',
	        'loopStart': 0,
	        'playbackRate': 1,
	        'probability': 1,
	        'humanize': false,
	        'mute': false,
	        'events': []
	    };
	    /**
		 *  Start the part at the given time. 
		 *  @param  {TransportTime}  time    When to start the part.
		 *  @param  {Time=}  offset  The offset from the start of the part
		 *                           to begin playing at.
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.start = function (time, offset) {
	        var ticks = this.toTicks(time);
	        if (this._state.getValueAtTime(ticks) !== Tone.State.Started) {
	            if (this._loop) {
	                offset = Tone.defaultArg(offset, this._loopStart);
	            } else {
	                offset = Tone.defaultArg(offset, 0);
	            }
	            offset = this.toTicks(offset);
	            this._state.add({
	                'state': Tone.State.Started,
	                'time': ticks,
	                'offset': offset
	            });
	            this._forEach(function (event) {
	                this._startNote(event, ticks, offset);
	            });
	        }
	        return this;
	    };
	    /**
		 *  Start the event in the given event at the correct time given
		 *  the ticks and offset and looping.
		 *  @param  {Tone.Event}  event 
		 *  @param  {Ticks}  ticks
		 *  @param  {Ticks}  offset
		 *  @private
		 */
	    Tone.Part.prototype._startNote = function (event, ticks, offset) {
	        ticks -= offset;
	        if (this._loop) {
	            if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {
	                if (event.startOffset < offset) {
	                    //start it on the next loop
	                    ticks += this._getLoopDuration();
	                }
	                event.start(Tone.TransportTime(ticks, 'i'));
	            } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {
	                event.loop = false;
	                event.start(Tone.TransportTime(ticks, 'i'));
	            }
	        } else {
	            if (event.startOffset >= offset) {
	                event.start(Tone.TransportTime(ticks, 'i'));
	            }
	        }
	    };
	    /**
		 *  The start from the scheduled start time
		 *  @type {Ticks}
		 *  @memberOf Tone.Part#
		 *  @name startOffset
		 *  @private
		 */
	    Object.defineProperty(Tone.Part.prototype, 'startOffset', {
	        get: function () {
	            return this._startOffset;
	        },
	        set: function (offset) {
	            this._startOffset = offset;
	            this._forEach(function (event) {
	                event.startOffset += this._startOffset;
	            });
	        }
	    });
	    /**
		 *  Stop the part at the given time.
		 *  @param  {TimelinePosition}  time  When to stop the part.
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.stop = function (time) {
	        var ticks = this.toTicks(time);
	        this._state.cancel(ticks);
	        this._state.setStateAtTime(Tone.State.Stopped, ticks);
	        this._forEach(function (event) {
	            event.stop(time);
	        });
	        return this;
	    };
	    /**
		 *  Get/Set an Event's value at the given time. 
		 *  If a value is passed in and no event exists at
		 *  the given time, one will be created with that value. 
		 *  If two events are at the same time, the first one will
		 *  be returned.
		 *  @example
		 * part.at("1m"); //returns the part at the first measure
		 *
		 * part.at("2m", "C2"); //set the value at "2m" to C2. 
		 * //if an event didn't exist at that time, it will be created.
		 *  @param {TransportTime} time The time of the event to get or set.
		 *  @param {*=} value If a value is passed in, the value of the
		 *                    event at the given time will be set to it.
		 *  @return {Tone.Event} the event at the time
		 */
	    Tone.Part.prototype.at = function (time, value) {
	        time = Tone.TransportTime(time);
	        var tickTime = Tone.Time(1, 'i').toSeconds();
	        for (var i = 0; i < this._events.length; i++) {
	            var event = this._events[i];
	            if (Math.abs(time.toTicks() - event.startOffset) < tickTime) {
	                if (!Tone.isUndef(value)) {
	                    event.value = value;
	                }
	                return event;
	            }
	        }
	        //if there was no event at that time, create one
	        if (!Tone.isUndef(value)) {
	            this.add(time, value);
	            //return the new event
	            return this._events[this._events.length - 1];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Add a an event to the part. 
		 *  @param {Time} time The time the note should start.
		 *                            If an object is passed in, it should
		 *                            have a 'time' attribute and the rest
		 *                            of the object will be used as the 'value'.
		 *  @param  {Tone.Event|*}  value 
		 *  @returns {Tone.Part} this
		 *  @example
		 * part.add("1m", "C#+11");
		 */
	    Tone.Part.prototype.add = function (time, value) {
	        //extract the parameters
	        if (time.hasOwnProperty('time')) {
	            value = time;
	            time = value.time;
	        }
	        time = this.toTicks(time);
	        var event;
	        if (value instanceof Tone.Event) {
	            event = value;
	            event.callback = this._tick.bind(this);
	        } else {
	            event = new Tone.Event({
	                'callback': this._tick.bind(this),
	                'value': value
	            });
	        }
	        //the start offset
	        event.startOffset = time;
	        //initialize the values
	        event.set({
	            'loopEnd': this.loopEnd,
	            'loopStart': this.loopStart,
	            'loop': this.loop,
	            'humanize': this.humanize,
	            'playbackRate': this.playbackRate,
	            'probability': this.probability
	        });
	        this._events.push(event);
	        //start the note if it should be played right now
	        this._restartEvent(event);
	        return this;
	    };
	    /**
		 *  Restart the given event
		 *  @param  {Tone.Event}  event 
		 *  @private
		 */
	    Tone.Part.prototype._restartEvent = function (event) {
	        this._state.forEach(function (stateEvent) {
	            if (stateEvent.state === Tone.State.Started) {
	                this._startNote(event, stateEvent.time, stateEvent.offset);
	            } else {
	                //stop the note
	                event.stop(Tone.TransportTime(stateEvent.time, 'i'));
	            }
	        }.bind(this));
	    };
	    /**
		 *  Remove an event from the part. Will recursively iterate
		 *  into nested parts to find the event.
		 *  @param {Time} time The time of the event
		 *  @param {*} value Optionally select only a specific event value
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.remove = function (time, value) {
	        //extract the parameters
	        if (time.hasOwnProperty('time')) {
	            value = time;
	            time = value.time;
	        }
	        time = this.toTicks(time);
	        for (var i = this._events.length - 1; i >= 0; i--) {
	            var event = this._events[i];
	            if (event instanceof Tone.Part) {
	                event.remove(time, value);
	            } else {
	                if (event.startOffset === time) {
	                    if (Tone.isUndef(value) || !Tone.isUndef(value) && event.value === value) {
	                        this._events.splice(i, 1);
	                        event.dispose();
	                    }
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Remove all of the notes from the group. 
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.removeAll = function () {
	        this._forEach(function (event) {
	            event.dispose();
	        });
	        this._events = [];
	        return this;
	    };
	    /**
		 *  Cancel scheduled state change events: i.e. "start" and "stop".
		 *  @param {TimelinePosition} after The time after which to cancel the scheduled events.
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.cancel = function (after) {
	        this._forEach(function (event) {
	            event.cancel(after);
	        });
	        this._state.cancel(this.toTicks(after));
	        return this;
	    };
	    /**
		 *  Iterate over all of the events
		 *  @param {Function} callback
		 *  @param {Object} ctx The context
		 *  @private
		 */
	    Tone.Part.prototype._forEach = function (callback, ctx) {
	        if (this._events) {
	            ctx = Tone.defaultArg(ctx, this);
	            for (var i = this._events.length - 1; i >= 0; i--) {
	                var e = this._events[i];
	                if (e instanceof Tone.Part) {
	                    e._forEach(callback, ctx);
	                } else {
	                    callback.call(ctx, e);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Set the attribute of all of the events
		 *  @param  {String}  attr  the attribute to set
		 *  @param  {*}  value      The value to set it to
		 *  @private
		 */
	    Tone.Part.prototype._setAll = function (attr, value) {
	        this._forEach(function (event) {
	            event[attr] = value;
	        });
	    };
	    /**
		 *  Internal tick method
		 *  @param  {Number}  time  The time of the event in seconds
		 *  @private
		 */
	    Tone.Part.prototype._tick = function (time, value) {
	        if (!this.mute) {
	            this.callback(time, value);
	        }
	    };
	    /**
		 *  Determine if the event should be currently looping
		 *  given the loop boundries of this Part.
		 *  @param  {Tone.Event}  event  The event to test
		 *  @private
		 */
	    Tone.Part.prototype._testLoopBoundries = function (event) {
	        if (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd) {
	            event.cancel(0);
	        } else {
	            //reschedule it if it's stopped
	            if (event.state === Tone.State.Stopped) {
	                this._restartEvent(event);
	            }
	        }
	    };
	    /**
		 *  The probability of the notes being triggered.
		 *  @memberOf Tone.Part#
		 *  @type {NormalRange}
		 *  @name probability
		 */
	    Object.defineProperty(Tone.Part.prototype, 'probability', {
	        get: function () {
	            return this._probability;
	        },
	        set: function (prob) {
	            this._probability = prob;
	            this._setAll('probability', prob);
	        }
	    });
	    /**
		 *  If set to true, will apply small random variation
		 *  to the callback time. If the value is given as a time, it will randomize
		 *  by that amount.
		 *  @example
		 * event.humanize = true;
		 *  @type {Boolean|Time}
		 *  @name humanize
		 */
	    Object.defineProperty(Tone.Part.prototype, 'humanize', {
	        get: function () {
	            return this._humanize;
	        },
	        set: function (variation) {
	            this._humanize = variation;
	            this._setAll('humanize', variation);
	        }
	    });
	    /**
		 *  If the part should loop or not
		 *  between Tone.Part.loopStart and 
		 *  Tone.Part.loopEnd. An integer
		 *  value corresponds to the number of
		 *  loops the Part does after it starts.
		 *  @memberOf Tone.Part#
		 *  @type {Boolean|Positive}
		 *  @name loop
		 *  @example
		 * //loop the part 8 times
		 * part.loop = 8;
		 */
	    Object.defineProperty(Tone.Part.prototype, 'loop', {
	        get: function () {
	            return this._loop;
	        },
	        set: function (loop) {
	            this._loop = loop;
	            this._forEach(function (event) {
	                event._loopStart = this._loopStart;
	                event._loopEnd = this._loopEnd;
	                event.loop = loop;
	                this._testLoopBoundries(event);
	            });
	        }
	    });
	    /**
		 *  The loopEnd point determines when it will 
		 *  loop if Tone.Part.loop is true.
		 *  @memberOf Tone.Part#
		 *  @type {TransportTime}
		 *  @name loopEnd
		 */
	    Object.defineProperty(Tone.Part.prototype, 'loopEnd', {
	        get: function () {
	            return Tone.TransportTime(this._loopEnd, 'i').toNotation();
	        },
	        set: function (loopEnd) {
	            this._loopEnd = this.toTicks(loopEnd);
	            if (this._loop) {
	                this._forEach(function (event) {
	                    event.loopEnd = loopEnd;
	                    this._testLoopBoundries(event);
	                });
	            }
	        }
	    });
	    /**
		 *  The loopStart point determines when it will 
		 *  loop if Tone.Part.loop is true.
		 *  @memberOf Tone.Part#
		 *  @type {TransportTime}
		 *  @name loopStart
		 */
	    Object.defineProperty(Tone.Part.prototype, 'loopStart', {
	        get: function () {
	            return Tone.TransportTime(this._loopStart, 'i').toNotation();
	        },
	        set: function (loopStart) {
	            this._loopStart = this.toTicks(loopStart);
	            if (this._loop) {
	                this._forEach(function (event) {
	                    event.loopStart = this.loopStart;
	                    this._testLoopBoundries(event);
	                });
	            }
	        }
	    });
	    /**
		 * 	The playback rate of the part
		 *  @memberOf Tone.Part#
		 *  @type {Positive}
		 *  @name playbackRate
		 */
	    Object.defineProperty(Tone.Part.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            this._setAll('playbackRate', rate);
	        }
	    });
	    /**
		 * 	The number of scheduled notes in the part. 
		 *  @memberOf Tone.Part#
		 *  @type {Positive}
		 *  @name length
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Part.prototype, 'length', {
	        get: function () {
	            return this._events.length;
	        }
	    });
	    /**
		 *  Clean up
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.dispose = function () {
	        this.removeAll();
	        this._state.dispose();
	        this._state = null;
	        this.callback = null;
	        this._events = null;
	        return this;
	    };
	    return Tone.Part;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Pattern arpeggiates between the given notes
		 *         in a number of patterns. See Tone.CtrlPattern for
		 *         a full list of patterns.
		 *  @example
		 * var pattern = new Tone.Pattern(function(time, note){
		 *   //the order of the notes passed in depends on the pattern
		 * }, ["C2", "D4", "E5", "A6"], "upDown");
		 *  @extends {Tone.Loop}
		 *  @param {Function} callback The callback to invoke with the
		 *                             event.
		 *  @param {Array} values The values to arpeggiate over.
		 */
	    Tone.Pattern = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'values',
	            'pattern'
	        ], Tone.Pattern);
	        Tone.Loop.call(this, options);
	        /**
			 *  The pattern manager
			 *  @type {Tone.CtrlPattern}
			 *  @private
			 */
	        this._pattern = new Tone.CtrlPattern({
	            'values': options.values,
	            'type': options.pattern,
	            'index': options.index
	        });
	    };
	    Tone.extend(Tone.Pattern, Tone.Loop);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Pattern.defaults = {
	        'pattern': Tone.CtrlPattern.Type.Up,
	        'callback': Tone.noOp,
	        'values': []
	    };
	    /**
		 *  Internal function called when the notes should be called
		 *  @param  {Number}  time  The time the event occurs
		 *  @private
		 */
	    Tone.Pattern.prototype._tick = function (time) {
	        this.callback(time, this._pattern.value);
	        this._pattern.next();
	    };
	    /**
		 *  The current index in the values array.
		 *  @memberOf Tone.Pattern#
		 *  @type {Positive}
		 *  @name index
		 */
	    Object.defineProperty(Tone.Pattern.prototype, 'index', {
	        get: function () {
	            return this._pattern.index;
	        },
	        set: function (i) {
	            this._pattern.index = i;
	        }
	    });
	    /**
		 *  The array of events.
		 *  @memberOf Tone.Pattern#
		 *  @type {Array}
		 *  @name values
		 */
	    Object.defineProperty(Tone.Pattern.prototype, 'values', {
	        get: function () {
	            return this._pattern.values;
	        },
	        set: function (vals) {
	            this._pattern.values = vals;
	        }
	    });
	    /**
		 *  The current value of the pattern.
		 *  @memberOf Tone.Pattern#
		 *  @type {*}
		 *  @name value
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Pattern.prototype, 'value', {
	        get: function () {
	            return this._pattern.value;
	        }
	    });
	    /**
		 *  The pattern type. See Tone.CtrlPattern for the full list of patterns.
		 *  @memberOf Tone.Pattern#
		 *  @type {String}
		 *  @name pattern
		 */
	    Object.defineProperty(Tone.Pattern.prototype, 'pattern', {
	        get: function () {
	            return this._pattern.type;
	        },
	        set: function (pattern) {
	            this._pattern.type = pattern;
	        }
	    });
	    /**
		 *  Clean up
		 *  @return  {Tone.Pattern}  this
		 */
	    Tone.Pattern.prototype.dispose = function () {
	        Tone.Loop.prototype.dispose.call(this);
	        this._pattern.dispose();
	        this._pattern = null;
	    };
	    return Tone.Pattern;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A sequence is an alternate notation of a part. Instead
		 *         of passing in an array of [time, event] pairs, pass
		 *         in an array of events which will be spaced at the
		 *         given subdivision. Sub-arrays will subdivide that beat
		 *         by the number of items are in the array. 
		 *         Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)
		 *  @param  {Function}  callback  The callback to invoke with every note
		 *  @param  {Array}    events  The sequence
		 *  @param  {Time} subdivision  The subdivision between which events are placed. 
		 *  @extends {Tone.Part}
		 *  @example
		 * var seq = new Tone.Sequence(function(time, note){
		 * 	console.log(note);
		 * //straight quater notes
		 * }, ["C4", "E4", "G4", "A4"], "4n");
		 *  @example
		 * var seq = new Tone.Sequence(function(time, note){
		 * 	console.log(note);
		 * //subdivisions are given as subarrays
		 * }, ["C4", ["E4", "D4", "E4"], "G4", ["A4", "G4"]]);
		 */
	    Tone.Sequence = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'events',
	            'subdivision'
	        ], Tone.Sequence);
	        //remove the events
	        var events = options.events;
	        delete options.events;
	        Tone.Part.call(this, options);
	        /**
			 *  The subdivison of each note
			 *  @type  {Ticks}
			 *  @private
			 */
	        this._subdivision = this.toTicks(options.subdivision);
	        //if no time was passed in, the loop end is the end of the cycle
	        if (Tone.isUndef(options.loopEnd) && !Tone.isUndef(events)) {
	            this._loopEnd = events.length * this._subdivision;
	        }
	        //defaults to looping
	        this._loop = true;
	        //add all of the events
	        if (!Tone.isUndef(events)) {
	            for (var i = 0; i < events.length; i++) {
	                this.add(i, events[i]);
	            }
	        }
	    };
	    Tone.extend(Tone.Sequence, Tone.Part);
	    /**
		 *  The default values.
		 *  @type  {Object}
		 */
	    Tone.Sequence.defaults = { 'subdivision': '4n' };
	    /**
		 *  The subdivision of the sequence. This can only be 
		 *  set in the constructor. The subdivision is the 
		 *  interval between successive steps. 
		 *  @type {Time}
		 *  @memberOf Tone.Sequence#
		 *  @name subdivision
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Sequence.prototype, 'subdivision', {
	        get: function () {
	            return Tone.Time(this._subdivision, 'i').toNotation();
	        }
	    });
	    /**
		 *  Get/Set an index of the sequence. If the index contains a subarray, 
		 *  a Tone.Sequence representing that sub-array will be returned. 
		 *  @example
		 * var sequence = new Tone.Sequence(playNote, ["E4", "C4", "F#4", ["A4", "Bb3"]])
		 * sequence.at(0)// => returns "E4"
		 * //set a value
		 * sequence.at(0, "G3");
		 * //get a nested sequence
		 * sequence.at(3).at(1)// => returns "Bb3"
		 * @param {Positive} index The index to get or set
		 * @param {*} value Optionally pass in the value to set at the given index.
		 */
	    Tone.Sequence.prototype.at = function (index, value) {
	        //if the value is an array, 
	        if (Tone.isArray(value)) {
	            //remove the current event at that index
	            this.remove(index);
	        }
	        //call the parent's method
	        return Tone.Part.prototype.at.call(this, this._indexTime(index), value);
	    };
	    /**
		 *  Add an event at an index, if there's already something
		 *  at that index, overwrite it. If `value` is an array, 
		 *  it will be parsed as a subsequence.
		 *  @param {Number} index The index to add the event to
		 *  @param {*} value The value to add at that index
		 *  @returns {Tone.Sequence} this
		 */
	    Tone.Sequence.prototype.add = function (index, value) {
	        if (value === null) {
	            return this;
	        }
	        if (Tone.isArray(value)) {
	            //make a subsequence and add that to the sequence
	            var subSubdivision = Math.round(this._subdivision / value.length);
	            value = new Tone.Sequence(this._tick.bind(this), value, Tone.Time(subSubdivision, 'i'));
	        }
	        Tone.Part.prototype.add.call(this, this._indexTime(index), value);
	        return this;
	    };
	    /**
		 *  Remove a value from the sequence by index
		 *  @param {Number} index The index of the event to remove
		 *  @returns {Tone.Sequence} this
		 */
	    Tone.Sequence.prototype.remove = function (index, value) {
	        Tone.Part.prototype.remove.call(this, this._indexTime(index), value);
	        return this;
	    };
	    /**
		 *  Get the time of the index given the Sequence's subdivision
		 *  @param  {Number}  index 
		 *  @return  {Time}  The time of that index
		 *  @private
		 */
	    Tone.Sequence.prototype._indexTime = function (index) {
	        if (index instanceof Tone.TransportTime) {
	            return index;
	        } else {
	            return Tone.TransportTime(index * this._subdivision + this.startOffset, 'i');
	        }
	    };
	    /**
		 *  Clean up.
		 *  @return {Tone.Sequence} this
		 */
	    Tone.Sequence.prototype.dispose = function () {
	        Tone.Part.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.Sequence;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.PulseOscillator is a pulse oscillator with control over pulse width,
		 *         also known as the duty cycle. At 50% duty cycle (width = 0.5) the wave is 
		 *         a square and only odd-numbered harmonics are present. At all other widths 
		 *         even-numbered harmonics are present. Read more 
		 *         [here](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).
		 *
		 *  @constructor
		 *  @extends {Tone.Source}
		 *  @param {Frequency} [frequency] The frequency of the oscillator
		 *  @param {NormalRange} [width] The width of the pulse
		 *  @example
		 * var pulse = new Tone.PulseOscillator("E5", 0.4).toMaster().start();
		 */
	    Tone.PulseOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'width'
	        ], Tone.Oscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The width of the pulse. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);
	        /**
			 *  gate the width amount
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._widthGate = new Tone.Gain();
	        /**
			 *  the sawtooth oscillator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._sawtooth = new Tone.Oscillator({
	            frequency: options.frequency,
	            detune: options.detune,
	            type: 'sawtooth',
	            phase: options.phase
	        });
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._sawtooth.frequency;
	        /**
			 *  The detune in cents. 
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this._sawtooth.detune;
	        /**
			 *  Threshold the signal to turn it into a square
			 *  @type {Tone.WaveShaper}
			 *  @private
			 */
	        this._thresh = new Tone.WaveShaper(function (val) {
	            if (val < 0) {
	                return -1;
	            } else {
	                return 1;
	            }
	        });
	        //connections
	        this._sawtooth.chain(this._thresh, this.output);
	        this.width.chain(this._widthGate, this._thresh);
	        this._readOnly([
	            'width',
	            'frequency',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.PulseOscillator, Tone.Source);
	    /**
		 *  The default parameters.
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.PulseOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'width': 0.2
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} time 
		 *  @private
		 */
	    Tone.PulseOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._sawtooth.start(time);
	        this._widthGate.gain.setValueAtTime(1, time);
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time 
		 *  @private
		 */
	    Tone.PulseOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._sawtooth.stop(time);
	        //the width is still connected to the output. 
	        //that needs to be stopped also
	        this._widthGate.gain.setValueAtTime(0, time);
	    };
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.PulseOscillator#
		 * @type {Degrees}
		 * @name phase
		 */
	    Object.defineProperty(Tone.PulseOscillator.prototype, 'phase', {
	        get: function () {
	            return this._sawtooth.phase;
	        },
	        set: function (phase) {
	            this._sawtooth.phase = phase;
	        }
	    });
	    /**
		 * The type of the oscillator. Always returns "pulse".
		 * @readOnly
		 * @memberOf Tone.PulseOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.PulseOscillator.prototype, 'type', {
	        get: function () {
	            return 'pulse';
	        }
	    });
	    /**
		 * The partials of the waveform. Cannot set partials for this waveform type
		 * @memberOf Tone.PulseOscillator#
		 * @type {Array}
		 * @name partials
		 * @private
		 */
	    Object.defineProperty(Tone.PulseOscillator.prototype, 'partials', {
	        get: function () {
	            return [];
	        }
	    });
	    /**
		 *  Clean up method.
		 *  @return {Tone.PulseOscillator} this
		 */
	    Tone.PulseOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._sawtooth.dispose();
	        this._sawtooth = null;
	        this._writable([
	            'width',
	            'frequency',
	            'detune'
	        ]);
	        this.width.dispose();
	        this.width = null;
	        this._widthGate.dispose();
	        this._widthGate = null;
	        this._thresh.dispose();
	        this._thresh = null;
	        this.frequency = null;
	        this.detune = null;
	        return this;
	    };
	    return Tone.PulseOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.PWMOscillator modulates the width of a Tone.PulseOscillator 
		 *         at the modulationFrequency. This has the effect of continuously
		 *         changing the timbre of the oscillator by altering the harmonics 
		 *         generated.
		 *
		 *  @extends {Tone.Source}
		 *  @constructor
		 *  @param {Frequency} frequency The starting frequency of the oscillator. 
		 *  @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse. 
		 *  @example
		 *  var pwm = new Tone.PWMOscillator("Ab3", 0.3).toMaster().start();
		 */
	    Tone.PWMOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'modulationFrequency'
	        ], Tone.PWMOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  the pulse oscillator
			 *  @type {Tone.PulseOscillator}
			 *  @private
			 */
	        this._pulse = new Tone.PulseOscillator(options.modulationFrequency);
	        //change the pulse oscillator type
	        this._pulse._sawtooth.type = 'sine';
	        /**
			 *  the modulator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._modulator = new Tone.Oscillator({
	            'frequency': options.frequency,
	            'detune': options.detune,
	            'phase': options.phase
	        });
	        /**
			 *  Scale the oscillator so it doesn't go silent 
			 *  at the extreme values.
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._scale = new Tone.Multiply(2);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._modulator.frequency;
	        /**
			 *  The detune of the oscillator.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this._modulator.detune;
	        /**
			 *  The modulation rate of the oscillator. 
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.modulationFrequency = this._pulse.frequency;
	        //connections
	        this._modulator.chain(this._scale, this._pulse.width);
	        this._pulse.connect(this.output);
	        this._readOnly([
	            'modulationFrequency',
	            'frequency',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.PWMOscillator, Tone.Source);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.PWMOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'modulationFrequency': 0.4
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now]
		 *  @private
		 */
	    Tone.PWMOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.start(time);
	        this._pulse.start(time);
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time (optional) timing parameter
		 *  @private
		 */
	    Tone.PWMOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.stop(time);
	        this._pulse.stop(time);
	    };
	    /**
		 * The type of the oscillator. Always returns "pwm".
		 * @readOnly
		 * @memberOf Tone.PWMOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.PWMOscillator.prototype, 'type', {
	        get: function () {
	            return 'pwm';
	        }
	    });
	    /**
		 * The partials of the waveform. Cannot set partials for this waveform type
		 * @memberOf Tone.PWMOscillator#
		 * @type {Array}
		 * @name partials
		 * @private
		 */
	    Object.defineProperty(Tone.PWMOscillator.prototype, 'partials', {
	        get: function () {
	            return [];
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.PWMOscillator#
		 * @type {number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.PWMOscillator.prototype, 'phase', {
	        get: function () {
	            return this._modulator.phase;
	        },
	        set: function (phase) {
	            this._modulator.phase = phase;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.PWMOscillator} this
		 */
	    Tone.PWMOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._pulse.dispose();
	        this._pulse = null;
	        this._scale.dispose();
	        this._scale = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this._writable([
	            'modulationFrequency',
	            'frequency',
	            'detune'
	        ]);
	        this.frequency = null;
	        this.detune = null;
	        this.modulationFrequency = null;
	        return this;
	    };
	    return Tone.PWMOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.FMOscillator 
		 *
		 *  @extends {Tone.Source}
		 *  @constructor
		 *  @param {Frequency} frequency The starting frequency of the oscillator. 
		 *  @param {String} type The type of the carrier oscillator.
		 *  @param {String} modulationType The type of the modulator oscillator.
		 *  @example
		 * //a sine oscillator frequency-modulated by a square wave
		 * var fmOsc = new Tone.FMOscillator("Ab3", "sine", "square").toMaster().start();
		 */
	    Tone.FMOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type',
	            'modulationType'
	        ], Tone.FMOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The carrier oscillator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._carrier = new Tone.Oscillator(options.frequency, options.type);
	        /**
			 *  The oscillator's frequency
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune control signal.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this._carrier.detune;
	        this.detune.value = options.detune;
	        /**
			 *  The modulation index which is in essence the depth or amount of the modulation. In other terms it is the 
			 *  ratio of the frequency of the modulating signal (mf) to the amplitude of the 
			 *  modulating signal (ma) -- as in ma/mf. 
			 *	@type {Positive}
			 *	@signal
			 */
	        this.modulationIndex = new Tone.Multiply(options.modulationIndex);
	        this.modulationIndex.units = Tone.Type.Positive;
	        /**
			 *  The modulating oscillator
			 *  @type  {Tone.Oscillator}
			 *  @private
			 */
	        this._modulator = new Tone.Oscillator(options.frequency, options.modulationType);
	        /**
			 *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. 
			 *  A harmonicity of 1 gives both oscillators the same frequency. 
			 *  Harmonicity = 2 means a change of an octave. 
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch the modulator an octave below carrier
			 * synth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        /**
			 *  the node where the modulation happens
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._modulationNode = new Tone.Gain(0);
	        //connections
	        this.frequency.connect(this._carrier.frequency);
	        this.frequency.chain(this.harmonicity, this._modulator.frequency);
	        this.frequency.chain(this.modulationIndex, this._modulationNode);
	        this._modulator.connect(this._modulationNode.gain);
	        this._modulationNode.connect(this._carrier.frequency);
	        this._carrier.connect(this.output);
	        this.detune.connect(this._modulator.detune);
	        this.phase = options.phase;
	        this._readOnly([
	            'modulationIndex',
	            'frequency',
	            'detune',
	            'harmonicity'
	        ]);
	    };
	    Tone.extend(Tone.FMOscillator, Tone.Source);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.FMOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'modulationIndex': 2,
	        'modulationType': 'square',
	        'harmonicity': 1
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now]
		 *  @private
		 */
	    Tone.FMOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.start(time);
	        this._carrier.start(time);
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time (optional) timing parameter
		 *  @private
		 */
	    Tone.FMOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.stop(time);
	        this._carrier.stop(time);
	    };
	    /**
		 * The type of the carrier oscillator
		 * @memberOf Tone.FMOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.FMOscillator.prototype, 'type', {
	        get: function () {
	            return this._carrier.type;
	        },
	        set: function (type) {
	            this._carrier.type = type;
	        }
	    });
	    /**
		 * The type of the modulator oscillator
		 * @memberOf Tone.FMOscillator#
		 * @type {String}
		 * @name modulationType
		 */
	    Object.defineProperty(Tone.FMOscillator.prototype, 'modulationType', {
	        get: function () {
	            return this._modulator.type;
	        },
	        set: function (type) {
	            this._modulator.type = type;
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.FMOscillator#
		 * @type {number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.FMOscillator.prototype, 'phase', {
	        get: function () {
	            return this._carrier.phase;
	        },
	        set: function (phase) {
	            this._carrier.phase = phase;
	            this._modulator.phase = phase;
	        }
	    });
	    /**
		 * The partials of the carrier waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * @memberOf Tone.FMOscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.FMOscillator.prototype, 'partials', {
	        get: function () {
	            return this._carrier.partials;
	        },
	        set: function (partials) {
	            this._carrier.partials = partials;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.FMOscillator} this
		 */
	    Tone.FMOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._writable([
	            'modulationIndex',
	            'frequency',
	            'detune',
	            'harmonicity'
	        ]);
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this._carrier.dispose();
	        this._carrier = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this._modulationNode.dispose();
	        this._modulationNode = null;
	        this.modulationIndex.dispose();
	        this.modulationIndex = null;
	        return this;
	    };
	    return Tone.FMOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.AMOscillator 
		 *
		 *  @extends {Tone.Oscillator}
		 *  @constructor
		 *  @param {Frequency} frequency The starting frequency of the oscillator. 
		 *  @param {String} type The type of the carrier oscillator.
		 *  @param {String} modulationType The type of the modulator oscillator.
		 *  @example
		 * //a sine oscillator frequency-modulated by a square wave
		 * var fmOsc = new Tone.AMOscillator("Ab3", "sine", "square").toMaster().start();
		 */
	    Tone.AMOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type',
	            'modulationType'
	        ], Tone.AMOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The carrier oscillator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._carrier = new Tone.Oscillator(options.frequency, options.type);
	        /**
			 *  The oscillator's frequency
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._carrier.frequency;
	        /**
			 *  The detune control signal.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this._carrier.detune;
	        this.detune.value = options.detune;
	        /**
			 *  The modulating oscillator
			 *  @type  {Tone.Oscillator}
			 *  @private
			 */
	        this._modulator = new Tone.Oscillator(options.frequency, options.modulationType);
	        /**
			 *  convert the -1,1 output to 0,1
			 *  @type {Tone.AudioToGain}
			 *  @private
			 */
	        this._modulationScale = new Tone.AudioToGain();
	        /**
			 *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. 
			 *  A harmonicity of 1 gives both oscillators the same frequency. 
			 *  Harmonicity = 2 means a change of an octave. 
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch the modulator an octave below carrier
			 * synth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        /**
			 *  the node where the modulation happens
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._modulationNode = new Tone.Gain(0);
	        //connections
	        this.frequency.chain(this.harmonicity, this._modulator.frequency);
	        this.detune.connect(this._modulator.detune);
	        this._modulator.chain(this._modulationScale, this._modulationNode.gain);
	        this._carrier.chain(this._modulationNode, this.output);
	        this.phase = options.phase;
	        this._readOnly([
	            'frequency',
	            'detune',
	            'harmonicity'
	        ]);
	    };
	    Tone.extend(Tone.AMOscillator, Tone.Oscillator);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.AMOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'modulationType': 'square',
	        'harmonicity': 1
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now]
		 *  @private
		 */
	    Tone.AMOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.start(time);
	        this._carrier.start(time);
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time (optional) timing parameter
		 *  @private
		 */
	    Tone.AMOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.stop(time);
	        this._carrier.stop(time);
	    };
	    /**
		 * The type of the carrier oscillator
		 * @memberOf Tone.AMOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.AMOscillator.prototype, 'type', {
	        get: function () {
	            return this._carrier.type;
	        },
	        set: function (type) {
	            this._carrier.type = type;
	        }
	    });
	    /**
		 * The type of the modulator oscillator
		 * @memberOf Tone.AMOscillator#
		 * @type {string}
		 * @name modulationType
		 */
	    Object.defineProperty(Tone.AMOscillator.prototype, 'modulationType', {
	        get: function () {
	            return this._modulator.type;
	        },
	        set: function (type) {
	            this._modulator.type = type;
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.AMOscillator#
		 * @type {number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.AMOscillator.prototype, 'phase', {
	        get: function () {
	            return this._carrier.phase;
	        },
	        set: function (phase) {
	            this._carrier.phase = phase;
	            this._modulator.phase = phase;
	        }
	    });
	    /**
		 * The partials of the carrier waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * @memberOf Tone.AMOscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.AMOscillator.prototype, 'partials', {
	        get: function () {
	            return this._carrier.partials;
	        },
	        set: function (partials) {
	            this._carrier.partials = partials;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.AMOscillator} this
		 */
	    Tone.AMOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'detune',
	            'harmonicity'
	        ]);
	        this.frequency = null;
	        this.detune = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this._carrier.dispose();
	        this._carrier = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this._modulationNode.dispose();
	        this._modulationNode = null;
	        this._modulationScale.dispose();
	        this._modulationScale = null;
	        return this;
	    };
	    return Tone.AMOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.FatOscillator 
		 *
		 *  @extends {Tone.Source}
		 *  @constructor
		 *  @param {Frequency} frequency The starting frequency of the oscillator. 
		 *  @param {String} type The type of the carrier oscillator.
		 *  @param {String} modulationType The type of the modulator oscillator.
		 *  @example
		 * //a sine oscillator frequency-modulated by a square wave
		 * var fmOsc = new Tone.FatOscillator("Ab3", "sine", "square").toMaster().start();
		 */
	    Tone.FatOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type',
	            'spread'
	        ], Tone.FatOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The oscillator's frequency
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune control signal.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  The array of oscillators
			 *  @type {Array}
			 *  @private
			 */
	        this._oscillators = [];
	        /**
			 *  The total spread of the oscillators
			 *  @type  {Cents}
			 *  @private
			 */
	        this._spread = options.spread;
	        /**
			 *  The type of the oscillator
			 *  @type {String}
			 *  @private
			 */
	        this._type = options.type;
	        /**
			 *  The phase of the oscillators
			 *  @type {Degrees}
			 *  @private
			 */
	        this._phase = options.phase;
	        /**
			 *  The partials array
			 *  @type {Array}
			 *  @private
			 */
	        this._partials = Tone.defaultArg(options.partials, []);
	        //set the count initially
	        this.count = options.count;
	        this._readOnly([
	            'frequency',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.FatOscillator, Tone.Source);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.FatOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'spread': 20,
	        'count': 3,
	        'type': 'sawtooth'
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now]
		 *  @private
		 */
	    Tone.FatOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._forEach(function (osc) {
	            osc.start(time);
	        });
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time (optional) timing parameter
		 *  @private
		 */
	    Tone.FatOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._forEach(function (osc) {
	            osc.stop(time);
	        });
	    };
	    /**
		 *  Iterate over all of the oscillators
		 *  @param  {Function}  iterator  The iterator function
		 *  @private
		 */
	    Tone.FatOscillator.prototype._forEach = function (iterator) {
	        for (var i = 0; i < this._oscillators.length; i++) {
	            iterator.call(this, this._oscillators[i], i);
	        }
	    };
	    /**
		 * The type of the carrier oscillator
		 * @memberOf Tone.FatOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            this._type = type;
	            this._forEach(function (osc) {
	                osc.type = type;
	            });
	        }
	    });
	    /**
		 * The detune spread between the oscillators. If "count" is
		 * set to 3 oscillators and the "spread" is set to 40,
		 * the three oscillators would be detuned like this: [-20, 0, 20]
		 * for a total detune spread of 40 cents.
		 * @memberOf Tone.FatOscillator#
		 * @type {Cents}
		 * @name spread
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'spread', {
	        get: function () {
	            return this._spread;
	        },
	        set: function (spread) {
	            this._spread = spread;
	            if (this._oscillators.length > 1) {
	                var start = -spread / 2;
	                var step = spread / (this._oscillators.length - 1);
	                this._forEach(function (osc, i) {
	                    osc.detune.value = start + step * i;
	                });
	            }
	        }
	    });
	    /**
		 * The number of detuned oscillators
		 * @memberOf Tone.FatOscillator#
		 * @type {Number}
		 * @name count
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'count', {
	        get: function () {
	            return this._oscillators.length;
	        },
	        set: function (count) {
	            count = Math.max(count, 1);
	            if (this._oscillators.length !== count) {
	                // var partials = this.partials;
	                // var type = this.type;
	                //dispose the previous oscillators
	                this._forEach(function (osc) {
	                    osc.dispose();
	                });
	                this._oscillators = [];
	                for (var i = 0; i < count; i++) {
	                    var osc = new Tone.Oscillator();
	                    if (this.type === Tone.Oscillator.Type.Custom) {
	                        osc.partials = this._partials;
	                    } else {
	                        osc.type = this._type;
	                    }
	                    osc.phase = this._phase;
	                    osc.volume.value = -6 - count;
	                    this.frequency.connect(osc.frequency);
	                    this.detune.connect(osc.detune);
	                    osc.connect(this.output);
	                    this._oscillators[i] = osc;
	                }
	                //set the spread
	                this.spread = this._spread;
	                if (this.state === Tone.State.Started) {
	                    this._forEach(function (osc) {
	                        osc.start();
	                    });
	                }
	            }
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.FatOscillator#
		 * @type {Number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'phase', {
	        get: function () {
	            return this._phase;
	        },
	        set: function (phase) {
	            this._phase = phase;
	            this._forEach(function (osc) {
	                osc.phase = phase;
	            });
	        }
	    });
	    /**
		 * The partials of the carrier waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * @memberOf Tone.FatOscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'partials', {
	        get: function () {
	            return this._partials;
	        },
	        set: function (partials) {
	            this._partials = partials;
	            this._type = Tone.Oscillator.Type.Custom;
	            this._forEach(function (osc) {
	                osc.partials = partials;
	            });
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.FatOscillator} this
		 */
	    Tone.FatOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'detune'
	        ]);
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune.dispose();
	        this.detune = null;
	        this._forEach(function (osc) {
	            osc.dispose();
	        });
	        this._oscillators = null;
	        this._partials = null;
	        return this;
	    };
	    return Tone.FatOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,
		 *         Tone.PWMOscillator, Tone.FMOscillator, Tone.AMOscillator, and Tone.FatOscillator
		 *         into one class. The oscillator class can be changed by setting the `type`. 
		 *         `omniOsc.type = "pwm"` will set it to the Tone.PWMOscillator. Prefixing
		 *         any of the basic types ("sine", "square4", etc.) with "fm", "am", or "fat"
		 *         will use the FMOscillator, AMOscillator or FatOscillator respectively. 
		 *         For example: `omniOsc.type = "fatsawtooth"` will create set the oscillator
		 *         to a FatOscillator of type "sawtooth". 
		 *
		 *  @extends {Tone.Source}
		 *  @constructor
		 *  @param {Frequency} frequency The initial frequency of the oscillator.
		 *  @param {String} type The type of the oscillator.
		 *  @example
		 *  var omniOsc = new Tone.OmniOscillator("C#4", "pwm");
		 */
	    Tone.OmniOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type'
	        ], Tone.OmniOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune control
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  the type of the oscillator source
			 *  @type {String}
			 *  @private
			 */
	        this._sourceType = undefined;
	        /**
			 *  the oscillator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._oscillator = null;
	        //set the oscillator
	        this.type = options.type;
	        this._readOnly([
	            'frequency',
	            'detune'
	        ]);
	        //set the options
	        this.set(options);
	    };
	    Tone.extend(Tone.OmniOscillator, Tone.Source);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.OmniOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'type': 'sine',
	        'phase': 0
	    };
	    /**
		 *  @enum {String}
		 *  @private
		 */
	    var OmniOscType = {
	        Pulse: 'PulseOscillator',
	        PWM: 'PWMOscillator',
	        Osc: 'Oscillator',
	        FM: 'FMOscillator',
	        AM: 'AMOscillator',
	        Fat: 'FatOscillator'
	    };
	    /**
		 *  start the oscillator
		 *  @param {Time} [time=now] the time to start the oscillator
		 *  @private
		 */
	    Tone.OmniOscillator.prototype._start = function (time) {
	        this._oscillator.start(time);
	    };
	    /**
		 *  start the oscillator
		 *  @param {Time} [time=now] the time to start the oscillator
		 *  @private
		 */
	    Tone.OmniOscillator.prototype._stop = function (time) {
	        this._oscillator.stop(time);
	    };
	    /**
		 * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or
		 * prefix the basic types with "fm", "am", or "fat" to use the FMOscillator, AMOscillator or FatOscillator
		 * types. The oscillator could also be set to "pwm" or "pulse". All of the parameters of the
		 * oscillator's class are accessible when the oscillator is set to that type, but throws an error 
		 * when it's not.
		 * 
		 * @memberOf Tone.OmniOscillator#
		 * @type {String}
		 * @name type
		 * @example
		 * omniOsc.type = "pwm";
		 * //modulationFrequency is parameter which is available
		 * //only when the type is "pwm". 
		 * omniOsc.modulationFrequency.value = 0.5;
		 * @example
		 * //an square wave frequency modulated by a sawtooth
		 * omniOsc.type = "fmsquare";
		 * omniOsc.modulationType = "sawtooth";
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'type', {
	        get: function () {
	            var prefix = '';
	            if (this._sourceType === OmniOscType.FM) {
	                prefix = 'fm';
	            } else if (this._sourceType === OmniOscType.AM) {
	                prefix = 'am';
	            } else if (this._sourceType === OmniOscType.Fat) {
	                prefix = 'fat';
	            }
	            return prefix + this._oscillator.type;
	        },
	        set: function (type) {
	            if (type.substr(0, 2) === 'fm') {
	                this._createNewOscillator(OmniOscType.FM);
	                this._oscillator.type = type.substr(2);
	            } else if (type.substr(0, 2) === 'am') {
	                this._createNewOscillator(OmniOscType.AM);
	                this._oscillator.type = type.substr(2);
	            } else if (type.substr(0, 3) === 'fat') {
	                this._createNewOscillator(OmniOscType.Fat);
	                this._oscillator.type = type.substr(3);
	            } else if (type === 'pwm') {
	                this._createNewOscillator(OmniOscType.PWM);
	            } else if (type === 'pulse') {
	                this._createNewOscillator(OmniOscType.Pulse);
	            } else {
	                this._createNewOscillator(OmniOscType.Osc);
	                this._oscillator.type = type;
	            }
	        }
	    });
	    /**
		 * The partials of the waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * This is not available on "pwm" and "pulse" oscillator types.
		 * @memberOf Tone.OmniOscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'partials', {
	        get: function () {
	            return this._oscillator.partials;
	        },
	        set: function (partials) {
	            this._oscillator.partials = partials;
	        }
	    });
	    /**
		 *  Set a member/attribute of the oscillator. 
		 *  @param {Object|String} params
		 *  @param {number=} value
		 *  @param {Time=} rampTime
		 *  @returns {Tone.OmniOscillator} this
		 */
	    Tone.OmniOscillator.prototype.set = function (params, value) {
	        //make sure the type is set first
	        if (params === 'type') {
	            this.type = value;
	        } else if (Tone.isObject(params) && params.hasOwnProperty('type')) {
	            this.type = params.type;
	        }
	        //then set the rest
	        Tone.prototype.set.apply(this, arguments);
	        return this;
	    };
	    /**
		 *  connect the oscillator to the frequency and detune signals
		 *  @private
		 */
	    Tone.OmniOscillator.prototype._createNewOscillator = function (oscType) {
	        if (oscType !== this._sourceType) {
	            this._sourceType = oscType;
	            var OscillatorConstructor = Tone[oscType];
	            //short delay to avoid clicks on the change
	            var now = this.now();
	            if (this._oscillator !== null) {
	                var oldOsc = this._oscillator;
	                oldOsc.stop(now);
	                //dispose the old one
	                this.context.setTimeout(function () {
	                    oldOsc.dispose();
	                    oldOsc = null;
	                }, this.blockTime);
	            }
	            this._oscillator = new OscillatorConstructor();
	            this.frequency.connect(this._oscillator.frequency);
	            this.detune.connect(this._oscillator.detune);
	            this._oscillator.connect(this.output);
	            if (this.state === Tone.State.Started) {
	                this._oscillator.start(now);
	            }
	        }
	    };
	    /**
		 * The phase of the oscillator in degrees. 
		 * @memberOf Tone.OmniOscillator#
		 * @type {Degrees}
		 * @name phase
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'phase', {
	        get: function () {
	            return this._oscillator.phase;
	        },
	        set: function (phase) {
	            this._oscillator.phase = phase;
	        }
	    });
	    /**
		 * The width of the oscillator (only if the oscillator is set to "pulse")
		 * @memberOf Tone.OmniOscillator#
		 * @type {NormalRange}
		 * @signal
		 * @name width
		 * @example
		 * var omniOsc = new Tone.OmniOscillator(440, "pulse");
		 * //can access the width attribute only if type === "pulse"
		 * omniOsc.width.value = 0.2; 
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'width', {
	        get: function () {
	            if (this._sourceType === OmniOscType.Pulse) {
	                return this._oscillator.width;
	            }
	        }
	    });
	    /**
		 * The number of detuned oscillators
		 * @memberOf Tone.OmniOscillator#
		 * @type {Number}
		 * @name count
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'count', {
	        get: function () {
	            if (this._sourceType === OmniOscType.Fat) {
	                return this._oscillator.count;
	            }
	        },
	        set: function (count) {
	            if (this._sourceType === OmniOscType.Fat) {
	                this._oscillator.count = count;
	            }
	        }
	    });
	    /**
		 * The detune spread between the oscillators. If "count" is
		 * set to 3 oscillators and the "spread" is set to 40,
		 * the three oscillators would be detuned like this: [-20, 0, 20]
		 * for a total detune spread of 40 cents. See Tone.FatOscillator
		 * for more info.
		 * @memberOf Tone.OmniOscillator#
		 * @type {Cents}
		 * @name spread
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'spread', {
	        get: function () {
	            if (this._sourceType === OmniOscType.Fat) {
	                return this._oscillator.spread;
	            }
	        },
	        set: function (spread) {
	            if (this._sourceType === OmniOscType.Fat) {
	                this._oscillator.spread = spread;
	            }
	        }
	    });
	    /**
		 * The type of the modulator oscillator. Only if the oscillator
		 * is set to "am" or "fm" types. see. Tone.AMOscillator or Tone.FMOscillator
		 * for more info. 
		 * @memberOf Tone.OmniOscillator#
		 * @type {String}
		 * @name modulationType
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationType', {
	        get: function () {
	            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {
	                return this._oscillator.modulationType;
	            }
	        },
	        set: function (mType) {
	            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {
	                this._oscillator.modulationType = mType;
	            }
	        }
	    });
	    /**
		 * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the 
		 * ratio of the frequency of the modulating signal (mf) to the amplitude of the 
		 * modulating signal (ma) -- as in ma/mf. 
		 * See Tone.FMOscillator for more info. 
		 * @type {Positive}
		 * @signal
		 * @name modulationIndex
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationIndex', {
	        get: function () {
	            if (this._sourceType === OmniOscType.FM) {
	                return this._oscillator.modulationIndex;
	            }
	        }
	    });
	    /**
		 *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. 
		 *  A harmonicity of 1 gives both oscillators the same frequency. 
		 *  Harmonicity = 2 means a change of an octave. See Tone.AMOscillator or Tone.FMOscillator
		 *  for more info. 
		 *  @memberOf Tone.OmniOscillator#
		 *  @signal
		 *  @type {Positive}
		 *  @name harmonicity
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'harmonicity', {
	        get: function () {
	            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {
	                return this._oscillator.harmonicity;
	            }
	        }
	    });
	    /**
		 * The modulationFrequency Signal of the oscillator 
		 * (only if the oscillator type is set to pwm). See 
		 * Tone.PWMOscillator for more info. 
		 * @memberOf Tone.OmniOscillator#
		 * @type {Frequency}
		 * @signal
		 * @name modulationFrequency
		 * @example
		 * var omniOsc = new Tone.OmniOscillator(440, "pwm");
		 * //can access the modulationFrequency attribute only if type === "pwm"
		 * omniOsc.modulationFrequency.value = 0.2; 
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationFrequency', {
	        get: function () {
	            if (this._sourceType === OmniOscType.PWM) {
	                return this._oscillator.modulationFrequency;
	            }
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.OmniOscillator} this
		 */
	    Tone.OmniOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'detune'
	        ]);
	        this.detune.dispose();
	        this.detune = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this._oscillator.dispose();
	        this._oscillator = null;
	        this._sourceType = null;
	        return this;
	    };
	    return Tone.OmniOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Base-class for all instruments
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 */
	    Tone.Instrument = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.Instrument.defaults);
	        Tone.AudioNode.call(this);
	        /**
			 *  The output and volume triming node
			 *  @type  {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 * The volume of the output in decibels.
			 * @type {Decibels}
			 * @signal
			 * @example
			 * source.volume.value = -6;
			 */
	        this.volume = this._volume.volume;
	        this._readOnly('volume');
	    };
	    Tone.extend(Tone.Instrument, Tone.AudioNode);
	    /**
		 *  the default attributes
		 *  @type {object}
		 */
	    Tone.Instrument.defaults = {
	        /** the volume of the output in decibels */
	        'volume': 0
	    };
	    /**
		 *  @abstract
		 *  @param {string|number} note the note to trigger
		 *  @param {Time} [time=now] the time to trigger the ntoe
		 *  @param {number} [velocity=1] the velocity to trigger the note
		 */
	    Tone.Instrument.prototype.triggerAttack = Tone.noOp;
	    /**
		 *  @abstract
		 *  @param {Time} [time=now] when to trigger the release
		 */
	    Tone.Instrument.prototype.triggerRelease = Tone.noOp;
	    /**
		 *  Trigger the attack and then the release after the duration.
		 *  @param  {Frequency} note     The note to trigger.
		 *  @param  {Time} duration How long the note should be held for before
		 *                          triggering the release. This value must be greater than 0.
		 *  @param {Time} [time=now]  When the note should be triggered.
		 *  @param  {NormalRange} [velocity=1] The velocity the note should be triggered at.
		 *  @returns {Tone.Instrument} this
		 *  @example
		 * //trigger "C4" for the duration of an 8th note
		 * synth.triggerAttackRelease("C4", "8n");
		 */
	    Tone.Instrument.prototype.triggerAttackRelease = function (note, duration, time, velocity) {
	        time = this.toSeconds(time);
	        duration = this.toSeconds(duration);
	        this.triggerAttack(note, time, velocity);
	        this.triggerRelease(time + duration);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.Instrument} this
		 */
	    Tone.Instrument.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._volume.dispose();
	        this._volume = null;
	        this._writable(['volume']);
	        this.volume = null;
	        return this;
	    };
	    return Tone.Instrument;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  This is an abstract base class for other monophonic instruments to 
		 *          extend. IMPORTANT: It does not make any sound on its own and
		 *          shouldn't be directly instantiated.
		 *
		 *  @constructor
		 *  @abstract
		 *  @extends {Tone.Instrument}
		 */
	    Tone.Monophonic = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.Monophonic.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  The glide time between notes. 
			 *  @type {Time}
			 */
	        this.portamento = options.portamento;
	    };
	    Tone.extend(Tone.Monophonic, Tone.Instrument);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Monophonic.defaults = { 'portamento': 0 };
	    /**
		 *  Trigger the attack of the note optionally with a given velocity. 
		 *  
		 *  
		 *  @param  {Frequency} note     The note to trigger.
		 *  @param  {Time} [time=now]     When the note should start.
		 *  @param  {number} [velocity=1] velocity The velocity scaler 
		 *                                determines how "loud" the note 
		 *                                will be triggered.
		 *  @returns {Tone.Monophonic} this
		 *  @example
		 * synth.triggerAttack("C4");
		 *  @example
		 * //trigger the note a half second from now at half velocity
		 * synth.triggerAttack("C4", "+0.5", 0.5);
		 */
	    Tone.Monophonic.prototype.triggerAttack = function (note, time, velocity) {
	        time = this.toSeconds(time);
	        this._triggerEnvelopeAttack(time, velocity);
	        this.setNote(note, time);
	        return this;
	    };
	    /**
		 *  Trigger the release portion of the envelope
		 *  @param  {Time} [time=now] If no time is given, the release happens immediatly
		 *  @returns {Tone.Monophonic} this
		 *  @example
		 * synth.triggerRelease();
		 */
	    Tone.Monophonic.prototype.triggerRelease = function (time) {
	        time = this.toSeconds(time);
	        this._triggerEnvelopeRelease(time);
	        return this;
	    };
	    /**
		 *  override this method with the actual method
		 *  @abstract
		 *  @private
		 */
	    Tone.Monophonic.prototype._triggerEnvelopeAttack = function () {
	    };
	    /**
		 *  override this method with the actual method
		 *  @abstract
		 *  @private
		 */
	    Tone.Monophonic.prototype._triggerEnvelopeRelease = function () {
	    };
	    /**
		 *  Set the note at the given time. If no time is given, the note
		 *  will set immediately. 
		 *  @param {Frequency} note The note to change to.
		 *  @param  {Time} [time=now] The time when the note should be set. 
		 *  @returns {Tone.Monophonic} this
		 * @example
		 * //change to F#6 in one quarter note from now.
		 * synth.setNote("F#6", "+4n");
		 * @example
		 * //change to Bb4 right now
		 * synth.setNote("Bb4");
		 */
	    Tone.Monophonic.prototype.setNote = function (note, time) {
	        time = this.toSeconds(time);
	        if (this.portamento > 0) {
	            var currentNote = this.frequency.value;
	            this.frequency.setValueAtTime(currentNote, time);
	            var portTime = this.toSeconds(this.portamento);
	            this.frequency.exponentialRampToValueAtTime(note, time + portTime);
	        } else {
	            this.frequency.setValueAtTime(note, time);
	        }
	        return this;
	    };
	    return Tone.Monophonic;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Synth is composed simply of a Tone.OmniOscillator
		 *          routed through a Tone.AmplitudeEnvelope. 
		 *          <img src="https://docs.google.com/drawings/d/1-1_0YW2Z1J2EPI36P8fNCMcZG7N1w1GZluPs4og4evo/pub?w=1163&h=231">
		 *
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 *  @example
		 * var synth = new Tone.Synth().toMaster();
		 * synth.triggerAttackRelease("C4", "8n");
		 */
	    Tone.Synth = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.Synth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  The oscillator.
			 *  @type {Tone.OmniOscillator}
			 */
	        this.oscillator = new Tone.OmniOscillator(options.oscillator);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this.oscillator.frequency;
	        /**
			 *  The detune control.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this.oscillator.detune;
	        /**
			 *  The amplitude envelope.
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
	        //connect the oscillators to the output
	        this.oscillator.chain(this.envelope, this.output);
	        //start the oscillators
	        this.oscillator.start();
	        this._readOnly([
	            'oscillator',
	            'frequency',
	            'detune',
	            'envelope'
	        ]);
	    };
	    Tone.extend(Tone.Synth, Tone.Monophonic);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Synth.defaults = {
	        'oscillator': { 'type': 'triangle' },
	        'envelope': {
	            'attack': 0.005,
	            'decay': 0.1,
	            'sustain': 0.3,
	            'release': 1
	        }
	    };
	    /**
		 *  start the attack portion of the envelope
		 *  @param {Time} [time=now] the time the attack should start
		 *  @param {number} [velocity=1] the velocity of the note (0-1)
		 *  @returns {Tone.Synth} this
		 *  @private
		 */
	    Tone.Synth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        return this;
	    };
	    /**
		 *  start the release portion of the envelope
		 *  @param {Time} [time=now] the time the release should start
		 *  @returns {Tone.Synth} this
		 *  @private
		 */
	    Tone.Synth.prototype._triggerEnvelopeRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.Synth} this
		 */
	    Tone.Synth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'oscillator',
	            'frequency',
	            'detune',
	            'envelope'
	        ]);
	        this.oscillator.dispose();
	        this.oscillator = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        this.frequency = null;
	        this.detune = null;
	        return this;
	    };
	    return Tone.Synth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  AMSynth uses the output of one Tone.Synth to modulate the
		 *          amplitude of another Tone.Synth. The harmonicity (the ratio between
		 *          the two signals) affects the timbre of the output signal greatly.
		 *          Read more about Amplitude Modulation Synthesis on
		 *          [SoundOnSound](https://web.archive.org/web/20160404103653/http://www.soundonsound.com:80/sos/mar00/articles/synthsecrets.htm).
		 *          <img src="https://docs.google.com/drawings/d/1TQu8Ed4iFr1YTLKpB3U1_hur-UwBrh5gdBXc8BxfGKw/pub?w=1009&h=457">
		 *
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth
		 *                            see defaults below
		 *  @example
		 * var synth = new Tone.AMSynth().toMaster();
		 * synth.triggerAttackRelease("C4", "4n");
		 */
	    Tone.AMSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.AMSynth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  The carrier voice.
			 *  @type {Tone.Synth}
			 *  @private
			 */
	        this._carrier = new Tone.Synth();
	        this._carrier.volume.value = -10;
	        /**
			 *  The carrier's oscillator
			 *  @type {Tone.Oscillator}
			 */
	        this.oscillator = this._carrier.oscillator;
	        /**
			 *  The carrier's envelope
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = this._carrier.envelope.set(options.envelope);
	        /**
			 *  The modulator voice.
			 *  @type {Tone.Synth}
			 *  @private
			 */
	        this._modulator = new Tone.Synth();
	        this._modulator.volume.value = -10;
	        /**
			 *  The modulator's oscillator which is applied
			 *  to the amplitude of the oscillator
			 *  @type {Tone.Oscillator}
			 */
	        this.modulation = this._modulator.oscillator.set(options.modulation);
	        /**
			 *  The modulator's envelope
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.modulationEnvelope = this._modulator.envelope.set(options.modulationEnvelope);
	        /**
			 *  The frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
	        /**
			 *  The detune in cents
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  Harmonicity is the ratio between the two voices. A harmonicity of
			 *  1 is no change. Harmonicity = 2 means a change of an octave.
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch voice1 an octave below voice0
			 * synth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        /**
			 *  convert the -1,1 output to 0,1
			 *  @type {Tone.AudioToGain}
			 *  @private
			 */
	        this._modulationScale = new Tone.AudioToGain();
	        /**
			 *  the node where the modulation happens
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._modulationNode = new Tone.Gain();
	        //control the two voices frequency
	        this.frequency.connect(this._carrier.frequency);
	        this.frequency.chain(this.harmonicity, this._modulator.frequency);
	        this.detune.fan(this._carrier.detune, this._modulator.detune);
	        this._modulator.chain(this._modulationScale, this._modulationNode.gain);
	        this._carrier.chain(this._modulationNode, this.output);
	        this._readOnly([
	            'frequency',
	            'harmonicity',
	            'oscillator',
	            'envelope',
	            'modulation',
	            'modulationEnvelope',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.AMSynth, Tone.Monophonic);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.AMSynth.defaults = {
	        'harmonicity': 3,
	        'detune': 0,
	        'oscillator': { 'type': 'sine' },
	        'envelope': {
	            'attack': 0.01,
	            'decay': 0.01,
	            'sustain': 1,
	            'release': 0.5
	        },
	        'modulation': { 'type': 'square' },
	        'modulationEnvelope': {
	            'attack': 0.5,
	            'decay': 0,
	            'sustain': 1,
	            'release': 0.5
	        }
	    };
	    /**
		 *  trigger the attack portion of the note
		 *
		 *  @param  {Time} [time=now] the time the note will occur
		 *  @param {NormalRange} [velocity=1] the velocity of the note
		 *  @private
		 *  @returns {Tone.AMSynth} this
		 */
	    Tone.AMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        //the port glide
	        time = this.toSeconds(time);
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        this.modulationEnvelope.triggerAttack(time, velocity);
	        return this;
	    };
	    /**
		 *  trigger the release portion of the note
		 *
		 *  @param  {Time} [time=now] the time the note will release
		 *  @private
		 *  @returns {Tone.AMSynth} this
		 */
	    Tone.AMSynth.prototype._triggerEnvelopeRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        this.modulationEnvelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.AMSynth} this
		 */
	    Tone.AMSynth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'harmonicity',
	            'oscillator',
	            'envelope',
	            'modulation',
	            'modulationEnvelope',
	            'detune'
	        ]);
	        this._carrier.dispose();
	        this._carrier = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune.dispose();
	        this.detune = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this._modulationScale.dispose();
	        this._modulationScale = null;
	        this._modulationNode.dispose();
	        this._modulationNode = null;
	        this.oscillator = null;
	        this.envelope = null;
	        this.modulationEnvelope = null;
	        this.modulation = null;
	        return this;
	    };
	    return Tone.AMSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.MonoSynth is composed of one oscillator, one filter, and two envelopes.
		 *          The amplitude of the Tone.Oscillator and the cutoff frequency of the 
		 *          Tone.Filter are controlled by Tone.Envelopes. 
		 *          <img src="https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240">
		 *          
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 *  @example
		 * var synth = new Tone.MonoSynth({
		 * 	"oscillator" : {
		 * 		"type" : "square"
		 *  },
		 *  "envelope" : {
		 *  	"attack" : 0.1
		 *  }
		 * }).toMaster();
		 * synth.triggerAttackRelease("C4", "8n");
		 */
	    Tone.MonoSynth = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.MonoSynth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  The oscillator.
			 *  @type {Tone.OmniOscillator}
			 */
	        this.oscillator = new Tone.OmniOscillator(options.oscillator);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this.oscillator.frequency;
	        /**
			 *  The detune control.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this.oscillator.detune;
	        /**
			 *  The filter.
			 *  @type {Tone.Filter}
			 */
	        this.filter = new Tone.Filter(options.filter);
	        /**
			 *  The filter envelope.
			 *  @type {Tone.FrequencyEnvelope}
			 */
	        this.filterEnvelope = new Tone.FrequencyEnvelope(options.filterEnvelope);
	        /**
			 *  The amplitude envelope.
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
	        //connect the oscillators to the output
	        this.oscillator.chain(this.filter, this.envelope, this.output);
	        //start the oscillators
	        this.oscillator.start();
	        //connect the filter envelope
	        this.filterEnvelope.connect(this.filter.frequency);
	        this._readOnly([
	            'oscillator',
	            'frequency',
	            'detune',
	            'filter',
	            'filterEnvelope',
	            'envelope'
	        ]);
	    };
	    Tone.extend(Tone.MonoSynth, Tone.Monophonic);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MonoSynth.defaults = {
	        'frequency': 'C4',
	        'detune': 0,
	        'oscillator': { 'type': 'square' },
	        'filter': {
	            'Q': 6,
	            'type': 'lowpass',
	            'rolloff': -24
	        },
	        'envelope': {
	            'attack': 0.005,
	            'decay': 0.1,
	            'sustain': 0.9,
	            'release': 1
	        },
	        'filterEnvelope': {
	            'attack': 0.06,
	            'decay': 0.2,
	            'sustain': 0.5,
	            'release': 2,
	            'baseFrequency': 200,
	            'octaves': 7,
	            'exponent': 2
	        }
	    };
	    /**
		 *  start the attack portion of the envelope
		 *  @param {Time} [time=now] the time the attack should start
		 *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)
		 *  @returns {Tone.MonoSynth} this
		 *  @private
		 */
	    Tone.MonoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        this.filterEnvelope.triggerAttack(time);
	        return this;
	    };
	    /**
		 *  start the release portion of the envelope
		 *  @param {Time} [time=now] the time the release should start
		 *  @returns {Tone.MonoSynth} this
		 *  @private
		 */
	    Tone.MonoSynth.prototype._triggerEnvelopeRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        this.filterEnvelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.MonoSynth} this
		 */
	    Tone.MonoSynth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'oscillator',
	            'frequency',
	            'detune',
	            'filter',
	            'filterEnvelope',
	            'envelope'
	        ]);
	        this.oscillator.dispose();
	        this.oscillator = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        this.filterEnvelope.dispose();
	        this.filterEnvelope = null;
	        this.filter.dispose();
	        this.filter = null;
	        this.frequency = null;
	        this.detune = null;
	        return this;
	    };
	    return Tone.MonoSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.DuoSynth is a monophonic synth composed of two 
		 *          MonoSynths run in parallel with control over the 
		 *          frequency ratio between the two voices and vibrato effect.
		 *          <img src="https://docs.google.com/drawings/d/1bL4GXvfRMMlqS7XyBm9CjL9KJPSUKbcdBNpqOlkFLxk/pub?w=1012&h=448">
		 *
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 *  @example
		 * var duoSynth = new Tone.DuoSynth().toMaster();
		 * duoSynth.triggerAttackRelease("C4", "2n");
		 */
	    Tone.DuoSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.DuoSynth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  the first voice
			 *  @type {Tone.MonoSynth}
			 */
	        this.voice0 = new Tone.MonoSynth(options.voice0);
	        this.voice0.volume.value = -10;
	        /**
			 *  the second voice
			 *  @type {Tone.MonoSynth}
			 */
	        this.voice1 = new Tone.MonoSynth(options.voice1);
	        this.voice1.volume.value = -10;
	        /**
			 *  The vibrato LFO. 
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._vibrato = new Tone.LFO(options.vibratoRate, -50, 50);
	        this._vibrato.start();
	        /**
			 * the vibrato frequency
			 * @type {Frequency}
			 * @signal
			 */
	        this.vibratoRate = this._vibrato.frequency;
	        /**
			 *  the vibrato gain
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._vibratoGain = new Tone.Gain(options.vibratoAmount, Tone.Type.Positive);
	        /**
			 * The amount of vibrato
			 * @type {Positive}
			 * @signal
			 */
	        this.vibratoAmount = this._vibratoGain.gain;
	        /**
			 *  the frequency control
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
	        /**
			 *  Harmonicity is the ratio between the two voices. A harmonicity of
			 *  1 is no change. Harmonicity = 2 means a change of an octave. 
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch voice1 an octave below voice0
			 * duoSynth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        //control the two voices frequency
	        this.frequency.connect(this.voice0.frequency);
	        this.frequency.chain(this.harmonicity, this.voice1.frequency);
	        this._vibrato.connect(this._vibratoGain);
	        this._vibratoGain.fan(this.voice0.detune, this.voice1.detune);
	        this.voice0.connect(this.output);
	        this.voice1.connect(this.output);
	        this._readOnly([
	            'voice0',
	            'voice1',
	            'frequency',
	            'vibratoAmount',
	            'vibratoRate'
	        ]);
	    };
	    Tone.extend(Tone.DuoSynth, Tone.Monophonic);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.DuoSynth.defaults = {
	        'vibratoAmount': 0.5,
	        'vibratoRate': 5,
	        'harmonicity': 1.5,
	        'voice0': {
	            'volume': -10,
	            'portamento': 0,
	            'oscillator': { 'type': 'sine' },
	            'filterEnvelope': {
	                'attack': 0.01,
	                'decay': 0,
	                'sustain': 1,
	                'release': 0.5
	            },
	            'envelope': {
	                'attack': 0.01,
	                'decay': 0,
	                'sustain': 1,
	                'release': 0.5
	            }
	        },
	        'voice1': {
	            'volume': -10,
	            'portamento': 0,
	            'oscillator': { 'type': 'sine' },
	            'filterEnvelope': {
	                'attack': 0.01,
	                'decay': 0,
	                'sustain': 1,
	                'release': 0.5
	            },
	            'envelope': {
	                'attack': 0.01,
	                'decay': 0,
	                'sustain': 1,
	                'release': 0.5
	            }
	        }
	    };
	    /**
		 *  start the attack portion of the envelopes
		 *  
		 *  @param {Time} [time=now] the time the attack should start
		 *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)
		 *  @returns {Tone.DuoSynth} this
		 *  @private
		 */
	    Tone.DuoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        time = this.toSeconds(time);
	        this.voice0.envelope.triggerAttack(time, velocity);
	        this.voice1.envelope.triggerAttack(time, velocity);
	        this.voice0.filterEnvelope.triggerAttack(time);
	        this.voice1.filterEnvelope.triggerAttack(time);
	        return this;
	    };
	    /**
		 *  start the release portion of the envelopes
		 *  
		 *  @param {Time} [time=now] the time the release should start
		 *  @returns {Tone.DuoSynth} this
		 *  @private
		 */
	    Tone.DuoSynth.prototype._triggerEnvelopeRelease = function (time) {
	        this.voice0.triggerRelease(time);
	        this.voice1.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.DuoSynth} this
		 */
	    Tone.DuoSynth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'voice0',
	            'voice1',
	            'frequency',
	            'vibratoAmount',
	            'vibratoRate'
	        ]);
	        this.voice0.dispose();
	        this.voice0 = null;
	        this.voice1.dispose();
	        this.voice1 = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this._vibratoGain.dispose();
	        this._vibratoGain = null;
	        this._vibrato = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this.vibratoAmount.dispose();
	        this.vibratoAmount = null;
	        this.vibratoRate = null;
	        return this;
	    };
	    return Tone.DuoSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  FMSynth is composed of two Tone.Synths where one Tone.Synth modulates
		 *          the frequency of a second Tone.Synth. A lot of spectral content 
		 *          can be explored using the modulationIndex parameter. Read more about
		 *          frequency modulation synthesis on Sound On Sound: [Part 1](https://web.archive.org/web/20160403123704/http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm), [Part 2](https://web.archive.org/web/20160403115835/http://www.soundonsound.com/sos/may00/articles/synth.htm).
		 *          <img src="https://docs.google.com/drawings/d/1h0PUDZXPgi4Ikx6bVT6oncrYPLluFKy7lj53puxj-DM/pub?w=902&h=462">
		 *
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth
		 *                          see defaults below
		 *  @example
		 * var fmSynth = new Tone.FMSynth().toMaster();
		 * fmSynth.triggerAttackRelease("C5", "4n");
		 */
	    Tone.FMSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.FMSynth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  The carrier voice.
			 *  @type {Tone.Synth}
			 *  @private
			 */
	        this._carrier = new Tone.Synth(options.carrier);
	        this._carrier.volume.value = -10;
	        /**
			 *  The carrier's oscillator
			 *  @type {Tone.Oscillator}
			 */
	        this.oscillator = this._carrier.oscillator;
	        /**
			 *  The carrier's envelope
			 *  @type {Tone.Oscillator}
			 */
	        this.envelope = this._carrier.envelope.set(options.envelope);
	        /**
			 *  The modulator voice.
			 *  @type {Tone.Synth}
			 *  @private
			 */
	        this._modulator = new Tone.Synth(options.modulator);
	        this._modulator.volume.value = -10;
	        /**
			 *  The modulator's oscillator which is applied
			 *  to the amplitude of the oscillator
			 *  @type {Tone.Oscillator}
			 */
	        this.modulation = this._modulator.oscillator.set(options.modulation);
	        /**
			 *  The modulator's envelope
			 *  @type {Tone.Oscillator}
			 */
	        this.modulationEnvelope = this._modulator.envelope.set(options.modulationEnvelope);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
	        /**
			 *  The detune in cents
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  Harmonicity is the ratio between the two voices. A harmonicity of
			 *  1 is no change. Harmonicity = 2 means a change of an octave.
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch voice1 an octave below voice0
			 * synth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        /**
			 *  The modulation index which essentially the depth or amount of the modulation. It is the
			 *  ratio of the frequency of the modulating signal (mf) to the amplitude of the
			 *  modulating signal (ma) -- as in ma/mf.
			 *	@type {Positive}
			 *	@signal
			 */
	        this.modulationIndex = new Tone.Multiply(options.modulationIndex);
	        this.modulationIndex.units = Tone.Type.Positive;
	        /**
			 *  the node where the modulation happens
			 *  @type {GainNode}
			 *  @private
			 */
	        this._modulationNode = new Tone.Gain(0);
	        //control the two voices frequency
	        this.frequency.connect(this._carrier.frequency);
	        this.frequency.chain(this.harmonicity, this._modulator.frequency);
	        this.frequency.chain(this.modulationIndex, this._modulationNode);
	        this.detune.fan(this._carrier.detune, this._modulator.detune);
	        this._modulator.connect(this._modulationNode.gain);
	        this._modulationNode.connect(this._carrier.frequency);
	        this._carrier.connect(this.output);
	        this._readOnly([
	            'frequency',
	            'harmonicity',
	            'modulationIndex',
	            'oscillator',
	            'envelope',
	            'modulation',
	            'modulationEnvelope',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.FMSynth, Tone.Monophonic);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.FMSynth.defaults = {
	        'harmonicity': 3,
	        'modulationIndex': 10,
	        'detune': 0,
	        'oscillator': { 'type': 'sine' },
	        'envelope': {
	            'attack': 0.01,
	            'decay': 0.01,
	            'sustain': 1,
	            'release': 0.5
	        },
	        'modulation': { 'type': 'square' },
	        'modulationEnvelope': {
	            'attack': 0.5,
	            'decay': 0,
	            'sustain': 1,
	            'release': 0.5
	        }
	    };
	    /**
		 * 	trigger the attack portion of the note
		 *
		 *  @param  {Time} [time=now] the time the note will occur
		 *  @param {number} [velocity=1] the velocity of the note
		 *  @returns {Tone.FMSynth} this
		 *  @private
		 */
	    Tone.FMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        time = this.toSeconds(time);
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        this.modulationEnvelope.triggerAttack(time);
	        return this;
	    };
	    /**
		 *  trigger the release portion of the note
		 *
		 *  @param  {Time} [time=now] the time the note will release
		 *  @returns {Tone.FMSynth} this
		 *  @private
		 */
	    Tone.FMSynth.prototype._triggerEnvelopeRelease = function (time) {
	        time = this.toSeconds(time);
	        this.envelope.triggerRelease(time);
	        this.modulationEnvelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.FMSynth} this
		 */
	    Tone.FMSynth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'harmonicity',
	            'modulationIndex',
	            'oscillator',
	            'envelope',
	            'modulation',
	            'modulationEnvelope',
	            'detune'
	        ]);
	        this._carrier.dispose();
	        this._carrier = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune.dispose();
	        this.detune = null;
	        this.modulationIndex.dispose();
	        this.modulationIndex = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this._modulationNode.dispose();
	        this._modulationNode = null;
	        this.oscillator = null;
	        this.envelope = null;
	        this.modulationEnvelope = null;
	        this.modulation = null;
	        return this;
	    };
	    return Tone.FMSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.MembraneSynth makes kick and tom sounds using a single oscillator
		 *          with an amplitude envelope and frequency ramp. A Tone.OmniOscillator
		 *          is routed through a Tone.AmplitudeEnvelope to the output. The drum
		 *          quality of the sound comes from the frequency envelope applied
		 *          during during Tone.MembraneSynth.triggerAttack(note). The frequency
		 *          envelope starts at <code>note * .octaves</code> and ramps to 
		 *          <code>note</code> over the duration of <code>.pitchDecay</code>. 
		 *
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 *  @example
		 * var synth = new Tone.MembraneSynth().toMaster();
		 * synth.triggerAttackRelease("C2", "8n");
		 */
	    Tone.MembraneSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.MembraneSynth.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  The oscillator.
			 *  @type {Tone.OmniOscillator}
			 */
	        this.oscillator = new Tone.OmniOscillator(options.oscillator).start();
	        /**
			 *  The amplitude envelope.
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
	        /**
			 *  The number of octaves the pitch envelope ramps.
			 *  @type {Positive}
			 */
	        this.octaves = options.octaves;
	        /**
			 *  The amount of time the frequency envelope takes. 
			 *  @type {Time}
			 */
	        this.pitchDecay = options.pitchDecay;
	        this.oscillator.chain(this.envelope, this.output);
	        this._readOnly([
	            'oscillator',
	            'envelope'
	        ]);
	    };
	    Tone.extend(Tone.MembraneSynth, Tone.Instrument);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MembraneSynth.defaults = {
	        'pitchDecay': 0.05,
	        'octaves': 10,
	        'oscillator': { 'type': 'sine' },
	        'envelope': {
	            'attack': 0.001,
	            'decay': 0.4,
	            'sustain': 0.01,
	            'release': 1.4,
	            'attackCurve': 'exponential'
	        }
	    };
	    /**
		 *  Trigger the note at the given time with the given velocity. 
		 *  
		 *  @param  {Frequency} note     the note
		 *  @param  {Time} [time=now]     the time, if not given is now
		 *  @param  {number} [velocity=1] velocity defaults to 1
		 *  @returns {Tone.MembraneSynth} this
		 *  @example
		 *  kick.triggerAttack(60);
		 */
	    Tone.MembraneSynth.prototype.triggerAttack = function (note, time, velocity) {
	        time = this.toSeconds(time);
	        note = this.toFrequency(note);
	        var maxNote = note * this.octaves;
	        this.oscillator.frequency.setValueAtTime(maxNote, time);
	        this.oscillator.frequency.exponentialRampToValueAtTime(note, time + this.toSeconds(this.pitchDecay));
	        this.envelope.triggerAttack(time, velocity);
	        return this;
	    };
	    /**
		 *  Trigger the release portion of the note.
		 *  
		 *  @param  {Time} [time=now] the time the note will release
		 *  @returns {Tone.MembraneSynth} this
		 */
	    Tone.MembraneSynth.prototype.triggerRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.MembraneSynth} this
		 */
	    Tone.MembraneSynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        this._writable([
	            'oscillator',
	            'envelope'
	        ]);
	        this.oscillator.dispose();
	        this.oscillator = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        return this;
	    };
	    return Tone.MembraneSynth;
	});
	Module(function (Tone) {
	    /**
		 *  Inharmonic ratio of frequencies based on the Roland TR-808
		 *  Taken from https://ccrma.stanford.edu/papers/tr-808-cymbal-physically-informed-circuit-bendable-digital-model
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var inharmRatios = [
	        1,
	        1.483,
	        1.932,
	        2.546,
	        2.63,
	        3.897
	    ];
	    /**
		 *  @class  A highly inharmonic and spectrally complex source with a highpass filter
		 *          and amplitude envelope which is good for making metalophone sounds. Based
		 *          on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).
		 *          Inspiration from [Sound on Sound](https://web.archive.org/web/20160610143924/https://www.soundonsound.com/sos/jul02/articles/synthsecrets0702.asp).
		 *
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {Object} [options] The options availble for the synth
		 *                             see defaults below
		 */
	    Tone.MetalSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.MetalSynth.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  The frequency of the cymbal
			 *  @type  {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The array of FMOscillators
			 *  @type  {Array}
			 *  @private
			 */
	        this._oscillators = [];
	        /**
			 *  The frequency multipliers
			 *  @type {Array}
			 *  @private
			 */
	        this._freqMultipliers = [];
	        /**
			 *  The amplitude for the body
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._amplitue = new Tone.Gain(0).connect(this.output);
	        /**
			 *  highpass the output
			 *  @type {Tone.Filter}
			 *  @private
			 */
	        this._highpass = new Tone.Filter({
	            'type': 'highpass',
	            'Q': -3.0102999566398125
	        }).connect(this._amplitue);
	        /**
			 *  The number of octaves the highpass
			 *  filter frequency ramps
			 *  @type {Number}
			 *  @private
			 */
	        this._octaves = options.octaves;
	        /**
			 *  Scale the body envelope
			 *  for the bandpass
			 *  @type {Tone.Scale}
			 *  @private
			 */
	        this._filterFreqScaler = new Tone.Scale(options.resonance, 7000);
	        /**
			 *  The envelope which is connected both to the
			 *  amplitude and highpass filter's cutoff frequency
			 *  @type  {Tone.Envelope}
			 */
	        this.envelope = new Tone.Envelope({
	            'attack': options.envelope.attack,
	            'attackCurve': 'linear',
	            'decay': options.envelope.decay,
	            'sustain': 0,
	            'release': options.envelope.release
	        }).chain(this._filterFreqScaler, this._highpass.frequency);
	        this.envelope.connect(this._amplitue.gain);
	        for (var i = 0; i < inharmRatios.length; i++) {
	            var osc = new Tone.FMOscillator({
	                'type': 'square',
	                'modulationType': 'square',
	                'harmonicity': options.harmonicity,
	                'modulationIndex': options.modulationIndex
	            });
	            osc.connect(this._highpass).start(0);
	            this._oscillators[i] = osc;
	            var mult = new Tone.Multiply(inharmRatios[i]);
	            this._freqMultipliers[i] = mult;
	            this.frequency.chain(mult, osc.frequency);
	        }
	        //set the octaves
	        this.octaves = options.octaves;
	    };
	    Tone.extend(Tone.MetalSynth, Tone.Instrument);
	    /**
		 *  default values
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.MetalSynth.defaults = {
	        'frequency': 200,
	        'envelope': {
	            'attack': 0.001,
	            'decay': 1.4,
	            'release': 0.2
	        },
	        'harmonicity': 5.1,
	        'modulationIndex': 32,
	        'resonance': 4000,
	        'octaves': 1.5
	    };
	    /**
		 *  Trigger the attack.
		 *  @param  {Time}  time      When the attack should be triggered.
		 *  @param  {NormalRange}  [velocity=1]  The velocity that the envelope should be triggered at.
		 *  @return  {Tone.MetalSynth}  this
		 */
	    Tone.MetalSynth.prototype.triggerAttack = function (time, vel) {
	        time = this.toSeconds(time);
	        vel = Tone.defaultArg(vel, 1);
	        this.envelope.triggerAttack(time, vel);
	        return this;
	    };
	    /**
		 *  Trigger the release of the envelope.
		 *  @param  {Time}  time      When the release should be triggered.
		 *  @return  {Tone.MetalSynth}  this
		 */
	    Tone.MetalSynth.prototype.triggerRelease = function (time) {
	        time = this.toSeconds(time);
	        this.envelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  Trigger the attack and release of the envelope after the given
		 *  duration.
		 *  @param  {Time}  duration  The duration before triggering the release
		 *  @param  {Time}  time      When the attack should be triggered.
		 *  @param  {NormalRange}  [velocity=1]  The velocity that the envelope should be triggered at.
		 *  @return  {Tone.MetalSynth}  this
		 */
	    Tone.MetalSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {
	        time = this.toSeconds(time);
	        duration = this.toSeconds(duration);
	        this.triggerAttack(time, velocity);
	        this.triggerRelease(time + duration);
	        return this;
	    };
	    /**
		 *  The modulationIndex of the oscillators which make up the source.
		 *  see Tone.FMOscillator.modulationIndex
		 *  @memberOf Tone.MetalSynth#
		 *  @type {Positive}
		 *  @name  modulationIndex
		 */
	    Object.defineProperty(Tone.MetalSynth.prototype, 'modulationIndex', {
	        get: function () {
	            return this._oscillators[0].modulationIndex.value;
	        },
	        set: function (val) {
	            for (var i = 0; i < this._oscillators.length; i++) {
	                this._oscillators[i].modulationIndex.value = val;
	            }
	        }
	    });
	    /**
		 *  The harmonicity of the oscillators which make up the source.
		 *  see Tone.FMOscillator.harmonicity
		 *  @memberOf Tone.MetalSynth#
		 *  @type {Positive}
		 *  @name  harmonicity
		 */
	    Object.defineProperty(Tone.MetalSynth.prototype, 'harmonicity', {
	        get: function () {
	            return this._oscillators[0].harmonicity.value;
	        },
	        set: function (val) {
	            for (var i = 0; i < this._oscillators.length; i++) {
	                this._oscillators[i].harmonicity.value = val;
	            }
	        }
	    });
	    /**
		 *  The frequency of the highpass filter attached to the envelope
		 *  @memberOf Tone.MetalSynth#
		 *  @type {Frequency}
		 *  @name  resonance
		 */
	    Object.defineProperty(Tone.MetalSynth.prototype, 'resonance', {
	        get: function () {
	            return this._filterFreqScaler.min;
	        },
	        set: function (val) {
	            this._filterFreqScaler.min = val;
	            this.octaves = this._octaves;
	        }
	    });
	    /**
		 *  The number of octaves above the "resonance" frequency
		 *  that the filter ramps during the attack/decay envelope
		 *  @memberOf Tone.MetalSynth#
		 *  @type {Number}
		 *  @name  octaves
		 */
	    Object.defineProperty(Tone.MetalSynth.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (octs) {
	            this._octaves = octs;
	            this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, octs);
	        }
	    });
	    /**
		 *  Clean up
		 *  @returns {Tone.MetalSynth} this
		 */
	    Tone.MetalSynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        for (var i = 0; i < this._oscillators.length; i++) {
	            this._oscillators[i].dispose();
	            this._freqMultipliers[i].dispose();
	        }
	        this._oscillators = null;
	        this._freqMultipliers = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this._filterFreqScaler.dispose();
	        this._filterFreqScaler = null;
	        this._amplitue.dispose();
	        this._amplitue = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        this._highpass.dispose();
	        this._highpass = null;
	    };
	    return Tone.MetalSynth;
	});
	Module(function (Tone) {
	    /**
		 *  BufferSource polyfill
		 */
	    if (window.AudioBufferSourceNode && !AudioBufferSourceNode.prototype.start) {
	        AudioBufferSourceNode.prototype.start = AudioBufferSourceNode.prototype.noteGrainOn;
	        AudioBufferSourceNode.prototype.stop = AudioBufferSourceNode.prototype.noteOff;
	    }
	    /**
		 *  @class Wrapper around the native BufferSourceNode.
		 *  @extends {Tone.AudioNode}
		 *  @param  {AudioBuffer|Tone.Buffer}  buffer   The buffer to play
		 *  @param  {Function}  onload  The callback to invoke when the
		 *                               buffer is done playing.
		 */
	    Tone.BufferSource = function () {
	        var options = Tone.defaults(arguments, [
	            'buffer',
	            'onload'
	        ], Tone.BufferSource);
	        Tone.AudioNode.call(this);
	        /**
			 *  The callback to invoke after the
			 *  buffer source is done playing.
			 *  @type  {Function}
			 */
	        this.onended = options.onended;
	        /**
			 *  The time that the buffer was started.
			 *  @type  {Number}
			 *  @private
			 */
	        this._startTime = -1;
	        /**
			 *  The time that the buffer is scheduled to stop.
			 *  @type  {Number}
			 *  @private
			 */
	        this._stopTime = -1;
	        /**
			 *  The gain node which envelopes the BufferSource
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._gainNode = this.output = new Tone.Gain();
	        /**
			 *  The buffer source
			 *  @type  {AudioBufferSourceNode}
			 *  @private
			 */
	        this._source = this.context.createBufferSource();
	        this._source.connect(this._gainNode);
	        /**
			 * The private buffer instance
			 * @type {Tone.Buffer}
			 * @private
			 */
	        this._buffer = new Tone.Buffer(options.buffer, options.onload);
	        /**
			 *  The playbackRate of the buffer
			 *  @type {Positive}
			 *  @signal
			 */
	        this.playbackRate = new Tone.Param(this._source.playbackRate, Tone.Type.Positive);
	        /**
			 *  The fadeIn time of the amplitude envelope.
			 *  @type {Time}
			 */
	        this.fadeIn = options.fadeIn;
	        /**
			 *  The fadeOut time of the amplitude envelope.
			 *  @type {Time}
			 */
	        this.fadeOut = options.fadeOut;
	        /**
			 *  The value that the buffer ramps to
			 *  @type {Gain}
			 *  @private
			 */
	        this._gain = 1;
	        /**
			 * The onended timeout
			 * @type {Number}
			 * @private
			 */
	        this._onendedTimeout = -1;
	        this.loop = options.loop;
	        this.loopStart = options.loopStart;
	        this.loopEnd = options.loopEnd;
	        this.playbackRate.value = options.playbackRate;
	    };
	    Tone.extend(Tone.BufferSource, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.BufferSource.defaults = {
	        'onended': Tone.noOp,
	        'onload': Tone.noOp,
	        'loop': false,
	        'loopStart': 0,
	        'loopEnd': 0,
	        'fadeIn': 0,
	        'fadeOut': 0,
	        'playbackRate': 1
	    };
	    /**
		 *  Returns the playback state of the source, either "started" or "stopped".
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.BufferSource#
		 *  @name state
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'state', {
	        get: function () {
	            var now = this.now();
	            if (this._startTime !== -1 && now >= this._startTime && now < this._stopTime) {
	                return Tone.State.Started;
	            } else {
	                return Tone.State.Stopped;
	            }
	        }
	    });
	    /**
		 *  Start the buffer
		 *  @param  {Time} [startTime=now] When the player should start.
		 *  @param  {Time} [offset=0] The offset from the beginning of the sample
		 *                                 to start at.
		 *  @param  {Time=} duration How long the sample should play. If no duration
		 *                                is given, it will default to the full length
		 *                                of the sample (minus any offset)
		 *  @param  {Gain}  [gain=1]  The gain to play the buffer back at.
		 *  @param  {Time=}  fadeInTime  The optional fadeIn ramp time.
		 *  @return  {Tone.BufferSource}  this
		 */
	    Tone.BufferSource.prototype.start = function (time, offset, duration, gain, fadeInTime) {
	        if (this._startTime !== -1) {
	            throw new Error('Tone.BufferSource can only be started once.');
	        }
	        if (this.buffer.loaded) {
	            time = this.toSeconds(time);
	            //if it's a loop the default offset is the loopstart point
	            if (this.loop) {
	                offset = Tone.defaultArg(offset, this.loopStart);
	            } else {
	                //otherwise the default offset is 0
	                offset = Tone.defaultArg(offset, 0);
	            }
	            offset = this.toSeconds(offset);
	            //the values in seconds
	            time = this.toSeconds(time);
	            gain = Tone.defaultArg(gain, 1);
	            this._gain = gain;
	            //the fadeIn time
	            if (Tone.isUndef(fadeInTime)) {
	                fadeInTime = this.toSeconds(this.fadeIn);
	            } else {
	                fadeInTime = this.toSeconds(fadeInTime);
	            }
	            if (fadeInTime > 0) {
	                this._gainNode.gain.setValueAtTime(0, time);
	                this._gainNode.gain.linearRampToValueAtTime(this._gain, time + fadeInTime);
	            } else {
	                this._gainNode.gain.setValueAtTime(gain, time);
	            }
	            this._startTime = time + fadeInTime;
	            var computedDur = Tone.defaultArg(duration, this.buffer.duration - offset);
	            computedDur = this.toSeconds(computedDur);
	            computedDur = Math.max(computedDur, 0);
	            if (!this.loop || this.loop && !Tone.isUndef(duration)) {
	                //clip the duration when not looping
	                if (!this.loop) {
	                    computedDur = Math.min(computedDur, this.buffer.duration - offset);
	                }
	                this.stop(time + computedDur + fadeInTime, this.fadeOut);
	            }
	            //start the buffer source
	            if (this.loop) {
	                //modify the offset if it's greater than the loop time
	                var loopEnd = this.loopEnd || this.buffer.duration;
	                var loopStart = this.loopStart;
	                var loopDuration = loopEnd - loopStart;
	                //move the offset back
	                if (offset > loopEnd) {
	                    offset = (offset - loopStart) % loopDuration + loopStart;
	                }
	            }
	            this._source.buffer = this.buffer.get();
	            this._source.loopEnd = this.loopEnd || this.buffer.duration;
	            this._source.start(time, offset);
	        } else {
	            throw new Error('Tone.BufferSource: buffer is either not set or not loaded.');
	        }
	        return this;
	    };
	    /**
		 *  Stop the buffer. Optionally add a ramp time to fade the
		 *  buffer out.
		 *  @param  {Time=}  time         The time the buffer should stop.
		 *  @param  {Time=}  fadeOutTime  How long the gain should fade out for
		 *  @return  {Tone.BufferSource}  this
		 */
	    Tone.BufferSource.prototype.stop = function (time, fadeOutTime) {
	        if (this.buffer.loaded) {
	            time = this.toSeconds(time);
	            //the fadeOut time
	            if (Tone.isUndef(fadeOutTime)) {
	                fadeOutTime = this.toSeconds(this.fadeOut);
	            } else {
	                fadeOutTime = this.toSeconds(fadeOutTime);
	            }
	            //only stop if the last stop was scheduled later
	            if (this._stopTime === -1 || this._stopTime > time) {
	                this._stopTime = time;
	                //cancel the end curve
	                this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);
	                time = Math.max(this._startTime, time);
	                //set a new one
	                if (fadeOutTime > 0) {
	                    var startFade = Math.max(this._startTime, time - fadeOutTime);
	                    this._gainNode.gain.setValueAtTime(this._gain, startFade);
	                    this._gainNode.gain.linearRampToValueAtTime(0, time);
	                } else {
	                    this._gainNode.gain.setValueAtTime(0, time);
	                }
	                Tone.context.clearTimeout(this._onendedTimeout);
	                this._onendedTimeout = Tone.context.setTimeout(this._onended.bind(this), this._stopTime - this.now());
	            }
	        } else {
	            throw new Error('Tone.BufferSource: buffer is either not set or not loaded.');
	        }
	        return this;
	    };
	    /**
		 *  Internal callback when the buffer is ended.
		 *  Invokes `onended` and disposes the node.
		 *  @private
		 */
	    Tone.BufferSource.prototype._onended = function () {
	        this.onended(this);
	    };
	    /**
		 * If loop is true, the loop will start at this position.
		 * @memberOf Tone.BufferSource#
		 * @type {Time}
		 * @name loopStart
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'loopStart', {
	        get: function () {
	            return this._source.loopStart;
	        },
	        set: function (loopStart) {
	            this._source.loopStart = this.toSeconds(loopStart);
	        }
	    });
	    /**
		 * If loop is true, the loop will end at this position.
		 * @memberOf Tone.BufferSource#
		 * @type {Time}
		 * @name loopEnd
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'loopEnd', {
	        get: function () {
	            return this._source.loopEnd;
	        },
	        set: function (loopEnd) {
	            this._source.loopEnd = this.toSeconds(loopEnd);
	        }
	    });
	    /**
		 * The audio buffer belonging to the player.
		 * @memberOf Tone.BufferSource#
		 * @type {Tone.Buffer}
		 * @name buffer
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'buffer', {
	        get: function () {
	            return this._buffer;
	        },
	        set: function (buffer) {
	            this._buffer.set(buffer);
	        }
	    });
	    /**
		 * If the buffer should loop once it's over.
		 * @memberOf Tone.BufferSource#
		 * @type {Boolean}
		 * @name loop
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'loop', {
	        get: function () {
	            return this._source.loop;
	        },
	        set: function (loop) {
	            this._source.loop = loop;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return  {Tone.BufferSource}  this
		 */
	    Tone.BufferSource.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.onended = null;
	        this._source.disconnect();
	        this._source = null;
	        this._gainNode.dispose();
	        this._gainNode = null;
	        this._buffer.dispose();
	        this._buffer = null;
	        this._startTime = -1;
	        this.playbackRate = null;
	        Tone.context.clearTimeout(this._onendedTimeout);
	        return this;
	    };
	    return Tone.BufferSource;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Noise is a noise generator. It uses looped noise buffers to save on performance.
		 *          Tone.Noise supports the noise types: "pink", "white", and "brown". Read more about
		 *          colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).
		 *
		 *  @constructor
		 *  @extends {Tone.Source}
		 *  @param {string} type the noise type (white|pink|brown)
		 *  @example
		 * //initialize the noise and start
		 * var noise = new Tone.Noise("pink").start();
		 * 
		 * //make an autofilter to shape the noise
		 * var autoFilter = new Tone.AutoFilter({
		 * 	"frequency" : "8m", 
		 * 	"min" : 800, 
		 * 	"max" : 15000
		 * }).connect(Tone.Master);
		 * 
		 * //connect the noise
		 * noise.connect(autoFilter);
		 * //start the autofilter LFO
		 * autoFilter.start()
		 */
	    Tone.Noise = function () {
	        var options = Tone.defaults(arguments, ['type'], Tone.Noise);
	        Tone.Source.call(this, options);
	        /**
			 *  @private
			 *  @type {AudioBufferSourceNode}
			 */
	        this._source = null;
	        /**
			 *  the buffer
			 *  @private
			 *  @type {AudioBuffer}
			 */
	        this._type = options.type;
	        /**
			 *  The playback rate of the noise. Affects
			 *  the "frequency" of the noise.
			 *  @type {Positive}
			 *  @signal
			 */
	        this._playbackRate = options.playbackRate;
	    };
	    Tone.extend(Tone.Noise, Tone.Source);
	    /**
		 *  the default parameters
		 *
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Noise.defaults = {
	        'type': 'white',
	        'playbackRate': 1
	    };
	    /**
		 * The type of the noise. Can be "white", "brown", or "pink". 
		 * @memberOf Tone.Noise#
		 * @type {string}
		 * @name type
		 * @example
		 * noise.type = "white";
		 */
	    Object.defineProperty(Tone.Noise.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            if (this._type !== type) {
	                if (type in _noiseBuffers) {
	                    this._type = type;
	                    //if it's playing, stop and restart it
	                    if (this.state === Tone.State.Started) {
	                        var now = this.now();
	                        this._stop(now);
	                        this._start(now);
	                    }
	                } else {
	                    throw new TypeError('Tone.Noise: invalid type: ' + type);
	                }
	            }
	        }
	    });
	    /**
		 *  The playback rate of the noise. Affects
		 *  the "frequency" of the noise.
		 *  @type {Positive}
		 *  @signal
		 */
	    Object.defineProperty(Tone.Noise.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            if (this._source) {
	                this._source.playbackRate.value = rate;
	            }
	        }
	    });
	    /**
		 *  internal start method
		 *
		 *  @param {Time} time
		 *  @private
		 */
	    Tone.Noise.prototype._start = function (time) {
	        var buffer = _noiseBuffers[this._type];
	        this._source = new Tone.BufferSource(buffer).connect(this.output);
	        this._source.loop = true;
	        this._source.playbackRate.value = this._playbackRate;
	        this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));
	    };
	    /**
		 *  internal stop method
		 *
		 *  @param {Time} time
		 *  @private
		 */
	    Tone.Noise.prototype._stop = function (time) {
	        if (this._source) {
	            this._source.stop(this.toSeconds(time));
	            this._source = null;
	        }
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Noise} this
		 */
	    Tone.Noise.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        if (this._source !== null) {
	            this._source.disconnect();
	            this._source = null;
	        }
	        this._buffer = null;
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    // THE BUFFERS
	    ///////////////////////////////////////////////////////////////////////////
	    //Noise buffer stats
	    var bufferLength = 44100 * 5;
	    var channels = 2;
	    /**
		 *	The noise arrays. Generated on initialization.
		 *  borrowed heavily from https://github.com/zacharydenton/noise.js 
		 *  (c) 2013 Zach Denton (MIT)
		 *  @static
		 *  @private
		 *  @type {Array}
		 */
	    var _noiseArrays = {
	        'pink': function () {
	            var buffer = [];
	            for (var channelNum = 0; channelNum < channels; channelNum++) {
	                var channel = new Float32Array(bufferLength);
	                buffer[channelNum] = channel;
	                var b0, b1, b2, b3, b4, b5, b6;
	                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;
	                for (var i = 0; i < bufferLength; i++) {
	                    var white = Math.random() * 2 - 1;
	                    b0 = 0.99886 * b0 + white * 0.0555179;
	                    b1 = 0.99332 * b1 + white * 0.0750759;
	                    b2 = 0.969 * b2 + white * 0.153852;
	                    b3 = 0.8665 * b3 + white * 0.3104856;
	                    b4 = 0.55 * b4 + white * 0.5329522;
	                    b5 = -0.7616 * b5 - white * 0.016898;
	                    channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
	                    channel[i] *= 0.11;
	                    // (roughly) compensate for gain
	                    b6 = white * 0.115926;
	                }
	            }
	            return buffer;
	        }(),
	        'brown': function () {
	            var buffer = [];
	            for (var channelNum = 0; channelNum < channels; channelNum++) {
	                var channel = new Float32Array(bufferLength);
	                buffer[channelNum] = channel;
	                var lastOut = 0;
	                for (var i = 0; i < bufferLength; i++) {
	                    var white = Math.random() * 2 - 1;
	                    channel[i] = (lastOut + 0.02 * white) / 1.02;
	                    lastOut = channel[i];
	                    channel[i] *= 3.5;    // (roughly) compensate for gain
	                }
	            }
	            return buffer;
	        }(),
	        'white': function () {
	            var buffer = [];
	            for (var channelNum = 0; channelNum < channels; channelNum++) {
	                var channel = new Float32Array(bufferLength);
	                buffer[channelNum] = channel;
	                for (var i = 0; i < bufferLength; i++) {
	                    channel[i] = Math.random() * 2 - 1;
	                }
	            }
	            return buffer;
	        }()
	    };
	    /**
		 *	static noise buffers
		 *  @static
		 *  @private
		 *  @type {Tone.Buffer}
		 */
	    var _noiseBuffers = {};
	    //create the Tone.Buffers
	    function createBuffers() {
	        for (var type in _noiseArrays) {
	            _noiseBuffers[type] = new Tone.Buffer().fromArray(_noiseArrays[type]);
	        }
	    }
	    //create the noise buffers
	    Tone.getContext(createBuffers);
	    Tone.Context.on('init', createBuffers);
	    return Tone.Noise;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.NoiseSynth is composed of a noise generator (Tone.Noise), one filter (Tone.Filter), 
		 *          and two envelopes (Tone.Envelop). One envelope controls the amplitude
		 *          of the noise and the other is controls the cutoff frequency of the filter. 
		 *          <img src="https://docs.google.com/drawings/d/1rqzuX9rBlhT50MRvD2TKml9bnZhcZmzXF1rf_o7vdnE/pub?w=918&h=242">
		 *
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 * @example
		 * var noiseSynth = new Tone.NoiseSynth().toMaster();
		 * noiseSynth.triggerAttackRelease("8n");
		 */
	    Tone.NoiseSynth = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.NoiseSynth.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  The noise source.
			 *  @type {Tone.Noise}
			 *  @example
			 * noiseSynth.set("noise.type", "brown");
			 */
	        this.noise = new Tone.Noise();
	        /**
			 *  The amplitude envelope. 
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
	        //connect the noise to the output
	        this.noise.chain(this.envelope, this.output);
	        //start the noise
	        this.noise.start();
	        this._readOnly([
	            'noise',
	            'envelope'
	        ]);
	    };
	    Tone.extend(Tone.NoiseSynth, Tone.Instrument);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.NoiseSynth.defaults = {
	        'noise': { 'type': 'white' },
	        'envelope': {
	            'attack': 0.005,
	            'decay': 0.1,
	            'sustain': 0
	        }
	    };
	    /**
		 *  Start the attack portion of the envelopes. Unlike other 
		 *  instruments, Tone.NoiseSynth doesn't have a note. 
		 *  @param {Time} [time=now] the time the attack should start
		 *  @param {number} [velocity=1] the velocity of the note (0-1)
		 *  @returns {Tone.NoiseSynth} this
		 *  @example
		 * noiseSynth.triggerAttack();
		 */
	    Tone.NoiseSynth.prototype.triggerAttack = function (time, velocity) {
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        return this;
	    };
	    /**
		 *  Start the release portion of the envelopes.
		 *  @param {Time} [time=now] the time the release should start
		 *  @returns {Tone.NoiseSynth} this
		 */
	    Tone.NoiseSynth.prototype.triggerRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  Trigger the attack and then the release. 
		 *  @param  {Time} duration the duration of the note
		 *  @param  {Time} [time=now]     the time of the attack
		 *  @param  {number} [velocity=1] the velocity
		 *  @returns {Tone.NoiseSynth} this
		 */
	    Tone.NoiseSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {
	        time = this.toSeconds(time);
	        duration = this.toSeconds(duration);
	        this.triggerAttack(time, velocity);
	        this.triggerRelease(time + duration);
	        return this;
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.NoiseSynth} this
		 */
	    Tone.NoiseSynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        this._writable([
	            'noise',
	            'envelope'
	        ]);
	        this.noise.dispose();
	        this.noise = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        return this;
	    };
	    return Tone.NoiseSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Karplus-String string synthesis. Often out of tune. 
		 *         Will change when the AudioWorkerNode is available across
		 *         browsers. 
		 *  
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {Object} [options] see the defaults
		 *  @example
		 * var plucky = new Tone.PluckSynth().toMaster();
		 * plucky.triggerAttack("C4");
		 */
	    Tone.PluckSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.PluckSynth.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  @type {Tone.Noise}
			 *  @private
			 */
	        this._noise = new Tone.Noise('pink');
	        /**
			 *  The amount of noise at the attack. 
			 *  Nominal range of [0.1, 20]
			 *  @type {number}
			 */
	        this.attackNoise = options.attackNoise;
	        /**
			 *  the LFCF
			 *  @type {Tone.LowpassCombFilter}
			 *  @private
			 */
	        this._lfcf = new Tone.LowpassCombFilter({
	            'resonance': options.resonance,
	            'dampening': options.dampening
	        });
	        /**
			 *  The resonance control. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.resonance = this._lfcf.resonance;
	        /**
			 *  The dampening control. i.e. the lowpass filter frequency of the comb filter
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.dampening = this._lfcf.dampening;
	        //connections
	        this._noise.connect(this._lfcf);
	        this._lfcf.connect(this.output);
	        this._readOnly([
	            'resonance',
	            'dampening'
	        ]);
	    };
	    Tone.extend(Tone.PluckSynth, Tone.Instrument);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.PluckSynth.defaults = {
	        'attackNoise': 1,
	        'dampening': 4000,
	        'resonance': 0.9
	    };
	    /**
		 *  Trigger the note. 
		 *  @param {Frequency} note The note to trigger.
		 *  @param {Time} [time=now] When the note should be triggered.
		 *  @returns {Tone.PluckSynth} this
		 */
	    Tone.PluckSynth.prototype.triggerAttack = function (note, time) {
	        note = this.toFrequency(note);
	        time = this.toSeconds(time);
	        var delayAmount = 1 / note;
	        this._lfcf.delayTime.setValueAtTime(delayAmount, time);
	        this._noise.start(time);
	        this._noise.stop(time + delayAmount * this.attackNoise);
	        return this;
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.PluckSynth} this
		 */
	    Tone.PluckSynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        this._noise.dispose();
	        this._lfcf.dispose();
	        this._noise = null;
	        this._lfcf = null;
	        this._writable([
	            'resonance',
	            'dampening'
	        ]);
	        this.dampening = null;
	        this.resonance = null;
	        return this;
	    };
	    return Tone.PluckSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.PolySynth handles voice creation and allocation for any
		 *          instruments passed in as the second paramter. PolySynth is 
		 *          not a synthesizer by itself, it merely manages voices of 
		 *          one of the other types of synths, allowing any of the 
		 *          monophonic synthesizers to be polyphonic. 
		 *
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {number|Object} [polyphony=4] The number of voices to create
		 *  @param {function} [voice=Tone.Synth] The constructor of the voices
		 *                                            uses Tone.Synth by default. 
		 *  @example
		 * //a polysynth composed of 6 Voices of Synth
		 * var synth = new Tone.PolySynth(6, Tone.Synth).toMaster();
		 * //set the attributes using the set interface
		 * synth.set("detune", -1200);
		 * //play a chord
		 * synth.triggerAttackRelease(["C4", "E4", "A4"], "4n");
		 */
	    Tone.PolySynth = function () {
	        var options = Tone.defaults(arguments, [
	            'polyphony',
	            'voice'
	        ], Tone.PolySynth);
	        Tone.Instrument.call(this, options);
	        options = Tone.defaultArg(options, Tone.Instrument.defaults);
	        //max polyphony
	        options.polyphony = Math.min(Tone.PolySynth.MAX_POLYPHONY, options.polyphony);
	        /**
			 *  the array of voices
			 *  @type {Array}
			 */
	        this.voices = new Array(options.polyphony);
	        /**
			 *  The queue of voices with data about last trigger
			 *  and the triggered note
			 *  @private
			 *  @type {Array}
			 */
	        this._triggers = new Array(options.polyphony);
	        /**
			 *  The detune in cents
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        this._readOnly('detune');
	        //create the voices
	        for (var i = 0; i < options.polyphony; i++) {
	            var v = new options.voice(arguments[2], arguments[3]);
	            this.voices[i] = v;
	            v.connect(this.output);
	            if (v.hasOwnProperty('detune')) {
	                this.detune.connect(v.detune);
	            }
	            this._triggers[i] = {
	                release: -1,
	                note: null,
	                voice: v
	            };
	        }
	    };
	    Tone.extend(Tone.PolySynth, Tone.Instrument);
	    /**
		 *  the defaults
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.PolySynth.defaults = {
	        'polyphony': 4,
	        'volume': 0,
	        'detune': 0,
	        'voice': Tone.Synth
	    };
	    /**
		 *  Trigger the attack portion of the note
		 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
		 *                                  Frequency or an array of frequencies.
		 *  @param  {Time} [time=now]  The start time of the note.
		 *  @param {number} [velocity=1] The velocity of the note.
		 *  @returns {Tone.PolySynth} this
		 *  @example
		 * //trigger a chord immediately with a velocity of 0.2
		 * poly.triggerAttack(["Ab3", "C4", "F5"], undefined, 0.2);
		 */
	    Tone.PolySynth.prototype.triggerAttack = function (notes, time, velocity) {
	        if (!Array.isArray(notes)) {
	            notes = [notes];
	        }
	        time = this.toSeconds(time);
	        for (var i = 0; i < notes.length; i++) {
	            var val = notes[i];
	            //trigger the oldest voice
	            var oldest = this._triggers[0];
	            var oldestIndex = 0;
	            for (var j = 1; j < this._triggers.length; j++) {
	                if (this._triggers[j].release < oldest.release) {
	                    oldest = this._triggers[j];
	                    oldestIndex = j;
	                }
	            }
	            oldest.release = Infinity;
	            oldest.note = JSON.stringify(val);
	            oldest.voice.triggerAttack(val, time, velocity);
	        }
	        return this;
	    };
	    /**
		 *  Trigger the attack and release after the specified duration
		 *  
		 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
		 *                                  Frequency or an array of frequencies.
		 *  @param  {Time} duration the duration of the note
		 *  @param  {Time} [time=now]     if no time is given, defaults to now
		 *  @param  {number} [velocity=1] the velocity of the attack (0-1)
		 *  @returns {Tone.PolySynth} this
		 *  @example
		 * //trigger a chord for a duration of a half note 
		 * poly.triggerAttackRelease(["Eb3", "G4", "C5"], "2n");
		 *  @example
		 * //can pass in an array of durations as well
		 * poly.triggerAttackRelease(["Eb3", "G4", "C5"], ["2n", "4n", "4n"]);
		 */
	    Tone.PolySynth.prototype.triggerAttackRelease = function (notes, duration, time, velocity) {
	        time = this.toSeconds(time);
	        this.triggerAttack(notes, time, velocity);
	        if (Tone.isArray(duration) && Tone.isArray(notes)) {
	            for (var i = 0; i < notes.length; i++) {
	                var d = duration[Math.min(i, duration.length - 1)];
	                this.triggerRelease(notes[i], time + this.toSeconds(d));
	            }
	        } else {
	            this.triggerRelease(notes, time + this.toSeconds(duration));
	        }
	        return this;
	    };
	    /**
		 *  Trigger the release of the note. Unlike monophonic instruments, 
		 *  a note (or array of notes) needs to be passed in as the first argument.
		 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
		 *                                  Frequency or an array of frequencies.
		 *  @param  {Time} [time=now]  When the release will be triggered. 
		 *  @returns {Tone.PolySynth} this
		 *  @example
		 * poly.triggerRelease(["Ab3", "C4", "F5"], "+2n");
		 */
	    Tone.PolySynth.prototype.triggerRelease = function (notes, time) {
	        if (!Array.isArray(notes)) {
	            notes = [notes];
	        }
	        time = this.toSeconds(time);
	        for (var i = 0; i < notes.length; i++) {
	            //get the voice
	            var stringified = JSON.stringify(notes[i]);
	            for (var v = 0; v < this._triggers.length; v++) {
	                var desc = this._triggers[v];
	                if (desc.note === stringified && desc.release > time) {
	                    desc.voice.triggerRelease(time);
	                    desc.release = time;
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Set a member/attribute of the voices. 
		 *  @param {Object|string} params
		 *  @param {number=} value
		 *  @param {Time=} rampTime
		 *  @returns {Tone.PolySynth} this
		 *  @example
		 * poly.set({
		 * 	"filter" : {
		 * 		"type" : "highpass"
		 * 	},
		 * 	"envelope" : {
		 * 		"attack" : 0.25
		 * 	}
		 * });
		 */
	    Tone.PolySynth.prototype.set = function (params, value, rampTime) {
	        for (var i = 0; i < this.voices.length; i++) {
	            this.voices[i].set(params, value, rampTime);
	        }
	        return this;
	    };
	    /**
		 *  Get the synth's attributes. Given no arguments get
		 *  will return all available object properties and their corresponding
		 *  values. Pass in a single attribute to retrieve or an array
		 *  of attributes. The attribute strings can also include a "."
		 *  to access deeper properties.
		 *  @param {Array=} params the parameters to get, otherwise will return 
		 *  					   all available.
		 */
	    Tone.PolySynth.prototype.get = function (params) {
	        return this.voices[0].get(params);
	    };
	    /**
		 *  Trigger the release portion of all the currently active voices.
		 *  @param {Time} [time=now] When the notes should be released.
		 *  @return {Tone.PolySynth} this
		 */
	    Tone.PolySynth.prototype.releaseAll = function (time) {
	        time = this.toSeconds(time);
	        for (var i = 0; i < this._triggers.length; i++) {
	            var desc = this._triggers[i];
	            if (desc.release > time) {
	                desc.release = time;
	                desc.voice.triggerRelease(time);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.PolySynth} this
		 */
	    Tone.PolySynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        for (var i = 0; i < this.voices.length; i++) {
	            this.voices[i].dispose();
	            this.voices[i] = null;
	        }
	        this._writable('detune');
	        this.detune.dispose();
	        this.detune = null;
	        this.voices = null;
	        this._triggers = null;
	        return this;
	    };
	    /**
		 *  The maximum number of notes that can be allocated 
		 *  to a polysynth. 
		 *  @type  {Number}
		 *  @static
		 */
	    Tone.PolySynth.MAX_POLYPHONY = 20;
	    return Tone.PolySynth;
	});
	Module(function (Tone) {
	    /**
		 * @class Automatically interpolates between a set of pitched samples. Pass in an object which maps the note's pitch or midi value to the url, then you can trigger the attack and release of that note like other instruments. By automatically repitching the samples, it is possible to play pitches which were not explicitly included which can save loading time.
		 *        For sample or buffer playback where repitching is not necessary, use [Tone.Player](https://tonejs.github.io/docs/Player).
		 * @param {Object} samples An object of samples mapping either Midi
		 *                         Note Numbers or Scientific Pitch Notation
		 *                         to the url of that sample.
		 * @example
		 * var sampler = new Tone.Sampler({
		 * 	"C3" : "path/to/C3.mp3",
		 * 	"D#3" : "path/to/Dsharp3.mp3",
		 * 	"F#3" : "path/to/Fsharp3.mp3",
		 * 	"A3" : "path/to/A3.mp3",
		 * }, function(){
		 * 	//sampler will repitch the closest sample
		 * 	sampler.triggerAttack("D3")
		 * })
		 * @extends {Tone.Instrument}
		 */
	    Tone.Sampler = function (urls) {
	        // shift arguments over one. Those are the remainder of the options
	        var args = Array.prototype.slice.call(arguments);
	        args.shift();
	        var options = Tone.defaults(args, [
	            'onload',
	            'baseUrl'
	        ], Tone.Sampler);
	        Tone.Instrument.call(this, options);
	        var urlMap = {};
	        for (var note in urls) {
	            if (Tone.isNote(note)) {
	                //convert the note name to MIDI
	                var mid = Tone.Frequency(note).toMidi();
	                urlMap[mid] = urls[note];
	            } else if (!isNaN(parseFloat(note))) {
	                //otherwise if it's numbers assume it's midi
	                urlMap[note] = urls[note];
	            } else {
	                throw new Error('Tone.Sampler: url keys must be the note\'s pitch');
	            }
	        }
	        /**
			 * The stored and loaded buffers
			 * @type {Tone.Buffers}
			 * @private
			 */
	        this._buffers = new Tone.Buffers(urlMap, options.onload, options.baseUrl);
	        /**
			 * The object of all currently playing BufferSources
			 * @type {Object}
			 * @private
			 */
	        this._activeSources = {};
	        /**
			 * The envelope applied to the beginning of the sample.
			 * @type {Time}
			 */
	        this.attack = options.attack;
	        /**
			 * The envelope applied to the end of the envelope.
			 * @type {Time}
			 */
	        this.release = options.release;
	    };
	    Tone.extend(Tone.Sampler, Tone.Instrument);
	    /**
		 * The defaults
		 * @const
		 * @type {Object}
		 */
	    Tone.Sampler.defaults = {
	        attack: 0,
	        release: 0.1,
	        onload: Tone.noOp,
	        baseUrl: ''
	    };
	    /**
		 * Returns the difference in steps between the given midi note at the closets sample.
		 * @param  {Midi} midi
		 * @return {Interval}
		 * @private
		 */
	    Tone.Sampler.prototype._findClosest = function (midi) {
	        var MAX_INTERVAL = 24;
	        var interval = 0;
	        while (interval < MAX_INTERVAL) {
	            // check above and below
	            if (this._buffers.has(midi + interval)) {
	                return -interval;
	            } else if (this._buffers.has(midi - interval)) {
	                return interval;
	            }
	            interval++;
	        }
	        return null;
	    };
	    /**
		 * @param  {Frequency} note     The note to play
		 * @param  {Time=} time     When to play the note
		 * @param  {NormalRange=} velocity The velocity to play the sample back.
		 * @return {Tone.Sampler}          this
		 */
	    Tone.Sampler.prototype.triggerAttack = function (note, time, velocity) {
	        var midi = Tone.Frequency(note).toMidi();
	        // find the closest note pitch
	        var difference = this._findClosest(midi);
	        if (difference !== null) {
	            var closestNote = midi - difference;
	            var buffer = this._buffers.get(closestNote);
	            // play that note
	            var source = new Tone.BufferSource({
	                'buffer': buffer,
	                'playbackRate': Tone.intervalToFrequencyRatio(difference),
	                'fadeIn': this.attack,
	                'fadeOut': this.release
	            }).connect(this.output);
	            source.start(time, 0, buffer.duration, velocity);
	            // add it to the active sources
	            if (!Tone.isArray(this._activeSources[midi])) {
	                this._activeSources[midi] = [];
	            }
	            this._activeSources[midi].push({
	                note: midi,
	                source: source
	            });
	        }
	        return this;
	    };
	    /**
		 * @param  {Frequency} note     The note to release.
		 * @param  {Time=} time     	When to release the note.
		 * @return {Tone.Sampler}	this
		 */
	    Tone.Sampler.prototype.triggerRelease = function (note, time) {
	        var midi = Tone.Frequency(note).toMidi();
	        // find the note
	        if (this._activeSources[midi] && this._activeSources[midi].length) {
	            var source = this._activeSources[midi].shift().source;
	            time = this.toSeconds(time);
	            source.stop(time + this.release, this.release);
	        }
	    };
	    /**
		 * Invoke the attack phase, then after the duration, invoke the release.
		 * @param  {Frequency} note     The note to play
		 * @param  {Time} duration The time the note should be held
		 * @param  {Time=} time     When to start the attack
		 * @param  {NormalRange} [velocity=1] The velocity of the attack
		 * @return {Tone.Sampler}          this
		 */
	    Tone.Sampler.prototype.triggerAttackRelease = function (note, duration, time, velocity) {
	        time = this.toSeconds(time);
	        duration = this.toSeconds(duration);
	        this.triggerAttack(note, time, velocity);
	        this.triggerRelease(note, time + duration);
	        return this;
	    };
	    /**
		 *  Add a note to the sampler.
		 *  @param  {Note|Midi}   note      The buffer's pitch.
		 *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer,
		 *                                                 or a buffer which will be added
		 *                                                 with the given name.
		 *  @param  {Function=}  callback  The callback to invoke
		 *                                 when the url is loaded.
		 */
	    Tone.Sampler.prototype.add = function (note, url, callback) {
	        if (Tone.isNote(note)) {
	            //convert the note name to MIDI
	            var mid = Tone.Frequency(note).toMidi();
	            this._buffers.add(mid, url, callback);
	        } else if (!isNaN(parseFloat(note))) {
	            //otherwise if it's numbers assume it's midi
	            this._buffers.add(note, url, callback);
	        } else {
	            throw new Error('Tone.Sampler: note must be the note\'s pitch. Instead got ' + note);
	        }
	    };
	    /**
		 * If the buffers are loaded or not
		 * @memberOf Tone.Sampler#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Sampler.prototype, 'loaded', {
	        get: function () {
	            return this._buffers.loaded;
	        }
	    });
	    /**
		 * Clean up
		 * @return {Tone.Sampler} this
		 */
	    Tone.Sampler.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        this._buffers.dispose();
	        this._buffers = null;
	        for (var midi in this._activeSources) {
	            this._activeSources[midi].forEach(function (event) {
	                event.source.dispose();
	            });
	        }
	        this._activeSources = null;
	        return this;
	    };
	    return Tone.Sampler;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Maps a NormalRange [0, 1] to an AudioRange [-1, 1]. 
		 *         See also Tone.AudioToGain. 
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @example
		 * var g2a = new Tone.GainToAudio();
		 */
	    Tone.GainToAudio = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {
	            return Math.abs(x) * 2 - 1;
	        });
	    };
	    Tone.extend(Tone.GainToAudio, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @returns {Tone.GainToAudio} this
		 */
	    Tone.GainToAudio.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._norm.dispose();
	        this._norm = null;
	        return this;
	    };
	    return Tone.GainToAudio;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Normalize takes an input min and max and maps it linearly to NormalRange [0,1]
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @param {number} inputMin the min input value
		 *  @param {number} inputMax the max input value
		 *  @example
		 * var norm = new Tone.Normalize(2, 4);
		 * var sig = new Tone.Signal(3).connect(norm);
		 * //output of norm is 0.5. 
		 */
	    Tone.Normalize = function (inputMin, inputMax) {
	        Tone.SignalBase.call(this);
	        /**
			 *  the min input value
			 *  @type {number}
			 *  @private
			 */
	        this._inputMin = Tone.defaultArg(inputMin, 0);
	        /**
			 *  the max input value
			 *  @type {number}
			 *  @private
			 */
	        this._inputMax = Tone.defaultArg(inputMax, 1);
	        /**
			 *  subtract the min from the input
			 *  @type {Tone.Add}
			 *  @private
			 */
	        this._sub = this.input = new Tone.Add(0);
	        /**
			 *  divide by the difference between the input and output
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._div = this.output = new Tone.Multiply(1);
	        this._sub.connect(this._div);
	        this._setRange();
	    };
	    Tone.extend(Tone.Normalize, Tone.SignalBase);
	    /**
		 * The minimum value the input signal will reach.
		 * @memberOf Tone.Normalize#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.Normalize.prototype, 'min', {
	        get: function () {
	            return this._inputMin;
	        },
	        set: function (min) {
	            this._inputMin = min;
	            this._setRange();
	        }
	    });
	    /**
		 * The maximum value the input signal will reach.
		 * @memberOf Tone.Normalize#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.Normalize.prototype, 'max', {
	        get: function () {
	            return this._inputMax;
	        },
	        set: function (max) {
	            this._inputMax = max;
	            this._setRange();
	        }
	    });
	    /**
		 *  set the values
		 *  @private
		 */
	    Tone.Normalize.prototype._setRange = function () {
	        this._sub.value = -this._inputMin;
	        this._div.value = 1 / (this._inputMax - this._inputMin);
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.Normalize} this
		 */
	    Tone.Normalize.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._sub.dispose();
	        this._sub = null;
	        this._div.dispose();
	        this._div = null;
	        return this;
	    };
	    return Tone.Normalize;
	});
	Module(function (Tone) {
	    /**
		 * @class Tone.TransportTimelineSignal extends Tone.TimelineSignal, but adds the ability to synchronize the signal to the signal to the Tone.Transport
		 * @extends {Tone.TimelineSignal}
		 */
	    Tone.TransportTimelineSignal = function () {
	        Tone.TimelineSignal.apply(this, arguments);
	        /**
			 * The real signal output
			 * @type {Tone.Signal}
			 * @private
			 */
	        this.output = this._outputSig = new Tone.Signal(this._initial);
	        /**
			 * Keep track of the last value. (small optimization)
			 * @private
			 * @type {Number}
			 */
	        this._lastVal = this.value;
	        /**
			 * The event id of the tick update loop
			 * @private
			 * @type {Number}
			 */
	        this._synced = Tone.Transport.scheduleRepeat(this._onTick.bind(this), '1i');
	        /**
			 * A bound version of the anchor value methods
			 * @type {Function}
			 * @private
			 */
	        this._bindAnchorValue = this._anchorValue.bind(this);
	        Tone.Transport.on('start stop pause', this._bindAnchorValue);
	        this._events.memory = Infinity;
	    };
	    Tone.extend(Tone.TransportTimelineSignal, Tone.TimelineSignal);
	    /**
		 * Callback which is invoked every tick.
		 * @private
		 * @param  {Number} time
		 * @return {Tone.TransportTimelineSignal}      this
		 */
	    Tone.TransportTimelineSignal.prototype._onTick = function (time) {
	        var val = this.getValueAtTime(Tone.Transport.seconds);
	        if (this._lastVal !== val) {
	            this._lastVal = val;
	            //approximate ramp curves with linear ramps
	            this._outputSig.linearRampToValueAtTime(val, time);
	        }
	    };
	    /**
		 * Anchor the value at the start and stop of the Transport
		 * @param  {Number} time The time of the event
		 * @return {Tone.TransportTimelineSignal}      this
		 * @private
		 */
	    Tone.TransportTimelineSignal.prototype._anchorValue = function (time) {
	        var val = this.getValueAtTime(Tone.Transport.ticks);
	        this._lastVal = val;
	        this._outputSig.cancelScheduledValues(time);
	        this._outputSig.setValueAtTime(val, time);
	        return this;
	    };
	    /**
		 *  Get the scheduled value at the given time. This will
		 *  return the unconverted (raw) value.
		 *  @param  {TransportTime}  time  The time in seconds.
		 *  @return  {Number}  The scheduled value at the given time.
		 */
	    Tone.TransportTimelineSignal.prototype.getValueAtTime = function (time) {
	        time = this.toTicks(time);
	        return Tone.TimelineSignal.prototype.getValueAtTime.call(this, time);
	    };
	    /**
		 * Set the output of the signal at the given time
		 * @param  {Number} value The value to change to at the given time
		 * @param  {TransportTime} time  The time to change the signal
		 * @return {Tone.TransportTimelineSignal}       this
		 */
	    Tone.TransportTimelineSignal.prototype.setValueAtTime = function (value, time) {
	        time = this.toTicks(time);
	        Tone.TimelineSignal.prototype.setValueAtTime.call(this, value, time);
	        return this;
	    };
	    /**
		 * Linear ramp to the given value from the previous scheduled point to the given value
		 * @param  {Number} value The value to change to at the given time
		 * @param  {TransportTime} time  The time to change the signal
		 * @return {Tone.TransportTimelineSignal}       this
		 */
	    Tone.TransportTimelineSignal.prototype.linearRampToValueAtTime = function (value, time) {
	        time = this.toTicks(time);
	        Tone.TimelineSignal.prototype.linearRampToValueAtTime.call(this, value, time);
	        return this;
	    };
	    /**
		 * Exponential ramp to the given value from the previous scheduled point to the given value
		 * @param  {Number} value The value to change to at the given time
		 * @param  {TransportTime} time  The time to change the signal
		 * @return {Tone.TransportTimelineSignal}       this
		 */
	    Tone.TransportTimelineSignal.prototype.exponentialRampToValueAtTime = function (value, time) {
	        time = this.toTicks(time);
	        Tone.TimelineSignal.prototype.exponentialRampToValueAtTime.call(this, value, time);
	        return this;
	    };
	    /**
		 *  Start exponentially approaching the target value at the given time with
		 *  a rate having the given time constant.
		 *  @param {number} value
		 *  @param {TransportTime} startTime
		 *  @param {number} timeConstant
		 * @return {Tone.TransportTimelineSignal}       this
		 */
	    Tone.TransportTimelineSignal.prototype.setTargetAtTime = function (value, startTime, timeConstant) {
	        startTime = this.toTicks(startTime);
	        Tone.TimelineSignal.prototype.setTargetAtTime.call(this, value, startTime, timeConstant);
	        return this;
	    };
	    /**
		 *  Cancels all scheduled parameter changes with times greater than or
		 *  equal to startTime.
		 *  @param  {TransportTime} startTime
		 *  @returns {Tone.Param} this
		 */
	    Tone.TransportTimelineSignal.prototype.cancelScheduledValues = function (startTime) {
	        startTime = this.toTicks(startTime);
	        Tone.TimelineSignal.prototype.cancelScheduledValues.call(this, startTime);
	        return this;
	    };
	    /**
		 *  Set an array of arbitrary values starting at the given time for the given duration.
		 *  @param {Float32Array} values
		 *  @param {Time} startTime
		 *  @param {Time} duration
		 *  @param {NormalRange} [scaling=1] If the values in the curve should be scaled by some value
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TransportTimelineSignal.prototype.setValueCurveAtTime = function (values, startTime, duration, scaling) {
	        startTime = this.toTicks(startTime);
	        duration = this.toTicks(duration);
	        Tone.TimelineSignal.prototype.setValueCurveAtTime.call(this, values, startTime, duration, scaling);
	        return this;
	    };
	    /**
		 * Dispose and disconnect
		 * @return {Tone.TransportTimelineSignal} this
		 */
	    Tone.TransportTimelineSignal.prototype.dispose = function () {
	        Tone.Transport.clear(this._synced);
	        Tone.Transport.off('start stop pause', this._syncedCallback);
	        this._events.cancel(0);
	        Tone.TimelineSignal.prototype.dispose.call(this);
	        this._outputSig.dispose();
	        this._outputSig = null;
	    };
	    return Tone.TransportTimelineSignal;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.MultiPlayer is well suited for one-shots, multi-sampled instruments
		 *         or any time you need to play a bunch of audio buffers. 
		 *
		 *  @deprecated Use [Tone.Players](Players) instead.
		 *  @param  {Object|Array|Tone.Buffers}  buffers  The buffers which are available
		 *                                                to the MultiPlayer
		 *  @param {Function} onload The callback to invoke when all of the buffers are loaded.
		 *  @extends {Tone}
		 *  @example
		 * var multiPlayer = new MultiPlayer({
		 * 	"kick" : "path/to/kick.mp3",
		 * 	"snare" : "path/to/snare.mp3",
		 * }, function(){
		 * 	multiPlayer.start("kick");
		 * });
		 *  @example
		 * //can also store the values in an array
		 * var multiPlayer = new MultiPlayer(["path/to/kick.mp3", "path/to/snare.mp3"], 
		 * function(){
		 * 	//if an array is passed in, the samples are referenced to by index
		 * 	multiPlayer.start(1);
		 * });
		 */
	    Tone.MultiPlayer = function (urls) {
	        console.warn('Tone.MultiPlayer is deprecated. Use Tone.Players instead.');
	        //remove the urls from the options
	        if (arguments.length === 1 && !Tone.isUndef(arguments[0]) && !arguments[0].hasOwnProperty('urls')) {
	            urls = { 'urls': urls };
	        }
	        var options = Tone.defaults(arguments, [
	            'urls',
	            'onload'
	        ], Tone.MultiPlayer);
	        Tone.Source.call(this, options);
	        if (options.urls instanceof Tone.Buffers) {
	            /**
				 *  All the buffers belonging to the player.
				 *  @type  {Tone.Buffers}
				 */
	            this.buffers = options.urls;
	        } else {
	            this.buffers = new Tone.Buffers(options.urls, options.onload);
	        }
	        /**
			 *  Keeps track of the currently playing sources.
			 *  @type  {Object}
			 *  @private
			 */
	        this._activeSources = {};
	        /**
			 *  The fade in envelope which is applied
			 *  to the beginning of the BufferSource
			 *  @type  {Time}
			 */
	        this.fadeIn = options.fadeIn;
	        /**
			 *  The fade out envelope which is applied
			 *  to the end of the BufferSource
			 *  @type  {Time}
			 */
	        this.fadeOut = options.fadeOut;
	    };
	    Tone.extend(Tone.MultiPlayer, Tone.Source);
	    /**
		 *  The defaults
		 *  @type  {Object}
		 */
	    Tone.MultiPlayer.defaults = {
	        'onload': Tone.noOp,
	        'fadeIn': 0,
	        'fadeOut': 0
	    };
	    /**
		 * Make the source from the buffername
		 * @param  {String} bufferName
		 * @return {Tone.BufferSource}
		 * @private
		 */
	    Tone.MultiPlayer.prototype._makeSource = function (bufferName) {
	        var buffer;
	        if (Tone.isString(bufferName) || Tone.isNumber(bufferName)) {
	            buffer = this.buffers.get(bufferName).get();
	        } else if (bufferName instanceof Tone.Buffer) {
	            buffer = bufferName.get();
	        } else if (bufferName instanceof AudioBuffer) {
	            buffer = bufferName;
	        }
	        var source = new Tone.BufferSource(buffer).connect(this.output);
	        if (!this._activeSources.hasOwnProperty(bufferName)) {
	            this._activeSources[bufferName] = [];
	        }
	        this._activeSources[bufferName].push(source);
	        return source;
	    };
	    /**
		 *  Start a buffer by name. The `start` method allows a number of options
		 *  to be passed in such as offset, interval, and gain. This is good for multi-sampled 
		 *  instruments and sound sprites where samples are repitched played back at different velocities.
		 *  @param  {String}  bufferName    The name of the buffer to start.
		 *  @param  {Time}  time      When to start the buffer.
		 *  @param  {Time}  [offset=0]    The offset into the buffer to play from.
		 *  @param  {Time=}  duration   How long to play the buffer for.
		 *  @param  {Interval}  [pitch=0]  The interval to repitch the buffer.
		 *  @param  {Gain}  [gain=1]      The gain to play the sample at.
		 *  @return  {Tone.MultiPlayer}  this
		 */
	    Tone.MultiPlayer.prototype.start = function (bufferName, time, offset, duration, pitch, gain) {
	        time = this.toSeconds(time);
	        var source = this._makeSource(bufferName);
	        source.start(time, offset, duration, Tone.defaultArg(gain, 1), this.fadeIn);
	        if (duration) {
	            source.stop(time + this.toSeconds(duration), this.fadeOut);
	        }
	        pitch = Tone.defaultArg(pitch, 0);
	        source.playbackRate.value = Tone.intervalToFrequencyRatio(pitch);
	        return this;
	    };
	    /**
		 *  Start a looping buffer by name. Similar to `start`, but the buffer
		 *  is looped instead of played straight through. Can still be stopped with `stop`. 
		 *  @param  {String}  bufferName    The name of the buffer to start.
		 *  @param  {Time}  time      When to start the buffer.
		 *  @param  {Time}  [offset=0]    The offset into the buffer to play from.
		 *  @param  {Time=}  loopStart   The start of the loop.
		 *  @param  {Time=}  loopEnd	The end of the loop.
		 *  @param  {Interval}  [pitch=0]  The interval to repitch the buffer.
		 *  @param  {Gain}  [gain=1]      The gain to play the sample at.
		 *  @return  {Tone.MultiPlayer}  this
		 */
	    Tone.MultiPlayer.prototype.startLoop = function (bufferName, time, offset, loopStart, loopEnd, pitch, gain) {
	        time = this.toSeconds(time);
	        var source = this._makeSource(bufferName);
	        source.loop = true;
	        source.loopStart = this.toSeconds(Tone.defaultArg(loopStart, 0));
	        source.loopEnd = this.toSeconds(Tone.defaultArg(loopEnd, 0));
	        source.start(time, offset, undefined, Tone.defaultArg(gain, 1), this.fadeIn);
	        pitch = Tone.defaultArg(pitch, 0);
	        source.playbackRate.value = Tone.intervalToFrequencyRatio(pitch);
	        return this;
	    };
	    /**
		 *  Stop the first played instance of the buffer name.
		 *  @param  {String}  bufferName  The buffer to stop.
		 *  @param  {Time=}  time    When to stop the buffer
		 *  @return  {Tone.MultiPlayer}  this
		 */
	    Tone.MultiPlayer.prototype.stop = function (bufferName, time) {
	        if (this._activeSources[bufferName] && this._activeSources[bufferName].length) {
	            time = this.toSeconds(time);
	            this._activeSources[bufferName].shift().stop(time, this.fadeOut);
	        } else {
	            throw new Error('Tone.MultiPlayer: cannot stop a buffer that hasn\'t been started or is already stopped');
	        }
	        return this;
	    };
	    /**
		 *  Stop all currently playing buffers at the given time.
		 *  @param  {Time=}  time  When to stop the buffers.
		 *  @return  {Tone.MultiPlayer}  this
		 */
	    Tone.MultiPlayer.prototype.stopAll = function (time) {
	        time = this.toSeconds(time);
	        for (var bufferName in this._activeSources) {
	            var sources = this._activeSources[bufferName];
	            for (var i = 0; i < sources.length; i++) {
	                sources[i].stop(time);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Add another buffer to the available buffers.
		 *  @param {String} name The name to that the buffer is refered
		 *                       to in start/stop methods. 
		 *  @param {String|Tone.Buffer} url The url of the buffer to load
		 *                                  or the buffer.
		 *  @param {Function} callback The function to invoke after the buffer is loaded.
		 */
	    Tone.MultiPlayer.prototype.add = function (name, url, callback) {
	        this.buffers.add(name, url, callback);
	        return this;
	    };
	    /**
		 *  Returns the playback state of the source. "started"
		 *  if there are any buffers playing. "stopped" otherwise.
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.MultiPlayer#
		 *  @name state
		 */
	    Object.defineProperty(Tone.MultiPlayer.prototype, 'state', {
	        get: function () {
	            return this._activeSources.length > 0 ? Tone.State.Started : Tone.State.Stopped;
	        }
	    });
	    /**
		 * Mute the output. 
		 * @memberOf Tone.MultiPlayer#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * source.mute = true;
		 */
	    Object.defineProperty(Tone.MultiPlayer.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return  {Tone.MultiPlayer}  this
		 */
	    Tone.MultiPlayer.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        for (var bufferName in this._activeSources) {
	            this._activeSources[bufferName].forEach(function (source) {
	                source.dispose();
	            });
	        }
	        this.buffers.dispose();
	        this.buffers = null;
	        this._activeSources = null;
	        return this;
	    };
	    return Tone.MultiPlayer;
	});
	Module(function (Tone) {
	    /**
		 * @class Tone.GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).
		 *        Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the
		 *        amount of time each small chunk of audio is played for and the overlap is the
		 *        amount of crossfading transition time between successive grains.
		 * @extends {Tone.Source}
		 * @param {String|Tone.Buffer} url	The url to load, or the Tone.Buffer to play.
		 * @param {Function=} callback The callback to invoke after the url is loaded.
		 */
	    Tone.GrainPlayer = function () {
	        var options = Tone.defaults(arguments, [
	            'url',
	            'onload'
	        ], Tone.GrainPlayer);
	        Tone.Source.call(this, options);
	        /**
			 *  The audio buffer belonging to the player.
			 *  @type  {Tone.Buffer}
			 */
	        this.buffer = new Tone.Buffer(options.url, options.onload);
	        /**
			 *  Create a repeating tick to schedule
			 *  the grains.
			 *  @type  {Tone.Clock}
			 *  @private
			 */
	        this._clock = new Tone.Clock(this._tick.bind(this), options.grainSize);
	        /**
			 *  @type  {Number}
			 *  @private
			 */
	        this._loopStart = 0;
	        /**
			 *  @type  {Number}
			 *  @private
			 */
	        this._loopEnd = 0;
	        /**
			 * All of the currently playing BufferSources
			 * @type {Array}
			 * @private
			 */
	        this._activeSources = [];
	        /**
			 *  @type  {Number}
			 *  @private
			 */
	        this._playbackRate = options.playbackRate;
	        /**
			 *  @type  {Number}
			 *  @private
			 */
	        this._grainSize = options.grainSize;
	        /**
			 *  @private
			 *  @type {Number}
			 */
	        this._overlap = options.overlap;
	        /**
			 *  Adjust the pitch independently of the playbackRate.
			 *  @type  {Cents}
			 */
	        this.detune = options.detune;
	        //setup
	        this.overlap = options.overlap;
	        this.loop = options.loop;
	        this.playbackRate = options.playbackRate;
	        this.grainSize = options.grainSize;
	        this.loopStart = options.loopStart;
	        this.loopEnd = options.loopEnd;
	        this.reverse = options.reverse;
	        this._clock.on('stop', this._onstop.bind(this));
	    };
	    Tone.extend(Tone.GrainPlayer, Tone.Source);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.GrainPlayer.defaults = {
	        'onload': Tone.noOp,
	        'overlap': 0.1,
	        'grainSize': 0.2,
	        'playbackRate': 1,
	        'detune': 0,
	        'loop': false,
	        'loopStart': 0,
	        'loopEnd': 0,
	        'reverse': false
	    };
	    /**
		 *  Play the buffer at the given startTime. Optionally add an offset
		 *  and/or duration which will play the buffer from a position
		 *  within the buffer for the given duration.
		 *
		 *  @param  {Time} [startTime=now] When the player should start.
		 *  @param  {Time} [offset=0] The offset from the beginning of the sample
		 *                                 to start at.
		 *  @param  {Time=} duration How long the sample should play. If no duration
		 *                                is given, it will default to the full length
		 *                                of the sample (minus any offset)
		 *  @returns {Tone.GrainPlayer} this
		 *  @memberOf Tone.GrainPlayer#
		 *  @method start
		 *  @name start
		 */
	    /**
		 *  Internal start method
		 *  @param {Time} time
		 *  @param {Time} offset
		 *  @private
		 */
	    Tone.GrainPlayer.prototype._start = function (time, offset, duration) {
	        offset = Tone.defaultArg(offset, 0);
	        offset = this.toSeconds(offset);
	        time = this.toSeconds(time);
	        this._offset = offset;
	        this._clock.start(time);
	        if (duration) {
	            this.stop(time + this.toSeconds(duration));
	        }
	    };
	    /**
		 *  Internal start method
		 *  @param {Time} time
		 *  @private
		 */
	    Tone.GrainPlayer.prototype._stop = function (time) {
	        this._clock.stop(time);
	    };
	    /**
		 * Invoked when the clock is stopped
		 * @param  {Number} time
		 * @private
		 */
	    Tone.GrainPlayer.prototype._onstop = function (time) {
	        //stop the players
	        this._activeSources.forEach(function (source) {
	            source.stop(time, 0);
	        });
	    };
	    /**
		 *  Invoked on each clock tick. scheduled a new
		 *  grain at this time.
		 *  @param  {Time}  time
		 *  @private
		 */
	    Tone.GrainPlayer.prototype._tick = function (time) {
	        var fadeIn = this._offset < this._overlap ? 0 : this._overlap;
	        var source = new Tone.BufferSource({
	            'buffer': this.buffer,
	            'fadeIn': fadeIn,
	            'fadeOut': this._overlap,
	            'loop': this.loop,
	            'loopStart': this._loopStart,
	            'loopEnd': this._loopEnd,
	            'playbackRate': Tone.intervalToFrequencyRatio(this.detune / 100)
	        }).connect(this.output);
	        source.start(time, this._offset);
	        this._offset += this.grainSize;
	        source.stop(time + this.grainSize);
	        //add it to the active sources
	        this._activeSources.push(source);
	        //remove it when it's done
	        source.onended = function () {
	            var index = this._activeSources.indexOf(source);
	            if (index !== -1) {
	                this._activeSources.splice(index, 1);
	            }
	        }.bind(this);
	    };
	    /**
		 *  Jump to a specific time and play it.
		 *  @param  {Time}  offset  The offset to jump to.
		 *  @param {Time=} time When to make the jump.
		 *  @return  {Tone.GrainPlayer}  this
		 */
	    Tone.GrainPlayer.prototype.seek = function (offset, time) {
	        this._offset = this.toSeconds(offset);
	        this._tick(this.toSeconds(time));
	        return this;
	    };
	    /**
		 * The playback rate of the sample
		 * @memberOf Tone.GrainPlayer#
		 * @type {Positive}
		 * @name playbackRate
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            this.grainSize = this._grainSize;
	        }
	    });
	    /**
		 * The loop start time.
		 * @memberOf Tone.GrainPlayer#
		 * @type {Time}
		 * @name loopStart
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'loopStart', {
	        get: function () {
	            return this._loopStart;
	        },
	        set: function (time) {
	            this._loopStart = this.toSeconds(time);
	        }
	    });
	    /**
		 * The loop end time.
		 * @memberOf Tone.GrainPlayer#
		 * @type {Time}
		 * @name loopEnd
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'loopEnd', {
	        get: function () {
	            return this._loopEnd;
	        },
	        set: function (time) {
	            this._loopEnd = this.toSeconds(time);
	        }
	    });
	    /**
		 * The direction the buffer should play in
		 * @memberOf Tone.GrainPlayer#
		 * @type {boolean}
		 * @name reverse
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'reverse', {
	        get: function () {
	            return this.buffer.reverse;
	        },
	        set: function (rev) {
	            this.buffer.reverse = rev;
	        }
	    });
	    /**
		 * The size of each chunk of audio that the
		 * buffer is chopped into and played back at.
		 * @memberOf Tone.GrainPlayer#
		 * @type {Time}
		 * @name grainSize
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'grainSize', {
	        get: function () {
	            return this._grainSize;
	        },
	        set: function (size) {
	            this._grainSize = this.toSeconds(size);
	            this._clock.frequency.value = this._playbackRate / this._grainSize;
	        }
	    });
	    /**
		 * This is the duration of the cross-fade between
		 * sucessive grains.
		 * @memberOf Tone.GrainPlayer#
		 * @type {Time}
		 * @name overlap
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'overlap', {
	        get: function () {
	            return this._overlap;
	        },
	        set: function (time) {
	            this._overlap = this.toSeconds(time);
	        }
	    });
	    /**
		 * Clean up
		 * @return {Tone.GrainPlayer} this
		 */
	    Tone.GrainPlayer.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this.buffer.dispose();
	        this.buffer = null;
	        this._clock.dispose();
	        this._clock = null;
	        this._activeSources.forEach(function (source) {
	            source.dispose();
	        });
	        this._activeSources = null;
	        return this;
	    };
	    return Tone.GrainPlayer;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Player is an audio file player with start, loop, and stop functions.
		 *  
		 *  @constructor
		 *  @extends {Tone.Source} 
		 *  @param {string|AudioBuffer} url Either the AudioBuffer or the url from
		 *                                  which to load the AudioBuffer
		 *  @param {function=} onload The function to invoke when the buffer is loaded. 
		 *                            Recommended to use Tone.Buffer.on('load') instead.
		 *  @example
		 * var player = new Tone.Player("./path/to/sample.mp3").toMaster();
		 * //play as soon as the buffer is loaded
		 * player.autostart = true;
		 */
	    Tone.Player = function (url) {
	        var options;
	        if (url instanceof Tone.Buffer) {
	            url = url.get();
	            options = Tone.Player.defaults;
	        } else {
	            options = Tone.defaults(arguments, [
	                'url',
	                'onload'
	            ], Tone.Player);
	        }
	        Tone.Source.call(this, options);
	        /**
			 *  @private
			 *  @type {AudioBufferSourceNode}
			 */
	        this._source = null;
	        /**
			 *  If the file should play as soon
			 *  as the buffer is loaded. 
			 *  @type {boolean}
			 *  @example
			 * //will play as soon as it's loaded
			 * var player = new Tone.Player({
			 * 	"url" : "./path/to/sample.mp3",
			 * 	"autostart" : true,
			 * }).toMaster();
			 */
	        this.autostart = options.autostart;
	        /**
			 *  the buffer
			 *  @private
			 *  @type {Tone.Buffer}
			 */
	        this._buffer = new Tone.Buffer({
	            'url': options.url,
	            'onload': this._onload.bind(this, options.onload),
	            'reverse': options.reverse
	        });
	        if (url instanceof AudioBuffer) {
	            this._buffer.set(url);
	        }
	        /**
			 *  if the buffer should loop once it's over
			 *  @type {boolean}
			 *  @private
			 */
	        this._loop = options.loop;
	        /**
			 *  if 'loop' is true, the loop will start at this position
			 *  @type {Time}
			 *  @private
			 */
	        this._loopStart = options.loopStart;
	        /**
			 *  if 'loop' is true, the loop will end at this position
			 *  @type {Time}
			 *  @private
			 */
	        this._loopEnd = options.loopEnd;
	        /**
			 *  the playback rate
			 *  @private
			 *  @type {number}
			 */
	        this._playbackRate = options.playbackRate;
	        /**
			 *  Enabling retrigger will allow a player to be restarted
			 *  before the the previous 'start' is done playing. Otherwise, 
			 *  successive calls to Tone.Player.start will only start
			 *  the sample if it had played all the way through. 
			 *  @type {boolean}
			 */
	        this.retrigger = options.retrigger;
	        /**
			 *  The fadeIn time of the amplitude envelope.
			 *  @type {Time}
			 */
	        this.fadeIn = options.fadeIn;
	        /**
			 *  The fadeOut time of the amplitude envelope.
			 *  @type {Time}
			 */
	        this.fadeOut = options.fadeOut;
	    };
	    Tone.extend(Tone.Player, Tone.Source);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Player.defaults = {
	        'onload': Tone.noOp,
	        'playbackRate': 1,
	        'loop': false,
	        'autostart': false,
	        'loopStart': 0,
	        'loopEnd': 0,
	        'retrigger': false,
	        'reverse': false,
	        'fadeIn': 0,
	        'fadeOut': 0
	    };
	    /**
		 *  Load the audio file as an audio buffer.
		 *  Decodes the audio asynchronously and invokes
		 *  the callback once the audio buffer loads. 
		 *  Note: this does not need to be called if a url
		 *  was passed in to the constructor. Only use this
		 *  if you want to manually load a new url. 
		 * @param {string} url The url of the buffer to load.
		 *                     Filetype support depends on the
		 *                     browser.
		 *  @param  {function=} callback The function to invoke once
		 *                               the sample is loaded.
		 *  @returns {Promise}
		 */
	    Tone.Player.prototype.load = function (url, callback) {
	        return this._buffer.load(url, this._onload.bind(this, callback));
	    };
	    /**
		 * Internal callback when the buffer is loaded.
		 * @private
		 */
	    Tone.Player.prototype._onload = function (callback) {
	        callback = Tone.defaultArg(callback, Tone.noOp);
	        callback(this);
	        if (this.autostart) {
	            this.start();
	        }
	    };
	    /**
		 *  Play the buffer at the given startTime. Optionally add an offset
		 *  and/or duration which will play the buffer from a position
		 *  within the buffer for the given duration. 
		 *  
		 *  @param  {Time} [startTime=now] When the player should start.
		 *  @param  {Time} [offset=0] The offset from the beginning of the sample
		 *                                 to start at. 
		 *  @param  {Time=} duration How long the sample should play. If no duration
		 *                                is given, it will default to the full length 
		 *                                of the sample (minus any offset)
		 *  @returns {Tone.Player} this
		 *  @memberOf Tone.Player#
		 *  @method start
		 *  @name start
		 */
	    /**
		 *  Internal start method
		 *  @private
		 */
	    Tone.Player.prototype._start = function (startTime, offset, duration) {
	        //if it's a loop the default offset is the loopstart point
	        if (this._loop) {
	            offset = Tone.defaultArg(offset, this._loopStart);
	        } else {
	            //otherwise the default offset is 0
	            offset = Tone.defaultArg(offset, 0);
	        }
	        //compute the values in seconds
	        offset = this.toSeconds(offset);
	        duration = Tone.defaultArg(duration, Math.max(this._buffer.duration - offset, 0));
	        duration = this.toSeconds(duration);
	        startTime = this.toSeconds(startTime);
	        // //make the source
	        this._source = new Tone.BufferSource({
	            'buffer': this._buffer,
	            'loop': this._loop,
	            'loopStart': this._loopStart,
	            'loopEnd': this._loopEnd,
	            'playbackRate': this._playbackRate,
	            'fadeIn': this.fadeIn,
	            'fadeOut': this.fadeOut
	        }).connect(this.output);
	        //set the looping properties
	        if (!this._loop && !this._synced) {
	            //if it's not looping, set the state change at the end of the sample
	            this._state.setStateAtTime(Tone.State.Stopped, startTime + duration);
	        }
	        //start it
	        if (this._loop) {
	            this._source.start(startTime, offset);
	        } else {
	            this._source.start(startTime, offset, duration);
	        }
	        return this;
	    };
	    /**
		 *  Stop playback.
		 *  @private
		 *  @param  {Time} [time=now]
		 *  @returns {Tone.Player} this
		 */
	    Tone.Player.prototype._stop = function (time) {
	        if (this._source) {
	            this._source.stop(this.toSeconds(time));
	        }
	        return this;
	    };
	    /**
		 *  Seek to a specific time in the player's buffer. If the 
		 *  source is no longer playing at that time, it will stop.
		 *  If you seek to a time that 
		 *  @param {Time} offset The time to seek to.
		 *  @param {Time=} time The time for the seek event to occur.
		 *  @return {Tone.Player} this
		 *  @example
		 * source.start(0.2);
		 * source.stop(0.4);
		 */
	    Tone.Player.prototype.seek = function (offset, time) {
	        time = this.toSeconds(time);
	        if (this._state.getValueAtTime(time) === Tone.State.Started) {
	            offset = this.toSeconds(offset);
	            // if it's currently playing, stop it
	            this._stop(time);
	            //restart it at the given time
	            this._start(time, offset);
	        }
	        return this;
	    };
	    /**
		 *  Set the loop start and end. Will only loop if loop is 
		 *  set to true. 
		 *  @param {Time} loopStart The loop end time
		 *  @param {Time} loopEnd The loop end time
		 *  @returns {Tone.Player} this
		 *  @example
		 * //loop 0.1 seconds of the file. 
		 * player.setLoopPoints(0.2, 0.3);
		 * player.loop = true;
		 */
	    Tone.Player.prototype.setLoopPoints = function (loopStart, loopEnd) {
	        this.loopStart = loopStart;
	        this.loopEnd = loopEnd;
	        return this;
	    };
	    /**
		 * If loop is true, the loop will start at this position. 
		 * @memberOf Tone.Player#
		 * @type {Time}
		 * @name loopStart
		 */
	    Object.defineProperty(Tone.Player.prototype, 'loopStart', {
	        get: function () {
	            return this._loopStart;
	        },
	        set: function (loopStart) {
	            this._loopStart = loopStart;
	            if (this._source) {
	                this._source.loopStart = this.toSeconds(loopStart);
	            }
	        }
	    });
	    /**
		 * If loop is true, the loop will end at this position.
		 * @memberOf Tone.Player#
		 * @type {Time}
		 * @name loopEnd
		 */
	    Object.defineProperty(Tone.Player.prototype, 'loopEnd', {
	        get: function () {
	            return this._loopEnd;
	        },
	        set: function (loopEnd) {
	            this._loopEnd = loopEnd;
	            if (this._source) {
	                this._source.loopEnd = this.toSeconds(loopEnd);
	            }
	        }
	    });
	    /**
		 * The audio buffer belonging to the player. 
		 * @memberOf Tone.Player#
		 * @type {Tone.Buffer}
		 * @name buffer
		 */
	    Object.defineProperty(Tone.Player.prototype, 'buffer', {
	        get: function () {
	            return this._buffer;
	        },
	        set: function (buffer) {
	            this._buffer.set(buffer);
	        }
	    });
	    /**
		 * If the buffer should loop once it's over. 
		 * @memberOf Tone.Player#
		 * @type {boolean}
		 * @name loop
		 */
	    Object.defineProperty(Tone.Player.prototype, 'loop', {
	        get: function () {
	            return this._loop;
	        },
	        set: function (loop) {
	            this._loop = loop;
	            if (this._source) {
	                this._source.loop = loop;
	            }
	        }
	    });
	    /**
		 * The playback speed. 1 is normal speed. This is not a signal because
		 * Safari and iOS currently don't support playbackRate as a signal.
		 * @memberOf Tone.Player#
		 * @type {number}
		 * @name playbackRate
		 */
	    Object.defineProperty(Tone.Player.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            if (this._source) {
	                this._source.playbackRate.value = rate;
	            }
	        }
	    });
	    /**
		 * The direction the buffer should play in
		 * @memberOf Tone.Player#
		 * @type {boolean}
		 * @name reverse
		 */
	    Object.defineProperty(Tone.Player.prototype, 'reverse', {
	        get: function () {
	            return this._buffer.reverse;
	        },
	        set: function (rev) {
	            this._buffer.reverse = rev;
	        }
	    });
	    /**
		 * If all the buffer is loaded
		 * @memberOf Tone.Player#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Player.prototype, 'loaded', {
	        get: function () {
	            return this._buffer.loaded;
	        }
	    });
	    /**
		 *  Dispose and disconnect.
		 *  @return {Tone.Player} this
		 */
	    Tone.Player.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        if (this._source !== null) {
	            this._source.disconnect();
	            this._source = null;
	        }
	        this._buffer.dispose();
	        this._buffer = null;
	        return this;
	    };
	    return Tone.Player;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Players combines multiple [Tone.Player](Player) objects.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Object} urls An object mapping a name to a url.
		 *  @param {function=} onload The function to invoke when the buffer is loaded.
		 */
	    Tone.Players = function (urls) {
	        var args = Array.prototype.slice.call(arguments);
	        args.shift();
	        var options = Tone.defaults(args, ['onload'], Tone.Players);
	        Tone.call(this);
	        /**
			 *  The output volume node
			 *  @type  {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 * The volume of the output in decibels.
			 * @type {Decibels}
			 * @signal
			 * @example
			 * source.volume.value = -6;
			 */
	        this.volume = this._volume.volume;
	        this._readOnly('volume');
	        //make the output explicitly stereo
	        this._volume.output.output.channelCount = 2;
	        this._volume.output.output.channelCountMode = 'explicit';
	        //mute initially
	        this.mute = options.mute;
	        /**
			 * The container of all of the players
			 * @type {Object}
			 * @private
			 */
	        this._players = {};
	        /**
			 * The loading count
			 * @type {Number}
			 * @private
			 */
	        this._loadingCount = 0;
	        /**
			 * private holder of the fadeIn time
			 * @type {Time}
			 * @private
			 */
	        this._fadeIn = options.fadeIn;
	        /**
			 * private holder of the fadeOut time
			 * @type {Time}
			 * @private
			 */
	        this._fadeOut = options.fadeOut;
	        //add all of the players
	        for (var name in urls) {
	            this._loadingCount++;
	            this.add(name, urls[name], this._bufferLoaded.bind(this, options.onload));
	        }
	    };
	    Tone.extend(Tone.Players, Tone.AudioNode);
	    /**
		 * The default values
		 * @type {Object}
		 */
	    Tone.Players.defaults = {
	        'volume': 0,
	        'mute': false,
	        'onload': Tone.noOp,
	        'fadeIn': 0,
	        'fadeOut': 0
	    };
	    /**
		 *  A buffer was loaded. decrement the counter.
		 *  @param  {Function}  callback
		 *  @private
		 */
	    Tone.Players.prototype._bufferLoaded = function (callback) {
	        this._loadingCount--;
	        if (this._loadingCount === 0 && callback) {
	            callback(this);
	        }
	    };
	    /**
		 * Mute the output.
		 * @memberOf Tone.Source#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * source.mute = true;
		 */
	    Object.defineProperty(Tone.Players.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 * The fadeIn time of the amplitude envelope.
		 * @memberOf Tone.Source#
		 * @type {Time}
		 * @name fadeIn
		 */
	    Object.defineProperty(Tone.Players.prototype, 'fadeIn', {
	        get: function () {
	            return this._fadeIn;
	        },
	        set: function (fadeIn) {
	            this._fadeIn = fadeIn;
	            this._forEach(function (player) {
	                player.fadeIn = fadeIn;
	            });
	        }
	    });
	    /**
		 * The fadeOut time of the amplitude envelope.
		 * @memberOf Tone.Source#
		 * @type {Time}
		 * @name fadeOut
		 */
	    Object.defineProperty(Tone.Players.prototype, 'fadeOut', {
	        get: function () {
	            return this._fadeOut;
	        },
	        set: function (fadeOut) {
	            this._fadeOut = fadeOut;
	            this._forEach(function (player) {
	                player.fadeOut = fadeOut;
	            });
	        }
	    });
	    /**
		 * The state of the players object. Returns "started" if any of the players are playing.
		 * @memberOf Tone.Players#
		 * @type {String}
		 * @name state
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Players.prototype, 'state', {
	        get: function () {
	            var playing = false;
	            this._forEach(function (player) {
	                playing = playing || player.state === Tone.State.Started;
	            });
	            return playing ? Tone.State.Started : Tone.State.Stopped;
	        }
	    });
	    /**
		 *  True if the buffers object has a buffer by that name.
		 *  @param  {String|Number}  name  The key or index of the
		 *                                 buffer.
		 *  @return  {Boolean}
		 */
	    Tone.Players.prototype.has = function (name) {
	        return this._players.hasOwnProperty(name);
	    };
	    /**
		 *  Get a player by name.
		 *  @param  {String}  name  The players name as defined in
		 *                          the constructor object or `add` method.
		 *  @return  {Tone.Player}
		 */
	    Tone.Players.prototype.get = function (name) {
	        if (this.has(name)) {
	            return this._players[name];
	        } else {
	            throw new Error('Tone.Players: no player named ' + name);
	        }
	    };
	    /**
		 * Iterate over all of the players
		 * @param  {Function} callback
		 * @return {Tone.Players}            this
		 * @private
		 */
	    Tone.Players.prototype._forEach = function (callback) {
	        for (var playerName in this._players) {
	            callback(this._players[playerName], playerName);
	        }
	        return this;
	    };
	    /**
		 * If all the buffers are loaded or not
		 * @memberOf Tone.Players#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Players.prototype, 'loaded', {
	        get: function () {
	            var isLoaded = true;
	            this._forEach(function (player) {
	                isLoaded = isLoaded && player.loaded;
	            });
	            return isLoaded;
	        }
	    });
	    /**
		 *  Add a player by name and url to the Players
		 *  @param  {String}    name      A unique name to give the player
		 *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer,
		 *                                                 or a buffer which will be added
		 *                                                 with the given name.
		 *  @param  {Function=}  callback  The callback to invoke
		 *                                 when the url is loaded.
		 */
	    Tone.Players.prototype.add = function (name, url, callback) {
	        this._players[name] = new Tone.Player(url, callback).connect(this.output);
	        this._players[name].fadeIn = this._fadeIn;
	        this._players[name].fadeOut = this._fadeOut;
	        return this;
	    };
	    /**
		 * Stop all of the players at the given time
		 * @param {Time} time The time to stop all of the players.
		 * @return {Tone.Players} this
		 */
	    Tone.Players.prototype.stopAll = function (time) {
	        this._forEach(function (player) {
	            player.stop(time);
	        });
	    };
	    /**
		 *  Dispose and disconnect.
		 *  @return {Tone.Players} this
		 */
	    Tone.Players.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._volume.dispose();
	        this._volume = null;
	        this._writable('volume');
	        this.volume = null;
	        this.output = null;
	        this._forEach(function (player) {
	            player.dispose();
	        });
	        this._players = null;
	        return this;
	    };
	    return Tone.Players;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.UserMedia uses MediaDevices.getUserMedia to open up
		 *          and external microphone or audio input. Check
		 *          [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)
		 *          to see which browsers are supported. Access to an external input
		 *          is limited to secure (HTTPS) connections.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Decibels=} volume The level of the input
		 *  @example
		 * //list the inputs and open the third one
		 * var motu = new Tone.UserMedia();
		 *
		 * //opening the input asks the user to activate their mic
		 * motu.open().then(function(){
		 * 	//opening is activates the microphone
		 * 	//starting lets audio through
		 * 	motu.start(10);
		 * });
		 */
	    Tone.UserMedia = function () {
	        var options = Tone.defaults(arguments, ['volume'], Tone.UserMedia);
	        Tone.AudioNode.call(this);
	        /**
			 *  The MediaStreamNode
			 *  @type {MediaStreamAudioSourceNode}
			 *  @private
			 */
	        this._mediaStream = null;
	        /**
			 *  The media stream created by getUserMedia.
			 *  @type {LocalMediaStream}
			 *  @private
			 */
	        this._stream = null;
	        /**
			 *  The open device
			 *  @type  {MediaDeviceInfo}
			 *  @private
			 */
	        this._device = null;
	        /**
			 *  The output volume node
			 *  @type  {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 * The volume of the output in decibels.
			 * @type {Decibels}
			 * @signal
			 * @example
			 * input.volume.value = -6;
			 */
	        this.volume = this._volume.volume;
	        this._readOnly('volume');
	        this.mute = options.mute;
	    };
	    Tone.extend(Tone.UserMedia, Tone.AudioNode);
	    /**
		 * the default parameters
		 * @type {Object}
		 */
	    Tone.UserMedia.defaults = {
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 *  Open the media stream. If a string is passed in, it is assumed
		 *  to be the label or id of the stream, if a number is passed in,
		 *  it is the input number of the stream.
		 *  @param  {String|Number} [labelOrId="default"] The label or id of the audio input media device.
		 *                                                With no argument, the default stream is opened.
		 *  @return {Promise} The promise is resolved when the stream is open.
		 */
	    Tone.UserMedia.prototype.open = function (labelOrId) {
	        labelOrId = Tone.defaultArg(labelOrId, 'default');
	        return Tone.UserMedia.enumerateDevices().then(function (devices) {
	            var device;
	            if (Tone.isNumber(labelOrId)) {
	                device = devices[labelOrId];
	            } else {
	                device = devices.find(function (device) {
	                    return device.label === labelOrId || device.deviceId === labelOrId;
	                });
	                //didn't find a matching device
	                if (!device) {
	                    throw new Error('Tone.UserMedia: no matching device: ' + labelOrId);
	                }
	            }
	            this._device = device;
	            //do getUserMedia
	            var constraints = {
	                audio: {
	                    'deviceId': device.deviceId,
	                    'echoCancellation': false,
	                    'sampleRate': this.context.sampleRate
	                }
	            };
	            return navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
	                //start a new source only if the previous one is closed
	                if (!this._stream) {
	                    this._stream = stream;
	                    //Wrap a MediaStreamSourceNode around the live input stream.
	                    this._mediaStream = this.context.createMediaStreamSource(stream);
	                    //Connect the MediaStreamSourceNode to a gate gain node
	                    this._mediaStream.connect(this.output);
	                }
	                return this;
	            }.bind(this));
	        }.bind(this));
	    };
	    /**
		 *  Close the media stream
		 *  @return {Tone.UserMedia} this
		 */
	    Tone.UserMedia.prototype.close = function () {
	        if (this._stream) {
	            this._stream.getAudioTracks().forEach(function (track) {
	                track.stop();
	            });
	            this._stream = null;
	            //remove the old media stream
	            this._mediaStream.disconnect();
	            this._mediaStream = null;
	        }
	        this._device = null;
	        return this;
	    };
	    /**
		 *  Returns a promise which resolves with the list of audio input devices available.
		 *  @return {Promise} The promise that is resolved with the devices
		 *  @static
		 *  @example
		 * Tone.UserMedia.enumerateDevices().then(function(devices){
		 * 	console.log(devices)
		 * })
		 */
	    Tone.UserMedia.enumerateDevices = function () {
	        return navigator.mediaDevices.enumerateDevices().then(function (devices) {
	            return devices.filter(function (device) {
	                return device.kind === 'audioinput';
	            });
	        });
	    };
	    /**
		 *  Returns the playback state of the source, "started" when the microphone is open
		 *  and "stopped" when the mic is closed.
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.UserMedia#
		 *  @name state
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'state', {
	        get: function () {
	            return this._stream && this._stream.active ? Tone.State.Started : Tone.State.Stopped;
	        }
	    });
	    /**
		 * 	Returns an identifier for the represented device that is
		 * 	persisted across sessions. It is un-guessable by other applications and
		 * 	unique to the origin of the calling application. It is reset when the
		 * 	user clears cookies (for Private Browsing, a different identifier is
		 * 	used that is not persisted across sessions). Returns undefined when the
		 * 	device is not open.
		 *  @type {String}
		 *  @readOnly
		 *  @memberOf Tone.UserMedia#
		 *  @name deviceId
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'deviceId', {
	        get: function () {
	            if (this._device) {
	                return this._device.deviceId;
	            }
	        }
	    });
	    /**
		 * 	Returns a group identifier. Two devices have the
		 * 	same group identifier if they belong to the same physical device.
		 * 	Returns undefined when the device is not open.
		 *  @type {String}
		 *  @readOnly
		 *  @memberOf Tone.UserMedia#
		 *  @name groupId
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'groupId', {
	        get: function () {
	            if (this._device) {
	                return this._device.groupId;
	            }
	        }
	    });
	    /**
		 * 	Returns a label describing this device (for example "Built-in Microphone").
		 * 	Returns undefined when the device is not open or label is not available
		 * 	because of permissions.
		 *  @type {String}
		 *  @readOnly
		 *  @memberOf Tone.UserMedia#
		 *  @name groupId
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'label', {
	        get: function () {
	            if (this._device) {
	                return this._device.label;
	            }
	        }
	    });
	    /**
		 * Mute the output.
		 * @memberOf Tone.UserMedia#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * userMedia.mute = true;
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 * Clean up.
		 * @return {Tone.UserMedia} this
		 */
	    Tone.UserMedia.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.close();
	        this._writable('volume');
	        this._volume.dispose();
	        this._volume = null;
	        this.volume = null;
	        return this;
	    };
	    /**
		 *  If getUserMedia is supported by the browser.
		 *  @type  {Boolean}
		 *  @memberOf Tone.UserMedia#
		 *  @name supported
		 *  @static
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.UserMedia, 'supported', {
	        get: function () {
	            return !Tone.isUndef(navigator.mediaDevices) && Tone.isFunction(navigator.mediaDevices.getUserMedia);
	        }
	    });
	    return Tone.UserMedia;
	});
	
	return Tone;
}));
},{}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var MANIFEST_FILE = 'manifest.json';
var CheckpointLoader = (function () {
    function CheckpointLoader(urlPath) {
        this.urlPath = urlPath;
        if (this.urlPath.charAt(this.urlPath.length - 1) !== '/') {
            this.urlPath += '/';
        }
    }
    CheckpointLoader.prototype.loadManifest = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', _this.urlPath + MANIFEST_FILE);
            xhr.onload = function () {
                _this.checkpointManifest = JSON.parse(xhr.responseText);
                resolve();
            };
            xhr.onerror = function (error) {
                throw new Error(MANIFEST_FILE + " not found at " + _this.urlPath + ". " + error);
            };
            xhr.send();
        });
    };
    CheckpointLoader.prototype.getCheckpointManifest = function () {
        var _this = this;
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    resolve(_this.checkpointManifest);
                });
            });
        }
        return new Promise(function (resolve, reject) {
            resolve(_this.checkpointManifest);
        });
    };
    CheckpointLoader.prototype.getAllVariables = function () {
        var _this = this;
        if (this.variables != null) {
            return new Promise(function (resolve, reject) {
                resolve(_this.variables);
            });
        }
        return new Promise(function (resolve, reject) {
            _this.getCheckpointManifest().then(function (checkpointDefinition) {
                var variableNames = Object.keys(_this.checkpointManifest);
                var variablePromises = [];
                for (var i = 0; i < variableNames.length; i++) {
                    variablePromises.push(_this.getVariable(variableNames[i]));
                }
                Promise.all(variablePromises).then(function (variables) {
                    _this.variables = {};
                    for (var i = 0; i < variables.length; i++) {
                        _this.variables[variableNames[i]] = variables[i];
                    }
                    resolve(_this.variables);
                });
            });
        });
    };
    CheckpointLoader.prototype.getVariable = function (varName) {
        var _this = this;
        if (!(varName in this.checkpointManifest)) {
            throw new Error('Cannot load non-existant variable ' + varName);
        }
        var variableRequestPromiseMethod = function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.responseType = 'arraybuffer';
            var fname = _this.checkpointManifest[varName].filename;
            xhr.open('GET', _this.urlPath + fname);
            xhr.onload = function () {
                var values = new Float32Array(xhr.response);
                var ndarray = ndarray_1.NDArray.make(_this.checkpointManifest[varName].shape, { values: values });
                resolve(ndarray);
            };
            xhr.onerror = function (error) {
                throw new Error('Could not fetch variable ' + varName + ': ' + error);
            };
            xhr.send();
        };
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    new Promise(variableRequestPromiseMethod).then(resolve);
                });
            });
        }
        return new Promise(variableRequestPromiseMethod);
    };
    return CheckpointLoader;
}());
exports.CheckpointLoader = CheckpointLoader;

},{"./math/ndarray":24}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var util = require("./util");
var STATS_SAMPLE_PERCENTAGE = 0.1;
var InMemoryDataset = (function () {
    function InMemoryDataset(dataShapes) {
        this.dataShapes = dataShapes;
        this.normalizationInfo = {};
    }
    InMemoryDataset.prototype.getDataShape = function (dataIndex) {
        return this.dataShapes[dataIndex];
    };
    InMemoryDataset.prototype.getData = function () {
        return this.dataset;
    };
    InMemoryDataset.prototype.getStats = function () {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        return this.dataset.map(function (d) { return _this.getStatsForData(d); });
    };
    InMemoryDataset.prototype.getStatsForData = function (data) {
        var inputMin = Number.POSITIVE_INFINITY;
        var inputMax = Number.NEGATIVE_INFINITY;
        var exampleIndices = data.map(function (example, i) { return i; });
        util.shuffle(exampleIndices);
        exampleIndices =
            exampleIndices.slice(exampleIndices.length * STATS_SAMPLE_PERCENTAGE);
        for (var i = 0; i < exampleIndices.length; i++) {
            var inputValues = data[exampleIndices[i]].getValues();
            for (var j = 0; j < inputValues.length; j++) {
                inputMin = Math.min(inputMin, inputValues[j]);
                inputMax = Math.max(inputMax, inputValues[j]);
            }
        }
        return {
            inputMin: inputMin,
            inputMax: inputMax,
            exampleCount: data.length,
            shape: data[0].shape,
        };
    };
    InMemoryDataset.prototype.normalizeExamplesToRange = function (examples, curLowerBounds, curUpperBounds, newLowerBounds, newUpperBounds) {
        var curBoundsIsPerDimension = (curUpperBounds instanceof Float32Array &&
            curLowerBounds instanceof Float32Array);
        var newBoundsIsPerDimension = (newLowerBounds instanceof Float32Array &&
            newUpperBounds instanceof Float32Array);
        var inputSize = util.sizeFromShape(examples[0].shape);
        var newExamples = [];
        examples.forEach(function (example) {
            var inputValues = example.getValues();
            var normalizedValues = new Float32Array(inputSize);
            for (var j = 0; j < inputSize; j++) {
                var curLowerBound = curBoundsIsPerDimension ?
                    curLowerBounds[j] :
                    curLowerBounds;
                var curUpperBound = curBoundsIsPerDimension ?
                    curUpperBounds[j] :
                    curUpperBounds;
                var curRange = curUpperBound - curLowerBound;
                var newLowerBound = newBoundsIsPerDimension ?
                    newLowerBounds[j] :
                    newLowerBounds;
                var newUpperBound = newBoundsIsPerDimension ?
                    newUpperBounds[j] :
                    newUpperBounds;
                var newRange = newUpperBound - newLowerBound;
                if (curRange === 0) {
                    normalizedValues[j] = newLowerBound;
                }
                else {
                    normalizedValues[j] = newLowerBound +
                        newRange * (inputValues[j] - curLowerBound) / curRange;
                }
            }
            newExamples.push(ndarray_1.NDArray.make(example.shape, { values: normalizedValues }));
        });
        return newExamples;
    };
    InMemoryDataset.prototype.computeBounds = function (dataIndex) {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        var size = util.sizeFromShape(this.dataset[dataIndex][0].shape);
        this.normalizationInfo[dataIndex] = {
            isNormalized: false,
            minValues: new Float32Array(size),
            maxValues: new Float32Array(size)
        };
        for (var i = 0; i < size; i++) {
            this.normalizationInfo[dataIndex].minValues[i] = Number.POSITIVE_INFINITY;
            this.normalizationInfo[dataIndex].maxValues[i] = Number.NEGATIVE_INFINITY;
        }
        this.dataset[dataIndex].forEach(function (example) {
            var inputValues = example.getValues();
            for (var k = 0; k < size; k++) {
                _this.normalizationInfo[dataIndex].minValues[k] = Math.min(_this.normalizationInfo[dataIndex].minValues[k], inputValues[k]);
                _this.normalizationInfo[dataIndex].maxValues[k] = Math.max(_this.normalizationInfo[dataIndex].maxValues[k], inputValues[k]);
            }
        });
    };
    InMemoryDataset.prototype.normalizeWithinBounds = function (dataIndex, lowerBound, upperBound) {
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        if (dataIndex >= this.dataset.length) {
            throw new Error('dataIndex out of bounds.');
        }
        if (this.normalizationInfo[dataIndex] == null) {
            this.computeBounds(dataIndex);
        }
        var curLowerBounds;
        var curUpperBounds;
        if (this.normalizationInfo[dataIndex].isNormalized) {
            curLowerBounds = this.normalizationInfo[dataIndex].lowerBound;
            curUpperBounds = this.normalizationInfo[dataIndex].upperBound;
        }
        else {
            curLowerBounds = this.normalizationInfo[dataIndex].minValues;
            curUpperBounds = this.normalizationInfo[dataIndex].maxValues;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], curLowerBounds, curUpperBounds, lowerBound, upperBound);
        this.normalizationInfo[dataIndex].isNormalized = true;
        this.normalizationInfo[dataIndex].lowerBound = lowerBound;
        this.normalizationInfo[dataIndex].upperBound = upperBound;
    };
    InMemoryDataset.prototype.isNormalized = function (dataIndex) {
        return this.normalizationInfo != null &&
            this.normalizationInfo[dataIndex].isNormalized;
    };
    InMemoryDataset.prototype.removeNormalization = function (dataIndex) {
        if (this.dataset == null) {
            throw new Error('Training or test data is null.');
        }
        if (!this.isNormalized(dataIndex)) {
            return;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
        this.normalizationInfo[dataIndex].isNormalized = false;
    };
    InMemoryDataset.prototype.unnormalizeExamples = function (examples, dataIndex) {
        if (!this.isNormalized(dataIndex)) {
            return examples;
        }
        return this.normalizeExamplesToRange(examples, this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
    };
    InMemoryDataset.prototype.dispose = function () {
        if (this.dataset == null) {
            return;
        }
        for (var i = 0; i < this.dataset.length; i++) {
            for (var j = 0; j < this.dataset[i].length; j++) {
                this.dataset[i][j].dispose();
            }
        }
        this.dataset = [];
    };
    return InMemoryDataset;
}());
exports.InMemoryDataset = InMemoryDataset;

},{"./math/ndarray":24,"./util":81}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_layers_1 = require("./graph_layers");
var concat3d_util = require("./math/concat3d_util");
var conv_util = require("./math/conv_util");
var ndarray_1 = require("./math/ndarray");
var util = require("./util");
var Graph = (function () {
    function Graph() {
        this.nodes = [];
        this.layers = new graph_layers_1.GraphLayers(this);
    }
    Graph.prototype.variable = function (name, data) {
        return this.addNodeAndReturnOutput(new VariableNode(this, name, data));
    };
    Graph.prototype.placeholder = function (name, shape) {
        return this.addNodeAndReturnOutput(new PlaceholderNode(this, name, shape));
    };
    Graph.prototype.constant = function (value) {
        var finalValue;
        if (typeof value === 'number') {
            finalValue = ndarray_1.Scalar.new(value);
        }
        else if (value instanceof ndarray_1.NDArray) {
            finalValue = value;
        }
        else if (value instanceof Array) {
            var vals = new Float32Array(util.flatten(value));
            finalValue = ndarray_1.NDArray.make(util.inferShape(value), { values: vals });
        }
        else {
            throw new Error('unimplemented constant type.');
        }
        return this.addNodeAndReturnOutput(new ConstantNode(this, finalValue));
    };
    Graph.prototype.reshape = function (x, shape) {
        return this.addNodeAndReturnOutput(new ReshapeNode(this, 'Reshape', x, shape));
    };
    Graph.prototype.fusedLinearCombination = function (x1, x2, c1, c2) {
        return this.addNodeAndReturnOutput(new FusedLinearCombinationNode(this, x1, x2, c1, c2));
    };
    Graph.prototype.add = function (x1, x2) {
        return this.addNodeAndReturnOutput(new AddNode(this, x1, x2));
    };
    Graph.prototype.subtract = function (x1, x2) {
        return this.addNodeAndReturnOutput(new SubtractNode(this, x1, x2));
    };
    Graph.prototype.multiply = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MultiplyNode(this, x1, x2));
    };
    Graph.prototype.divide = function (x1, x2) {
        return this.addNodeAndReturnOutput(new DivideNode(this, x1, x2));
    };
    Graph.prototype.reduceSum = function (x) {
        return this.addNodeAndReturnOutput(new ReduceSumNode(this, x));
    };
    Graph.prototype.concat3d = function (x1, x2, axis) {
        return this.addNodeAndReturnOutput(new Concat3DNode(this, x1, x2, axis));
    };
    Graph.prototype.matmul = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MatMulNode(this, x1, x2));
    };
    Graph.prototype.conv2d = function (x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new Convolution2DNode(this, x, w, b, fieldSize, outputDepth, stride, zeroPad));
    };
    Graph.prototype.maxPool = function (x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new MaxPoolNode(this, x, fieldSize, stride, zeroPad));
    };
    Graph.prototype.exp = function (x) {
        return this.addNodeAndReturnOutput(new ExpNode(this, x));
    };
    Graph.prototype.log = function (x) {
        return this.addNodeAndReturnOutput(new LogNode(this, x));
    };
    Graph.prototype.relu = function (x) {
        return this.addNodeAndReturnOutput(new ReLUNode(this, x));
    };
    Graph.prototype.tanh = function (x) {
        return this.addNodeAndReturnOutput(new TanHNode(this, x));
    };
    Graph.prototype.sigmoid = function (x) {
        return this.addNodeAndReturnOutput(new SigmoidNode(this, x));
    };
    Graph.prototype.square = function (x) {
        return this.addNodeAndReturnOutput(new SquareNode(this, x));
    };
    Graph.prototype.softmax = function (x) {
        return this.addNodeAndReturnOutput(new SoftmaxNode(this, x));
    };
    Graph.prototype.softmaxCrossEntropyCost = function (x, target) {
        return this.addNodeAndReturnOutput(new SoftmaxCrossEntropyCostNode(this, x, target));
    };
    Graph.prototype.meanSquaredCost = function (label, prediction) {
        return this.addNodeAndReturnOutput(new MeanSquaredCostNode(this, label, prediction));
    };
    Graph.prototype.argmax = function (x) {
        return this.addNodeAndReturnOutput(new ArgMaxNode(this, x));
    };
    Graph.prototype.argmaxEquals = function (x1, x2) {
        return this.addNodeAndReturnOutput(new ArgMaxEqualsNode(this, x1, x2));
    };
    Graph.prototype.addNodeAndReturnOutput = function (node) {
        this.nodes.push(node);
        node.validate();
        return node.output;
    };
    Graph.prototype.getNodes = function () {
        return this.nodes;
    };
    return Graph;
}());
exports.Graph = Graph;
var Tensor = (function () {
    function Tensor(shape) {
        this.shape = shape;
        this.id = Tensor.nextID++;
    }
    Tensor.nextID = 0;
    return Tensor;
}());
exports.Tensor = Tensor;
var Node = (function () {
    function Node(graph, name, inputs, output) {
        this.graph = graph;
        this.name = name;
        this.inputs = inputs;
        this.output = output;
        this.id = Node.nextID++;
        output.node = this;
    }
    Node.nextID = 0;
    return Node;
}());
exports.Node = Node;
var VariableNode = (function (_super) {
    __extends(VariableNode, _super);
    function VariableNode(graph, name, data) {
        var _this = _super.call(this, graph, name, {}, new Tensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    VariableNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding variable op: Data for variable \'' + this.name +
            '\' is null or undefined');
    };
    return VariableNode;
}(Node));
exports.VariableNode = VariableNode;
var PlaceholderNode = (function (_super) {
    __extends(PlaceholderNode, _super);
    function PlaceholderNode(graph, name, shape) {
        return _super.call(this, graph, name, {}, new Tensor(shape)) || this;
    }
    PlaceholderNode.prototype.validate = function () { };
    return PlaceholderNode;
}(Node));
exports.PlaceholderNode = PlaceholderNode;
var ConstantNode = (function (_super) {
    __extends(ConstantNode, _super);
    function ConstantNode(graph, data) {
        var _this = _super.call(this, graph, 'Constant', {}, new Tensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    ConstantNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding constant: data for placeholder \'' + this.name +
            '\' is null or undefined');
    };
    return ConstantNode;
}(Node));
exports.ConstantNode = ConstantNode;
var ReshapeNode = (function (_super) {
    __extends(ReshapeNode, _super);
    function ReshapeNode(graph, name, x, shape) {
        var _this = _super.call(this, graph, name, { x: x }, new Tensor(shape)) || this;
        _this.name = name;
        _this.x = x;
        _this.shape = shape;
        return _this;
    }
    ReshapeNode.prototype.validate = function () {
        var xSize = util.sizeFromShape(this.x.shape);
        var shapeSize = util.sizeFromShape(this.shape);
        util.assert(xSize === shapeSize, 'Error making reshape operation: input Tensor to reshape \'' +
            this.name + '\' of shape (' + this.x.shape +
            ') does not match size of requested shape ' + this.shape + '.');
    };
    ReshapeNode.X = 'x';
    return ReshapeNode;
}(Node));
exports.ReshapeNode = ReshapeNode;
var FusedLinearCombinationNode = (function (_super) {
    __extends(FusedLinearCombinationNode, _super);
    function FusedLinearCombinationNode(graph, t1, t2, c1, c2) {
        var _this = _super.call(this, graph, 'Linear Combination', { t1: t1, t2: t2, c1: c1, c2: c2 }, new Tensor(t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.c1 = c1;
        _this.c2 = c2;
        return _this;
    }
    FusedLinearCombinationNode.prototype.validate = function () {
        util.assertShapesMatch(this.t1.shape, this.t2.shape);
        if (!util.isScalarShape(this.c1.shape)) {
            throw new Error('Error adding fusedLinearCombination: c1 is not a scalar, got ' +
                'shape: ' + this.c1.shape);
        }
        if (!util.isScalarShape(this.c2.shape)) {
            throw new Error('Error adding fusedLinearCombination: c2 is not a scalar, got ' +
                'shape: ' + this.c2.shape);
        }
    };
    FusedLinearCombinationNode.T1 = 't1';
    FusedLinearCombinationNode.T2 = 't2';
    FusedLinearCombinationNode.C1 = 'c1';
    FusedLinearCombinationNode.C2 = 'c2';
    return FusedLinearCombinationNode;
}(Node));
exports.FusedLinearCombinationNode = FusedLinearCombinationNode;
var AddNode = (function (_super) {
    __extends(AddNode, _super);
    function AddNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Add', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    AddNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding add operation op: one of inputs must be scalar or the ' +
            'shapes ' + this.t1.shape + ' and ' + this.t2.shape +
            ' must match.');
    };
    AddNode.T1 = 't1';
    AddNode.T2 = 't2';
    return AddNode;
}(Node));
exports.AddNode = AddNode;
var SubtractNode = (function (_super) {
    __extends(SubtractNode, _super);
    function SubtractNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Subtract', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    SubtractNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding subtract op: one of inputs must be scalar or the ' +
            'shapes ' + this.t1.shape + ' and ' + this.t2.shape +
            ' must match.');
    };
    SubtractNode.T1 = 't1';
    SubtractNode.T2 = 't2';
    return SubtractNode;
}(Node));
exports.SubtractNode = SubtractNode;
var MultiplyNode = (function (_super) {
    __extends(MultiplyNode, _super);
    function MultiplyNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Multiply', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    MultiplyNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding multiply op: one of inputs must be scalar or the ' +
            'shapes ' + this.t1.shape + ' and ' + this.t2.shape +
            ' must match.');
    };
    MultiplyNode.T1 = 't1';
    MultiplyNode.T2 = 't2';
    return MultiplyNode;
}(Node));
exports.MultiplyNode = MultiplyNode;
var DivideNode = (function (_super) {
    __extends(DivideNode, _super);
    function DivideNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Divide', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    DivideNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding divide op: one of inputs must be scalar or the ' +
            'shapes ' + this.t1.shape + ' and ' + this.t2.shape +
            ' must match.');
    };
    DivideNode.T1 = 't1';
    DivideNode.T2 = 't2';
    return DivideNode;
}(Node));
exports.DivideNode = DivideNode;
var ReduceSumNode = (function (_super) {
    __extends(ReduceSumNode, _super);
    function ReduceSumNode(graph, x) {
        return _super.call(this, graph, 'ReduceSum', { x: x }, new Tensor([])) || this;
    }
    ReduceSumNode.prototype.validate = function () { };
    ReduceSumNode.X = 'x';
    return ReduceSumNode;
}(Node));
exports.ReduceSumNode = ReduceSumNode;
var Concat3DNode = (function (_super) {
    __extends(Concat3DNode, _super);
    function Concat3DNode(graph, x1, x2, axis) {
        var _this = _super.call(this, graph, 'Concat3D', { x1: x1, x2: x2 }, new Tensor(concat3d_util.computeConcat3DOutputShape(x1.shape, x2.shape, axis))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        _this.axis = axis;
        return _this;
    }
    Concat3DNode.prototype.validate = function () {
        concat3d_util.assertConcat3DShapesMatch(this.x1.shape, this.x2.shape, this.axis);
    };
    Concat3DNode.X1 = 'x1';
    Concat3DNode.X2 = 'x2';
    Concat3DNode.AXIS = 'axis';
    return Concat3DNode;
}(Node));
exports.Concat3DNode = Concat3DNode;
function getMatMulOutputShape(x1Shape, x2Shape) {
    if (x1Shape.length === 1 && x2Shape.length === 1) {
        return [1];
    }
    else if (x1Shape.length === 1 && x2Shape.length === 2) {
        return [x2Shape[1]];
    }
    else if (x1Shape.length === 2 && x2Shape.length === 1) {
        return [x1Shape[0]];
    }
    return [x1Shape[0], x2Shape[1]];
}
var MatMulNode = (function (_super) {
    __extends(MatMulNode, _super);
    function MatMulNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'MatMul', { x1: x1, x2: x2 }, new Tensor(getMatMulOutputShape(x1.shape, x2.shape))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    MatMulNode.prototype.validate = function () {
        if (this.x1.shape.length === 2 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: inner shapes of matrices with shapes ' +
                this.x1.shape + ' and ' + this.x2.shape + ' must match.');
        }
        else if (this.x1.shape.length === 2 && this.x2.shape.length === 1) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: second dimension of matrix with shape ' +
                this.x1.shape + ' must match size of vector with shape ' +
                this.x2.shape + '.');
        }
        else if (this.x1.shape.length === 1 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[0] === this.x2.shape[0], 'Error adding matmul op: size of vector with shape ' + this.x1.shape +
                ' must match first dimension of matrix with ' +
                'shape ' + this.x2.shape + '.');
        }
        else {
            throw new Error('Error adding matmul op: inputs must be vectors or matrices.');
        }
    };
    MatMulNode.X1 = 'x1';
    MatMulNode.X2 = 'x2';
    return MatMulNode;
}(Node));
exports.MatMulNode = MatMulNode;
var Convolution2DNode = (function (_super) {
    __extends(Convolution2DNode, _super);
    function Convolution2DNode(graph, x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Convolution 2D', { x: x, w: w, b: b }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, outputDepth, stride, zeroPad))) || this;
        _this.x = x;
        _this.w = w;
        _this.b = b;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    Convolution2DNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding conv2d op: input must be of rank 3, but got shape: ' +
            this.x.shape + '.');
        util.assert(this.w.shape.length === 4, 'Error adding conv2d op: weights must be of rank 4, but got shape: ' +
            this.w.shape + '.');
        util.assert(this.b.shape.length === 1, 'Error adding conv2d op: biases must be of rank 1, but got shape: ' +
            this.b.shape + '.');
        util.assert(this.x.shape[2] === this.w.shape[2], 'Error adding conv2d op: depth of input (' + this.x.shape[2] +
            ') must match input depth for weights (' + this.w.shape[2] + ').');
    };
    Convolution2DNode.X = 'x';
    Convolution2DNode.W = 'w';
    Convolution2DNode.B = 'b';
    return Convolution2DNode;
}(Node));
exports.Convolution2DNode = Convolution2DNode;
var MaxPoolNode = (function (_super) {
    __extends(MaxPoolNode, _super);
    function MaxPoolNode(graph, x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Max pool', { x: x }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, x.shape[2], stride, zeroPad))) || this;
        _this.x = x;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    MaxPoolNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding maxPool op: input must be of rank 3, but got shape: ' +
            this.x.shape + '.');
    };
    MaxPoolNode.X = 'x';
    return MaxPoolNode;
}(Node));
exports.MaxPoolNode = MaxPoolNode;
var ReLUNode = (function (_super) {
    __extends(ReLUNode, _super);
    function ReLUNode(graph, x) {
        return _super.call(this, graph, 'ReLU', { x: x }, new Tensor(x.shape)) || this;
    }
    ReLUNode.prototype.validate = function () { };
    ReLUNode.X = 'x';
    return ReLUNode;
}(Node));
exports.ReLUNode = ReLUNode;
var ExpNode = (function (_super) {
    __extends(ExpNode, _super);
    function ExpNode(graph, x) {
        return _super.call(this, graph, 'Exp', { x: x }, new Tensor(x.shape)) || this;
    }
    ExpNode.prototype.validate = function () { };
    ExpNode.X = 'x';
    return ExpNode;
}(Node));
exports.ExpNode = ExpNode;
var LogNode = (function (_super) {
    __extends(LogNode, _super);
    function LogNode(graph, x) {
        return _super.call(this, graph, 'Log', { x: x }, new Tensor(x.shape)) || this;
    }
    LogNode.prototype.validate = function () { };
    LogNode.X = 'x';
    return LogNode;
}(Node));
exports.LogNode = LogNode;
var TanHNode = (function (_super) {
    __extends(TanHNode, _super);
    function TanHNode(graph, x) {
        return _super.call(this, graph, 'TanH', { x: x }, new Tensor(x.shape)) || this;
    }
    TanHNode.prototype.validate = function () { };
    TanHNode.X = 'x';
    return TanHNode;
}(Node));
exports.TanHNode = TanHNode;
var SigmoidNode = (function (_super) {
    __extends(SigmoidNode, _super);
    function SigmoidNode(graph, x) {
        return _super.call(this, graph, 'Sigmoid', { x: x }, new Tensor(x.shape)) || this;
    }
    SigmoidNode.prototype.validate = function () { };
    SigmoidNode.X = 'x';
    return SigmoidNode;
}(Node));
exports.SigmoidNode = SigmoidNode;
var SquareNode = (function (_super) {
    __extends(SquareNode, _super);
    function SquareNode(graph, x) {
        return _super.call(this, graph, 'Square', { x: x }, new Tensor(x.shape)) || this;
    }
    SquareNode.prototype.validate = function () { };
    SquareNode.X = 'x';
    return SquareNode;
}(Node));
exports.SquareNode = SquareNode;
var SoftmaxCrossEntropyCostNode = (function (_super) {
    __extends(SoftmaxCrossEntropyCostNode, _super);
    function SoftmaxCrossEntropyCostNode(graph, x, target) {
        var _this = _super.call(this, graph, 'SoftmaxCrossEntropyCost', { x: x, target: target }, new Tensor([])) || this;
        _this.x = x;
        _this.target = target;
        return _this;
    }
    SoftmaxCrossEntropyCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x.shape, this.target.shape), 'Error adding softmaxCrossEntropyCost op: x shape (' + this.x.shape +
            ') must match target shape (' + this.target.shape + ').');
    };
    SoftmaxCrossEntropyCostNode.X = 'x';
    SoftmaxCrossEntropyCostNode.TARGET = 'target';
    return SoftmaxCrossEntropyCostNode;
}(Node));
exports.SoftmaxCrossEntropyCostNode = SoftmaxCrossEntropyCostNode;
var SoftmaxNode = (function (_super) {
    __extends(SoftmaxNode, _super);
    function SoftmaxNode(graph, x) {
        var _this = _super.call(this, graph, 'Softmax', { x: x }, new Tensor(x.shape)) || this;
        _this.x = x;
        return _this;
    }
    SoftmaxNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 1, 'The input to a softmax must be a 1-D tensor');
        util.assert(this.x.shape[0] >= 2, 'The input to a softmax must have at least 2 values');
    };
    SoftmaxNode.X = 'x';
    return SoftmaxNode;
}(Node));
exports.SoftmaxNode = SoftmaxNode;
var MeanSquaredCostNode = (function (_super) {
    __extends(MeanSquaredCostNode, _super);
    function MeanSquaredCostNode(graph, label, prediction) {
        var _this = _super.call(this, graph, 'Mean Squared Cost', { label: label, prediction: prediction }, new Tensor([])) || this;
        _this.label = label;
        _this.prediction = prediction;
        return _this;
    }
    MeanSquaredCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.label.shape, this.prediction.shape), 'Error adding meanSquaredCost op: label shape (' + this.label.shape +
            ') must match prediction shape (' + this.prediction.shape + ').');
    };
    MeanSquaredCostNode.LABEL = 'label';
    MeanSquaredCostNode.PREDICTION = 'prediction';
    return MeanSquaredCostNode;
}(Node));
exports.MeanSquaredCostNode = MeanSquaredCostNode;
var ArgMaxNode = (function (_super) {
    __extends(ArgMaxNode, _super);
    function ArgMaxNode(graph, x) {
        var _this = _super.call(this, graph, 'ArgMax', { x: x }, new Tensor([1])) || this;
        _this.x = x;
        return _this;
    }
    ArgMaxNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.x.shape) > 0, 'Error adding argmax op: input tensor must have at least one entry.');
    };
    ArgMaxNode.X = 'x';
    return ArgMaxNode;
}(Node));
exports.ArgMaxNode = ArgMaxNode;
var ArgMaxEqualsNode = (function (_super) {
    __extends(ArgMaxEqualsNode, _super);
    function ArgMaxEqualsNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'ArgMaxEquals', { x1: x1, x2: x2 }, new Tensor([1])) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    ArgMaxEqualsNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x1.shape, this.x2.shape), 'Error adding ArgMaxEquals op: x1 shape (' + this.x1.shape +
            ') must match x2 shape (' + this.x2.shape + ').');
    };
    ArgMaxEqualsNode.X1 = 'x1';
    ArgMaxEqualsNode.X2 = 'x2';
    return ArgMaxEqualsNode;
}(Node));
exports.ArgMaxEqualsNode = ArgMaxEqualsNode;
var SplitNode = (function (_super) {
    __extends(SplitNode, _super);
    function SplitNode(graph, x) {
        var _this = _super.call(this, graph, 'SplitNode', { x: x }, new Tensor(x.shape)) || this;
        _this.outputs = [];
        return _this;
    }
    SplitNode.prototype.getNewOutputTensor = function () {
        var output = new Tensor(this.inputs[SplitNode.X].shape);
        output.node = this;
        this.outputs.push(output);
        return output;
    };
    SplitNode.prototype.validate = function () { };
    SplitNode.X = 'x';
    return SplitNode;
}(Node));
exports.SplitNode = SplitNode;

},{"./graph_layers":10,"./math/concat3d_util":17,"./math/conv_util":18,"./math/ndarray":24,"./util":81}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var initializers_1 = require("./initializers");
var GraphLayers = (function () {
    function GraphLayers(g) {
        this.g = g;
    }
    GraphLayers.prototype.dense = function (name, x, units, activation, useBias, kernelInitializer, biasInitializer) {
        if (activation === void 0) { activation = null; }
        if (useBias === void 0) { useBias = true; }
        if (kernelInitializer === void 0) { kernelInitializer = new initializers_1.VarianceScalingInitializer(); }
        if (biasInitializer === void 0) { biasInitializer = new initializers_1.ZerosInitializer(); }
        var weights = this.g.variable(name + '-weights', kernelInitializer.initialize([x.shape[0], units], x.shape[0], units));
        var out = this.g.matmul(x, weights);
        if (useBias) {
            var bias = this.g.variable(name + '-bias', biasInitializer.initialize([units], x.shape[0], units));
            out = this.g.add(out, bias);
        }
        if (activation != null) {
            out = activation(out);
        }
        return out;
    };
    return GraphLayers;
}());
exports.GraphLayers = GraphLayers;

},{"./initializers":14}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var session_1 = require("./session");
var DEFAULT_EVAL_INTERVAL_MS = 1500;
var DEFAULT_COST_INTERVAL_MS = 500;
var DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS = 3000;
var MetricReduction;
(function (MetricReduction) {
    MetricReduction[MetricReduction["SUM"] = 0] = "SUM";
    MetricReduction[MetricReduction["MEAN"] = 1] = "MEAN";
})(MetricReduction = exports.MetricReduction || (exports.MetricReduction = {}));
var GraphRunner = (function () {
    function GraphRunner(math, session, eventObserver) {
        this.math = math;
        this.session = session;
        this.eventObserver = eventObserver;
        this.lastCostTimestamp = 0;
        this.lastEvalTimestamp = 0;
        this.totalIdleTimeMs = 0;
        this.resetStatistics();
        this.zeroScalar = ndarray_1.Scalar.new(0);
    }
    GraphRunner.prototype.resetStatistics = function () {
        this.totalBatchesTrained = 0;
        this.totalIdleTimeMs = 0;
        this.lastStopTimestamp = null;
    };
    GraphRunner.prototype.train = function (costTensor, trainFeedEntries, batchSize, optimizer, numBatches, metricTensor, metricFeedEntries, metricBatchSize, metricReduction, evalIntervalMs, costIntervalMs) {
        if (metricReduction === void 0) { metricReduction = MetricReduction.MEAN; }
        if (evalIntervalMs === void 0) { evalIntervalMs = DEFAULT_EVAL_INTERVAL_MS; }
        if (costIntervalMs === void 0) { costIntervalMs = DEFAULT_COST_INTERVAL_MS; }
        this.costTensor = costTensor;
        this.trainFeedEntries = trainFeedEntries;
        this.metricTensor = metricTensor;
        this.metricFeedEntries = metricFeedEntries;
        if (metricBatchSize != null && this.metricBatchSize !== metricBatchSize) {
            if (this.metricBatchSizeScalar != null) {
                this.metricBatchSizeScalar.dispose();
            }
            this.metricBatchSizeScalar = ndarray_1.Scalar.new(metricBatchSize);
        }
        this.metricBatchSize = metricBatchSize;
        this.metricReduction = metricReduction;
        this.batchSize = batchSize;
        this.optimizer = optimizer;
        this.metricIntervalMs = evalIntervalMs;
        this.costIntervalMs = costIntervalMs;
        this.currentTrainLoopNumBatches = numBatches;
        this.batchesTrainedThisRun = 0;
        this.isTraining = true;
        this.trainStartTimestamp = performance.now();
        this.trainNetwork();
    };
    GraphRunner.prototype.stopTraining = function () {
        this.isTraining = false;
        this.lastStopTimestamp = performance.now();
    };
    GraphRunner.prototype.resumeTraining = function () {
        this.isTraining = true;
        if (this.lastStopTimestamp != null) {
            this.totalIdleTimeMs += performance.now() - this.lastStopTimestamp;
        }
        this.trainNetwork();
    };
    GraphRunner.prototype.trainNetwork = function () {
        var _this = this;
        if (this.batchesTrainedThisRun === this.currentTrainLoopNumBatches) {
            this.stopTraining();
        }
        if (!this.isTraining) {
            if (this.eventObserver.doneTrainingCallback != null) {
                this.eventObserver.doneTrainingCallback();
            }
            return;
        }
        var start = performance.now();
        var shouldComputeCost = this.eventObserver.avgCostCallback != null &&
            (start - this.lastCostTimestamp > this.costIntervalMs);
        if (shouldComputeCost) {
            this.lastCostTimestamp = start;
        }
        var costReduction = shouldComputeCost ? session_1.CostReduction.MEAN : session_1.CostReduction.NONE;
        this.math.scope(function (keep) {
            var avgCost = _this.session.train(_this.costTensor, _this.trainFeedEntries, _this.batchSize, _this.optimizer, costReduction);
            if (shouldComputeCost) {
                var trainTime = performance.now() - start;
                _this.eventObserver.avgCostCallback(avgCost);
                if (_this.eventObserver.trainExamplesPerSecCallback != null) {
                    var examplesPerSec = (_this.batchSize * 1000 / trainTime);
                    _this.eventObserver.trainExamplesPerSecCallback(examplesPerSec);
                }
            }
            if (_this.eventObserver.metricCallback != null &&
                _this.metricFeedEntries != null &&
                start - _this.lastEvalTimestamp > _this.metricIntervalMs) {
                _this.lastEvalTimestamp = start;
                if (_this.lastComputedMetric != null) {
                    _this.lastComputedMetric.dispose();
                }
                _this.lastComputedMetric = _this.computeMetric();
                _this.eventObserver.metricCallback(_this.lastComputedMetric);
            }
            if (_this.eventObserver.totalTimeCallback != null) {
                _this.eventObserver.totalTimeCallback((start - _this.trainStartTimestamp) / 1000);
            }
            _this.batchesTrainedThisRun++;
            _this.totalBatchesTrained++;
            if (_this.eventObserver.batchesTrainedCallback != null) {
                _this.eventObserver.batchesTrainedCallback(_this.totalBatchesTrained);
            }
        });
        setTimeout(function () { return _this.trainNetwork(); });
    };
    GraphRunner.prototype.infer = function (inferenceTensor, inferenceFeedEntries, inferenceExampleIntervalMs, inferenceExampleCount, numPasses) {
        var _this = this;
        if (inferenceExampleIntervalMs === void 0) { inferenceExampleIntervalMs = DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS; }
        if (inferenceExampleCount === void 0) { inferenceExampleCount = 5; }
        if (this.eventObserver.inferenceExamplesCallback == null &&
            this.eventObserver.inferenceExamplesPerSecCallback == null) {
            throw new Error('Cannot start inference loop, no inference example or ' +
                'examples/sec observer provided.');
        }
        for (var i = 0; i < inferenceFeedEntries.length; i++) {
            var feedEntry = inferenceFeedEntries[i];
            if (feedEntry.data instanceof ndarray_1.NDArray) {
                throw new Error('Cannot start inference on the model runner with feed entries of ' +
                    'type NDArray. Please use InputProviders.');
            }
        }
        this.inferenceExampleIntervalMs = inferenceExampleIntervalMs;
        this.inferenceTensor = inferenceTensor;
        this.inferenceFeedEntries = inferenceFeedEntries;
        this.inferenceExampleCount = inferenceExampleCount;
        this.currentInferenceLoopNumPasses = numPasses;
        if (!this.isInferring) {
            this.inferencePassesThisRun = 0;
            setTimeout(function () { return _this.inferNetwork(); });
        }
        this.isInferring = true;
    };
    GraphRunner.prototype.inferNetwork = function () {
        var _this = this;
        if (!this.isInferring ||
            this.inferencePassesThisRun === this.currentInferenceLoopNumPasses) {
            return;
        }
        this.math.scope(function (keep, track) {
            var feeds = [];
            var inferenceValues = [];
            var start = performance.now();
            for (var i = 0; i < _this.inferenceExampleCount; i++) {
                var ndarrayFeedEntries = [];
                for (var j = 0; j < _this.inferenceFeedEntries.length; j++) {
                    var feedEntry = _this.inferenceFeedEntries[j];
                    ndarrayFeedEntries.push({
                        tensor: feedEntry.tensor,
                        data: track(feedEntry.data.getNextCopy(_this.math))
                    });
                }
                feeds.push(ndarrayFeedEntries);
                inferenceValues.push(_this.session.eval(_this.inferenceTensor, ndarrayFeedEntries));
            }
            if (_this.eventObserver.inferenceExamplesPerSecCallback != null) {
                inferenceValues[inferenceValues.length - 1].getValues();
                var inferenceExamplesPerSecTime = performance.now() - start;
                var examplesPerSec = (_this.inferenceExampleCount * 1000 / inferenceExamplesPerSecTime);
                _this.eventObserver.inferenceExamplesPerSecCallback(examplesPerSec);
            }
            if (_this.eventObserver.inferenceExamplesCallback != null) {
                _this.eventObserver.inferenceExamplesCallback(feeds, inferenceValues);
            }
            _this.inferencePassesThisRun++;
        });
        setTimeout(function () { return _this.inferNetwork(); }, this.inferenceExampleIntervalMs);
    };
    GraphRunner.prototype.stopInferring = function () {
        this.isInferring = false;
    };
    GraphRunner.prototype.isInferenceRunning = function () {
        return this.isInferring;
    };
    GraphRunner.prototype.computeMetric = function () {
        var _this = this;
        if (this.metricFeedEntries == null) {
            throw new Error('Cannot compute metric, no metric FeedEntries provided.');
        }
        var metric = this.zeroScalar;
        return this.math.scope(function (keep) {
            for (var i = 0; i < _this.metricBatchSize; i++) {
                var metricValue = _this.session.eval(_this.metricTensor, _this.metricFeedEntries);
                metric = _this.math.add(metric, metricValue);
            }
            if (_this.metricReduction === MetricReduction.MEAN) {
                metric = _this.math.divide(metric, _this.metricBatchSizeScalar);
            }
            return metric;
        });
    };
    GraphRunner.prototype.getTotalBatchesTrained = function () {
        return this.totalBatchesTrained;
    };
    GraphRunner.prototype.getLastComputedMetric = function () {
        return this.lastComputedMetric;
    };
    GraphRunner.prototype.setMath = function (math) {
        this.math = math;
    };
    GraphRunner.prototype.setSession = function (session) {
        this.session = session;
    };
    GraphRunner.prototype.setInferenceTensor = function (inferenceTensor) {
        this.inferenceTensor = inferenceTensor;
    };
    GraphRunner.prototype.setInferenceExampleCount = function (inferenceExampleCount) {
        this.inferenceExampleCount = inferenceExampleCount;
    };
    return GraphRunner;
}());
exports.GraphRunner = GraphRunner;

},{"./math/ndarray":24,"./session":77}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var priority_queue = require("./priority_queue");
var priority_queue_1 = require("./priority_queue");
function getUnorderedEvaluationSet(nodes, terminatingNodes) {
    var terminatingNodeMap = {};
    var seen = {};
    var set = [];
    var visit = nodes.slice();
    terminatingNodes.forEach(function (node) { return terminatingNodeMap[node.id] = node; });
    var _loop_1 = function () {
        var cur = visit.pop();
        if (seen[cur.id] == null) {
            if (terminatingNodeMap[cur.id] == null) {
                Object.keys(cur.inputs)
                    .map(function (inputName) { return cur.inputs[inputName]; })
                    .forEach(function (input) { return visit.push(input.node); });
            }
            set.push(cur);
            seen[cur.id] = cur;
        }
    };
    while (visit.length !== 0) {
        _loop_1();
    }
    return set;
}
exports.getUnorderedEvaluationSet = getUnorderedEvaluationSet;
function getOrderedEvaluationSet(unorderedEvaluationSet) {
    var set = [];
    var nodeIndices = {};
    var pendingDependencies = {};
    var nodeQueue = new priority_queue_1.PriorityQueue(function (a, b) { return priority_queue.defaultCompare(pendingDependencies[a.id], pendingDependencies[b.id]); }, function (node, newIndex) { return nodeIndices[node.id] = newIndex; });
    unorderedEvaluationSet.forEach(function (node) { return pendingDependencies[node.id] = 0; });
    unorderedEvaluationSet.forEach(function (node) { return Object.keys(node.inputs)
        .map(function (key) { return node.inputs[key]; })
        .forEach(function (input) {
        if (unorderedEvaluationSet.indexOf(input.node) !== -1) {
            pendingDependencies[input.node.id]++;
        }
    }); });
    unorderedEvaluationSet.forEach(function (node) { return nodeQueue.enqueue(node); });
    while (!nodeQueue.empty()) {
        set.unshift(nodeQueue.dequeue());
        Object.keys(set[0].inputs).map(function (key) { return set[0].inputs[key]; }).forEach(function (input) {
            if (unorderedEvaluationSet.indexOf(input.node) === -1) {
                return;
            }
            pendingDependencies[input.node.id]--;
            nodeQueue.update(input.node, nodeIndices[input.node.id]);
        });
    }
    return set;
}
exports.getOrderedEvaluationSet = getOrderedEvaluationSet;
function isInputNode(node) {
    return Object.keys(node.inputs).length === 0;
}
exports.isInputNode = isInputNode;
function shouldBackProp(t) {
    return !(t.node instanceof graph_1.ConstantNode);
}
exports.shouldBackProp = shouldBackProp;
function isPassthroughNode(node, map) {
    var keys = Object.keys(node.inputs);
    for (var i = 0; i < keys.length; i++) {
        var input = node.inputs[keys[i]];
        if (map.get(input, true) === map.get(node.output, true)) {
            return true;
        }
    }
    return false;
}
exports.isPassthroughNode = isPassthroughNode;

},{"./graph":9,"./priority_queue":76}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("./math/conv_util");
exports.conv_util = conv_util;
var gpgpu_util = require("./math/webgl/gpgpu_util");
exports.gpgpu_util = gpgpu_util;
var render_ndarray_gpu_util = require("./math/webgl/render_ndarray_gpu_util");
exports.render_ndarray_gpu_util = render_ndarray_gpu_util;
var webgl_util = require("./math/webgl/webgl_util");
exports.webgl_util = webgl_util;
var util = require("./util");
exports.util = util;
var checkpoint_loader_1 = require("./checkpoint_loader");
exports.CheckpointLoader = checkpoint_loader_1.CheckpointLoader;
var dataset_1 = require("./dataset");
exports.InMemoryDataset = dataset_1.InMemoryDataset;
var graph_1 = require("./graph");
exports.Graph = graph_1.Graph;
exports.Tensor = graph_1.Tensor;
var graph_runner_1 = require("./graph_runner");
exports.GraphRunner = graph_runner_1.GraphRunner;
exports.MetricReduction = graph_runner_1.MetricReduction;
var initializers_1 = require("./initializers");
exports.ConstantInitializer = initializers_1.ConstantInitializer;
exports.NDArrayInitializer = initializers_1.NDArrayInitializer;
exports.OnesInitializer = initializers_1.OnesInitializer;
exports.RandomNormalInitializer = initializers_1.RandomNormalInitializer;
exports.RandomTruncatedNormalInitializer = initializers_1.RandomTruncatedNormalInitializer;
exports.RandomUniformInitializer = initializers_1.RandomUniformInitializer;
exports.VarianceScalingInitializer = initializers_1.VarianceScalingInitializer;
exports.ZerosInitializer = initializers_1.ZerosInitializer;
var input_provider_1 = require("./input_provider");
exports.InCPUMemoryShuffledInputProviderBuilder = input_provider_1.InCPUMemoryShuffledInputProviderBuilder;
exports.InGPUMemoryShuffledInputProviderBuilder = input_provider_1.InGPUMemoryShuffledInputProviderBuilder;
var math_1 = require("./math/math");
exports.MatrixOrientation = math_1.MatrixOrientation;
exports.NDArrayMath = math_1.NDArrayMath;
var math_cpu_1 = require("./math/math_cpu");
exports.NDArrayMathCPU = math_cpu_1.NDArrayMathCPU;
var math_gpu_1 = require("./math/math_gpu");
exports.NDArrayMathGPU = math_gpu_1.NDArrayMathGPU;
var ndarray_1 = require("./math/ndarray");
exports.Array1D = ndarray_1.Array1D;
exports.Array2D = ndarray_1.Array2D;
exports.Array3D = ndarray_1.Array3D;
exports.Array4D = ndarray_1.Array4D;
exports.NDArray = ndarray_1.NDArray;
exports.Scalar = ndarray_1.Scalar;
var gpgpu_context_1 = require("./math/webgl/gpgpu_context");
exports.GPGPUContext = gpgpu_context_1.GPGPUContext;
var optimizer_1 = require("./optimizer");
exports.Optimizer = optimizer_1.Optimizer;
var session_1 = require("./session");
exports.CostReduction = session_1.CostReduction;
exports.Session = session_1.Session;
var sgd_optimizer_1 = require("./sgd_optimizer");
exports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;

},{"./checkpoint_loader":7,"./dataset":8,"./graph":9,"./graph_runner":11,"./initializers":14,"./input_provider":15,"./math/conv_util":18,"./math/math":21,"./math/math_cpu":22,"./math/math_gpu":23,"./math/ndarray":24,"./math/webgl/gpgpu_context":35,"./math/webgl/gpgpu_util":37,"./math/webgl/render_ndarray_gpu_util":46,"./math/webgl/webgl_util":53,"./optimizer":75,"./session":77,"./sgd_optimizer":79,"./util":81}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var VarianceScalingInitializer = (function () {
    function VarianceScalingInitializer(scale, mode, distribution) {
        if (scale === void 0) { scale = 1.0; }
        if (mode === void 0) { mode = 'fan_in'; }
        if (distribution === void 0) { distribution = 'normal'; }
        this.scale = scale;
        this.mode = mode;
        this.distribution = distribution;
    }
    VarianceScalingInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var n = 0;
        if (this.mode === 'fan_in') {
            n = inputUnits;
        }
        else if (this.mode === 'fan_out') {
            n = outputUnits;
        }
        else if (this.mode === 'fan_avg') {
            n = (inputUnits + outputUnits) / 2;
        }
        else {
            throw new Error('Unexpected mode for variance scaling initializer: ' + this.mode);
        }
        if (this.distribution === 'normal') {
            return ndarray_1.NDArray.randTruncatedNormal(weightsShape, 0.0, Math.sqrt(this.scale / n));
        }
        else if (this.distribution === 'uniform') {
            return ndarray_1.NDArray.randUniform(weightsShape, 0.0, Math.sqrt(3 * this.scale / n));
        }
        else {
            throw new Error('Unexpected distribution for variance scaling initializer: ' +
                this.distribution);
        }
    };
    return VarianceScalingInitializer;
}());
exports.VarianceScalingInitializer = VarianceScalingInitializer;
var ZerosInitializer = (function () {
    function ZerosInitializer() {
    }
    ZerosInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.zeros(weightsShape);
    };
    return ZerosInitializer;
}());
exports.ZerosInitializer = ZerosInitializer;
var OnesInitializer = (function () {
    function OnesInitializer() {
    }
    OnesInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var values = ndarray_1.NDArray.zeros(weightsShape);
        values.fill(1);
        return values;
    };
    return OnesInitializer;
}());
exports.OnesInitializer = OnesInitializer;
var ConstantInitializer = (function () {
    function ConstantInitializer(value) {
        if (value === void 0) { value = 0; }
        this.value = value;
    }
    ConstantInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var values = ndarray_1.NDArray.zeros(weightsShape);
        values.fill(this.value);
        return values;
    };
    return ConstantInitializer;
}());
exports.ConstantInitializer = ConstantInitializer;
var NDArrayInitializer = (function () {
    function NDArrayInitializer(ndarray) {
        this.ndarray = ndarray;
    }
    NDArrayInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return this.ndarray;
    };
    return NDArrayInitializer;
}());
exports.NDArrayInitializer = NDArrayInitializer;
var RandomNormalInitializer = (function () {
    function RandomNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomNormalInitializer;
}());
exports.RandomNormalInitializer = RandomNormalInitializer;
var RandomTruncatedNormalInitializer = (function () {
    function RandomTruncatedNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomTruncatedNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randTruncatedNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomTruncatedNormalInitializer;
}());
exports.RandomTruncatedNormalInitializer = RandomTruncatedNormalInitializer;
var RandomUniformInitializer = (function () {
    function RandomUniformInitializer(minval, maxval) {
        if (minval === void 0) { minval = -.05; }
        if (maxval === void 0) { maxval = .05; }
        this.minval = minval;
        this.maxval = maxval;
    }
    RandomUniformInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randUniform(weightsShape, this.minval, this.maxval);
    };
    return RandomUniformInitializer;
}());
exports.RandomUniformInitializer = RandomUniformInitializer;

},{"./math/ndarray":24}],15:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var util = require("./util");
var InMemoryShuffledInputProviderBuilder = (function () {
    function InMemoryShuffledInputProviderBuilder(inputs) {
        this.inputs = inputs;
        this.idx = 0;
        this.inputCounter = 0;
        this.epoch = 0;
        this.shuffledIndices = util.createShuffledIndices(inputs[0].length);
        this.numInputs = inputs.length;
        var numExamples = this.inputs[0].length;
        for (var i = 0; i < this.numInputs; i++) {
            util.assert(this.inputs[i].length === numExamples, 'Number of examples must match across different inputs.');
        }
        for (var i = 0; i < this.numInputs; i++) {
            var inputShape = this.inputs[i][0].shape;
            for (var j = 0; j < this.inputs[i].length; j++) {
                util.assertShapesMatch(inputShape, this.inputs[i][j].shape);
            }
        }
    }
    InMemoryShuffledInputProviderBuilder.prototype.getCurrentExampleIndex = function () {
        var returnIdx = this.idx;
        this.inputCounter++;
        if (this.inputCounter >= this.numInputs) {
            this.idx++;
            this.inputCounter = 0;
            if (this.idx >= this.inputs[0].length) {
                this.idx = 0;
                this.epoch++;
            }
        }
        return returnIdx;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getNextInput = function (inputId) {
        var currentExampleIndex = this.getCurrentExampleIndex();
        return this.inputs[inputId][this.shuffledIndices[currentExampleIndex]];
    };
    InMemoryShuffledInputProviderBuilder.prototype.getEpoch = function () {
        return this.epoch;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getInputProviders = function () {
        var inputProviders = [];
        for (var i = 0; i < this.numInputs; i++) {
            inputProviders.push(this.getInputProvider(i));
        }
        return inputProviders;
    };
    return InMemoryShuffledInputProviderBuilder;
}());
exports.InMemoryShuffledInputProviderBuilder = InMemoryShuffledInputProviderBuilder;
var InCPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InCPUMemoryShuffledInputProviderBuilder, _super);
    function InCPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InCPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function (math) {
                return ndarray_1.NDArray.like(shuffledInputProvider.getNextInput(inputId));
            },
            disposeCopy: function (math, copy) {
                copy.dispose();
            }
        };
    };
    return InCPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InCPUMemoryShuffledInputProviderBuilder = InCPUMemoryShuffledInputProviderBuilder;
var InGPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InGPUMemoryShuffledInputProviderBuilder, _super);
    function InGPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InGPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function (math) {
                return math.clone(shuffledInputProvider.getNextInput(inputId));
            },
            disposeCopy: function (math, copy) {
                copy.dispose();
            }
        };
    };
    return InGPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InGPUMemoryShuffledInputProviderBuilder = InGPUMemoryShuffledInputProviderBuilder;

},{"./math/ndarray":24,"./util":81}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./ndarray");
var TanHFunc = (function () {
    function TanHFunc() {
    }
    TanHFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.tanh(x);
        });
    };
    TanHFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            var ySquared = math.elementWiseMul(y, y);
            return math.scalarMinusArray(ndarray_1.Scalar.ONE, ySquared);
        });
    };
    return TanHFunc;
}());
exports.TanHFunc = TanHFunc;
var ReLUFunc = (function () {
    function ReLUFunc() {
    }
    ReLUFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.relu(x);
        });
    };
    ReLUFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            return math.step(x);
        });
    };
    return ReLUFunc;
}());
exports.ReLUFunc = ReLUFunc;
var SigmoidFunc = (function () {
    function SigmoidFunc() {
    }
    SigmoidFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.sigmoid(x);
        });
    };
    SigmoidFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            var ySquared = math.elementWiseMul(y, y);
            return math.subStrict(y, ySquared);
        });
    };
    return SigmoidFunc;
}());
exports.SigmoidFunc = SigmoidFunc;
var SquareFunc = (function () {
    function SquareFunc() {
    }
    SquareFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.elementWiseMul(x, x);
        });
    };
    SquareFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            return math.scalarTimesArray(ndarray_1.Scalar.TWO, x);
        });
    };
    return SquareFunc;
}());
exports.SquareFunc = SquareFunc;

},{"./ndarray":24}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertConcat3DShapesMatch(x1Shape, x2Shape, axis, errorMessagePrefix) {
    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
    util.assert(x1Shape.length === 3, errorMessagePrefix + 'Concat3D x1 shape should be of rank 3.');
    util.assert(x2Shape.length === 3, errorMessagePrefix + 'Concat3D x2 shape should be of rank 3.');
    util.assert(axis >= 0 && axis < 3, 'Axis for concat3D must be between 0 and 2.');
    for (var i = 0; i < 3; i++) {
        util.assert((i === axis) || (x1Shape[i] === x2Shape[i]), errorMessagePrefix +
            ("Shape (" + x1Shape + ") does not match (" + x2Shape + ") along ") +
            "non-concatenated axis.");
    }
}
exports.assertConcat3DShapesMatch = assertConcat3DShapesMatch;
function computeConcat3DOutputShape(x1Shape, x2Shape, axis) {
    util.assert(x1Shape.length === 3, 'Concat3D x1 shape should be of rank 3.');
    util.assert(x2Shape.length === 3, 'Concat3D x2shape should be of rank 3.');
    var outputShape = x1Shape.slice();
    outputShape[axis] += x2Shape[axis];
    return outputShape;
}
exports.computeConcat3DOutputShape = computeConcat3DOutputShape;

},{"../util":81}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function computeOutputShape3D(inputShapeRowColDepth, fieldSize, depth, stride, zeroPad) {
    if (zeroPad == null) {
        zeroPad = computeDefaultPad(inputShapeRowColDepth, fieldSize, stride);
    }
    var inputRows = inputShapeRowColDepth[0];
    var inputCols = inputShapeRowColDepth[1];
    var outputRows = (inputRows - fieldSize + 2 * zeroPad) / stride + 1;
    util.assert(util.isInt(outputRows), "The output # of rows (" + outputRows + ") must be an integer. Change the " +
        "stride and/or zero pad parameters");
    var outputCols = (inputCols - fieldSize + 2 * zeroPad) / stride + 1;
    util.assert(util.isInt(outputCols), "The output # of columns (" + outputCols + ") must be an integer. Change " +
        "the stride and/or zero pad parameters");
    return [outputRows, outputCols, depth];
}
exports.computeOutputShape3D = computeOutputShape3D;
function computeDefaultPad(inputShape, fieldSize, stride) {
    return Math.floor((inputShape[0] * (stride - 1) - stride + fieldSize) / 2);
}
exports.computeDefaultPad = computeDefaultPad;
function computeTexShapeFrom3D(shapeRowColDepth) {
    return [shapeRowColDepth[0], shapeRowColDepth[1] * shapeRowColDepth[2]];
}
exports.computeTexShapeFrom3D = computeTexShapeFrom3D;
function computeWeightsShape4D(inputDepth, outputDepth, fSize) {
    return [fSize, fSize, inputDepth, outputDepth];
}
exports.computeWeightsShape4D = computeWeightsShape4D;
function computeWeightsTexShape(inputDepth, outputDepth, fieldSize) {
    return [fieldSize * fieldSize * inputDepth, outputDepth];
}
exports.computeWeightsTexShape = computeWeightsTexShape;
function computeBiasesTexShape(outputDepth) {
    return [1, outputDepth];
}
exports.computeBiasesTexShape = computeBiasesTexShape;
function computeDilatedRC(rc, origStride) {
    var rowsDilated = (rc[0] - 1) * origStride + 1;
    var colsDilated = (rc[1] - 1) * origStride + 1;
    return [rowsDilated, colsDilated];
}
exports.computeDilatedRC = computeDilatedRC;

},{"../util":81}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function validateShapes(sourceSize, destSize) {
    var srcArea = sourceSize[0] * sourceSize[1];
    var dstArea = destSize[0] * destSize[1];
    if (srcArea !== dstArea) {
        var srcStr = '[' + sourceSize[0] + ', ' + sourceSize[1] + ']';
        var dstStr = '[' + destSize[0] + ', ' + destSize[1] + ']';
        throw new Error('copy2D shapes have different areas:\n  sourceSize ' + srcStr +
            ', area ' + srcArea + '\n  destSize ' + dstStr + ', area ' + dstArea);
    }
}
exports.validateShapes = validateShapes;

},{}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./ndarray");
var SquareCostFunc = (function () {
    function SquareCostFunc() {
        this.halfOne = ndarray_1.Scalar.new(0.5);
    }
    SquareCostFunc.prototype.cost = function (math, x1, x2) {
        var diff = math.subStrict(x1, x2);
        var diffSquared = math.elementWiseMul(diff, diff);
        var result = math.scalarTimesArray(this.halfOne, diffSquared);
        diff.dispose();
        diffSquared.dispose();
        return result;
    };
    SquareCostFunc.prototype.der = function (math, x1, x2) {
        return math.subStrict(x1, x2);
    };
    SquareCostFunc.prototype.dispose = function () {
        this.halfOne.dispose();
    };
    return SquareCostFunc;
}());
exports.SquareCostFunc = SquareCostFunc;

},{"./ndarray":24}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var concat3d_util = require("./concat3d_util");
var copy2d_util = require("./copy2d_util");
var ndarray_1 = require("./ndarray");
var NDArrayMath = (function () {
    function NDArrayMath(safeMode) {
        this.safeMode = safeMode;
        this.ndarrayScopes = [];
        this.ndarraysToKeep = [];
        this.activeScopeNDArraysToKeep = [];
        this.debugMode = false;
    }
    NDArrayMath.prototype.scope = function (scopeFn) {
        var _this = this;
        this.startScope();
        var keepFn = function (ndarray) { return _this.keep(ndarray); };
        var trackFn = function (ndarray) { return _this.track(ndarray); };
        var result = scopeFn(keepFn, trackFn);
        this.endScope(result);
        return result;
    };
    NDArrayMath.prototype.enableDebugMode = function () {
        this.debugMode = true;
        console.warn('Debugging mode is ON. The output of every math call will ' +
            'be downloaded to CPU and checked for NaNs. ' +
            'This significantly impacts performance.');
    };
    NDArrayMath.prototype.startScope = function () {
        var newScope = [];
        this.ndarrayScopes.push(newScope);
        this.activeScope = newScope;
        var newNDArraysToKeep = [];
        this.ndarraysToKeep.push(newNDArraysToKeep);
        this.activeScopeNDArraysToKeep = newNDArraysToKeep;
    };
    NDArrayMath.prototype.endScope = function (result) {
        var _this = this;
        var arraysToKeep = this.activeScopeNDArraysToKeep;
        if (result != null) {
            arraysToKeep = arraysToKeep.concat(result);
        }
        for (var i = 0; i < this.activeScope.length; i++) {
            var ndarray = this.activeScope[i];
            if (this.isNDArrayDataInList(ndarray, arraysToKeep)) {
                continue;
            }
            ndarray.dispose();
        }
        this.ndarrayScopes.pop();
        this.activeScope = this.ndarrayScopes.length === 0 ?
            null :
            this.ndarrayScopes[this.ndarrayScopes.length - 1];
        if (result instanceof ndarray_1.NDArray &&
            !this.isNDArrayDataInList(result, this.activeScopeNDArraysToKeep)) {
            this.track(result);
        }
        else if (Array.isArray(result)) {
            result.forEach(function (r) {
                if (r instanceof ndarray_1.NDArray &&
                    !_this.isNDArrayDataInList(r, _this.activeScopeNDArraysToKeep)) {
                    _this.track(r);
                }
            });
        }
        this.ndarraysToKeep.pop();
        this.activeScopeNDArraysToKeep = this.ndarraysToKeep.length === 0 ?
            null :
            this.ndarraysToKeep[this.ndarraysToKeep.length - 1];
    };
    NDArrayMath.prototype.isNDArrayDataInList = function (ndarray, ndarrayList) {
        for (var i = 0; i < ndarrayList.length; i++) {
            if (ndarrayList[i].getData() === ndarray.getData()) {
                return true;
            }
        }
        return false;
    };
    NDArrayMath.prototype.keep = function (result) {
        if (this.activeScope == null) {
            if (this.safeMode) {
                throw new Error('You are using math in safe mode. Enclose all ' +
                    'math.method() calls inside a scope: ' +
                    'math.scope(() => {math.method();...}) to avoid memory ' +
                    'leaks.');
            }
            return result;
        }
        this.activeScopeNDArraysToKeep.push(result);
        return result;
    };
    NDArrayMath.prototype.checkForNaN = function (arr) {
        var vals = arr.getValues();
        for (var i = 0; i < vals.length; i++) {
            if (isNaN(vals[i])) {
                throw Error('The result NDArray of the last math call has NaNs.');
            }
        }
    };
    NDArrayMath.prototype.track = function (result) {
        if (this.debugMode) {
            this.checkForNaN(result);
        }
        if (this.activeScope == null) {
            if (this.safeMode) {
                throw new Error('You are using math in safe mode. Enclose all ' +
                    'math.method() calls inside a scope: ' +
                    'math.scope(() => {math.method();...}) to avoid memory ' +
                    'leaks.');
            }
            return result;
        }
        this.activeScope.push(result);
        return result;
    };
    NDArrayMath.prototype.matMul = function (a, b, aOrientation, bOrientation) {
        if (aOrientation === void 0) { aOrientation = MatrixOrientation.REGULAR; }
        if (bOrientation === void 0) { bOrientation = MatrixOrientation.REGULAR; }
        var innerShapeA = (aOrientation === MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
        var innerShapeB = (bOrientation === MatrixOrientation.REGULAR) ? b.shape[0] : b.shape[1];
        util.assert(a.rank === 2 && b.rank === 2, "Error in matMul: inputs must be rank 2, got ranks " + a.rank +
            ("and " + b.rank + "."));
        util.assert(innerShapeA === innerShapeB, "Error in matMul: inner shapes (" + innerShapeA + ") and (" +
            (innerShapeB + ") of NDArrays with shapes " + a.shape + " and ") +
            (b.shape + " and orientations " + MatrixOrientation[aOrientation]) +
            (" and " + MatrixOrientation[bOrientation] + " must match."));
        return this.track(this.matMulInternal(a, b, aOrientation, bOrientation));
    };
    NDArrayMath.prototype.vectorTimesMatrix = function (v, matrix) {
        util.assert(v.rank === 1, "Error in vectorTimesMatrix: first input must be rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in vectorTimesMatrix: second input must be rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[0], "Error in vectorTimesMatrix: size of first rank 1 input (" + v.size + ") " +
            "must match inner dimension of second rank 2 input, but got " +
            ("rank " + matrix.rank + "."));
        return this.matMul(v.as2D(1, v.size), matrix).as1D();
    };
    NDArrayMath.prototype.matrixTimesVector = function (matrix, v) {
        util.assert(v.rank === 1, "Error in vectorTimesMatrix: second input must rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in vectorTimesMatrix: first input must be a rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[1], "Error in vectorTimesMatrix: size of first rank 1 input " + v.size + " " +
            "must match inner dimension of second rank 2 input, but got " +
            ("shape " + matrix.shape + "."));
        return this.matMul(matrix, v.as2D(v.size, 1)).as1D();
    };
    NDArrayMath.prototype.dotProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in dotProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        util.assert(v1.size === v2.size, "Error in dotProduct: size of inputs (" + v1.size + ") and (" +
            (v2.size + ") must match."));
        return this.matMul(v1.as2D(1, v1.size), v2.as2D(v2.size, 1)).asScalar();
    };
    NDArrayMath.prototype.outerProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in outerProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        return this.matMul(v1.as2D(v1.size, 1), v2.as2D(1, v2.size));
    };
    NDArrayMath.prototype.clone = function (ndarray) {
        return this.track(this.cloneInternal(ndarray));
    };
    NDArrayMath.prototype.reshape = function (ndarray, newShape) {
        util.assert(ndarray.size === util.sizeFromShape(newShape), "Error in reshape: old size " + ndarray.size + " must match new size " +
            (util.sizeFromShape(newShape) + "."));
        return this.track(this.reshapeInternal(ndarray, newShape));
    };
    NDArrayMath.prototype.slice2D = function (input, begin, size) {
        util.assert(begin[0] + size[0] <= input.shape[0] &&
            begin[1] + size[1] <= input.shape[1], "Error in slice2D: requested start position " + begin + " and size " +
            (size + " would overflow input of shape " + input.shape + "."));
        return this.track(this.slice2DInternal(input, begin, size));
    };
    NDArrayMath.prototype.copy2D = function (source, sourceBegin, sourceSize, dest, destBegin, destSize) {
        util.assert(sourceBegin[0] + sourceSize[0] <= source.shape[0] &&
            sourceBegin[1] + sourceSize[1] <= source.shape[1], "Error in copy2D: requested source start position " + sourceBegin + " " +
            ("and source size " + sourceSize + " would overflow source NDArray") +
            ("of shape " + source.shape + "."));
        util.assert(destBegin[0] + destSize[0] <= dest.shape[0] &&
            destBegin[1] + destSize[1] <= dest.shape[1], "Error in copy2D: requested dest start position " + destBegin + " " +
            ("and source size " + destSize + " would overflow dest NDArray of") +
            ("shape " + dest.shape + "."));
        copy2d_util.validateShapes(sourceSize, destSize);
        return this.copy2DInternal(source, sourceBegin, sourceSize, dest, destBegin, destSize);
    };
    NDArrayMath.prototype.concat3D = function (ndarray1, ndarray2, axis) {
        concat3d_util.assertConcat3DShapesMatch(ndarray1.shape, ndarray2.shape, axis, 'Error in concat3d: ');
        return this.track(this.concat3DInternal(ndarray1, ndarray2, axis));
    };
    NDArrayMath.prototype.logSumExp = function (ndarray) {
        return this.track(this.logSumExpInternal(ndarray));
    };
    NDArrayMath.prototype.sum = function (ndarray) {
        return this.track(this.sumInternal(ndarray));
    };
    NDArrayMath.prototype.argMin = function (ndarray) {
        return this.track(this.argMinInternal(ndarray));
    };
    NDArrayMath.prototype.argMax = function (ndarray) {
        return this.track(this.argMaxInternal(ndarray));
    };
    NDArrayMath.prototype.argMaxEquals = function (x1, x2) {
        util.assertShapesMatch(x1.shape, x2.shape, 'Error in argMaxEquals: ');
        return this.track(this.argMaxEqualsInternal(x1, x2));
    };
    NDArrayMath.prototype.topK = function (ndarray, k) {
        util.assert(k <= ndarray.size, "Error in topK: k value (" + k + ") must be less than size of input " +
            ("ndarray, got shape " + ndarray.shape + "."));
        var result = this.topKInternal(ndarray, k);
        this.track(result.values);
        this.track(result.indices);
        return result;
    };
    NDArrayMath.prototype.min = function (ndarray) {
        return this.track(this.minInternal(ndarray));
    };
    NDArrayMath.prototype.max = function (ndarray) {
        return this.track(this.maxInternal(ndarray));
    };
    NDArrayMath.prototype.softmax = function (x) {
        var _this = this;
        return this.scope(function () {
            var lse = _this.logSumExp(x);
            var logResult = _this.arrayMinusScalar(x, lse);
            return _this.exp(logResult);
        });
    };
    NDArrayMath.prototype.switchDim = function (a, newDim) {
        util.assert(a.rank === newDim.length, "Error in switchDim: length of input shape " + a.shape + " " +
            ("must match size of newDim array " + newDim + "."));
        return this.track(this.switchDimInternal(a, newDim));
    };
    NDArrayMath.prototype.scalarPlusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarPlusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.add(c, a);
    };
    NDArrayMath.prototype.scalarMinusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarMinusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.sub(c, a);
    };
    NDArrayMath.prototype.arrayMinusScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayMinusScalar: second argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.sub(a, c);
    };
    NDArrayMath.prototype.neg = function (a) {
        return this.track(this.negInternal(a));
    };
    NDArrayMath.prototype.add = function (a, b) {
        util.assertAndGetBroadcastedShape(a.shape, b.shape);
        return this.track(this.addInternal(a, b));
    };
    NDArrayMath.prototype.addStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');
        return this.add(a, b);
    };
    NDArrayMath.prototype.sub = function (a, b) {
        util.assertAndGetBroadcastedShape(a.shape, b.shape);
        return this.track(this.subInternal(a, b));
    };
    NDArrayMath.prototype.subStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');
        return this.sub(a, b);
    };
    NDArrayMath.prototype.multiply = function (a, b) {
        util.assertAndGetBroadcastedShape(a.shape, b.shape);
        return this.track(this.multiplyInternal(a, b));
    };
    NDArrayMath.prototype.elementWiseMul = function (a, b) {
        return this.multiplyStrict(a, b);
    };
    NDArrayMath.prototype.multiplyStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');
        return this.multiply(a, b);
    };
    NDArrayMath.prototype.divide = function (a, b) {
        util.assertAndGetBroadcastedShape(a.shape, b.shape);
        return this.track(this.divideInternal(a, b));
    };
    NDArrayMath.prototype.divideStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');
        return this.divide(a, b);
    };
    NDArrayMath.prototype.scalarDividedByArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarDividedByArray: first argument must be rank 0, but " +
            ("got NDArray of rank " + c.rank + "."));
        return this.divide(c, a);
    };
    NDArrayMath.prototype.arrayDividedByScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: second argument must be rank 0, " +
            ("but got NDArray of rank " + c.rank + "."));
        return this.divide(a, c);
    };
    NDArrayMath.prototype.exp = function (ndarray) {
        return this.track(this.expInternal(ndarray));
    };
    NDArrayMath.prototype.log = function (ndarray) {
        return this.track(this.logInternal(ndarray));
    };
    NDArrayMath.prototype.relu = function (ndarray) {
        return this.track(this.reluInternal(ndarray));
    };
    NDArrayMath.prototype.sigmoid = function (ndarray) {
        return this.track(this.sigmoidInternal(ndarray));
    };
    NDArrayMath.prototype.tanh = function (ndarray) {
        return this.track(this.tanhInternal(ndarray));
    };
    NDArrayMath.prototype.sin = function (ndarray) {
        return this.track(this.sinInternal(ndarray));
    };
    NDArrayMath.prototype.step = function (ndarray) {
        return this.track(this.stepInternal(ndarray));
    };
    NDArrayMath.prototype.scaledArrayAdd = function (c1, a, c2, b) {
        util.assert(c1.size === 1, "Error in scaledArrayAdd: first argument must rank 0, but got " +
            (" rank " + c1.rank + "."));
        util.assert(c2.size === 1, "Error in scaledArrayAdd: third argument must be rank 0, but got " +
            ("NDArray of rank " + c2.rank + "."));
        util.assertShapesMatch(a.shape, b.shape, 'Error in scaledArrayAdd: ');
        return this.track(this.scaledArrayAddInternal(c1, a, c2, b));
    };
    NDArrayMath.prototype.scalarTimesArray = function (c, a) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: first argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.multiply(c, a);
    };
    NDArrayMath.prototype.elementWiseMulBroadcast = function (a, b) {
        util.assert(a.rank === 2, "Error in elementWiseMulBroadcast: first argument must be " +
            ("rank 2, but got rank " + a.rank + "."));
        util.assert(b.rank === 2, "Error in elementWiseMulBroadcast: second argument must be " +
            ("rank 2, but got rank " + b.rank + "."));
        return this.multiply(a, b);
    };
    NDArrayMath.prototype.conv2d = function (x, weights, biases, stride, zeroPad) {
        util.assert(x.rank === 3, "Error in conv2d: x must be rank 3, but got rank " + x.rank + ".");
        util.assert(weights.rank === 4, "Error in conv2d: weights must be rank 4, but got rank " +
            (weights.rank + "."));
        if (biases != null) {
            util.assert(biases.rank === 1, "Error in conv2d: biases must be rank 1, but got rank " +
                (biases.rank + "."));
        }
        util.assert(x.shape[2] === weights.shape[2], "Error in conv2d: depth of input (" + x.shape[2] + ") must match  " +
            ("input depth for weights " + weights.shape[2] + "."));
        return this.track(this.conv2dInternal(x, weights, biases, stride, zeroPad));
    };
    NDArrayMath.prototype.conv2dBackProp = function (x, dy, weights, stride, pad) {
        util.assert(x.rank === 3, "Error in conv2dBackProp: x must be rank 3, but got shape " +
            (x.shape + "."));
        util.assert(dy.rank === 3, "Error in conv2dBackProp: dy must be rank 3, but got shape " +
            (dy.shape + "."));
        util.assert(weights.rank === 4, "Error in conv2dBackProp: weights must be rank 4, but got shape " +
            (weights.shape + "."));
        util.assert(x.shape[2] === weights.shape[2], "Error in conv2dBackProp: depth of x " + x.shape[2] + ") must " +
            ("match input depth for weights (" + weights.shape[2] + "."));
        util.assert(dy.shape[2] === weights.shape[3], "Error in conv2dBackProp: depth of dy (" + dy.shape[2] + ") must " +
            ("match output depth for weights (" + weights.shape[3] + ")."));
        var backpropResult = this.conv2dBackPropInternal(x, dy, weights, stride, pad);
        this.track(backpropResult.db);
        this.track(backpropResult.dw);
        this.track(backpropResult.dx);
        return backpropResult;
    };
    NDArrayMath.prototype.conv2dTranspose = function (x, weights, biases, stride, pad) {
        util.assert(x.rank === 3, "Error in conv2dTranspose: x must be rank 3, but got rank " +
            (x.rank + "."));
        util.assert(weights.rank === 4, "Error in conv2dTranspose: weights must be rank 4, but got " +
            ("rank " + weights.rank));
        if (biases != null) {
            util.assert(biases.rank === 1, "Error in conv2dTranspose: biases must be rank 1, but got ' +\n              'rank " + biases.rank + ".");
        }
        util.assert(x.shape[2] === weights.shape[3], "Error in conv2dTranspose: depth of input (" + x.shape[2] + ") must " +
            ("match input depth for weights " + weights.shape[3] + "."));
        return this.track(this.conv2dTransposeInternal(x, weights, biases, stride, pad));
    };
    NDArrayMath.prototype.maxPool = function (x, fSize, stride, pad) {
        util.assert(x.rank === 3, 'Error in maxPool: x must be rank 3 but got rank ' + x.rank + '.');
        return this.track(this.maxPoolInternal(x, fSize, stride, pad));
    };
    NDArrayMath.prototype.maxPoolBackprop = function (dy, x, fSize, stride, pad) {
        util.assert(dy.rank === 3, "Error in maxPoolBackprop: dy must be rank 3 but got rank " +
            (dy.rank + "."));
        util.assert(x.rank === 3, "Error in maxPoolBackprop: x must be rank 3 but got rank " +
            (x.rank + "."));
        return this.track(this.maxPoolBackpropInternal(dy, x, fSize, stride, pad));
    };
    NDArrayMath.prototype.minPool = function (x, fSize, stride, pad) {
        util.assert(x.rank === 3, "Error in minPool: x must be rank 3 but got rank " + x.rank + ".");
        return this.track(this.minPoolInternal(x, fSize, stride, pad));
    };
    NDArrayMath.prototype.avgPool = function (x, fSize, stride, pad) {
        util.assert(x.rank === 3, "Error in avgPool: x must be rank 3 but got rank " + x.rank + ".");
        return this.track(this.avgPoolInternal(x, fSize, stride, pad));
    };
    NDArrayMath.prototype.resizeBilinear3D = function (x, newShape2D, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        util.assert(x.rank === 3, "Error in resizeBilinear3D: x must be rank 3 but got rank " + x.rank + ".");
        util.assert(newShape2D.length === 2, "Error in resizeBilinear3D: new shape must 2D, but got shape " +
            (newShape2D + "."));
        return this.track(this.resizeBilinear3DInternal(x, newShape2D, alignCorners));
    };
    NDArrayMath.prototype.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 3, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 3 || mean.rank === 1, "Error in batchNormalization3D: mean must be rank 3 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 3 || variance.rank === 1, "Error in batchNormalization3D: variance must be rank 3 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 3 || scale.rank === 1, "Error in batchNormalization3D: scale must be rank 3 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 3 || offset.rank === 1, "Error in batchNormalization3D: offset must be rank 3 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return this.track(this.batchNormalization3DInternal(x, mean, variance, varianceEpsilon, scale, offset));
    };
    NDArrayMath.prototype.multiRNNCell = function (lstmCells, data, c, h) {
        util.assert(data.shape[0] === 1, "Error in multiRNNCell: first dimension of data is " + data.shape[0] + ", " +
            "but batch sizes > 1 are not yet supported.");
        var res = this.scope(function () {
            var input = data;
            var newStates = [];
            for (var i = 0; i < lstmCells.length; i++) {
                var output = lstmCells[i](input, c[i], h[i]);
                newStates.push(output[0]);
                newStates.push(output[1]);
                input = output[1];
            }
            return newStates;
        });
        var newC = [];
        var newH = [];
        for (var i = 0; i < res.length; i += 2) {
            newC.push(res[i]);
            newH.push(res[i + 1]);
        }
        return [newC, newH];
    };
    NDArrayMath.prototype.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {
        var _this = this;
        var res = this.scope(function () {
            util.assert(data.shape[0] === 1, "Error in multiRNNCell: first dimension of data is " +
                (data.shape[0] + ", but batch sizes > 1 are not yet supported."));
            var data3D = data.as3D(1, 1, data.shape[1]);
            var h3D = h.as3D(1, 1, h.shape[1]);
            var combined3D = _this.concat3D(data3D, h3D, 2);
            var combined2D = combined3D.as2D(1, data.shape[1] + h.shape[1]);
            var weighted = _this.matMul(combined2D, lstmKernel);
            var res = _this.add(weighted, lstmBias);
            var i = _this.slice2D(res, [0, 0], [res.shape[0], res.shape[1] / 4]);
            var j = _this.slice2D(res, [0, res.shape[1] / 4 * 1], [res.shape[0], res.shape[1] / 4]);
            var f = _this.slice2D(res, [0, res.shape[1] / 4 * 2], [res.shape[0], res.shape[1] / 4]);
            var o = _this.slice2D(res, [0, res.shape[1] / 4 * 3], [res.shape[0], res.shape[1] / 4]);
            var newC = _this.add(_this.multiplyStrict(c, _this.sigmoid(_this.scalarPlusArray(forgetBias, f))), _this.multiplyStrict(_this.sigmoid(i), _this.tanh(j)));
            var newH = _this.multiplyStrict(_this.tanh(newC), _this.sigmoid(o));
            return [newC, newH];
        });
        return [res[0], res[1]];
    };
    return NDArrayMath;
}());
exports.NDArrayMath = NDArrayMath;
var MatrixOrientation;
(function (MatrixOrientation) {
    MatrixOrientation[MatrixOrientation["REGULAR"] = 0] = "REGULAR";
    MatrixOrientation[MatrixOrientation["TRANSPOSED"] = 1] = "TRANSPOSED";
})(MatrixOrientation = exports.MatrixOrientation || (exports.MatrixOrientation = {}));

},{"../util":81,"./concat3d_util":17,"./copy2d_util":19,"./ndarray":24}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../math/conv_util");
var util = require("../util");
var concat3d_util = require("./concat3d_util");
var copy2D_util = require("./copy2d_util");
var math_1 = require("./math");
var ndarray_1 = require("./ndarray");
var NDArrayMathCPU = (function (_super) {
    __extends(NDArrayMathCPU, _super);
    function NDArrayMathCPU(safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        return _super.call(this, safeMode) || this;
    }
    NDArrayMathCPU.prototype.cloneInternal = function (ndarray) {
        return ndarray_1.NDArray.make(ndarray.shape, { values: new Float32Array(ndarray.getValues()) });
    };
    NDArrayMathCPU.prototype.reshapeInternal = function (ndarray, newShape) {
        return this.cloneInternal(ndarray).reshape(newShape);
    };
    NDArrayMathCPU.prototype.slice2DInternal = function (input, beginRowCol, sizeRowCol) {
        var result = ndarray_1.Array2D.zeros(sizeRowCol);
        this.copy2DInternal(input, beginRowCol, sizeRowCol, result, [0, 0], sizeRowCol);
        return result;
    };
    NDArrayMathCPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
        copy2D_util.validateShapes(sourceSizeRowCol, destSizeRowCol);
        var srcValues = source.getValues();
        var dstValues = dest.getValues();
        var n = sourceSizeRowCol[0] * sourceSizeRowCol[1];
        for (var i = 0; i < n; ++i) {
            var srcRow = sourceBeginRowCol[0] + Math.floor(i / sourceSizeRowCol[1]);
            var srcCol = sourceBeginRowCol[1] + (i % sourceSizeRowCol[1]);
            var srcOff = srcRow * source.shape[1] + srcCol;
            var dstRow = destBeginRowCol[0] + Math.floor(i / destSizeRowCol[1]);
            var dstCol = destBeginRowCol[1] + (i % destSizeRowCol[1]);
            var dstOff = dstRow * dest.shape[1] + dstCol;
            dstValues[dstOff] = srcValues[srcOff];
        }
    };
    NDArrayMathCPU.prototype.concat3DInternal = function (x1, x2, axis) {
        var outputShape = concat3d_util.computeConcat3DOutputShape(x1.shape, x2.shape, axis);
        var values = ndarray_1.Array3D.zeros(outputShape);
        for (var i = 0; i < outputShape[0]; i++) {
            for (var j = 0; j < outputShape[1]; j++) {
                for (var k = 0; k < outputShape[2]; k++) {
                    var index = [i, j, k];
                    var value = void 0;
                    if (index[axis] < x1.shape[axis]) {
                        value = x1.get(i, j, k);
                    }
                    else {
                        index[axis] -= x1.shape[axis];
                        var i2 = index[0], j2 = index[1], k2 = index[2];
                        value = x2.get(i2, j2, k2);
                    }
                    values.set(value, i, j, k);
                }
            }
        }
        return values;
    };
    NDArrayMathCPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {
        var newShape = util.assertAndGetBroadcastedShape(a.shape, b.shape);
        var newValues = new Float32Array(util.sizeFromShape(newShape));
        var aValues = a.getValues();
        var bValues = b.getValues();
        var c1Val = c1.get();
        var c2Val = c2.get();
        for (var i = 0; i < newValues.length; ++i) {
            newValues[i] = c1Val * aValues[i % a.size] + c2Val * bValues[i % b.size];
        }
        return ndarray_1.NDArray.make(newShape, { values: newValues });
    };
    NDArrayMathCPU.prototype.negInternal = function (a) {
        return this.scalarTimesArray(ndarray_1.Scalar.NEG_ONE, a);
    };
    NDArrayMathCPU.prototype.addInternal = function (a, b) {
        return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.ONE, b);
    };
    NDArrayMathCPU.prototype.subInternal = function (a, b) {
        return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.NEG_ONE, b);
    };
    NDArrayMathCPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {
        if (aOrientation === void 0) { aOrientation = math_1.MatrixOrientation.REGULAR; }
        if (bOrientation === void 0) { bOrientation = math_1.MatrixOrientation.REGULAR; }
        var sharedDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
        var leftDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[0] : a.shape[1];
        var rightDim = (bOrientation === math_1.MatrixOrientation.REGULAR) ? b.shape[1] : b.shape[0];
        var normalGetter = function (matrix, i, j) {
            return matrix.get(i, j);
        };
        var transposedGetter = function (matrix, i, j) {
            return matrix.get(j, i);
        };
        var aGetter = (aOrientation === math_1.MatrixOrientation.REGULAR) ?
            normalGetter :
            transposedGetter;
        var bGetter = (bOrientation === math_1.MatrixOrientation.REGULAR) ?
            normalGetter :
            transposedGetter;
        var values = new Float32Array(leftDim * rightDim);
        var index = 0;
        for (var i = 0; i < leftDim; ++i) {
            for (var j = 0; j < rightDim; ++j) {
                var sum = 0;
                for (var k = 0; k < sharedDim; ++k) {
                    sum += aGetter(a, i, k) * bGetter(b, k, j);
                }
                values[index++] = sum;
            }
        }
        return ndarray_1.Array2D.new([leftDim, rightDim], values);
    };
    NDArrayMathCPU.prototype.multiplyInternal = function (a, b) {
        var newShape = util.assertAndGetBroadcastedShape(a.shape, b.shape);
        var newValues = new Float32Array(util.sizeFromShape(newShape));
        var aValues = a.getValues();
        var bValues = b.getValues();
        for (var i = 0; i < newValues.length; ++i) {
            newValues[i] = aValues[i % a.size] * bValues[i % b.size];
        }
        return ndarray_1.NDArray.make(newShape, { values: newValues });
    };
    NDArrayMathCPU.prototype.divideInternal = function (a, b) {
        var newShape = util.assertAndGetBroadcastedShape(a.shape, b.shape);
        var newValues = new Float32Array(util.sizeFromShape(newShape));
        var aValues = a.getValues();
        var bValues = b.getValues();
        for (var i = 0; i < newValues.length; ++i) {
            newValues[i] = aValues[i % a.size] / bValues[i % b.size];
        }
        return ndarray_1.NDArray.make(newShape, { values: newValues });
    };
    NDArrayMathCPU.prototype.sumInternal = function (ndarray) {
        var sum = 0;
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            sum += values[i];
        }
        return ndarray_1.Scalar.new(sum);
    };
    NDArrayMathCPU.prototype.argMinInternal = function (ndarray) {
        var min = Number.MAX_VALUE;
        var minIndex = -1;
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            if (isNaN(value)) {
                return ndarray_1.Scalar.new(NaN);
            }
            if (value < min) {
                min = value;
                minIndex = i;
            }
        }
        return ndarray_1.Scalar.new(minIndex);
    };
    NDArrayMathCPU.prototype.argMaxInternal = function (ndarray) {
        var max = Number.NEGATIVE_INFINITY;
        var maxIndex = -1;
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            if (isNaN(value)) {
                return ndarray_1.Scalar.new(NaN);
            }
            if (value > max) {
                max = value;
                maxIndex = i;
            }
        }
        return ndarray_1.Scalar.new(maxIndex);
    };
    NDArrayMathCPU.prototype.argMaxEqualsInternal = function (x1, x2) {
        var argMax1 = this.argMaxInternal(x1).get();
        var argMax2 = this.argMaxInternal(x2).get();
        if (isNaN(argMax1) || isNaN(argMax2)) {
            return ndarray_1.Scalar.new(NaN);
        }
        return ndarray_1.Scalar.new(+(argMax1 === argMax2));
    };
    NDArrayMathCPU.prototype.topKInternal = function (ndarray, k) {
        var values = ndarray.getValues();
        var valuesAndIndices = [];
        for (var i = 0; i < values.length; i++) {
            valuesAndIndices.push({ value: values[i], index: i });
        }
        valuesAndIndices.sort(function (a, b) {
            return b.value - a.value;
        });
        var topkValues = new Float32Array(k);
        var topkIndices = new Float32Array(k);
        for (var i = 0; i < k; i++) {
            topkValues[i] = valuesAndIndices[i].value;
            topkIndices[i] = valuesAndIndices[i].index;
        }
        return { values: ndarray_1.Array1D.new(topkValues), indices: ndarray_1.Array1D.new(topkIndices) };
    };
    NDArrayMathCPU.prototype.minInternal = function (ndarray) {
        var values = ndarray.getValues();
        var min = values[0];
        for (var i = 1; i < values.length; ++i) {
            var value = values[i];
            if (isNaN(value)) {
                return ndarray_1.Scalar.new(NaN);
            }
            if (value < min) {
                min = value;
            }
        }
        return ndarray_1.Scalar.new(min);
    };
    NDArrayMathCPU.prototype.maxInternal = function (ndarray) {
        var values = ndarray.getValues();
        var max = values[0];
        for (var i = 1; i < values.length; ++i) {
            var value = values[i];
            if (isNaN(value)) {
                return ndarray_1.Scalar.new(NaN);
            }
            if (value > max) {
                max = value;
            }
        }
        return ndarray_1.Scalar.new(max);
    };
    NDArrayMathCPU.prototype.expInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.exp(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.logInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.log(value);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.logSumExpInternal = function (ndarray) {
        var xMax = this.max(ndarray);
        var a = this.arrayMinusScalar(ndarray, xMax);
        var b = this.exp(a);
        var c = this.sum(b);
        var d = this.log(c);
        var result = this.add(xMax, d);
        xMax.dispose();
        a.dispose();
        b.dispose();
        c.dispose();
        d.dispose();
        return result;
    };
    NDArrayMathCPU.prototype.reluInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.max(0, values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.sigmoidInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = 1 / (1 + Math.exp(-values[i]));
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.tanhInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = util.tanh(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.sinInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sin(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.stepInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            resultValues[i] = value > 0 ? 1 : (value < 0 ? 0 : value);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.conv2dInternal = function (x, weights, biases, stride, pad) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], inputDepth = _a[2];
        var fieldSize = weights.shape[0];
        var outputDepth = weights.shape[3];
        var outputShape = conv_util.computeOutputShape3D([xRows, xCols, inputDepth], fieldSize, outputDepth, stride, pad);
        var y = ndarray_1.Array3D.zeros(outputShape);
        for (var d2 = 0; d2 < outputDepth; ++d2) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                var xRCorner = yR * stride - pad;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, fieldSize + xRCorner);
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xCCorner = yC * stride - pad;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, fieldSize + xCCorner);
                    var dotProd = 0;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        var wR = xR - xRCorner;
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var wC = xC - xCCorner;
                            for (var d1 = 0; d1 < inputDepth; ++d1) {
                                var pixel = x.get(xR, xC, d1);
                                var weight = weights.get(wR, wC, d1, d2);
                                dotProd += pixel * weight;
                            }
                        }
                    }
                    var bias = (biases != null) ? biases.get(d2) : 0;
                    y.set(dotProd + bias, yR, yC, d2);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.conv2dBackPropInternal = function (x, dy, weights, stride, pad) {
        var fSize = weights.shape[0];
        var dw = this.conv2dDerWeights(x, dy, fSize, stride, pad);
        var db = this.conv2dDerBias(dy);
        var dx = this.conv2dTransposeInternal(dy, weights, null, stride, pad);
        return { dx: dx, db: db, dw: dw };
    };
    NDArrayMathCPU.prototype.conv2dTransposeInternal = function (x, weights, biases, origStride, origPad) {
        var fSize = weights.shape[0];
        var pad = fSize - 1 - origPad;
        var origInputDepth = weights.shape[2];
        var origOutputDepth = weights.shape[3];
        var xRows = x.shape[0];
        var xCols = x.shape[1];
        var xRowsDilated = (xRows - 1) * origStride + 1;
        var xColsDilated = (xCols - 1) * origStride + 1;
        var outputShape = conv_util.computeOutputShape3D([xRowsDilated, xColsDilated, origOutputDepth], fSize, origInputDepth, 1, pad);
        var y = ndarray_1.Array3D.zeros(outputShape);
        for (var d2 = 0; d2 < origInputDepth; ++d2) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                var xRCorner = yR - pad;
                var xRMin = Math.max(0, Math.ceil(xRCorner / origStride));
                var xRMax = Math.min(xRows, (fSize + xRCorner) / origStride);
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xCCorner = yC - pad;
                    var xCMin = Math.max(0, Math.ceil(xCCorner / origStride));
                    var xCMax = Math.min(xCols, (fSize + xCCorner) / origStride);
                    var dotProd = 0;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        var wR = xR * origStride - xRCorner;
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var wC = xC * origStride - xCCorner;
                            for (var d1 = 0; d1 < origOutputDepth; ++d1) {
                                var pixel = x.get(xR, xC, d1);
                                var weight = weights.get(fSize - 1 - wR, fSize - 1 - wC, d2, d1);
                                dotProd += pixel * weight;
                            }
                        }
                    }
                    var bias = biases != null ? biases.get(d2) : 0;
                    y.set(dotProd + bias, yR, yC, d2);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.conv2dTransposeShaderLike = function (x, origWeights, origStride, origPad) {
        var fSize = origWeights.shape[0];
        var pad = fSize - 1 - origPad;
        var origInputDepth = origWeights.shape[2];
        var origOutputDepth = origWeights.shape[3];
        var xRows = x.shape[0];
        var xCols = x.shape[1];
        var xRowsDilated = (xRows - 1) * origStride + 1;
        var xColsDilated = (xCols - 1) * origStride + 1;
        var outputShape = conv_util.computeOutputShape3D([xRowsDilated, xColsDilated, origOutputDepth], fSize, origInputDepth, 1, pad);
        var y = ndarray_1.Array3D.zeros(outputShape);
        for (var d2 = 0; d2 < origInputDepth; ++d2) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xRCorner = yR - pad;
                    var xCCorner = yC - pad;
                    var dotProd = 0;
                    for (var wR = 0; wR < fSize; ++wR) {
                        var xR = (xRCorner + wR) / origStride;
                        if (xR < 0 || xR >= xRows || Math.floor(xR) !== xR) {
                            continue;
                        }
                        for (var wC = 0; wC < fSize; ++wC) {
                            var xC = (xCCorner + wC) / origStride;
                            if (xC < 0 || xC >= xCols || Math.floor(xC) !== xC) {
                                continue;
                            }
                            for (var d1 = 0; d1 < origOutputDepth; ++d1) {
                                var pixel = x.get(xR, xC, d1);
                                var weight = origWeights.get(fSize - 1 - wR, fSize - 1 - wC, d2, d1);
                                dotProd += pixel * weight;
                            }
                        }
                    }
                    y.set(dotProd, yR, yC, d2);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.conv2dDerWeights = function (x, dY, fSize, stride, zeroPad) {
        var inputDepth = x.shape[2];
        var outputDepth = dY.shape[2];
        var weightsShape = conv_util.computeWeightsShape4D(inputDepth, outputDepth, fSize);
        var dW = ndarray_1.Array4D.zeros(weightsShape);
        var yNumRows = dY.shape[0];
        var yNumCols = dY.shape[1];
        var xNumRows = x.shape[0];
        var xNumCols = x.shape[1];
        for (var wR = 0; wR < fSize; ++wR) {
            var yRMin = Math.max(0, Math.ceil((zeroPad - wR) / stride));
            var yRMax = Math.min(yNumRows, (xNumRows + zeroPad - wR) / stride);
            for (var wC = 0; wC < fSize; ++wC) {
                var yCMin = Math.max(0, Math.ceil((zeroPad - wC) / stride));
                var yCMax = Math.min(yNumCols, (xNumCols + zeroPad - wC) / stride);
                for (var d1 = 0; d1 < inputDepth; ++d1) {
                    for (var d2 = 0; d2 < outputDepth; ++d2) {
                        var dotProd = 0;
                        for (var yR = yRMin; yR < yRMax; ++yR) {
                            var xR = wR + yR * stride - zeroPad;
                            for (var yC = yCMin; yC < yCMax; ++yC) {
                                var xC = wC + yC * stride - zeroPad;
                                dotProd += x.get(xR, xC, d1) * dY.get(yR, yC, d2);
                            }
                        }
                        dW.set(dotProd, wR, wC, d1, d2);
                    }
                }
            }
        }
        return dW;
    };
    NDArrayMathCPU.prototype.conv2dDerBias = function (dY) {
        var outputDepth = dY.shape[2];
        var numRows = dY.shape[0];
        var numCols = dY.shape[1];
        var values = new Float32Array(outputDepth);
        for (var d2 = 0; d2 < outputDepth; ++d2) {
            var sum = 0;
            for (var r = 0; r < numRows; ++r) {
                for (var c = 0; c < numCols; ++c) {
                    sum += dY.get(r, c, d2);
                }
            }
            values[d2] = sum;
        }
        return ndarray_1.Array1D.new(values);
    };
    NDArrayMathCPU.prototype.switchDimInternal = function (t, newDim) {
        var newShape = new Array(t.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = t.shape[newDim[i]];
        }
        var resultValues = new Float32Array(t.size);
        var values = t.getValues();
        var result = ndarray_1.NDArray.make(newShape, { values: resultValues });
        for (var i = 0; i < t.size; ++i) {
            var loc = t.indexToLoc(i);
            var newLoc = new Array(loc.length);
            for (var i_1 = 0; i_1 < newLoc.length; i_1++) {
                newLoc[i_1] = loc[newDim[i_1]];
            }
            var newIndex = result.locToIndex(newLoc);
            resultValues[newIndex] = values[i];
        }
        return result;
    };
    NDArrayMathCPU.prototype.pool = function (x, fSize, stride, pad, poolType) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];
        var outputShape = conv_util.computeOutputShape3D([xRows, xCols, depth], fSize, depth, stride, pad);
        var y = ndarray_1.Array3D.zeros(outputShape);
        for (var d = 0; d < depth; ++d) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                var xRCorner = yR * stride - pad;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, fSize + xRCorner);
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xCCorner = yC * stride - pad;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, fSize + xCCorner);
                    var minMaxValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :
                        Number.POSITIVE_INFINITY);
                    var avgValue = 0;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var pixel = x.get(xR, xC, d);
                            if (isNaN(pixel)) {
                                minMaxValue = NaN;
                                avgValue = NaN;
                                break;
                            }
                            if ((poolType === 'max' && pixel > minMaxValue) ||
                                (poolType === 'min' && pixel < minMaxValue)) {
                                minMaxValue = pixel;
                            }
                            else if (poolType === 'avg') {
                                avgValue += pixel / (fSize * fSize);
                            }
                        }
                        if (isNaN(minMaxValue)) {
                            break;
                        }
                    }
                    y.set(poolType === 'avg' ? avgValue : minMaxValue, yR, yC, d);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.maxPoolInternal = function (x, fSize, stride, pad) {
        return this.pool(x, fSize, stride, pad, 'max');
    };
    NDArrayMathCPU.prototype.maxPoolPositions = function (x, fSize, stride, pad) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];
        var outputShape = conv_util.computeOutputShape3D(x.shape, fSize, depth, stride, pad);
        var maxPositions = ndarray_1.Array3D.zeros(outputShape);
        for (var d = 0; d < depth; ++d) {
            for (var yR = 0; yR < outputShape[0]; ++yR) {
                var xRCorner = yR * stride - pad;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, fSize + xRCorner);
                for (var yC = 0; yC < outputShape[1]; ++yC) {
                    var xCCorner = yC * stride - pad;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, fSize + xCCorner);
                    var maxValue = Number.NEGATIVE_INFINITY;
                    var maxPosition = -1;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        var wR = xR - xRCorner;
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var wC = xC - xCCorner;
                            var pixel = x.get(xR, xC, d);
                            if (pixel > maxValue) {
                                maxValue = pixel;
                                maxPosition = wR * fSize + wC;
                            }
                        }
                    }
                    maxPositions.set(maxPosition, yR, yC, d);
                }
            }
        }
        return maxPositions;
    };
    NDArrayMathCPU.prototype.maxPoolBackpropInternal = function (dy, x, fSize, origStride, origPad) {
        var maxPositions = this.maxPoolPositions(x, fSize, origStride, origPad);
        var pad = fSize - 1 - origPad;
        var _a = dy.shape, dyRows = _a[0], dyCols = _a[1], depth = _a[2];
        var dyRowsDilated = (dyRows - 1) * origStride + 1;
        var dxColsDilated = (dyCols - 1) * origStride + 1;
        var outputShape = conv_util.computeOutputShape3D([dyRowsDilated, dxColsDilated, depth], fSize, depth, 1, pad);
        var dx = ndarray_1.Array3D.zeros(outputShape);
        for (var d = 0; d < depth; ++d) {
            for (var dxR = 0; dxR < dx.shape[0]; ++dxR) {
                for (var dxC = 0; dxC < dx.shape[1]; ++dxC) {
                    var dyRCorner = dxR - pad;
                    var dyCCorner = dxC - pad;
                    var dotProd = 0;
                    for (var wR = 0; wR < fSize; ++wR) {
                        var dyR = (dyRCorner + wR) / origStride;
                        if (dyR < 0 || dyR >= dyRows || Math.floor(dyR) !== dyR) {
                            continue;
                        }
                        for (var wC = 0; wC < fSize; ++wC) {
                            var dyC = (dyCCorner + wC) / origStride;
                            if (dyC < 0 || dyC >= dyCols || Math.floor(dyC) !== dyC) {
                                continue;
                            }
                            var maxPos = fSize * fSize - 1 - maxPositions.get(dyR, dyC, d);
                            var curPos = wR * fSize + wC;
                            var mask = maxPos === curPos ? 1 : 0;
                            if (mask === 0) {
                                continue;
                            }
                            var pixel = dy.get(dyR, dyC, d);
                            dotProd += pixel * mask;
                        }
                    }
                    dx.set(dotProd, dxR, dxC, d);
                }
            }
        }
        return dx;
    };
    NDArrayMathCPU.prototype.minPoolInternal = function (x, fSize, stride, pad) {
        return this.pool(x, fSize, stride, pad, 'min');
    };
    NDArrayMathCPU.prototype.avgPoolInternal = function (x, fSize, stride, pad) {
        return this.pool(x, fSize, stride, pad, 'avg');
    };
    NDArrayMathCPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {
        var output = ndarray_1.Array3D.zeros([newShape2D[0], newShape2D[1], x.shape[2]]);
        var effectiveInputSize = alignCorners ? [x.shape[0] - 1, x.shape[1] - 1, x.shape[2]] : x.shape;
        var effectiveOutputSize = alignCorners ?
            [output.shape[0] - 1, output.shape[1] - 1, output.shape[2]] :
            output.shape;
        for (var r = 0; r < output.shape[0]; r++) {
            for (var c = 0; c < output.shape[1]; c++) {
                for (var d = 0; d < output.shape[2]; d++) {
                    var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
                    var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
                    var sourceRowFloor = Math.floor(sourceFracRow);
                    var sourceRowCeil = Math.min(x.shape[0] - 1, Math.ceil(sourceFracRow));
                    var sourceColFloor = Math.floor(sourceFracCol);
                    var sourceColCeil = Math.min(x.shape[1] - 1, Math.ceil(sourceFracCol));
                    var topLeft = x.get(sourceRowFloor, sourceColFloor, d);
                    var bottomLeft = x.get(sourceRowCeil, sourceColFloor, d);
                    var topRight = x.get(sourceRowFloor, sourceColCeil, d);
                    var bottomRight = x.get(sourceRowCeil, sourceColCeil, d);
                    var rowFrac = sourceFracRow - sourceRowFloor;
                    var colFrac = sourceFracCol - sourceColFloor;
                    var top_1 = topLeft + (topRight - topLeft) * colFrac;
                    var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                    var newValue = top_1 + (bottom - top_1) * rowFrac;
                    output.set(newValue, r, c, d);
                }
            }
        }
        return output;
    };
    NDArrayMathCPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        var xValues = x.getValues();
        var meanValues = mean.getValues();
        var varianceValues = variance.getValues();
        var scaleValues = scale ? scale.getValues() : new Float32Array([1]);
        var offsetValues = offset ? offset.getValues() : new Float32Array([0]);
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ndarray_1.NDArray.make(x.shape, { values: outValues });
    };
    return NDArrayMathCPU;
}(math_1.NDArrayMath));
exports.NDArrayMathCPU = NDArrayMathCPU;

},{"../math/conv_util":18,"../util":81,"./concat3d_util":17,"./copy2d_util":19,"./math":21,"./ndarray":24}],23:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var concat3d_util = require("./concat3d_util");
var conv_util = require("./conv_util");
var math_1 = require("./math");
var ndarray = require("./ndarray");
var ndarray_1 = require("./ndarray");
var addscaledmat_gpu = require("./webgl/addscaledmat_gpu");
var argmaxequals_gpu_1 = require("./webgl/argmaxequals_gpu");
var argminmax_gpu_1 = require("./webgl/argminmax_gpu");
var avg_pool_gpu = require("./webgl/avg_pool_gpu");
var batchnorm_gpu = require("./webgl/batchnorm_gpu");
var concat3d_gpu = require("./webgl/concat3d_gpu");
var conv_backprop_gpu = require("./webgl/conv_backprop_gpu");
var conv_gpu = require("./webgl/conv_gpu");
var copy_gpu = require("./webgl/copy_gpu");
var gpgpu_context_1 = require("./webgl/gpgpu_context");
var binaryop_gpu_1 = require("./webgl/binaryop_gpu");
var gpgpu_math = require("./webgl/gpgpu_math");
var gpgpu_util = require("./webgl/gpgpu_util");
var logsumexp_gpu_1 = require("./webgl/logsumexp_gpu");
var max_pool_backprop_gpu = require("./webgl/max_pool_backprop_gpu");
var max_pool_gpu = require("./webgl/max_pool_gpu");
var min_pool_gpu = require("./webgl/min_pool_gpu");
var minmax_gpu_1 = require("./webgl/minmax_gpu");
var mulmat_gpu_1 = require("./webgl/mulmat_gpu");
var pool_gpu = require("./webgl/pool_gpu");
var reducesum_gpu_1 = require("./webgl/reducesum_gpu");
var reshape_gpu = require("./webgl/reshape_gpu");
var resize_bilinear_gpu = require("./webgl/resize_bilinear_gpu");
var texture_manager_1 = require("./webgl/texture_manager");
var webgl_util = require("./webgl/webgl_util");
var unaryop_gpu_1 = require("./webgl/unaryop_gpu");
var BATCHNORM_PROG = 'batchnorm';
var COPY_PROG = 'copy';
var CONCAT_PROG = 'concat';
var ADD_SCALED_MAT_PROG = 'addscaledmat';
var RESHAPE_PROG = 'reshape';
var CONV2D_PROG = 'conv';
var CONV2D_TRANSPOSE_PROG = 'conv_transpose';
var CONV2D_DERW_PROG = 'conv_derw';
var CONV2D_DERB_PROG = 'conv_derb';
var MAX_POOL_PROG = 'maxpool';
var MAX_POOL_POSITIONS_PROG = 'maxpool_posn';
var MAX_POOL_BACKPROP_PROG = 'maxpool_backprop';
var MIN_POOL_PROG = 'minpool';
var AVG_POOL_PROG = 'avgpool';
var RESIZE_BILINEAR_PROG = 'resizebilin';
function makeCopyProgramName(sourceShapeRowCol, sourceSizeRowCol, destSizeRowCol) {
    var shapeName = sourceShapeRowCol[0] + "_" + sourceShapeRowCol[1];
    var srcSizeName = sourceSizeRowCol[0] + "_" + sourceSizeRowCol[1];
    var dstSizeName = destSizeRowCol[0] + "_" + destSizeRowCol[1];
    return COPY_PROG + "_" + shapeName + "_" + srcSizeName + "_" + dstSizeName;
}
var NDArrayMathGPU = (function (_super) {
    __extends(NDArrayMathGPU, _super);
    function NDArrayMathGPU(gpgpu, safeMode) {
        if (safeMode === void 0) { safeMode = true; }
        var _this = _super.call(this, safeMode) || this;
        _this.programCache = {};
        _this.binaryCache = {};
        if (gpgpu == null) {
            var gl = gpgpu_util.createWebGLContext();
            _this.gpgpu = new gpgpu_context_1.GPGPUContext(gl);
            _this.gpgpuCreatedLocally = true;
        }
        else {
            _this.gpgpu = gpgpu;
            _this.gpgpuCreatedLocally = false;
        }
        _this.textureManager = new texture_manager_1.TextureManager(_this.gpgpu);
        ndarray.initializeGPU(_this.gpgpu, _this.textureManager);
        return _this;
    }
    NDArrayMathGPU.prototype.getGPGPUContext = function () {
        return this.gpgpu;
    };
    NDArrayMathGPU.prototype.cloneInternal = function (ndarray) {
        var textureShapeRC = ndarray.getTextureShapeRC();
        var program = this.getAndSaveProgram(makeCopyProgramName(textureShapeRC, textureShapeRC, textureShapeRC), function () { return copy_gpu.getFragmentShaderSource(textureShapeRC, textureShapeRC, textureShapeRC); });
        var resultTexture = this.textureManager.acquireTexture(textureShapeRC);
        copy_gpu.copy(this.gpgpu, program, ndarray.getTexture(), textureShapeRC, [0, 0], textureShapeRC, resultTexture, textureShapeRC, [0, 0], textureShapeRC);
        return ndarray_1.NDArray.make(ndarray.shape, { texture: resultTexture, textureShapeRC: textureShapeRC });
    };
    NDArrayMathGPU.prototype.reshapeInternal = function (ndarray, newShape) {
        var newTexShape;
        switch (newShape.length) {
            case 0:
                newTexShape = [1, 1];
                break;
            case 1:
                newTexShape = [newShape[0], 1];
                break;
            case 2:
                newTexShape = [newShape[0], newShape[1]];
                break;
            case 3:
                newTexShape = [newShape[0], newShape[1] * newShape[2]];
                break;
            default:
                throw Error("Reshapes into " + newShape.length + "-dim ndarray is not yet " +
                    "supported on GPU");
        }
        var actualTexShape = ndarray.getTextureShapeRC(newTexShape);
        var clonedArray;
        if (!util.arraysEqual(actualTexShape, newTexShape)) {
            clonedArray = this.reshapeTexture(ndarray, newTexShape);
        }
        else {
            clonedArray = this.cloneInternal(ndarray);
        }
        return clonedArray.reshape(newShape);
    };
    NDArrayMathGPU.prototype.slice2DInternal = function (input, beginRowCol, sizeRowCol) {
        var result = ndarray_1.NDArray.make(sizeRowCol, {
            texture: this.textureManager.acquireTexture(sizeRowCol),
            textureShapeRC: sizeRowCol
        });
        this.copy2DInternal(input, beginRowCol, sizeRowCol, result, [0, 0], sizeRowCol);
        return result;
    };
    NDArrayMathGPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
        var sourceShapeRC = source.getTextureShapeRC();
        var destShapeRC = dest.getTextureShapeRC();
        var program = this.getAndSaveProgram(makeCopyProgramName(sourceShapeRC, sourceSizeRowCol, destSizeRowCol), function () { return copy_gpu.getFragmentShaderSource(sourceShapeRC, sourceSizeRowCol, destSizeRowCol); });
        copy_gpu.copy(this.gpgpu, program, source.getTexture(), sourceShapeRC, sourceBeginRowCol, sourceSizeRowCol, dest.getTexture(), destShapeRC, destBeginRowCol, destSizeRowCol);
    };
    NDArrayMathGPU.prototype.concat3DInternal = function (x1, x2, axis) {
        var x1TexShapeRC = conv_util.computeTexShapeFrom3D(x1.shape);
        var x2TexShapeRC = conv_util.computeTexShapeFrom3D(x2.shape);
        var actualX1TexShape = x1.getTextureShapeRC(x1TexShapeRC);
        var cleanupX1 = false;
        if (!util.arraysEqual(actualX1TexShape, x1TexShapeRC)) {
            x1 = this.reshapeTexture(x1, x1TexShapeRC);
            cleanupX1 = true;
        }
        var actualX2TexShape = x2.getTextureShapeRC(x2TexShapeRC);
        var cleanupX2 = false;
        if (!util.arraysEqual(actualX2TexShape, x2TexShapeRC)) {
            x2 = this.reshapeTexture(x2, x2TexShapeRC);
            cleanupX2 = true;
        }
        var resultShapeRCD = concat3d_util.computeConcat3DOutputShape(x1.shape, x2.shape, axis);
        var program = this.getAndSaveProgram(CONCAT_PROG + "_" + x1.shape + "_" + x2.shape + "_" + axis, function () { return concat3d_gpu.getFragmentShaderSource(x1.shape, x2.shape, resultShapeRCD, axis); });
        var resultTexShape = conv_util.computeTexShapeFrom3D(resultShapeRCD);
        var resultTex = this.textureManager.acquireTexture(resultTexShape);
        concat3d_gpu.concat3D(this.gpgpu, program, x1.getTexture(), x2.getTexture(), resultTex, resultTexShape);
        if (cleanupX1) {
            x1.dispose();
        }
        if (cleanupX2) {
            x2.dispose();
        }
        return ndarray_1.NDArray.make(resultShapeRCD, { texture: resultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {
        var cleanupB = false;
        if (!this.doGPUShapesMatch(a, b)) {
            b = this.reshapeTexture(b, a.getTextureShapeRC());
            cleanupB = true;
        }
        var program = this.getAndSaveProgram(ADD_SCALED_MAT_PROG, function () { return addscaledmat_gpu.getFragmentShaderSource(); });
        var textureShapeRC = a.getTextureShapeRC();
        var resultTexture = this.textureManager.acquireTexture(textureShapeRC);
        addscaledmat_gpu.addScaledMatrices(this.gpgpu, program, a.getTexture(), b.getTexture(), textureShapeRC[0], textureShapeRC[1], c1.getTexture(), c2.getTexture(), resultTexture);
        if (cleanupB) {
            b.dispose();
        }
        return ndarray_1.NDArray.make(a.shape, { texture: resultTexture, textureShapeRC: textureShapeRC });
    };
    NDArrayMathGPU.prototype.negInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.NEG);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.makeOutputArray = function (shape) {
        var textureShapeRC = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);
        var texture = this.textureManager.acquireTexture(textureShapeRC);
        return ndarray_1.NDArray.make(shape, { texture: texture, textureShapeRC: textureShapeRC });
    };
    NDArrayMathGPU.prototype.compileAndRun = function (program, inputs) {
        var _this = this;
        var output = this.makeOutputArray(program.outputShape);
        var key = gpgpu_math.makeShaderKey(program, inputs, output);
        var binary = this.getAndSaveBinary(key, function () {
            return gpgpu_math.compileProgram(_this.gpgpu, program, inputs, output);
        });
        gpgpu_math.runProgram(binary, inputs, output);
        return output;
    };
    NDArrayMathGPU.prototype.reshapeTexture = function (a, newTextureShape) {
        var aTexShape = a.getTextureShapeRC();
        var program = this.getAndSaveProgram(RESHAPE_PROG, function () { return reshape_gpu.getFragmentShaderSource(); });
        var resultTexture = this.textureManager.acquireTexture(newTextureShape);
        reshape_gpu.reshape(this.gpgpu, program, a.getTexture(), aTexShape[0], aTexShape[1], resultTexture, newTextureShape[0], newTextureShape[1]);
        return ndarray_1.NDArray.make(a.shape, { texture: resultTexture, textureShapeRC: newTextureShape });
    };
    NDArrayMathGPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {
        var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, aOrientation, bOrientation);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.multiplyInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram('*', a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xTexShape = x.getTextureShapeRC();
        var cleanupMean = false;
        var preferredMeanTexShape = mean.rank === 1 ? [1, mean.size] : xTexShape;
        var meanTexShape = mean.getTextureShapeRC(preferredMeanTexShape);
        if (!util.arraysEqual(meanTexShape, preferredMeanTexShape)) {
            mean = this.reshapeTexture(mean, preferredMeanTexShape);
            meanTexShape = preferredMeanTexShape;
            cleanupMean = true;
        }
        var cleanupVariance = false;
        var preferredVarianceTexShape = variance.rank === 1 ? [1, variance.size] : xTexShape;
        var varianceTexShape = variance.getTextureShapeRC(preferredMeanTexShape);
        if (!util.arraysEqual(varianceTexShape, preferredVarianceTexShape)) {
            variance = this.reshapeTexture(variance, preferredVarianceTexShape);
            varianceTexShape = preferredVarianceTexShape;
            cleanupVariance = true;
        }
        var scaleTexShape = null;
        var cleanupScale = false;
        if (scale != null) {
            var preferredScaleTexShape = scale.rank === 1 ? [1, scale.size] : xTexShape;
            scaleTexShape = scale.getTextureShapeRC(preferredScaleTexShape);
            if (!util.arraysEqual(scaleTexShape, preferredScaleTexShape)) {
                scale = this.reshapeTexture(scale, preferredScaleTexShape);
                scaleTexShape = preferredScaleTexShape;
                cleanupScale = true;
            }
        }
        var offsetTexShape = null;
        var cleanupOffset = false;
        if (offset != null) {
            var preferredOffsetTexShape = offset.rank === 1 ? [1, offset.size] : xTexShape;
            offsetTexShape = offset.getTextureShapeRC(preferredOffsetTexShape);
            if (!util.arraysEqual(offsetTexShape, preferredOffsetTexShape)) {
                offset = this.reshapeTexture(offset, preferredOffsetTexShape);
                offsetTexShape = preferredOffsetTexShape;
                cleanupOffset = true;
            }
        }
        var resultTexShape = x.getTextureShapeRC();
        var program = this.getAndSaveProgram(BATCHNORM_PROG + "_" + xTexShape + "_" + meanTexShape + "_" + varianceTexShape + "_" +
            (scaleTexShape + "_" + offsetTexShape + "_" + varianceEpsilon), function () { return batchnorm_gpu.getFragmentShaderSource(xTexShape, meanTexShape, varianceTexShape, offsetTexShape, scaleTexShape, varianceEpsilon); });
        var resultTexture = this.textureManager.acquireTexture(resultTexShape);
        batchnorm_gpu.batchNormalization(this.gpgpu, program, x.getTexture(), xTexShape, mean.getTexture(), meanTexShape, variance.getTexture(), varianceTexShape, offset != null ? offset.getTexture() : null, offset != null ? offsetTexShape : null, scale != null ? scale.getTexture() : null, scale != null ? scaleTexShape : null, resultTexture, resultTexShape);
        if (cleanupMean) {
            mean.dispose();
        }
        if (cleanupVariance) {
            variance.dispose();
        }
        if (cleanupScale) {
            scale.dispose();
        }
        if (cleanupOffset) {
            offset.dispose();
        }
        return ndarray_1.NDArray.make(x.shape, { texture: resultTexture, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.switchDimInternal = function (a, newDim) {
        throw new Error('Not yet implemented!');
    };
    NDArrayMathGPU.prototype.sumInternal = function (a) {
        var program = new reducesum_gpu_1.ReduceSumProgram(a.size);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.argMinInternal = function (a) {
        var program = new argminmax_gpu_1.ArgMinMaxProgram(a.size, 'min');
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.argMaxInternal = function (a) {
        var program = new argminmax_gpu_1.ArgMinMaxProgram(a.size, 'max');
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.argMaxEqualsInternal = function (x1, x2) {
        var program = new argmaxequals_gpu_1.ArgMaxEqualsProgram(x1.size, x2.size);
        return this.compileAndRun(program, [x1, x2]);
    };
    NDArrayMathGPU.prototype.topKInternal = function (ndarray, k) {
        throw new Error('topK GPU not yet implemented!');
    };
    NDArrayMathGPU.prototype.minInternal = function (a) {
        var program = new minmax_gpu_1.MinMaxProgram(a.size, 'min');
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.maxInternal = function (a) {
        var program = new minmax_gpu_1.MinMaxProgram(a.size, 'max');
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.divideInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram('/', a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.addInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram('+', a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.subInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram('-', a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.logSumExpInternal = function (a) {
        var program = new logsumexp_gpu_1.LogSumExpProgram(a.size);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.expInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.EXP);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.logInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.LOG);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.reluInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.RELU);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sigmoidInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.SIGMOID);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.tanhInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.TANH);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sinInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.SIN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.stepInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.STEP);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.conv2dInternal = function (x, weights, biases, stride, zeroPad) {
        var fieldSize = weights.shape[0];
        var inputDepth = weights.shape[2];
        var outputDepth = weights.shape[3];
        var progKey = [
            CONV2D_PROG, x.shape, outputDepth, fieldSize, stride, biases != null
        ].join('_');
        var program = this.getAndSaveProgram(progKey, function () {
            return conv_gpu.getFragmentShaderSource(x.shape, outputDepth, fieldSize, stride, zeroPad, biases != null);
        });
        var xTexShape = conv_util.computeTexShapeFrom3D(x.shape);
        var wTexShape = conv_util.computeWeightsTexShape(inputDepth, outputDepth, fieldSize);
        var biasTexShape = conv_util.computeBiasesTexShape(outputDepth);
        var actualXTexShape = x.getTextureShapeRC(xTexShape);
        var cleanupX = false;
        if (!util.arraysEqual(actualXTexShape, xTexShape)) {
            x = this.reshapeTexture(x, xTexShape);
            cleanupX = true;
        }
        var cleanupW = false;
        var actualWTexShape = weights.getTextureShapeRC(wTexShape);
        if (!util.arraysEqual(actualWTexShape, wTexShape)) {
            weights = this.reshapeTexture(weights, wTexShape);
            cleanupW = true;
        }
        var cleanupB = false;
        if (biases != null) {
            var actualBTexShape = biases.getTextureShapeRC(biasTexShape);
            if (!util.arraysEqual(actualBTexShape, biasTexShape)) {
                biases = this.reshapeTexture(biases, biasTexShape);
                cleanupB = true;
            }
        }
        var resultShape = conv_util.computeOutputShape3D(x.shape, fieldSize, outputDepth, stride, zeroPad);
        var resultTexShape = conv_util.computeTexShapeFrom3D(resultShape);
        var resultTex = this.textureManager.acquireTexture(resultTexShape);
        conv_gpu.convolve(this.gpgpu, program, x.getTexture(), weights.getTexture(), biases != null ? biases.getTexture() : null, resultTex, resultTexShape);
        if (cleanupX) {
            x.dispose();
        }
        if (cleanupW) {
            weights.dispose();
        }
        if (cleanupB && biases != null) {
            biases.dispose();
        }
        return ndarray_1.NDArray.make(resultShape, { texture: resultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.conv2dBackPropInternal = function (x, dy, weights, stride, pad) {
        var fSize = weights.shape[0];
        var inputDepth = weights.shape[2];
        var outputDepth = weights.shape[3];
        var xTexShape = conv_util.computeTexShapeFrom3D(x.shape);
        var wTexShape = conv_util.computeWeightsTexShape(inputDepth, outputDepth, fSize);
        var yTexShape = conv_util.computeTexShapeFrom3D(dy.shape);
        var cleanupX = false;
        var actualXTexShape = x.getTextureShapeRC(xTexShape);
        if (!util.arraysEqual(actualXTexShape, xTexShape)) {
            x = this.reshapeTexture(x, xTexShape);
            cleanupX = true;
        }
        var cleanupW = false;
        var actualWTexShape = weights.getTextureShapeRC(wTexShape);
        if (!util.arraysEqual(actualWTexShape, wTexShape)) {
            weights = this.reshapeTexture(weights, wTexShape);
            cleanupW = true;
        }
        var cleanupY = false;
        var actualYTexShape = dy.getTextureShapeRC(yTexShape);
        if (!util.arraysEqual(actualYTexShape, yTexShape)) {
            dy = this.reshapeTexture(dy, yTexShape);
            cleanupY = true;
        }
        var dw = this.conv2dDerWeights(x, dy, fSize, stride, pad);
        var db = this.conv2dDerBias(dy);
        var dx = this.conv2dTransposeInternal(dy, weights, null, stride, pad);
        if (cleanupX) {
            x.dispose();
        }
        if (cleanupW) {
            weights.dispose();
        }
        if (cleanupY) {
            dy.dispose();
        }
        return { dx: dx, db: db, dw: dw };
    };
    NDArrayMathGPU.prototype.conv2dTransposeInternal = function (x, weights, biases, origStride, origPad) {
        var origInputDepth = weights.shape[2];
        var origOutputDepth = weights.shape[3];
        var fieldSize = weights.shape[0];
        var progKey = [
            CONV2D_TRANSPOSE_PROG, x.shape, fieldSize, origInputDepth, origStride,
            origPad, biases != null
        ].join('_');
        var program = this.getAndSaveProgram(progKey, function () {
            return conv_backprop_gpu.getFragmentShaderConvTransposeSource(x.shape, fieldSize, origInputDepth, origStride, origPad, biases != null);
        });
        var xTexShape = conv_util.computeTexShapeFrom3D(x.shape);
        var wTexShape = conv_util.computeWeightsTexShape(origInputDepth, origOutputDepth, fieldSize);
        var biasTexShape = conv_util.computeBiasesTexShape(origInputDepth);
        var actualXTexShape = x.getTextureShapeRC(xTexShape);
        var cleanupX = false;
        if (!util.arraysEqual(actualXTexShape, xTexShape)) {
            x = this.reshapeTexture(x, xTexShape);
            cleanupX = true;
        }
        var cleanupW = false;
        var actualWTexShape = weights.getTextureShapeRC(wTexShape);
        if (!util.arraysEqual(actualWTexShape, wTexShape)) {
            weights = this.reshapeTexture(weights, wTexShape);
            cleanupW = true;
        }
        var cleanupB = false;
        if (biases != null) {
            var actualBiasTexShape = biases.getTextureShapeRC(biasTexShape);
            if (!util.arraysEqual(actualBiasTexShape, biasTexShape)) {
                biases = this.reshapeTexture(biases, biasTexShape);
                cleanupB = true;
            }
        }
        var dilatedRC = conv_util.computeDilatedRC([x.shape[0], x.shape[1]], origStride);
        var pad = fieldSize - 1 - origPad;
        var resultShape = conv_util.computeOutputShape3D([dilatedRC[0], dilatedRC[1], origOutputDepth], fieldSize, origInputDepth, 1, pad);
        var resultTexShape = conv_util.computeTexShapeFrom3D(resultShape);
        var resultTex = this.textureManager.acquireTexture(resultTexShape);
        conv_backprop_gpu.convTranspose(this.gpgpu, program, x.getTexture(), weights.getTexture(), biases != null ? biases.getTexture() : null, resultTex, resultTexShape);
        if (cleanupX) {
            x.dispose();
        }
        if (cleanupW) {
            weights.dispose();
        }
        if (cleanupB) {
            biases.dispose();
        }
        return ndarray_1.NDArray.make(resultShape, { texture: resultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.conv2dDerWeights = function (x, dY, fSize, stride, zeroPad) {
        var inputDepth = x.shape[2];
        var outputDepth = dY.shape[2];
        var progKey = [
            CONV2D_DERW_PROG, x.shape, fSize, outputDepth, stride, zeroPad
        ].join('_');
        var program = this.getAndSaveProgram(progKey, function () {
            return conv_backprop_gpu.getFragmentShaderDerWeightsSource(x.shape, fSize, outputDepth, stride, zeroPad);
        });
        var xTexShape = conv_util.computeTexShapeFrom3D(x.shape);
        var yShape = conv_util.computeOutputShape3D(x.shape, fSize, outputDepth, stride, zeroPad);
        var yTexShape = conv_util.computeTexShapeFrom3D(yShape);
        var actualXTexShape = x.getTextureShapeRC(xTexShape);
        var cleanupX = false;
        if (!util.arraysEqual(actualXTexShape, xTexShape)) {
            x = this.reshapeTexture(x, xTexShape);
            cleanupX = true;
        }
        var cleanupY = false;
        var actualYTexShape = dY.getTextureShapeRC(yTexShape);
        if (!util.arraysEqual(actualYTexShape, yTexShape)) {
            dY = this.reshapeTexture(dY, yTexShape);
            cleanupY = true;
        }
        var resultTexShape = conv_util.computeWeightsTexShape(inputDepth, outputDepth, fSize);
        var resultTex = this.textureManager.acquireTexture(resultTexShape);
        conv_backprop_gpu.derWeights(this.gpgpu, program, x.getTexture(), dY.getTexture(), resultTex, resultTexShape);
        if (cleanupX) {
            x.dispose();
        }
        if (cleanupY) {
            dY.dispose();
        }
        var weightsShape = conv_util.computeWeightsShape4D(inputDepth, outputDepth, fSize);
        return ndarray_1.NDArray.make(weightsShape, { texture: resultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.conv2dDerBias = function (dY) {
        var outputDepth = dY.shape[2];
        var progKey = [CONV2D_DERB_PROG, dY.shape].join('_');
        var program = this.getAndSaveProgram(progKey, function () {
            return conv_backprop_gpu.getFragmentShaderDerBiasSource(dY.shape);
        });
        var yTexShape = conv_util.computeTexShapeFrom3D(dY.shape);
        var cleanupY = false;
        var actualYTexShape = dY.getTextureShapeRC(yTexShape);
        if (!util.arraysEqual(actualYTexShape, yTexShape)) {
            dY = this.reshapeTexture(dY, yTexShape);
            cleanupY = true;
        }
        var resultTexShape = conv_util.computeBiasesTexShape(outputDepth);
        var resultTex = this.textureManager.acquireTexture(resultTexShape);
        conv_backprop_gpu.derBias(this.gpgpu, program, dY.getTexture(), resultTex, resultTexShape);
        if (cleanupY) {
            dY.dispose();
        }
        return ndarray_1.NDArray.make([outputDepth], { texture: resultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.pool = function (program, x, fSize, stride, pad) {
        var xTexShape = conv_util.computeTexShapeFrom3D(x.shape);
        var actualXTexShape = x.getTextureShapeRC(xTexShape);
        var cleanupX = false;
        if (!util.arraysEqual(actualXTexShape, xTexShape)) {
            x = this.reshapeTexture(x, xTexShape);
            cleanupX = true;
        }
        var resultShape = conv_util.computeOutputShape3D(x.shape, fSize, x.shape[2], stride, pad);
        var resultTexShape = conv_util.computeTexShapeFrom3D(resultShape);
        var poolResultTex = this.textureManager.acquireTexture(resultTexShape);
        pool_gpu.poolCommon(this.gpgpu, program, x.getTexture(), poolResultTex, resultTexShape);
        if (cleanupX) {
            x.dispose();
        }
        return ndarray_1.NDArray.make(resultShape, { texture: poolResultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.maxPoolInternal = function (x, fSize, stride, pad) {
        var maxPoolProgKey = [MAX_POOL_PROG, x.shape, fSize, stride, pad].join('_');
        var maxPoolProgram = this.getAndSaveProgram(maxPoolProgKey, function () {
            return max_pool_gpu.getFragmentShaderMaxPoolSource(x.shape, fSize, stride, pad);
        });
        return this.pool(maxPoolProgram, x, fSize, stride, pad);
    };
    NDArrayMathGPU.prototype.minPoolInternal = function (x, fSize, stride, pad) {
        var minPoolProgKey = [MIN_POOL_PROG, x.shape, fSize, stride, pad].join('_');
        var minPoolProgram = this.getAndSaveProgram(minPoolProgKey, function () {
            return min_pool_gpu.getFragmentShaderMinPoolSource(x.shape, fSize, stride, pad);
        });
        return this.pool(minPoolProgram, x, fSize, stride, pad);
    };
    NDArrayMathGPU.prototype.avgPoolInternal = function (x, fSize, stride, pad) {
        var avgPoolProgKey = [AVG_POOL_PROG, x.shape, fSize, stride, pad].join('_');
        var avgPoolProgram = this.getAndSaveProgram(avgPoolProgKey, function () {
            return avg_pool_gpu.getFragmentShaderAvgPoolSource(x.shape, fSize, stride, pad);
        });
        return this.pool(avgPoolProgram, x, fSize, stride, pad);
    };
    NDArrayMathGPU.prototype.maxPoolBackpropInternal = function (dy, x, fSize, origStride, origPad) {
        var maxPoolPositionsProgKey = [
            MAX_POOL_POSITIONS_PROG, x.shape, fSize, origStride, origPad
        ].join('_');
        var maxPoolPositionsProgram = this.getAndSaveProgram(maxPoolPositionsProgKey, function () {
            return max_pool_gpu.getFragmentShaderMaxPoolPositionsSource(x.shape, fSize, origStride, origPad);
        });
        var maxPoolResultShape = conv_util.computeOutputShape3D(x.shape, fSize, x.shape[2], origStride, origPad);
        var maxPoolResultTexShape = conv_util.computeTexShapeFrom3D(maxPoolResultShape);
        var maxPoolPositionsResultTex = this.textureManager.acquireTexture(maxPoolResultTexShape);
        var xTexShape = conv_util.computeTexShapeFrom3D(x.shape);
        var actualXTexShape = x.getTextureShapeRC(xTexShape);
        var cleanupX = false;
        if (!util.arraysEqual(actualXTexShape, xTexShape)) {
            x = this.reshapeTexture(x, xTexShape);
            cleanupX = true;
        }
        max_pool_gpu.maxPoolCommon(this.gpgpu, maxPoolPositionsProgram, x.getTexture(), maxPoolPositionsResultTex, maxPoolResultTexShape);
        var maxPoolBackpropProgKey = [
            MAX_POOL_BACKPROP_PROG, dy.shape, fSize, origStride, origPad
        ].join('_');
        var program = this.getAndSaveProgram(maxPoolBackpropProgKey, function () {
            return max_pool_backprop_gpu.getFragmentShaderMaxPoolBackprop(dy.shape, fSize, origStride, origPad);
        });
        var dyTexShape = conv_util.computeTexShapeFrom3D(dy.shape);
        var actualDyTexShape = dy.getTextureShapeRC(dyTexShape);
        var cleanupDy = false;
        if (!util.arraysEqual(actualDyTexShape, dyTexShape)) {
            dy = this.reshapeTexture(dy, dyTexShape);
            cleanupDy = true;
        }
        var dilatedDyRC = conv_util.computeDilatedRC([dy.shape[0], dy.shape[1]], origStride);
        var pad = fSize - 1 - origPad;
        var resultShapeRCD = conv_util.computeOutputShape3D([dilatedDyRC[0], dilatedDyRC[1], dy.shape[2]], fSize, dy.shape[2], 1, pad);
        var resultTexShape = conv_util.computeTexShapeFrom3D(resultShapeRCD);
        var resultTex = this.textureManager.acquireTexture(resultTexShape);
        max_pool_backprop_gpu.maxPoolBackprop(this.gpgpu, program, dy.getTexture(), maxPoolPositionsResultTex, resultTex, resultTexShape);
        if (cleanupDy) {
            dy.dispose();
        }
        if (cleanupX) {
            x.dispose();
        }
        this.textureManager.releaseTexture(maxPoolPositionsResultTex, maxPoolResultTexShape);
        return ndarray_1.NDArray.make(resultShapeRCD, { texture: resultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {
        var programKey = [RESIZE_BILINEAR_PROG, x.shape, newShape2D, alignCorners].join('_');
        var newShapeRCD = [newShape2D[0], newShape2D[1], x.shape[2]];
        var resultTexShape = conv_util.computeTexShapeFrom3D(newShapeRCD);
        var program = this.getAndSaveProgram(programKey, function () { return resize_bilinear_gpu.getFragmentShaderSource(x.shape, newShape2D, alignCorners); });
        var resultTexture = this.textureManager.acquireTexture(resultTexShape);
        resize_bilinear_gpu.resizeBilinear(this.gpgpu, program, x.getTexture(), resultTexture, resultTexShape);
        return ndarray_1.NDArray.make(newShapeRCD, { texture: resultTexture, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.getAndSaveBinary = function (key, getBinary) {
        if (!(key in this.binaryCache)) {
            this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
    };
    NDArrayMathGPU.prototype.getAndSaveProgram = function (programKey, getShaderSource) {
        if (!(programKey in this.programCache)) {
            this.programCache[programKey] =
                this.gpgpu.createProgram(getShaderSource());
        }
        return this.programCache[programKey];
    };
    NDArrayMathGPU.prototype.doGPUShapesMatch = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape);
        if (a.inGPU()) {
            b.getTextureShapeRC(a.getTextureShapeRC());
        }
        else if (b.inGPU()) {
            a.getTextureShapeRC(b.getTextureShapeRC());
        }
        return util.arraysEqual(a.getTextureShapeRC(), b.getTextureShapeRC());
    };
    NDArrayMathGPU.prototype.getTextureManager = function () {
        return this.textureManager;
    };
    NDArrayMathGPU.prototype.dispose = function () {
        for (var programKey in this.programCache) {
            if (this.programCache.hasOwnProperty(programKey)) {
                this.gpgpu.deleteProgram(this.programCache[programKey]);
            }
        }
        for (var key in this.binaryCache) {
            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
        }
        this.textureManager.dispose();
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.dispose();
        }
    };
    return NDArrayMathGPU;
}(math_1.NDArrayMath));
exports.NDArrayMathGPU = NDArrayMathGPU;

},{"../util":81,"./concat3d_util":17,"./conv_util":18,"./math":21,"./ndarray":24,"./webgl/addscaledmat_gpu":25,"./webgl/argmaxequals_gpu":26,"./webgl/argminmax_gpu":27,"./webgl/avg_pool_gpu":28,"./webgl/batchnorm_gpu":29,"./webgl/binaryop_gpu":30,"./webgl/concat3d_gpu":31,"./webgl/conv_backprop_gpu":32,"./webgl/conv_gpu":33,"./webgl/copy_gpu":34,"./webgl/gpgpu_context":35,"./webgl/gpgpu_math":36,"./webgl/gpgpu_util":37,"./webgl/logsumexp_gpu":38,"./webgl/max_pool_backprop_gpu":39,"./webgl/max_pool_gpu":40,"./webgl/min_pool_gpu":41,"./webgl/minmax_gpu":42,"./webgl/mulmat_gpu":43,"./webgl/pool_gpu":44,"./webgl/reducesum_gpu":45,"./webgl/reshape_gpu":47,"./webgl/resize_bilinear_gpu":48,"./webgl/texture_manager":51,"./webgl/unaryop_gpu":52,"./webgl/webgl_util":53}],24:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var webgl_util = require("./webgl/webgl_util");
exports.GPGPU = null;
exports.TEXTURE_MANAGER = null;
function initializeGPU(gpgpu, textureManager) {
    exports.GPGPU = gpgpu;
    exports.TEXTURE_MANAGER = textureManager;
}
exports.initializeGPU = initializeGPU;
function throwIfGPUNotInitialized() {
    if (exports.GPGPU == null || exports.TEXTURE_MANAGER == null) {
        throw new Error('GPU not intialized.');
    }
}
var NDArray = (function () {
    function NDArray(shape, data) {
        util.assert(data.values != null || data.texture != null, 'Either `values` or `texture` must be defined');
        util.assert(data.texture == null || (data.textureShapeRC != null), '`textureShape` must be defined when `texture` is defined');
        this.size = util.sizeFromShape(shape);
        if (data.values != null) {
            util.assert(this.size === data.values.length, 'Constructing ndarray of shape (' + this.size + ') should match the' +
                ' length of values (' + data.values.length + ')');
        }
        this.shape = shape;
        this.data = data;
        var dim = this.shape.length;
        if (dim < 2) {
            this.strides = [];
        }
        else {
            this.strides = new Array(dim - 1);
            this.strides[dim - 2] = this.shape[dim - 1];
            for (var i = dim - 3; i >= 0; --i) {
                this.strides[i] = this.strides[i + 1] * this.shape[i + 1];
            }
        }
    }
    NDArray.zeros = function (shape) {
        var values = new Float32Array(util.sizeFromShape(shape));
        return NDArray.make(shape, { values: values });
    };
    NDArray.zerosLike = function (another) {
        return NDArray.zeros(another.shape);
    };
    NDArray.like = function (another) {
        var values = another.getValues();
        return NDArray.make(another.shape, { values: new Float32Array(values) });
    };
    NDArray.make = function (shape, data) {
        switch (shape.length) {
            case 0:
                return new Scalar(data);
            case 1:
                return new Array1D(data);
            case 2:
                return new Array2D(shape, data);
            case 3:
                return new Array3D(shape, data);
            case 4:
                return new Array4D(shape, data);
            default:
                return new NDArray(shape, data);
        }
    };
    NDArray.prototype.reshape = function (newShape) {
        if (util.arraysEqual(this.shape, newShape)) {
            return this;
        }
        util.assert(this.size === util.sizeFromShape(newShape), 'new shape and old shape must have the same number of elements.');
        return NDArray.make(newShape, this.data);
    };
    NDArray.prototype.asScalar = function () {
        util.assert(this.size === 1, 'The array must have only 1 element.');
        return this.reshape([]);
    };
    NDArray.prototype.as1D = function () {
        return this.reshape([this.size]);
    };
    NDArray.prototype.as2D = function (rows, columns) {
        return this.reshape([rows, columns]);
    };
    NDArray.prototype.as3D = function (rows, columns, depth) {
        return this.reshape([rows, columns, depth]);
    };
    NDArray.prototype.as4D = function (rows, columns, depth, depth2) {
        return this.reshape([rows, columns, depth, depth2]);
    };
    Object.defineProperty(NDArray.prototype, "rank", {
        get: function () {
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    NDArray.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.getValues()[index];
    };
    NDArray.prototype.add = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        this.set.apply(this, [this.get.apply(this, locs) + value].concat(locs));
    };
    NDArray.prototype.set = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        this.getValues()[index] = value;
    };
    NDArray.prototype.locToIndex = function (locs) {
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return index;
    };
    NDArray.prototype.indexToLoc = function (index) {
        var locs = new Array(this.shape.length);
        for (var i = 0; i < locs.length - 1; ++i) {
            locs[i] = Math.floor(index / this.strides[i]);
            index -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index;
        return locs;
    };
    NDArray.prototype.fill = function (value) {
        this.getValues().fill(value);
    };
    NDArray.prototype.getData = function () {
        return this.data;
    };
    NDArray.prototype.getValues = function () {
        if (this.data.values == null) {
            throwIfGPUNotInitialized();
            this.data.values = exports.GPGPU.downloadMatrixFromTexture(this.data.texture, this.data.textureShapeRC[0], this.data.textureShapeRC[1]);
            this.disposeTexture();
        }
        return this.data.values;
    };
    NDArray.prototype.uploadToGPU = function (preferredTexShape) {
        throwIfGPUNotInitialized();
        this.data.textureShapeRC = webgl_util.getTextureShapeFromLogicalShape(exports.GPGPU.gl, this.shape, preferredTexShape);
        this.data.texture =
            exports.TEXTURE_MANAGER.acquireTexture(this.data.textureShapeRC);
        exports.GPGPU.uploadMatrixToTexture(this.data.texture, this.data.textureShapeRC[0], this.data.textureShapeRC[1], this.data.values);
        this.data.values = null;
    };
    NDArray.prototype.getTexture = function (preferredShapeRC) {
        if (this.data.texture == null) {
            this.uploadToGPU(preferredShapeRC);
        }
        return this.data.texture;
    };
    NDArray.prototype.getTextureShapeRC = function (preferredShapeRC) {
        if (this.data.textureShapeRC == null) {
            this.uploadToGPU(preferredShapeRC);
        }
        return this.data.textureShapeRC;
    };
    NDArray.prototype.dispose = function () {
        this.data.values = null;
        this.shape = null;
        if (this.data.texture != null) {
            this.disposeTexture();
        }
    };
    NDArray.prototype.disposeTexture = function () {
        throwIfGPUNotInitialized();
        exports.TEXTURE_MANAGER.releaseTexture(this.data.texture, this.data.textureShapeRC);
        this.data.texture = null;
        this.data.textureShapeRC = null;
    };
    NDArray.prototype.inGPU = function () {
        return this.data.texture != null;
    };
    NDArray.prototype.equals = function (t) {
        return util.arraysEqual(this.shape, t.shape) &&
            util.arraysEqual(this.getValues(), t.getValues());
    };
    NDArray.rand = function (shape, randFunction) {
        var size = util.sizeFromShape(shape);
        var values = new Float32Array(size);
        for (var i = 0; i < size; i++) {
            values[i] = randFunction();
        }
        return NDArray.make(shape, { values: values });
    };
    NDArray.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    NDArray.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    NDArray.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return NDArray;
}());
exports.NDArray = NDArray;
var Scalar = (function (_super) {
    __extends(Scalar, _super);
    function Scalar(data) {
        var _this = this;
        if (data.texture != null) {
            data.textureShapeRC = [1, 1];
        }
        _this = _super.call(this, [], data) || this;
        return _this;
    }
    Scalar.new = function (value) {
        return new Scalar({ values: new Float32Array([value]) });
    };
    Scalar.prototype.get = function () {
        return this.getValues()[0];
    };
    Scalar.prototype.set = function (value) {
        this.getValues()[0] = value;
    };
    Scalar.prototype.add = function (value) {
        this.getValues()[0] += value;
    };
    Scalar.ZERO = Scalar.new(0);
    Scalar.ONE = Scalar.new(1);
    Scalar.TWO = Scalar.new(2);
    Scalar.NEG_ONE = Scalar.new(-1);
    return Scalar;
}(NDArray));
exports.Scalar = Scalar;
var Array1D = (function (_super) {
    __extends(Array1D, _super);
    function Array1D(data) {
        var _this = this;
        var shape = (data.values != null) ?
            [data.values.length] :
            [util.sizeFromShape(data.textureShapeRC)];
        _this = _super.call(this, shape, data) || this;
        return _this;
    }
    Array1D.new = function (values) {
        if (!(values instanceof Float32Array)) {
            var inferredShape = util.inferShape(values);
            util.assert(inferredShape.length === 1, "Error constructing Array1D. Shape of values " + inferredShape + " is " +
                "not 1 dimensional.");
        }
        return new Array1D({ values: toTypedArray(values) });
    };
    Array1D.prototype.get = function (i) {
        return this.getValues()[i];
    };
    Array1D.prototype.set = function (value, i) {
        this.getValues()[i] = value;
    };
    Array1D.prototype.add = function (value, i) {
        this.getValues()[i] += value;
    };
    Array1D.prototype.locToIndex = function (loc) {
        return loc[0];
    };
    Array1D.prototype.indexToLoc = function (index) {
        return [index];
    };
    Array1D.zeros = function (shape) {
        return NDArray.zeros(shape);
    };
    return Array1D;
}(NDArray));
exports.Array1D = Array1D;
var Array2D = (function (_super) {
    __extends(Array2D, _super);
    function Array2D(shape, data) {
        var _this = this;
        util.assert(shape.length === 2, 'Shape should be of length 2');
        _this = _super.call(this, shape, data) || this;
        _this.stride0 = _this.strides[0];
        return _this;
    }
    Array2D.new = function (shape, values) {
        if (!(values instanceof Float32Array)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array2D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array2D(shape, { values: toTypedArray(values) });
    };
    Array2D.prototype.get = function (i, j) {
        return this.getValues()[this.stride0 * i + j];
    };
    Array2D.prototype.set = function (value, i, j) {
        this.getValues()[this.stride0 * i + j] = value;
    };
    Array2D.prototype.add = function (value, i, j) {
        this.getValues()[this.stride0 * i + j] += value;
    };
    Array2D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + locs[1];
    };
    Array2D.prototype.indexToLoc = function (index) {
        return [Math.floor(index / this.stride0), index % this.stride0];
    };
    Array2D.zeros = function (shape) {
        return NDArray.zeros(shape);
    };
    return Array2D;
}(NDArray));
exports.Array2D = Array2D;
var Array3D = (function (_super) {
    __extends(Array3D, _super);
    function Array3D(shape, data) {
        var _this = this;
        util.assert(shape.length === 3, 'Shape should be of length 3');
        _this = _super.call(this, shape, data) || this;
        _this.stride0 = _this.strides[0];
        _this.stride1 = _this.strides[1];
        return _this;
    }
    Array3D.new = function (shape, values) {
        if (!(values instanceof Float32Array)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array3D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array3D(shape, { values: toTypedArray(values) });
    };
    Array3D.prototype.get = function (i, j, k) {
        return this.getValues()[this.stride0 * i + this.stride1 * j + k];
    };
    Array3D.prototype.set = function (value, i, j, k) {
        this.getValues()[this.stride0 * i + this.stride1 * j + k] = value;
    };
    Array3D.prototype.add = function (value, i, j, k) {
        this.getValues()[this.stride0 * i + this.stride1 * j + k] += value;
    };
    Array3D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + this.stride1 * locs[1] + locs[2];
    };
    Array3D.prototype.indexToLoc = function (index) {
        var i = Math.floor(index / this.stride0);
        index -= i * this.stride0;
        return [i, Math.floor(index / this.stride1), index % this.stride1];
    };
    Array3D.zeros = function (shape) {
        return NDArray.zeros(shape);
    };
    return Array3D;
}(NDArray));
exports.Array3D = Array3D;
var Array4D = (function (_super) {
    __extends(Array4D, _super);
    function Array4D(shape, data) {
        var _this = this;
        util.assert(shape.length === 4, 'Shape should be of length 4');
        _this = _super.call(this, shape, data) || this;
        _this.stride0 = _this.strides[0];
        _this.stride1 = _this.strides[1];
        _this.stride2 = _this.strides[2];
        return _this;
    }
    Array4D.new = function (shape, values) {
        if (!(values instanceof Float32Array)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array4D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array4D(shape, { values: toTypedArray(values) });
    };
    Array4D.prototype.get = function (i, j, k, l) {
        return this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l];
    };
    Array4D.prototype.set = function (value, i, j, k, l) {
        this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] = value;
    };
    Array4D.prototype.add = function (value, i, j, k, l) {
        this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] += value;
    };
    Array4D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + this.stride1 * locs[1] +
            this.stride2 * locs[2] + locs[3];
    };
    Array4D.prototype.indexToLoc = function (index) {
        var i = Math.floor(index / this.stride0);
        index -= i * this.stride0;
        var j = Math.floor(index / this.stride1);
        index -= j * this.stride1;
        return [i, j, Math.floor(index / this.stride2), index % this.stride2];
    };
    Array4D.zeros = function (shape) {
        return NDArray.zeros(shape);
    };
    return Array4D;
}(NDArray));
exports.Array4D = Array4D;
function toTypedArray(a) {
    return (a instanceof Float32Array) ? a : new Float32Array(util.flatten(a));
}

},{"../util":81,"./webgl/webgl_util":53}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gpgpu_context_1 = require("./gpgpu_context");
function getFragmentShaderSource() {
    return "\n    precision highp float;\n    uniform sampler2D matrixA;\n    uniform sampler2D matrixB;\n    uniform sampler2D matrixAScalar;\n    uniform sampler2D matrixBScalar;\n    varying vec2 resultUV;\n\n    const vec2 halfTexel = vec2(0.5, 0.5);\n\n    void main() {\n      float a = texture2D(matrixA, resultUV).r;\n      float b = texture2D(matrixB, resultUV).r;\n      float aScalar = texture2D(matrixAScalar, halfTexel).r;\n      float bScalar = texture2D(matrixBScalar, halfTexel).r;\n      vec2 abScaled = vec2(a, b) * vec2(aScalar, bScalar);\n      gl_FragColor = vec4(abScaled.x + abScaled.y, 0, 0, 0);\n    }";
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function addScaledMatrices(gpgpu, addScaledMatricesProgram, a, b, rows, columns, aScalar, bScalar, result) {
    gpgpu.setOutputMatrixTexture(result, rows, columns);
    gpgpu.setProgram(addScaledMatricesProgram);
    gpgpu.setInputMatrixTexture(a, 'matrixA', 0);
    gpgpu.setInputMatrixTexture(b, 'matrixB', 1);
    gpgpu.setInputMatrixTexture(aScalar, 'matrixAScalar', 2);
    gpgpu.setInputMatrixTexture(bScalar, 'matrixBScalar', 3);
    gpgpu.executeProgram();
}
exports.addScaledMatrices = addScaledMatrices;
function uploadAddScaledMatricesDownload(a, b, rows, columns, aScalar, bScalar) {
    var gpgpu = new gpgpu_context_1.GPGPUContext();
    var program = gpgpu.createProgram(getFragmentShaderSource());
    var aTex = gpgpu.createMatrixTexture(rows, columns);
    var bTex = gpgpu.createMatrixTexture(rows, columns);
    var aScalarTex = gpgpu.createMatrixTexture(1, 1);
    var bScalarTex = gpgpu.createMatrixTexture(1, 1);
    var resultTex = gpgpu.createMatrixTexture(rows, columns);
    gpgpu.uploadMatrixToTexture(aTex, rows, columns, a);
    gpgpu.uploadMatrixToTexture(bTex, rows, columns, b);
    gpgpu.uploadMatrixToTexture(aScalarTex, 1, 1, new Float32Array([aScalar]));
    gpgpu.uploadMatrixToTexture(bScalarTex, 1, 1, new Float32Array([bScalar]));
    addScaledMatrices(gpgpu, program, aTex, bTex, rows, columns, aScalarTex, bScalarTex, resultTex);
    var result = gpgpu.downloadMatrixFromTexture(resultTex, rows, columns);
    gpgpu.deleteMatrixTexture(aTex);
    gpgpu.deleteMatrixTexture(bTex);
    gpgpu.deleteMatrixTexture(resultTex);
    gpgpu.deleteMatrixTexture(aScalarTex);
    gpgpu.deleteMatrixTexture(bScalarTex);
    gpgpu.deleteProgram(program);
    gpgpu.dispose();
    return result;
}
exports.uploadAddScaledMatricesDownload = uploadAddScaledMatricesDownload;

},{"./gpgpu_context":35}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var argminmax_gpu = require("./argminmax_gpu");
var ArgMaxEqualsProgram = (function () {
    function ArgMaxEqualsProgram(aSize, bSize) {
        this.variableNames = ['A', 'B'];
        this.outputShape = [];
        this.params = [];
        var aSnippet = argminmax_gpu.getArgMinMaxSnippet('max', 'A', aSize);
        var bSnippet = argminmax_gpu.getArgMinMaxSnippet('max', 'B', bSize);
        this.userCode = "\n      " + aSnippet + "\n      " + bSnippet + "\n\n      void main() {\n        float argMaxA = getArgMinMaxA();\n        float argMaxB = getArgMinMaxB();\n\n        float value;\n        if (isNaN(argMaxA)) {\n          value = argMaxA;\n        } else if (isNaN(argMaxB)) {\n          value = argMaxB;\n        } else {\n          value = float(argMaxA == argMaxB);\n        }\n\n        setOutput(value);\n      }\n    ";
    }
    return ArgMaxEqualsProgram;
}());
exports.ArgMaxEqualsProgram = ArgMaxEqualsProgram;

},{"./argminmax_gpu":27}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getArgMinMaxSnippet(op, texName, size) {
    var compOp = (op === 'min') ? '<' : '>';
    return "\n    float getArgMinMax" + texName + "() {\n      float bestIndex = 0.0;\n      float bestValue = get" + texName + "Flat(0.0);\n\n      for (int i = 0; i < " + size + "; i++) {\n        float i_float = float(i);\n        float candidate = get" + texName + "Flat(i_float);\n        if (isNaN(candidate)) {\n          return candidate;\n        }\n        if (candidate " + compOp + " bestValue) {\n          bestValue = candidate;\n          bestIndex = i_float;\n        }\n      }\n      return bestIndex;\n    }\n  ";
}
exports.getArgMinMaxSnippet = getArgMinMaxSnippet;
var ArgMinMaxProgram = (function () {
    function ArgMinMaxProgram(aSize, opType) {
        this.variableNames = ['A'];
        this.outputShape = [];
        this.params = [opType];
        var aSnippet = getArgMinMaxSnippet(opType, 'A', aSize);
        this.userCode = "\n      " + aSnippet + "\n\n      void main() {\n        setOutput(getArgMinMaxA());\n      }\n    ";
    }
    return ArgMinMaxProgram;
}());
exports.ArgMinMaxProgram = ArgMinMaxProgram;

},{}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var pool_gpu = require("./pool_gpu");
function getFragmentShaderAvgPoolSource(xShapeRCD, fSize, stride, pad) {
    return pool_gpu.getFragmentShaderPoolCommonSource(xShapeRCD, fSize, stride, pad, 'avg', false);
}
exports.getFragmentShaderAvgPoolSource = getFragmentShaderAvgPoolSource;
function avgPool(gpgpu, program, x, result, resultShapeRowCol) {
    pool_gpu.poolCommon(gpgpu, program, x, result, resultShapeRowCol);
}
exports.avgPool = avgPool;

},{"./pool_gpu":44}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getFragmentShaderSource(xTexShapeRC, meanTexShapeRC, varianceTexShapeRC, offsetTexShapeRC, scaleTexShapeRC, varianceEpsilon) {
    if (varianceEpsilon === void 0) { varianceEpsilon = 0.001; }
    var offsetSamplerSnippet = '';
    var offsetShapeInitializationSnippet = '';
    var offsetCoordsSnippet = '';
    var offsetUVSnippet = '';
    var offsetValueSnippet = '';
    var offsetOperationSnippet = '0.0';
    var scaleSamplerSnippet = '';
    var scaleShapeInitializationSnippet = '';
    var scaleCoordsSnippet = '';
    var scaleUVSnippet = '';
    var scaleValueSnippet = '';
    var scaleOperationSnippet = '';
    if (offsetTexShapeRC != null) {
        offsetSamplerSnippet = 'uniform sampler2D offset;';
        offsetShapeInitializationSnippet = "const vec2 offsetShapeCR = vec2(\n            " + offsetTexShapeRC[1] + ", " + offsetTexShapeRC[0] + ");";
        offsetCoordsSnippet = 'vec2 offsetCoordsCR = mod(yTexCR, offsetShapeCR);';
        offsetUVSnippet =
            'vec2 offsetUV = (offsetCoordsCR + halfCR) / offsetShapeCR;';
        offsetValueSnippet = 'float offsetValue = texture2D(offset, offsetUV).r;';
        offsetOperationSnippet = 'offsetValue';
    }
    if (scaleTexShapeRC != null) {
        scaleSamplerSnippet = 'uniform sampler2D scale;';
        scaleShapeInitializationSnippet = "const vec2 scaleShapeCR = vec2(\n            " + scaleTexShapeRC[1] + ", " + scaleTexShapeRC[0] + ");";
        scaleCoordsSnippet = 'vec2 scaleCoordsCR = mod(yTexCR, scaleShapeCR);';
        scaleUVSnippet = 'vec2 scaleUV = (scaleCoordsCR + halfCR) / scaleShapeCR;';
        scaleValueSnippet = 'float scaleValue = texture2D(scale, scaleUV).r;';
        scaleOperationSnippet = 'inv *= scaleValue;';
    }
    return "\n    precision highp float;\n    uniform sampler2D x;\n    uniform sampler2D mean;\n    uniform sampler2D variance;\n    " + offsetSamplerSnippet + "\n    " + scaleSamplerSnippet + "\n\n    varying vec2 resultUV;\n\n    const vec2 xShapeCR = vec2(" + xTexShapeRC[1] + ", " + xTexShapeRC[0] + ");\n    const vec2 meanShapeCR = vec2(" + meanTexShapeRC[1] + ", " + meanTexShapeRC[0] + ");\n    const vec2 varianceShapeCR = vec2(\n        " + varianceTexShapeRC[1] + ", " + varianceTexShapeRC[0] + ");\n\n    " + offsetShapeInitializationSnippet + "\n    " + scaleShapeInitializationSnippet + "\n\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const float varianceEpsilon = " + varianceEpsilon + ";\n\n    void main() {\n      vec2 yTexCR = floor(gl_FragCoord.xy);\n\n      vec2 meanCoordsCR = mod(yTexCR, meanShapeCR);\n      vec2 varianceCoordsCR = mod(yTexCR, varianceShapeCR);\n      " + offsetCoordsSnippet + "\n      " + scaleCoordsSnippet + "\n\n      vec2 meanUV = (meanCoordsCR + halfCR) / meanShapeCR;\n      vec2 varianceUV = (varianceCoordsCR + halfCR) / varianceShapeCR;\n      " + offsetUVSnippet + "\n      " + scaleUVSnippet + "\n\n      float xValue = texture2D(x, resultUV).r;\n      float meanValue = texture2D(mean, meanUV).r;\n      float varianceValue = texture2D(variance, varianceUV).r;\n      " + offsetValueSnippet + "\n      " + scaleValueSnippet + "\n\n      float inv = 1.0 / sqrt(varianceValue + varianceEpsilon);\n      " + scaleOperationSnippet + "\n      float xTimesInv = xValue * inv;\n      float meanTimesInvWithOffset = " + offsetOperationSnippet + "\n          - meanValue * inv;\n\n      gl_FragColor = vec4(xTimesInv + meanTimesInvWithOffset, 0, 0, 0);\n    }";
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function batchNormalization(gpgpu, program, x, xShapeRowCol, mean, meanShapeRowCol, variance, varianceShapeRowCol, offset, offsetShapeRowCol, scale, scaleShapeRowCol, result, resultShapeRowCol) {
    gpgpu.setOutputMatrixTexture(result, resultShapeRowCol[0], resultShapeRowCol[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(x, 'x', 0);
    gpgpu.setInputMatrixTexture(mean, 'mean', 1);
    gpgpu.setInputMatrixTexture(variance, 'variance', 2);
    var nextIndex = 3;
    if (offset != null) {
        gpgpu.setInputMatrixTexture(offset, 'offset', nextIndex);
        nextIndex++;
    }
    if (scale != null) {
        gpgpu.setInputMatrixTexture(scale, 'scale', nextIndex);
    }
    gpgpu.executeProgram();
}
exports.batchNormalization = batchNormalization;

},{}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var BinaryOpProgram = (function () {
    function BinaryOpProgram(op, aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.supportsBroadcasting = true;
        this.params = [op];
        this.outputShape = util.assertAndGetBroadcastedShape(aShape, bShape);
        this.userCode = "\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(a " + op + " b);\n      }\n    ";
    }
    return BinaryOpProgram;
}());
exports.BinaryOpProgram = BinaryOpProgram;

},{"../../util":81}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
function getFragmentShaderSource(x1ShapeRCD, x2ShapeRCD, resultShapeRCD, axis) {
    var x1TexShapeRC = conv_util.computeTexShapeFrom3D(x1ShapeRCD);
    var x2TexShapeRC = conv_util.computeTexShapeFrom3D(x2ShapeRCD);
    var yAxes = ['yR', 'yC', 'yD'];
    var concatAxis = yAxes[axis];
    return "\n    precision highp float;\n    uniform sampler2D x1;\n    uniform sampler2D x2;\n\n    const vec2 x1ShapeCR = vec2(" + x1TexShapeRC[1] + ", " + x1TexShapeRC[0] + ");\n    const vec2 x2ShapeCR = vec2(" + x2TexShapeRC[1] + ".0, " + x2TexShapeRC[0] + ".0);\n\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    void main() {\n      vec2 yTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (yTexR, yTexC) to 3D (yR, yC, yD).\n      float yR = yTexCR.y;\n      float yC = floor(yTexCR.x / " + resultShapeRCD[2] + ".0);\n      float yD = mod(yTexCR.x, " + resultShapeRCD[2] + ".0);\n\n      float value = 0.0;\n\n      if (" + concatAxis + " < " + x1ShapeRCD[axis] + ".0) {\n        // Map yR, yC, yD back to x1 coordinates.\n        vec2 x1CR = vec2(yC * " + x1ShapeRCD[2] + ".0 + yD, yR);\n        vec2 x1UV = (x1CR + halfCR) / x1ShapeCR;\n        value = texture2D(x1, x1UV).r;\n      } else {\n        " + concatAxis + " = " + concatAxis + " - " + x1ShapeRCD[axis] + ".0;\n\n        // Map yR, yC, yD back to x2 coordinates.\n        vec2 x2CR = vec2(yC * " + x2ShapeRCD[2] + ".0 + yD, yR);\n        vec2 x2UV = (x2CR + halfCR) / x2ShapeCR;\n        value = texture2D(x2, x2UV).r;\n      }\n\n      gl_FragColor = vec4(value, 0.0, 0.0, 0.0);\n    }";
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function concat3D(gpgpu, program, x1, x2, result, resultShapeRC) {
    gpgpu.setOutputMatrixTexture(result, resultShapeRC[0], resultShapeRC[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(x1, 'x1', 0);
    gpgpu.setInputMatrixTexture(x2, 'x2', 1);
    gpgpu.executeProgram();
}
exports.concat3D = concat3D;

},{"../conv_util":18}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
var conv_gpu = require("./conv_gpu");
function getFragmentShaderDerWeightsSource(xShapeRowColDepth, fSize, outputDepth, stride, zeroPad) {
    var getMatrixValueOrZeroPad = conv_gpu.getFragmentShaderGetMatrixValueOrZeroPadSource();
    var inputDepth = xShapeRowColDepth[2];
    var xTexShapeRC = conv_util.computeTexShapeFrom3D(xShapeRowColDepth);
    var yShape = conv_util.computeOutputShape3D(xShapeRowColDepth, fSize, outputDepth, stride, zeroPad);
    var yNumRows = yShape[0];
    var yNumCols = yShape[1];
    var yTexShapeRC = conv_util.computeTexShapeFrom3D(yShape);
    var fSizeTimesInputDepth = fSize * inputDepth;
    var prologue = "\n    precision highp float;\n    uniform sampler2D x;\n    uniform sampler2D dy;\n  ";
    return prologue + '\n' + getMatrixValueOrZeroPad + '\n' +
        ("\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const vec2 xShapeCR = vec2(" + xTexShapeRC[1] + ", " + xTexShapeRC[0] + ");\n    const vec2 dyShapeCR = vec2(" + yTexShapeRC[1] + ", " + yTexShapeRC[0] + ");\n\n    void main() {\n      vec2 wTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (wTexR, wTexC) to 4D (wR, wC, d1, d2).\n      float wR = floor(wTexCR.y / " + fSizeTimesInputDepth + ".0);\n      float wTexRLeftover = wTexCR.y - wR * " + fSizeTimesInputDepth + ".0;\n      float wC = floor(wTexRLeftover / " + inputDepth + ".0);\n      float d1 = mod(wTexRLeftover, " + inputDepth + ".0);\n      float d2 = wTexCR.x;\n\n      // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n      // ? = to be determined. : = across all values in that axis.\n      float dotProd = 0.0;\n      for (int yR = 0; yR < " + yNumRows + "; yR++) {\n        float yTexR = float(yR);\n        float xR = wR + yTexR * " + stride + ".0 - " + zeroPad + ".0;\n        float xTexR = xR;\n\n        for (int yC = 0; yC < " + yNumCols + "; yC++) {\n          float yC_float = float(yC);\n          float xC = wC + yC_float * " + stride + ".0 - " + zeroPad + ".0;\n\n          // Map from 3D (xR, xC, d1) to 2D (xTexR, xTexC).\n          // Map from 3D (yR, yC, d2) to 2D (yTexR, yTexC).\n          vec2 xyTexC =\n              vec2(xC, yC_float) * vec2(" + inputDepth + ".0, " + outputDepth + ".0) +\n              vec2(d1, d2);\n          float xTexC = xyTexC.x;\n          float yTexC = xyTexC.y;\n\n          // Read dy(yR, yC, d2).\n          vec2 dyUV = (vec2(yTexC, yTexR) + halfCR) / dyShapeCR;\n          float dyValue = texture2D(dy, dyUV).r;\n\n          // Read x(xR, xC, d1) (potentially zero-padded).\n          float xValue =\n            getMatrixValueOrZeroPad(x, xShapeCR, vec2(xTexC, xTexR));\n\n          dotProd += (xValue * dyValue);\n        }\n      }\n      gl_FragColor = vec4(dotProd, 0, 0, 0);\n    }");
}
exports.getFragmentShaderDerWeightsSource = getFragmentShaderDerWeightsSource;
function getFragmentShaderConvTransposeSource(xShapeRCD, fSize, origInputDepth, origStride, origPad, hasBias) {
    var pad = fSize - 1 - origPad;
    var xRows = xShapeRCD[0], xCols = xShapeRCD[1], origOutputDepth = xShapeRCD[2];
    var xTexShapeRC = conv_util.computeTexShapeFrom3D(xShapeRCD);
    var wTexShapeRC = conv_util.computeWeightsTexShape(origInputDepth, origOutputDepth, fSize);
    var getBiasValue = hasBias ?
        conv_gpu.getFragmentShaderGetBiasValueSource(origInputDepth) :
        '';
    var biasPrologue = hasBias ? 'uniform sampler2D biases;' : '';
    var biasOperation = hasBias ? 'dotProd += getBiasValue(biases, d2);' : '';
    var prologue = "\n    precision highp float;\n    uniform sampler2D x;\n    uniform sampler2D weights;\n    " + biasPrologue + "\n    ";
    return prologue + '\n' + getBiasValue + '\n' +
        ("\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const vec2 xShapeCR = vec2(" + xTexShapeRC[1] + ", " + xTexShapeRC[0] + ");\n    const vec2 wShapeCR = vec2(" + wTexShapeRC[1] + ", " + wTexShapeRC[0] + ");\n\n    void main() {\n      vec2 yTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (yTexR, yTexC) to 3D (yR, yC, d2).\n      float yR = yTexCR.y;\n      float yC = floor(yTexCR.x / " + origInputDepth + ".0);\n      float d2 = mod(yTexCR.x, " + origInputDepth + ".0);\n\n      vec2 xRCCorner = vec2(yR, yC) - vec2(" + pad + ".0, " + pad + ".0);\n      float xRCorner = xRCCorner.x;\n      float xCCorner = xRCCorner.y;\n\n      // Convolve x(?, ?, d1) with w(:, :, d2, d1) to get y(yR, yC, d2).\n      // ? = to be determined. : = across all values in that axis.\n      float dotProd = 0.0;\n      for (int wR = 0; wR < " + fSize + "; wR++) {\n        float wR_float = float(wR);\n        float xR = (xRCorner + wR_float) / " + origStride + ".0;\n        // TODO(smilkov): Splice this with another version where you call\n        // getMatrixValueOrZeroPad(). Here and below.\n        if (xR < 0.0 || xR >= " + xRows + ".0 || fract(xR) > 0.0) {\n          continue;\n        }\n\n        float wRPerm = " + fSize + ".0 - 1.0 - wR_float;\n        float xTexR = xR;\n\n        for (int wC = 0; wC < " + fSize + "; wC++) {\n          float wC_float = float(wC);\n          float xC = (xCCorner + wC_float) / " + origStride + ".0;\n          if (xC < 0.0 || xC >= " + xCols + ".0 || fract(xC) > 0.0) {\n            continue;\n          }\n\n          float wCPerm = " + fSize + ".0 - 1.0 - wC_float;\n          float wTexR = wRPerm * " + fSize + ".0 * " + origInputDepth + ".0 +\n                        wCPerm * " + origInputDepth + ".0 + d2;\n\n          for (int d1 = 0; d1 < " + origOutputDepth + "; d1++) {\n            float d1_float = float(d1);\n            float xTexC = xC * " + origOutputDepth + ".0 + d1_float;\n            float wTexC = d1_float;\n\n            // Read x(xR, xC, d1).\n            vec2 xUV = (vec2(xTexC, xTexR) + halfCR) / xShapeCR;\n            float xValue = texture2D(x, xUV).r;\n\n            // Read w(wRPerm, wCPerm, d2, d1).\n            vec2 wUV = (vec2(wTexC, wTexR) + halfCR) / wShapeCR;\n            float wValue = texture2D(weights, wUV).r;\n\n            dotProd += xValue * wValue;\n          }\n        }\n      }\n      " + biasOperation + "\n      gl_FragColor = vec4(dotProd, 0, 0, 0);\n    }");
}
exports.getFragmentShaderConvTransposeSource = getFragmentShaderConvTransposeSource;
function getFragmentShaderDerBiasSource(dyShapeRCD) {
    var dyTexShapeRC = conv_util.computeTexShapeFrom3D(dyShapeRCD);
    var yNumRows = dyShapeRCD[0], yNumCols = dyShapeRCD[1], outputDepth = dyShapeRCD[2];
    return "\n    precision highp float;\n    uniform sampler2D dy;\n\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const vec2 dyShapeCR = vec2(" + dyTexShapeRC[1] + ", " + dyTexShapeRC[0] + ");\n\n    void main() {\n      vec2 biasTexCR = floor(gl_FragCoord.xy);\n\n      // The bias texture RC shape is [1, d2].\n      float d2 = biasTexCR.x;\n\n      float derBias = 0.0;\n      for (int yR = 0; yR < " + yNumRows + "; yR++) {\n        float yTexR = float(yR);\n\n        for (int yC = 0; yC < " + yNumCols + "; yC++) {\n          float yC_float = float(yC);\n          // Map from 3D (yR, yC, d2) to 2D (yTexR, yTexC).\n          float yTexC = yC_float * " + outputDepth + ".0 + d2;\n\n          // Read dy(yR, yC, d2).\n          vec2 dyUV = (vec2(yTexC, yTexR) + halfCR) / dyShapeCR;\n          float dyValue = texture2D(dy, dyUV).r;\n\n          derBias += dyValue;\n        }\n      }\n      gl_FragColor = vec4(derBias, 0, 0, 0);\n    }";
}
exports.getFragmentShaderDerBiasSource = getFragmentShaderDerBiasSource;
function derBias(gpgpu, program, dyTex, result, resultTexShapeRC) {
    gpgpu.setOutputMatrixTexture(result, resultTexShapeRC[0], resultTexShapeRC[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(dyTex, 'dy', 0);
    gpgpu.executeProgram();
}
exports.derBias = derBias;
function derWeights(gpgpu, program, xTex, dyTex, result, resultTexShapeRC) {
    gpgpu.setOutputMatrixTexture(result, resultTexShapeRC[0], resultTexShapeRC[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(xTex, 'x', 0);
    gpgpu.setInputMatrixTexture(dyTex, 'dy', 1);
    gpgpu.executeProgram();
}
exports.derWeights = derWeights;
function convTranspose(gpgpu, program, xTex, weightsTex, biasesTex, resultTex, resultTexShapeRC) {
    gpgpu.setOutputMatrixTexture(resultTex, resultTexShapeRC[0], resultTexShapeRC[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(xTex, 'x', 0);
    gpgpu.setInputMatrixTexture(weightsTex, 'weights', 1);
    if (biasesTex != null) {
        gpgpu.setInputMatrixTexture(biasesTex, 'biases', 2);
    }
    gpgpu.executeProgram();
}
exports.convTranspose = convTranspose;

},{"../conv_util":18,"./conv_gpu":33}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
function getFragmentShaderPrologueSource() {
    return "\n    precision highp float;\n    uniform sampler2D x;\n    uniform sampler2D weights;\n    uniform sampler2D biases;\n    varying vec2 resultUV;";
}
exports.getFragmentShaderPrologueSource = getFragmentShaderPrologueSource;
function getFragmentShaderGetMatrixValueOrZeroPadSource() {
    return "\n    float getMatrixValueOrZeroPad(in sampler2D matrix, vec2 matrixShapeCR,\n        vec2 requestedCR) {\n      vec2 uv = (requestedCR + vec2(0.5, 0.5)) / matrixShapeCR;\n      float value = texture2D(matrix, uv).r;\n      bool lessThanZero = any(lessThan(uv, vec2(0, 0)));\n      bool greaterThanOne = any(greaterThan(uv, vec2(1, 1)));\n      bool outside = lessThanZero || greaterThanOne;\n      return mix(value, 0.0, float(outside));\n    }";
}
exports.getFragmentShaderGetMatrixValueOrZeroPadSource = getFragmentShaderGetMatrixValueOrZeroPadSource;
function getFragmentShaderConvolveSource(xShapeRCD, fSize, outputDepth, stride, pad, hasBias) {
    var inputDepth = xShapeRCD[2];
    var xTexShapeRC = conv_util.computeTexShapeFrom3D(xShapeRCD);
    var wTexShapeRC = conv_util.computeWeightsTexShape(inputDepth, outputDepth, fSize);
    return "\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const vec2 xShapeCR = vec2(" + xTexShapeRC[1] + ", " + xTexShapeRC[0] + ");\n    const vec2 wShapeCR = vec2(" + wTexShapeRC[1] + ", " + wTexShapeRC[0] + ");\n\n    void main() {\n      vec2 yTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (yTexR, yTexC) to 3D (yR, yC, d2).\n      float yR = yTexCR.y;\n      float yC = floor(yTexCR.x / " + outputDepth + ".0);\n      float d2 = mod(yTexCR.x, " + outputDepth + ".0);\n      float wTexC = d2;\n\n      vec2 xRCCorner = vec2(yR, yC) * vec2(" + stride + ", " + stride + ") -\n          vec2(" + pad + ".0, " + pad + ".0);\n      float xRCorner = xRCCorner.x;\n      float xCCorner = xRCCorner.y;\n\n      // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n      // ? = to be determined. : = across all values in that axis.\n      float dotProd = 0.0;\n      for (int wR = 0; wR < " + fSize + "; wR++) {\n        float wR_float = float(wR);\n        float xR = xRCorner + wR_float;\n        float xTexR = xR;\n\n        for (int wC = 0; wC < " + fSize + "; wC++) {\n          float wC_float = float(wC);\n          float xC = xCCorner + wC_float;\n\n          for (int d1 = 0; d1 < " + inputDepth + "; d1++) {\n            float d1_float = float(d1);\n            float xTexC = xC * " + inputDepth + ".0 + d1_float;\n            float wTexR = wR_float * " + fSize * inputDepth + ".0 +\n                wC_float * " + inputDepth + ".0 + d1_float;\n\n            float xValue =\n                getMatrixValueOrZeroPad(x, xShapeCR, vec2(xTexC, xTexR));\n\n            // Read w(wR, wC, d1, d2).\n            vec2 wUV = (vec2(wTexC, wTexR) + halfCR) / wShapeCR;\n            float wValue = texture2D(weights, wUV).r;\n\n            dotProd += xValue * wValue;\n          }\n        }\n      }\n      if (" + hasBias + ") {\n        dotProd += getBiasValue(biases, d2);\n      }\n      gl_FragColor = vec4(dotProd, 0, 0, 0);\n    }";
}
exports.getFragmentShaderConvolveSource = getFragmentShaderConvolveSource;
function getFragmentShaderGetBiasValueSource(outputDepth) {
    return "\n    float getBiasValue(in sampler2D bias, float biasC) {\n      const vec2 biasShapeCR = vec2(" + outputDepth + ", 1);\n      vec2 biasCR = vec2(mod(biasC, " + outputDepth + ".0), 0);\n      vec2 biasUV = (biasCR + vec2(0.5, 0.5)) / biasShapeCR;\n      return texture2D(bias, biasUV).r;\n    }";
}
exports.getFragmentShaderGetBiasValueSource = getFragmentShaderGetBiasValueSource;
function getFragmentShaderSource(aShapeRowColDepth, resultDepth, fieldSize, stride, zeroPad, hasBias) {
    var prologue = getFragmentShaderPrologueSource();
    var getMatrixValueOrZeroPad = getFragmentShaderGetMatrixValueOrZeroPadSource();
    var convolve = getFragmentShaderConvolveSource(aShapeRowColDepth, fieldSize, resultDepth, stride, zeroPad, hasBias);
    var getBiasValue = getFragmentShaderGetBiasValueSource(resultDepth);
    return [
        prologue,
        getMatrixValueOrZeroPad,
        getBiasValue,
        convolve,
    ].join('\n');
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function convolve(gpgpu, program, a, weights, biases, result, resultShapeRowCol) {
    gpgpu.setOutputMatrixTexture(result, resultShapeRowCol[0], resultShapeRowCol[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(a, 'x', 0);
    gpgpu.setInputMatrixTexture(weights, 'weights', 1);
    if (biases != null) {
        gpgpu.setInputMatrixTexture(biases, 'biases', 2);
    }
    gpgpu.executeProgram();
}
exports.convolve = convolve;

},{"../conv_util":18}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getFragmentShaderSource(sourceShapeRowCol, sourceSizeRowCol, destSizeRowCol) {
    return "\n    precision highp float;\n    uniform sampler2D source;\n    uniform vec2 sourceStartCR;\n    uniform vec2 destStartCR;\n\n    const vec2 sourceShapeCR =\n      vec2(" + sourceShapeRowCol[1] + ", " + sourceShapeRowCol[0] + ");\n    const vec2 sourceSizeCR =\n      vec2(" + sourceSizeRowCol[1] + ", " + sourceSizeRowCol[0] + ");\n    const vec2 destSizeCR =\n      vec2(" + destSizeRowCol[1] + ", " + destSizeRowCol[0] + ");\n\n    void main() {\n      vec2 destOffsetCR = floor(gl_FragCoord.xy) - destStartCR;\n      float destOffsetFlat = (destOffsetCR.y * destSizeCR.x) + destOffsetCR.x;\n      vec2 sourceOffsetCR = vec2(mod(destOffsetFlat, sourceSizeCR.x),\n        floor(destOffsetFlat / sourceSizeCR.x));\n      vec2 sourceCR = sourceStartCR + sourceOffsetCR;\n      vec2 sourceUV = (sourceCR + vec2(0.5, 0.5)) / sourceShapeCR;\n      gl_FragColor = texture2D(source, sourceUV);\n    }";
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function copy(gpgpu, program, source, sourceShapeRowCol, sourceStartRowCol, sourceSizeRowCol, dest, destShapeRowCol, destStartRowCol, destSizeRowCol) {
    gpgpu.setOutputMatrixTexture(dest, destShapeRowCol[0], destShapeRowCol[1]);
    gpgpu.setOutputMatrixWriteRegion(destStartRowCol[0], destSizeRowCol[0], destStartRowCol[1], destSizeRowCol[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(source, 'source', 0);
    var sourceStartCRLoc = gpgpu.getUniformLocation('sourceStartCR');
    gpgpu.gl.uniform2f(sourceStartCRLoc, sourceStartRowCol[1], sourceStartRowCol[0]);
    var destStartCRLoc = gpgpu.getUniformLocation('destStartCR');
    gpgpu.gl.uniform2f(destStartCRLoc, destStartRowCol[1], destStartRowCol[0]);
    gpgpu.executeProgram();
}
exports.copy = copy;

},{}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gpgpu_util = require("./gpgpu_util");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
var GPGPUContext = (function () {
    function GPGPUContext(gl) {
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.autoDebugValidate = false;
        if (gl != null) {
            this.gl = gl;
        }
        else {
            this.gl = gpgpu_util.createWebGLContext();
        }
        if (!webgl_util.isWebGL2Enabled()) {
            this.textureFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'OES_texture_float');
        }
        else {
            this.colorBufferFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'EXT_color_buffer_float');
        }
        this.loseContextExtension =
            webgl_util.getExtensionOrThrow(this.gl, 'WEBGL_lose_context');
        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);
        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);
        this.framebuffer = webgl_util.createFramebuffer(this.gl);
    }
    GPGPUContext.prototype.dispose = function () {
        var _this = this;
        this.throwIfDisposed();
        if (this.program != null) {
            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +
                ' This is probably a resource leak, delete the program with ' +
                'GPGPUContext.deleteProgram before disposing.');
        }
        if (this.outputTexture != null) {
            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +
                'texture.  This is probably a resource leak, delete the output ' +
                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +
                'disposing.');
        }
        var gl = this.gl;
        webgl_util.callAndCheck(gl, function () { return gl.finish(); });
        webgl_util.callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteFramebuffer(_this.framebuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.vertexBuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.indexBuffer); });
        this.loseContextExtension.loseContext();
        this.disposed = true;
    };
    GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {
        this.autoDebugValidate = enabled;
        webgl_util.enableDebugWebGLErrorChecking(enabled);
    };
    GPGPUContext.prototype.createMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {
        this.throwIfDisposed();
        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);
    };
    GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.deleteMatrixTexture = function (texture) {
        var _this = this;
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
            this.outputTexture = null;
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteTexture(texture); });
    };
    GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        var numChannels = 1;
        return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels);
    };
    GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix);
    };
    GPGPUContext.prototype.downloadMatrixFromTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () {
            return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl, rows, columns);
        });
    };
    GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, rows, columns); });
    };
    GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {
        this.throwIfDisposed();
        var gl = this.gl;
        var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);
        var vertexShader = gpgpu_util.createVertexShader(gl);
        var program = webgl_util.createProgram(gl);
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, vertexShader); });
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, fragmentShader); });
        webgl_util.linkProgram(gl, program);
        if (this.autoDebugValidate) {
            webgl_util.validateProgram(gl, program);
        }
        return program;
    };
    GPGPUContext.prototype.deleteProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        if (program === this.program) {
            this.program = null;
        }
        if (program != null) {
            webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteProgram(program); });
        }
    };
    GPGPUContext.prototype.setProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        this.program = program;
        if ((this.program != null) && this.autoDebugValidate) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.useProgram(program); });
    };
    GPGPUContext.prototype.getUniformLocation = function (uniformName) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        return webgl_util.getProgramUniformLocationOrThrow(this.gl, this.program, uniformName);
    };
    GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformName, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformName, textureUnit);
    };
    GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');
    };
    GPGPUContext.prototype.debugValidate = function () {
        if (this.program != null) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.validateFramebuffer(this.gl);
    };
    GPGPUContext.prototype.executeProgram = function () {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        var gl = this.gl;
        gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);
        if (this.autoDebugValidate) {
            this.debugValidate();
        }
        webgl_util.callAndCheck(gl, function () { return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); });
    };
    GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.finish(); });
    };
    GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {
        this.throwIfDisposed();
        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
        var result = downloadAndDecode();
        if (this.outputTexture != null) {
            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
            if (this.autoDebugValidate) {
                webgl_util.validateFramebuffer(this.gl);
            }
        }
        else {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        }
        return result;
    };
    GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        var gl = this.gl;
        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(gl);
        }
        this.outputTexture = outputMatrixTextureMaybePacked;
        webgl_util.callAndCheck(gl, function () { return gl.viewport(0, 0, width, height); });
        webgl_util.callAndCheck(gl, function () { return gl.scissor(0, 0, width, height); });
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.scissor(x, y, width, height); });
    };
    GPGPUContext.prototype.throwIfDisposed = function () {
        if (this.disposed) {
            throw new Error('Attempted to use disposed GPGPUContext.');
        }
    };
    GPGPUContext.prototype.throwIfNoProgram = function () {
        if (this.program == null) {
            throw new Error('No GPU program is currently set.');
        }
    };
    return GPGPUContext;
}());
exports.GPGPUContext = GPGPUContext;

},{"./gpgpu_util":37,"./tex_util":50,"./webgl_util":53}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler = require("./shader_compiler");
var util = require("../../util");
function compileProgram(gpgpu, program, inputs, output) {
    var userCode = program.userCode;
    var inputInfos = program.variableNames.map(function (x, i) {
        var shapeInfo = {
            logicalShape: inputs[i].shape,
            texShape: inputs[i].getTextureShapeRC()
        };
        return { name: x, shapeInfo: shapeInfo };
    });
    var inShapeInfos = inputInfos.map(function (x) { return x.shapeInfo; });
    var outShapeInfo = {
        logicalShape: output.shape,
        texShape: output.getTextureShapeRC()
    };
    var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);
    return {
        program: program,
        source: source,
        webGLProgram: gpgpu.createProgram(source),
        gpgpu: gpgpu,
        inShapeInfos: inShapeInfos,
        outShapeInfo: outShapeInfo
    };
}
exports.compileProgram = compileProgram;
function validateBinaryAndProgram(shapeInfos, bArrays) {
    shapeInfos.forEach(function (s, i) {
        var shapeA = s.logicalShape;
        var texShapeA = s.texShape;
        var shapeB = bArrays[i].shape;
        var texShapeB = bArrays[i].getTextureShapeRC();
        if (!util.arraysEqual(shapeA, shapeB)) {
            throw Error("Binary was compiled with different shapes than " +
                ("the current args. Shapes " + shapeA + " and " + shapeB + " must match"));
        }
        if (!util.arraysEqual(texShapeA, texShapeB)) {
            throw Error("Binary was compiled with different texture shapes than the" +
                (" current args. Shape " + texShapeA + " and " + texShapeB + " must match"));
        }
    });
}
function runProgram(binary, inputs, output) {
    validateBinaryAndProgram(binary.inShapeInfos, inputs);
    validateBinaryAndProgram([binary.outShapeInfo], [output]);
    var outTex = output.getTexture();
    var outTexShape = output.getTextureShapeRC();
    var gpgpu = binary.gpgpu;
    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    gpgpu.setProgram(binary.webGLProgram);
    inputs.forEach(function (input, i) {
        var tex = input.getTexture();
        gpgpu.setInputMatrixTexture(tex, binary.program.variableNames[i], i);
    });
    gpgpu.executeProgram();
}
exports.runProgram = runProgram;
function makeShaderKey(program, inputs, output) {
    var params = program.params;
    var keyStart = inputs.concat(output).map(function (x) { return x.shape + '_' + x.getTextureShapeRC(); });
    var keyEnd = params.map(function (p) { return p.toString(); });
    var key = [program.constructor.name];
    key.push((program.supportsBroadcasting === true).toString());
    key = key.concat(keyStart, keyEnd);
    return key.join('_');
}
exports.makeShaderKey = makeShaderKey;

},{"../../util":81,"./shader_compiler":49}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
function getWebGLContextAttributes() {
    return {
        alpha: false,
        antialias: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        depth: false,
        stencil: false,
        failIfMajorPerformanceCaveat: true
    };
}
exports.getWebGLContextAttributes = getWebGLContextAttributes;
function createWebGLContext(canvas) {
    var attributes = getWebGLContextAttributes();
    var gl;
    if (canvas != null) {
        gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);
    }
    else {
        gl = webgl_util.createWebGLRenderingContext(attributes);
    }
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DEPTH_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.STENCIL_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.BLEND); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DITHER); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.POLYGON_OFFSET_FILL); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.SAMPLE_COVERAGE); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.SCISSOR_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.CULL_FACE); });
    webgl_util.callAndCheck(gl, function () { return gl.cullFace(gl.BACK); });
    return gl;
}
exports.createWebGLContext = createWebGLContext;
function createVertexShader(gl) {
    var vertexShaderSource = "\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";
    return webgl_util.createVertexShader(gl, vertexShaderSource);
}
exports.createVertexShader = createVertexShader;
function createVertexBuffer(gl) {
    var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return webgl_util.createStaticVertexBuffer(gl, vertexArray);
}
exports.createVertexBuffer = createVertexBuffer;
function createIndexBuffer(gl) {
    var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);
}
exports.createIndexBuffer = createIndexBuffer;
function getTextureInternalFormat(gl, numChannels) {
    if (webgl_util.isWebGL2Enabled()) {
        if (numChannels === 4) {
            return gl.RGBA32F;
        }
        return gl.R32F;
    }
    return gl.RGBA;
}
function getTextureFormat(gl, numChannels) {
    if (webgl_util.isWebGL2Enabled() && numChannels === 1) {
        return gl.RED;
    }
    return gl.RGBA;
}
function createAndConfigureTexture(gl, width, height, numChannels) {
    webgl_util.validateTextureSize(gl, width, height);
    var texture = webgl_util.createTexture(gl);
    var tex2d = gl.TEXTURE_2D;
    var internalFormat = getTextureInternalFormat(gl, numChannels);
    var format = getTextureFormat(gl, numChannels);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(tex2d, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, gl.FLOAT, null); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
    return texture;
}
function createMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 1;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createMatrixTexture = createMatrixTexture;
function createColorMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createColorMatrixTexture = createColorMatrixTexture;
function createPackedMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createPackedMatrixTexture = createPackedMatrixTexture;
function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
    var posOffset = 0;
    var uvOffset = 3 * 4;
    var stride = (3 * 4) + (2 * 4);
    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); });
    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);
    try {
        webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);
    }
    catch (e) {
        if (!e.hasOwnProperty('namedVertexAttributeNotFound')) {
            throw e;
        }
    }
}
exports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;
function uploadPixelDataToTexture(gl, texture, pixels) {
    var numChannels = 4;
    var internalFormat = getTextureInternalFormat(gl, numChannels);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, gl.RGBA, gl.FLOAT, pixels); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.uploadPixelDataToTexture = uploadPixelDataToTexture;
function uploadDataToTexture(gl, texture, width, height, data, numChannels) {
    var textureFormat = getTextureFormat(gl, numChannels);
    webgl_util.validateTextureSize(gl, width, height);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, gl.FLOAT, data); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
function uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;
    var unpackedArray = new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));
    tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture);
    uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels);
}
exports.uploadMatrixToTexture = uploadMatrixToTexture;
function uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);
    var numChannels = 4;
    uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels);
}
exports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;
function downloadMatrixFromOutputTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var channelsPerTexture = 4;
    var unpackedArray = new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, channelsPerTexture));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, unpackedArray); });
    var matrix = new Float32Array(rows * columns);
    tex_util.decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture);
    return matrix;
}
exports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;
function downloadMatrixFromPackedOutputTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, packedRGBA); });
    var matrix = new Float32Array(rows * columns);
    return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix);
}
exports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;

},{"./tex_util":50,"./webgl_util":53}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LogSumExpProgram = (function () {
    function LogSumExpProgram(aSize) {
        this.variableNames = ['A'];
        this.params = [];
        this.outputShape = [];
        this.userCode = "\n      void main() {\n        float aMax = getAFlat(0.0);\n        for (int i = 0; i < " + aSize + "; i++) {\n          aMax = max(aMax, getAFlat(float(i)));\n        }\n\n        float expSum = 0.0;\n        for (int i = 0; i < " + aSize + "; i++) {\n          expSum += exp(getAFlat(float(i)) - aMax);\n        }\n\n        setOutput(aMax + log(expSum));\n      }\n    ";
    }
    return LogSumExpProgram;
}());
exports.LogSumExpProgram = LogSumExpProgram;

},{}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
function getFragmentShaderMaxPoolBackprop(dyShapeRCD, fSize, origStride, origPad) {
    var origInputDepth = dyShapeRCD[2];
    var pad = fSize - 1 - origPad;
    var dyRows = dyShapeRCD[0], dyCols = dyShapeRCD[1], depth = dyShapeRCD[2];
    var dyTexShapeRC = conv_util.computeTexShapeFrom3D(dyShapeRCD);
    return "\n    precision highp float;\n    uniform sampler2D dy;\n    uniform sampler2D maxPos;\n\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const vec2 dyShapeCR = vec2(" + dyTexShapeRC[1] + ", " + dyTexShapeRC[0] + ");\n\n    void main() {\n      vec2 dxTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (dxTexR, dxTexC) to 3D (dxR, dxC, d).\n      float dxR = dxTexCR.y;\n      float dxC = floor(dxTexCR.x / " + origInputDepth + ".0);\n      float d = mod(dxTexCR.x, " + origInputDepth + ".0);\n\n      vec2 dyRCCorner = vec2(dxR, dxC) - vec2(" + pad + ".0, " + pad + ".0);\n      float dyRCorner = dyRCCorner.x;\n      float dyCCorner = dyRCCorner.y;\n\n      // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(yR, dxC, d).\n      // ? = to be determined. : = across all values in that axis.\n      float dotProd = 0.0;\n      for (int wR = 0; wR < " + fSize + "; wR++) {\n        float wR_float = float(wR);\n        float dyR = (dyRCorner + wR_float) / " + origStride + ".0;\n        // TODO(nsthorat): Splice this with another version where you call\n        // getMatrixValueOrZeroPad(). Here and below.\n        if (dyR < 0.0 || dyR >= " + dyRows + ".0 || fract(dyR) > 0.0) {\n          continue;\n        }\n\n        float dyTexR = dyR;\n\n        for (int wC = 0; wC < " + fSize + "; wC++) {\n          float wC_float = float(wC);\n          float dyC = (dyCCorner + wC_float) / " + origStride + ".0;\n          if (dyC < 0.0 || dyC >= " + dyCols + ".0 || fract(dyC) > 0.0) {\n            continue;\n          }\n\n          float dyTexC = dyC * " + depth + ".0 + d;\n\n          // Read dy(dyR, dyC, d).\n          vec2 dyUV = (vec2(dyTexC, dyTexR) + halfCR) / dyShapeCR;\n          float dyValue = texture2D(dy, dyUV).r;\n\n          // Read maxPos(dyR, dyC, d).\n          float maxPosValue =\n              " + (fSize * fSize - 1) + ".0 - texture2D(maxPos, dyUV).r;\n\n          // Get the current value, check it against the value from the\n          // position matrix.\n          float curPosValue = wR_float * " + fSize + ".0 + wC_float;\n          float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n          dotProd += dyValue * mask;\n        }\n      }\n      gl_FragColor = vec4(dotProd, 0, 0, 0);\n    }";
}
exports.getFragmentShaderMaxPoolBackprop = getFragmentShaderMaxPoolBackprop;
function maxPoolBackprop(gpgpu, program, dyTex, maxPositionsTex, resultTex, resultTexShapeRC) {
    gpgpu.setOutputMatrixTexture(resultTex, resultTexShapeRC[0], resultTexShapeRC[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(dyTex, 'dy', 0);
    gpgpu.setInputMatrixTexture(maxPositionsTex, 'maxPos', 1);
    gpgpu.executeProgram();
}
exports.maxPoolBackprop = maxPoolBackprop;

},{"../conv_util":18}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var pool_gpu = require("./pool_gpu");
function getFragmentShaderMaxPoolPositionsSource(xShapeRCD, fSize, stride, pad) {
    return getFragmentShaderMaxPoolCommonSource(xShapeRCD, fSize, stride, pad, true);
}
exports.getFragmentShaderMaxPoolPositionsSource = getFragmentShaderMaxPoolPositionsSource;
function getFragmentShaderMaxPoolSource(xShapeRCD, fSize, stride, pad) {
    return getFragmentShaderMaxPoolCommonSource(xShapeRCD, fSize, stride, pad, false);
}
exports.getFragmentShaderMaxPoolSource = getFragmentShaderMaxPoolSource;
function getFragmentShaderMaxPoolCommonSource(xShapeRCD, fSize, stride, pad, computeMaxPositions) {
    return pool_gpu.getFragmentShaderPoolCommonSource(xShapeRCD, fSize, stride, pad, 'max', computeMaxPositions);
}
function maxPoolCommon(gpgpu, program, x, result, resultShapeRowCol) {
    pool_gpu.poolCommon(gpgpu, program, x, result, resultShapeRowCol);
}
exports.maxPoolCommon = maxPoolCommon;

},{"./pool_gpu":44}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var pool_gpu = require("./pool_gpu");
function getFragmentShaderMinPoolSource(xShapeRCD, fSize, stride, pad) {
    return pool_gpu.getFragmentShaderPoolCommonSource(xShapeRCD, fSize, stride, pad, 'min', false);
}
exports.getFragmentShaderMinPoolSource = getFragmentShaderMinPoolSource;
function minPool(gpgpu, program, x, result, resultShapeRowCol) {
    pool_gpu.poolCommon(gpgpu, program, x, result, resultShapeRowCol);
}
exports.minPool = minPool;

},{"./pool_gpu":44}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MinMaxProgram = (function () {
    function MinMaxProgram(aSize, opType) {
        this.variableNames = ['A'];
        this.outputShape = [];
        this.params = [opType];
        this.userCode = "\n      void main() {\n        float value = getAFlat(0.0);\n        for (int i = 0; i < " + aSize + "; i++) {\n          float candidate = getAFlat(float(i));\n          if (isNaN(candidate)) {\n            setOutput(candidate);\n            return;\n          }\n          value = " + opType + "(value, candidate);\n        }\n        setOutput(value);\n      }\n    ";
    }
    return MinMaxProgram;
}());
exports.MinMaxProgram = MinMaxProgram;

},{}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var math_1 = require("../math");
var MatMulProgram = (function () {
    function MatMulProgram(aShape, bShape, aOrient, bOrient) {
        if (aOrient === void 0) { aOrient = math_1.MatrixOrientation.REGULAR; }
        if (bOrient === void 0) { bOrient = math_1.MatrixOrientation.REGULAR; }
        this.variableNames = ['matrixA', 'matrixB'];
        this.params = [aOrient, bOrient];
        var outerShapeA = (aOrient === math_1.MatrixOrientation.REGULAR) ? aShape[0] : aShape[1];
        var outerShapeB = (bOrient === math_1.MatrixOrientation.REGULAR) ? bShape[1] : bShape[0];
        this.outputShape = [outerShapeA, outerShapeB];
        var sharedDim = (aOrient === math_1.MatrixOrientation.REGULAR ? aShape[1] : aShape[0]);
        var aSnippet = (aOrient === math_1.MatrixOrientation.REGULAR) ?
            'aRow, i_float' : 'i_float, aRow';
        var bSnippet = (bOrient === math_1.MatrixOrientation.REGULAR) ?
            'i_float, bCol' : 'bCol, i_float';
        this.userCode = "\n      const int sharedDim = " + sharedDim + ";\n\n      float dotARowBCol(float aRow, float bCol) {\n        float result = 0.0;\n        for (int i = 0; i < sharedDim; i++) {\n          float i_float = float(i);\n          float a = getMatrixA(" + aSnippet + ");\n          float b = getMatrixB(" + bSnippet + ");\n          result += (a * b);\n        }\n        return result;\n      }\n\n      void main() {\n        vec2 resRC = getOutputCoords();\n        setOutput(dotARowBCol(resRC.x, resRC.y));\n      }\n    ";
    }
    return MatMulProgram;
}());
exports.MatMulProgram = MatMulProgram;

},{"../math":21}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
function getFragmentShaderPoolCommonSource(xShapeRCD, fSize, stride, pad, poolType, computePositions) {
    if (poolType === 'avg' && computePositions) {
        throw new Error('Cannot compute positions for average pool.');
    }
    var depth = xShapeRCD[2];
    var xTexShapeRC = conv_util.computeTexShapeFrom3D(xShapeRCD);
    var returnValue = 'minMaxValue';
    if (computePositions) {
        returnValue = 'minMaxPosition';
    }
    else if (poolType === 'avg') {
        returnValue = 'avgValue';
    }
    return "\n    precision highp float;\n    uniform sampler2D x;\n    varying vec2 resultUV;\n\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const vec2 xShapeCR = vec2(" + xTexShapeRC[1] + ", " + xTexShapeRC[0] + ");\n\n    bool isNaN(float val) {\n      return val == val ? false : true;\n    }\n\n    void main() {\n      vec2 yTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (yTexR, yTexC) to 3D (yR, yC, d2).\n      float yR = yTexCR.y;\n      float yC = floor(yTexCR.x / " + depth + ".0);\n      float d = mod(yTexCR.x, " + depth + ".0);\n\n      vec2 xRCCorner = vec2(yR, yC) * vec2(" + stride + ", " + stride + ") -\n          vec2(" + pad + ".0, " + pad + ".0);\n      float xRCorner = xRCCorner.x;\n      float xCCorner = xRCCorner.y;\n\n      // max/min x(?, ?, d) to get y(yR, yC, d).\n      // ? = to be determined\n      float minMaxValue = 0.0;\n      float minMaxValueFound = 0.0;\n      float minMaxPosition = 0.0;\n      float avgValue = 0.0;\n\n      for (int wR = 0; wR < " + fSize + "; wR++) {\n        float wR_float = float(wR);\n        float xR = xRCorner + wR_float;\n        float xTexR = xR;\n\n        for (int wC = 0; wC < " + fSize + "; wC++) {\n          float wC_float = float(wC);\n          float xC = xCCorner + wC_float;\n          float xTexC = xC * " + depth + ".0 + d;\n\n          vec2 texCR = vec2(xTexC, xTexR);\n\n          // Check if the requested UV is invalid.\n          vec2 uv = (texCR + halfCR) / xShapeCR;\n          bool lessThanZero = any(lessThan(uv, vec2(0, 0)));\n          bool greaterThanOne = any(greaterThan(uv, vec2(1, 1)));\n          bool outside = lessThanZero || greaterThanOne;\n          if (outside) {\n            continue;\n          }\n\n          float value = texture2D(x, uv).r;\n          if (isNaN(value)) {\n            gl_FragColor = vec4(value, 0, 0, 0);\n            return;\n          }\n          if (" + (poolType === 'avg') + ") {\n            avgValue += value / " + fSize * fSize + ".0;\n          } else {\n            // If a min / max value has already been found, use it. If not, use\n            // the current value.\n            float currentMinMaxValue = mix(\n                value, minMaxValue, minMaxValueFound);\n            if (value " + (poolType === 'min' ? '<=' : '>=') + " currentMinMaxValue) {\n              minMaxValue = value;\n              minMaxValueFound = 1.0;\n              if (" + computePositions + ") {\n                minMaxPosition = wR_float * " + fSize + ".0 + wC_float;\n              }\n            }\n          }\n        }\n      }\n      gl_FragColor = vec4(" + returnValue + ", 0, 0, 0);\n    }";
}
exports.getFragmentShaderPoolCommonSource = getFragmentShaderPoolCommonSource;
function poolCommon(gpgpu, program, x, result, resultShapeRowCol) {
    gpgpu.setOutputMatrixTexture(result, resultShapeRowCol[0], resultShapeRowCol[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(x, 'x', 0);
    gpgpu.executeProgram();
}
exports.poolCommon = poolCommon;

},{"../conv_util":18}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReduceSumProgram = (function () {
    function ReduceSumProgram(aSize) {
        this.aSize = aSize;
        this.variableNames = ['A'];
        this.params = [];
        this.outputShape = [];
        this.userCode = "\n      void main() {\n        float sum = 0.0;\n        for (int i = 0; i < " + aSize + "; i++) {\n          sum += getAFlat(float(i));\n        }\n        setOutput(sum);\n      }\n    ";
    }
    return ReduceSumProgram;
}());
exports.ReduceSumProgram = ReduceSumProgram;

},{}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var webgl_util = require("./webgl_util");
function getRenderRGBShader(gpgpu, destinationWidth) {
    var fragmentShaderSource = "\n    precision highp float;\n    uniform sampler2D source;\n    varying vec2 resultUV;\n\n    const float destinationWidth = " + destinationWidth + ".0;\n    const float a = 1.0;\n\n    void main() {\n      float xr = floor(resultUV.s * destinationWidth) * 3.0;\n      vec3 x = xr + vec3(0, 1, 2);\n\n      float sourceWidth = destinationWidth * 3.0;\n      vec3 u = (x + 0.5) / sourceWidth;\n      float v = 1.0 - resultUV.t;\n\n      float r = texture2D(source, vec2(u[0], v)).r;\n      float g = texture2D(source, vec2(u[1], v)).r;\n      float b = texture2D(source, vec2(u[2], v)).r;\n\n      gl_FragColor = vec4(r, g, b, a);\n    }";
    return gpgpu.createProgram(fragmentShaderSource);
}
exports.getRenderRGBShader = getRenderRGBShader;
function renderToCanvas(gpgpu, renderShader, sourceTex) {
    webgl_util.bindCanvasToFramebuffer(gpgpu.gl);
    renderToFramebuffer(gpgpu, renderShader, sourceTex);
}
exports.renderToCanvas = renderToCanvas;
function renderToFramebuffer(gpgpu, renderShader, sourceTex) {
    gpgpu.setProgram(renderShader);
    gpgpu.setInputMatrixTexture(sourceTex, 'source', 0);
    gpgpu.executeProgram();
}
exports.renderToFramebuffer = renderToFramebuffer;

},{"./webgl_util":53}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
function getFragmentShaderSource() {
    return "\n    precision highp float;\n    uniform sampler2D matrixA;\n    uniform vec2 inputDimCR;\n    uniform vec2 resultDimCR;\n    varying vec2 resultUV;\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    void main() {\n      vec2 resultCR = floor(resultUV * resultDimCR);\n      // indexInFlat = row * stride + column, where stride == numOutputColumns\n      float indexInFlat = resultCR.y * resultDimCR.x + resultCR.x;\n\n      vec2 inputCR = vec2(\n        mod(indexInFlat, inputDimCR.x), // col = indexInFlat % numInputColumns\n        floor(indexInFlat / inputDimCR.x) // row = indexInFlat / numInputColumns\n      ) + halfCR;\n\n      vec2 inputUV = inputCR / inputDimCR;\n      gl_FragColor = texture2D(matrixA, inputUV);\n    }";
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function reshape(gpgpu, reshapeProgram, a, aNumRows, aNumCols, result, resultNumRows, resultNumCols) {
    var inputSize = aNumRows * aNumCols;
    var outputSize = resultNumCols * resultNumRows;
    util.assert(inputSize === outputSize, "The input size (" + inputSize + ") and output size (" + outputSize + ") " +
        "must match");
    gpgpu.setOutputMatrixTexture(result, resultNumRows, resultNumCols);
    gpgpu.setProgram(reshapeProgram);
    gpgpu.setInputMatrixTexture(a, 'matrixA', 0);
    var inputDimCRLocation = gpgpu.getUniformLocation('inputDimCR');
    gpgpu.gl.uniform2f(inputDimCRLocation, aNumCols, aNumRows);
    var resultDimCRLocation = gpgpu.getUniformLocation('resultDimCR');
    gpgpu.gl.uniform2f(resultDimCRLocation, resultNumCols, resultNumRows);
    gpgpu.executeProgram();
}
exports.reshape = reshape;

},{"../../util":81}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
function getFragmentShaderSource(inputShapeRCD, outputDimensionsRowCol, alignCorners) {
    var depth = inputShapeRCD[2];
    var inputTexShapeRC = conv_util.computeTexShapeFrom3D(inputShapeRCD);
    var effectiveInputShapeRCD = alignCorners ?
        [inputShapeRCD[0] - 1, inputShapeRCD[1] - 1, depth] :
        inputShapeRCD;
    var effectiveOutputShapeRCD = alignCorners ?
        [outputDimensionsRowCol[0] - 1, outputDimensionsRowCol[1] - 1, depth] :
        [outputDimensionsRowCol[0], outputDimensionsRowCol[1], depth];
    return "\n    precision highp float;\n    uniform sampler2D matrixA;\n    varying vec2 resultUV;\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    const vec2 inputShapeCR = vec2(" + inputShapeRCD[1] + ", " + inputShapeRCD[0] + ");\n    const vec2 inputShapeTexCR = vec2(\n        " + inputTexShapeRC[1] + ", " + inputTexShapeRC[0] + ");\n\n    const vec2 effectiveInputOverOutputRatioCR = vec2(\n        " + effectiveInputShapeRCD[1] / effectiveOutputShapeRCD[1] + ",\n        " + effectiveInputShapeRCD[0] / effectiveOutputShapeRCD[0] + ");\n\n    float sampleInput(float col, float row, float d) {\n      vec2 uv = (vec2(col * " + depth + ".0 + d, row) + halfCR) / inputShapeTexCR;\n      return texture2D(matrixA, uv).r;\n    }\n\n    void main() {\n      vec2 yTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (yTexR, yTexC) to 3D (yR, yC, d).\n      vec2 yCR = vec2(floor(yTexCR.x / " + depth + ".0), yTexCR.y);\n      float d = mod(yTexCR.x, " + depth + ".0);\n\n      // Fractional source index.\n      vec2 sourceFracIndexCR = yCR * effectiveInputOverOutputRatioCR;\n\n      // Compute the four integer indices.\n      vec2 sourceFloorCR = floor(sourceFracIndexCR);\n      vec2 sourceCeilCR = min(inputShapeCR - 1.0, ceil(sourceFracIndexCR));\n\n      float topLeft = sampleInput(sourceFloorCR[0], sourceFloorCR[1], d);\n      float bottomLeft = sampleInput(sourceFloorCR[0], sourceCeilCR[1], d);\n      float topRight = sampleInput(sourceCeilCR[0], sourceFloorCR[1], d);\n      float bottomRight = sampleInput(sourceCeilCR[0], sourceCeilCR[1], d);\n\n      vec2 fracCR = sourceFracIndexCR - sourceFloorCR;\n\n      float top = topLeft + (topRight - topLeft) * fracCR[0];\n      float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR[0];\n      float newValue = top + (bottom - top) * fracCR[1];\n\n      gl_FragColor = vec4(newValue, 0.0, 0.0, 0.0);\n    }";
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function resizeBilinear(gpgpu, resizeBilinearProgram, a, result, resultShapeRowCol) {
    gpgpu.setOutputMatrixTexture(result, resultShapeRowCol[0], resultShapeRowCol[1]);
    gpgpu.setProgram(resizeBilinearProgram);
    gpgpu.setInputMatrixTexture(a, 'matrixA', 0);
    gpgpu.executeProgram();
}
exports.resizeBilinear = resizeBilinear;

},{"../conv_util":18}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
function makeShader(inputsInfo, outputShape, userCode, broadcast) {
    var inputPrefixSnippet = inputsInfo.map(function (x) { return "uniform sampler2D " + x.name + ";"; }).join('\n');
    var inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })
        .join('\n');
    var outTexShape = outputShape.texShape;
    var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
    var source = [
        SHADER_PREFIX, inputPrefixSnippet, SAMPLE_1D_SNIPPET, SAMPLE_2D_SNIPPET,
        SAMPLE_3D_SNIPPET, SAMPLE_4D_SNIPPET, inputSamplingSnippet,
        outputSamplingSnippet, userCode
    ].join('\n');
    return source;
}
exports.makeShader = makeShader;
function getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {
    var shape = inInfo.shapeInfo.logicalShape;
    var texShape = inInfo.shapeInfo.texShape;
    var outTexShape = outShapeInfo.texShape;
    var res = '';
    switch (shape.length) {
        case 0:
            res += getSamplerScalar(inInfo.name);
            break;
        case 1:
            res += getSampler1D(inInfo.name, texShape);
            break;
        case 2:
            res += getSampler2D(inInfo.name, shape, texShape);
            break;
        case 3:
            res += getSampler3D(inInfo.name, shape, texShape);
            break;
        case 4:
            res += getSampler4D(inInfo.name, shape, texShape);
            break;
        default:
            throw new Error(shape.length + "-D input sampling" +
                " is not yet supported");
    }
    if (broadcast || util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {
        res +=
            getSamplerAtOutputCoords(inInfo.name, texShape, outTexShape, broadcast);
    }
    res += getSamplerFlat(inInfo.name, texShape);
    return res;
}
function getOutputSamplingSnippet(outShape, outTexShape) {
    switch (outShape.length) {
        case 0:
            return '';
        case 1:
            return getOutput1DCoords(outShape, outTexShape);
        case 2:
            return getOutput2DCoords(outShape, outTexShape);
        case 3:
            return getOutput3DCoords(outShape, outTexShape);
        case 4:
            return getOutput4DCoords(outShape, outTexShape);
        default:
            throw new Error(outShape.length + "-D output sampling is not yet supported");
    }
}
var SHADER_PREFIX = "\n  precision highp float;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n\n  bool isNaN(float val) {\n    return val == val ? false : true;\n  }\n";
var SAMPLE_1D_SNIPPET = "\n  float sample1D(sampler2D texture, float texNumR, float texNumC, float index) {\n    float texR = floor(index / texNumC);\n    float texC = mod(index, texNumC);\n    vec2 uv = (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n    return texture2D(texture, uv).r;\n  }\n";
var SAMPLE_2D_SNIPPET = "\n  float sample2D(sampler2D texture, float texNumR, float texNumC, float numC,\n      float row, float col) {\n    float index = dot(vec2(row, col), vec2(numC, 1.0));\n    float texR = floor(index / texNumC);\n    float texC = mod(index, texNumC);\n    vec2 uv = (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n    return texture2D(texture, uv).r;\n  }\n";
var SAMPLE_3D_SNIPPET = "\n  float sample3D(sampler2D texture, float texNumR, float texNumC, float stride0,\n      float stride1, float row, float col, float depth) {\n    float index = dot(vec3(row, col, depth), vec3(stride0, stride1, 1.0));\n    float texR = floor(index / texNumC);\n    float texC = mod(index, texNumC);\n    vec2 uv = (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n    return texture2D(texture, uv).r;\n  }\n";
var SAMPLE_4D_SNIPPET = "\n  float sample4D(sampler2D texture, float texNumR, float texNumC, float stride0,\n      float stride1, float stride2, float row, float col, float depth,\n      float depth2) {\n    float index = dot(vec4(row, col, depth, depth2),\n                      vec4(stride0, stride1, stride2, 1.0));\n    float texR = floor(index / texNumC);\n    float texC = mod(index, texNumC);\n    vec2 uv = (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n    return texture2D(texture, uv).r;\n  }\n";
function getOutput1DCoords(shape, texShape) {
    if (texShape[0] === 1) {
        return "\n      float getOutputCoords() {\n        return floor(gl_FragCoord.x);\n      }\n    ";
    }
    if (texShape[1] === 1) {
        return "\n      float getOutputCoords() {\n        return floor(gl_FragCoord.y);\n      }\n    ";
    }
    return "\n    float getOutputCoords() {\n      vec2 resTexRC = floor(gl_FragCoord.yx);\n      return dot(resTexRC, vec2(" + texShape[1] + ".0, 1.0));\n    }\n  ";
}
function getOutput3DCoords(shape, texShape) {
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    return "\n    vec3 getOutputCoords() {\n      vec2 resTexRC = floor(gl_FragCoord.yx);\n      float index = dot(resTexRC, vec2(" + texShape[1] + ".0, 1.0));\n      float r = floor(index / " + stride0 + ".0);\n      index -= r * " + stride0 + ".0;\n      float c = floor(index / " + stride1 + ".0);\n      float d = mod(index, " + stride1 + ".0);\n      return vec3(r, c, d);\n    }\n  ";
}
function getOutput4DCoords(shape, texShape) {
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    vec4 getOutputCoords() {\n      vec2 resTexRC = floor(gl_FragCoord.yx);\n      float index = dot(resTexRC, vec2(" + texShape[1] + ".0, 1.0));\n\n      float r = floor(index / " + stride0 + ".0);\n      index -= r * " + stride0 + ".0;\n\n      float c = floor(index / " + stride1 + ".0);\n      index -= c * " + stride1 + ".0;\n\n      float d = floor(index / " + stride2 + ".0);\n      float d2 = mod(index, " + stride2 + ".0);\n\n      return vec4(r, c, d, d2);\n    }\n  ";
}
function getOutput2DCoords(shape, texShape) {
    if (util.arraysEqual(shape, texShape)) {
        return "\n      vec2 getOutputCoords() {\n        return floor(gl_FragCoord.yx);\n      }\n    ";
    }
    return "\n    vec2 getOutputCoords() {\n      vec2 resTexRC = floor(gl_FragCoord.yx);\n      float index = dot(resTexRC, vec2(" + texShape[1] + ".0, 1.0));\n      float r = floor(index / " + shape[1] + ".0);\n      float c = mod(index, " + shape[1] + ".0);\n      return vec2(r, c);\n    }\n  ";
}
function getSamplerScalar(texName) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "() {\n      return texture2D(" + texName + ", halfCR).r;\n    }\n  ";
}
function getSampler1D(texName, texShape) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var tR = texShape[0];
    var tC = texShape[1];
    if (texShape[0] === 1 && texShape[1] === 1) {
        return "\n      float " + funcName + "(float index) {\n        return texture2D(" + texName + ", halfCR).r;\n      }\n    ";
    }
    if (texShape[1] === 1) {
        return "\n      float " + funcName + "(float index) {\n        vec2 uv = vec2(0.5, (index + 0.5) / " + tR + ".0);\n        return texture2D(" + texName + ", uv).r;\n      }\n    ";
    }
    if (texShape[0] === 1) {
        return "\n      float " + funcName + "(float index) {\n        vec2 uv = vec2((index + 0.5) / " + tC + ".0, 0.5);\n        return texture2D(" + texName + ", uv).r;\n      }\n    ";
    }
    return "\n    float " + funcName + "(float index) {\n      return sample1D(" + texName + ", " + tR + ".0, " + tC + ".0, index);\n    }\n  ";
}
function getSampler3D(texName, shape, texShape) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var tR = texShape[0];
    var tC = texShape[1];
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    return "\n    float " + funcName + "(float row, float col, float depth) {\n      return sample3D(" + texName + ", " + tR + ".0, " + tC + ".0, " + stride0 + ".0, " + stride1 + ".0,\n          row, col, depth);\n    }\n  ";
}
function getSampler4D(texName, shape, texShape) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var tR = texShape[0];
    var tC = texShape[1];
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n  float " + funcName + "(float row, float col, float depth, float depth2) {\n    return sample4D(" + texName + ", " + tR + ".0, " + tC + ".0, " + stride0 + ".0, " + stride1 + ".0,\n        " + stride2 + ".0, row, col, depth, depth2);\n  }\n";
}
function getSampler2D(texName, shape, texShape) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var tR = texShape[0];
    var tC = texShape[1];
    if (util.arraysEqual(shape, texShape)) {
        return "\n      float " + funcName + "(float row, float col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + tC + ".0, " + tR + ".0);\n        return texture2D(" + texName + ", uv).r;\n      }\n    ";
    }
    return "\n    float " + funcName + "(float row, float col) {\n      return sample2D(" + texName + ", " + tR + ".0, " + tC + ".0, " + shape[1] + ".0, row, col);\n    }\n  ";
}
function getSamplerFlat(texName, texShape) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) +
        'Flat';
    var tNumR = texShape[0];
    var tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
        return "\n      float " + funcName + "(float index) {\n        return texture2D(" + texName + ", halfCR).r;\n      }\n    ";
    }
    if (tNumC === 1) {
        return "\n      float " + funcName + "(float index) {\n        vec2 uv = vec2(0.5, (index + 0.5) / " + tNumR + ".0);\n        return texture2D(" + texName + ", uv).r;\n      }\n    ";
    }
    if (tNumR === 1) {
        return "\n      float " + funcName + "(float index) {\n        vec2 uv = vec2((index + 0.5) / " + tNumC + ".0, 0.5);\n        return texture2D(" + texName + ", uv).r;\n      }\n    ";
    }
    return "\n    float " + funcName + "(float index) {\n      float texR = floor(index / " + tNumC + ".0);\n      float texC = mod(index, " + tNumC + ".0);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + tNumC + ".0, " + tNumR + ".0);\n      return texture2D(" + texName + ", uv).r;\n    }\n  ";
}
function getSamplerAtOutputCoords(texName, inTexShape, outTexShape, broadcast) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) +
        'AtOutCoords';
    if (util.arraysEqual(inTexShape, outTexShape)) {
        return "\n      float " + funcName + "() {\n        return texture2D(" + texName + ", resultUV).r;\n      }\n    ";
    }
    var inSize = util.sizeFromShape(inTexShape);
    var broadcastSnippet = broadcast ? "index = mod(index, " + inSize + ".0);" : '';
    return "\n    float " + funcName + "() {\n      vec2 resTexRC = floor(gl_FragCoord.yx);\n      float index = dot(resTexRC, vec2(" + outTexShape[1] + ".0, 1.0));\n      " + broadcastSnippet + "\n      float texR = floor(index / " + inTexShape[1] + ".0);\n      float texC = mod(index, " + inTexShape[1] + ".0);\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(" + inTexShape[1] + ".0, " + inTexShape[0] + ".0);\n      return texture2D(" + texName + ", uv).r;\n    }\n  ";
}

},{"../../util":81}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
}
exports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;
function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
}
exports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;
function getColorMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns * 4, rows];
}
exports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;
function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
    if (unpackedSize % channelsPerTexture !== 0) {
        throw new Error('unpackedSize (' + unpackedSize + ') must be a multiple of ' +
            channelsPerTexture);
    }
    return unpackedSize / channelsPerTexture;
}
exports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;
function encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {
    var requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);
    if (unpackedArray.length < requiredSize) {
        throw new Error('unpackedArray length (' + unpackedArray.length +
            ') must be >= ' + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < matrix.length; ++src) {
        unpackedArray[dst] = matrix[src];
        dst += channelsPerTexture;
    }
}
exports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;
function decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {
    var requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
    if (matrix.length < requiredSize) {
        throw new Error('matrix length (' + matrix.length + ') must be >= ' + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += channelsPerTexture) {
        matrix[dst++] = unpackedArray[src];
    }
}
exports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;
function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [Math.ceil(columns / 2), Math.ceil(rows / 2)];
}
exports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;
function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    return w * h * 4;
}
exports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;
function encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {
    var requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);
    if (packedRGBA.length < requiredSize) {
        throw new Error('packedRGBA length (' + packedRGBA.length +
            ') must be >= ' + requiredSize);
    }
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    {
        var dstStride = (oddWidth ? 4 : 0);
        var oneRow = columns;
        var dst = 0;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            var matrixSrcRow = (blockY * 2 * columns);
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                var matrixSrcCol = blockX * 2;
                var src = matrixSrcRow + matrixSrcCol;
                packedRGBA[dst] = matrix[src];
                packedRGBA[dst + 1] = matrix[src + 1];
                packedRGBA[dst + 2] = matrix[src + oneRow];
                packedRGBA[dst + 3] = matrix[src + oneRow + 1];
                dst += 4;
            }
            dst += dstStride;
        }
    }
    if (oddWidth) {
        var src = columns - 1;
        var dst = (textureWidth - 1) * 4;
        var srcStride = 2 * columns;
        var dstStride = textureWidth * 4;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            packedRGBA[dst] = matrix[src];
            packedRGBA[dst + 2] = matrix[src + columns];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (rows - 1) * columns;
        var dst = (textureHeight - 1) * textureWidth * 4;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            packedRGBA[dst++] = matrix[src++];
            packedRGBA[dst++] = matrix[src++];
            dst += 2;
        }
    }
    if (oddWidth && oddHeight) {
        packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1];
    }
    return packedRGBA;
}
exports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;
function decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {
    var requiredSize = rows * columns;
    if (requiredSize < matrix.length) {
        throw new Error('matrix length (' + matrix.length + ') must be >= ' + requiredSize);
    }
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    {
        var srcStride = oddWidth ? 4 : 0;
        var dstStride = columns + (oddWidth ? 1 : 0);
        var src = 0;
        var dstRow1 = 0;
        var dstRow2 = columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
            }
            src += srcStride;
            dstRow1 += dstStride;
            dstRow2 += dstStride;
        }
    }
    if (oddWidth) {
        var src = (textureWidth - 1) * 4;
        var dst = columns - 1;
        var srcStride = textureWidth * 4;
        var dstStride = 2 * columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            matrix[dst] = packedRGBA[src];
            matrix[dst + columns] = packedRGBA[src + 2];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (textureHeight - 1) * textureWidth * 4;
        var dst = (rows - 1) * columns;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            matrix[dst++] = packedRGBA[src++];
            matrix[dst++] = packedRGBA[src++];
            src += 2;
        }
    }
    if (oddWidth && oddHeight) {
        matrix[matrix.length - 1] = packedRGBA[packedRGBA.length - 4];
    }
    return matrix;
}
exports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA;

},{}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextureManager = (function () {
    function TextureManager(gpgpu) {
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this.freeTextures = {};
        this.logEnabled = false;
        this.usedTextureCount = {};
    }
    TextureManager.prototype.acquireTexture = function (shapeRC) {
        var shapeKey = getKeyFromTextureShape(shapeRC);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        if (!(shapeKey in this.usedTextureCount)) {
            this.usedTextureCount[shapeKey] = 0;
        }
        this.usedTextureCount[shapeKey]++;
        if (this.freeTextures[shapeKey].length > 0) {
            this.numFreeTextures--;
            this.numUsedTextures++;
            this.log();
            return this.freeTextures[shapeKey].shift();
        }
        this.numUsedTextures++;
        this.log();
        return this.gpgpu.createMatrixTexture(shapeRC[0], shapeRC[1]);
    };
    TextureManager.prototype.releaseTexture = function (texture, shape) {
        var shapeKey = getKeyFromTextureShape(shape);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        this.freeTextures[shapeKey].push(texture);
        this.numFreeTextures++;
        this.numUsedTextures--;
        this.usedTextureCount[shapeKey]--;
        this.log();
    };
    TextureManager.prototype.log = function () {
        if (!this.logEnabled) {
            return;
        }
        var total = this.numFreeTextures + this.numUsedTextures;
        console.log('Free/Used', this.numFreeTextures + ' / ' + this.numUsedTextures, "(" + total + ")");
    };
    TextureManager.prototype.getNumUsedTextures = function () {
        return this.numUsedTextures;
    };
    TextureManager.prototype.getNumFreeTextures = function () {
        return this.numFreeTextures;
    };
    TextureManager.prototype.dispose = function () {
        for (var shape in this.freeTextures) {
            if (this.freeTextures.hasOwnProperty(shape)) {
                for (var i = 0; i < this.freeTextures[shape].length; i++) {
                    this.gpgpu.deleteMatrixTexture(this.freeTextures[shape][i]);
                }
            }
        }
    };
    return TextureManager;
}());
exports.TextureManager = TextureManager;
function getKeyFromTextureShape(shapeRowsCol) {
    return shapeRowsCol[0] + '_' + shapeRowsCol[1];
}

},{}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnaryOp;
(function (UnaryOp) {
    UnaryOp[UnaryOp["EXP"] = 0] = "EXP";
    UnaryOp[UnaryOp["LOG"] = 1] = "LOG";
    UnaryOp[UnaryOp["NEG"] = 2] = "NEG";
    UnaryOp[UnaryOp["RELU"] = 3] = "RELU";
    UnaryOp[UnaryOp["SIGMOID"] = 4] = "SIGMOID";
    UnaryOp[UnaryOp["STEP"] = 5] = "STEP";
    UnaryOp[UnaryOp["SIN"] = 6] = "SIN";
    UnaryOp[UnaryOp["TANH"] = 7] = "TANH";
})(UnaryOp = exports.UnaryOp || (exports.UnaryOp = {}));
var UnaryOpProgram = (function () {
    function UnaryOpProgram(aShape, op) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        this.params = [op];
        this.userCode = "\n      void main() {\n        float v = getAAtOutCoords();\n        " + getOpSnippet(op) + "\n        setOutput(r);\n      }\n    ";
    }
    return UnaryOpProgram;
}());
exports.UnaryOpProgram = UnaryOpProgram;
function getOpSnippet(op) {
    switch (op) {
        case UnaryOp.EXP:
            return 'float r = exp(v);';
        case UnaryOp.LOG:
            return 'float r = log(v);';
        case UnaryOp.NEG:
            return 'float r = -v;';
        case UnaryOp.RELU:
            return 'float r = (v < 0.0) ? 0.0 : v;';
        case UnaryOp.SIGMOID:
            return 'float r = 1.0 / (1.0 + exp(-1.0 * v));';
        case UnaryOp.STEP:
            return 'float r = (v == v) ? (v > 0.0 ? 1.0 : 0.0) : v;';
        case UnaryOp.SIN:
            return 'float r = sin(v);';
        case UnaryOp.TANH:
            return "float e2x = exp(-2.0 * abs(v));\n              float r = sign(v) * (1.0 - e2x) / (1.0 + e2x);";
        default:
            throw Error('Unrecognized unary op type ' + op);
    }
}

},{}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var USE_WEBGL2_WHEN_AVAILABLE = true;
var WEBGL2_ENABLED = null;
var MAX_TEXTURE_SIZE = null;
var util = require("../../util");
function createWebGLRenderingContext(attributes) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return createWebGLRenderingContextFromCanvas(canvas, attributes);
}
exports.createWebGLRenderingContext = createWebGLRenderingContext;
function preferWebGL1() {
    USE_WEBGL2_WHEN_AVAILABLE = false;
    WEBGL2_ENABLED = null;
}
exports.preferWebGL1 = preferWebGL1;
function preferWebGL2() {
    USE_WEBGL2_WHEN_AVAILABLE = true;
    WEBGL2_ENABLED = null;
}
exports.preferWebGL2 = preferWebGL2;
function isWebGL2Enabled() {
    if (!USE_WEBGL2_WHEN_AVAILABLE) {
        return false;
    }
    if (WEBGL2_ENABLED == null) {
        var tempCanvas = document.createElement('canvas');
        var gl = tempCanvas.getContext('webgl2');
        if (gl != null) {
            WEBGL2_ENABLED = true;
            var loseContextExtension = getExtensionOrThrow(gl, 'WEBGL_lose_context');
            loseContextExtension.loseContext();
        }
        else {
            WEBGL2_ENABLED = false;
        }
    }
    return WEBGL2_ENABLED;
}
exports.isWebGL2Enabled = isWebGL2Enabled;
function createWebGLRenderingContextFromCanvas(canvas, attributes) {
    var gl;
    if (isWebGL2Enabled()) {
        gl = canvas.getContext('webgl2', attributes);
    }
    else {
        gl = (canvas.getContext('webgl', attributes) ||
            canvas.getContext('experimental-webgl', attributes));
    }
    if (gl == null) {
        throw new Error('This browser does not support WebGL.');
    }
    return gl;
}
exports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;
function callAndCheck(gl, func) {
    var returnValue = func();
    checkWebGLError(gl);
    return returnValue;
}
exports.callAndCheck = callAndCheck;
var webGLDebugErrorCheckingEnabled = false;
function enableDebugWebGLErrorChecking(enabled) {
    webGLDebugErrorCheckingEnabled = enabled;
}
exports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;
function checkWebGLError(gl) {
    if (webGLDebugErrorCheckingEnabled) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));
        }
    }
}
exports.checkWebGLError = checkWebGLError;
function getWebGLErrorMessage(gl, status) {
    switch (status) {
        case gl.NO_ERROR:
            return 'NO_ERROR';
        case gl.INVALID_ENUM:
            return 'INVALID_ENUM';
        case gl.INVALID_VALUE:
            return 'INVALID_VALUE';
        case gl.INVALID_OPERATION:
            return 'INVALID_OPERATION';
        case gl.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
        case gl.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
        case gl.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
        default:
            return 'Unknown error code ' + status;
    }
}
exports.getWebGLErrorMessage = getWebGLErrorMessage;
function getExtensionOrThrow(gl, extensionName) {
    return throwIfNull(gl, function () { return gl.getExtension(extensionName); }, 'Extension "' + extensionName + '" not supported on this browser.');
}
exports.getExtensionOrThrow = getExtensionOrThrow;
function createVertexShader(gl, vertexShaderSource) {
    var vertexShader = throwIfNull(gl, function () { return gl.createShader(gl.VERTEX_SHADER); }, 'Unable to create vertex WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(vertexShader, vertexShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(vertexShader); });
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error('Failed to compile vertex shader.');
    }
    return vertexShader;
}
exports.createVertexShader = createVertexShader;
function createFragmentShader(gl, fragmentShaderSource) {
    var fragmentShader = throwIfNull(gl, function () { return gl.createShader(gl.FRAGMENT_SHADER); }, 'Unable to create fragment WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(fragmentShader, fragmentShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(fragmentShader); });
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(fragmentShader));
        throw new Error('Failed to compile fragment shader.');
    }
    return fragmentShader;
}
exports.createFragmentShader = createFragmentShader;
function createProgram(gl) {
    return throwIfNull(gl, function () { return gl.createProgram(); }, 'Unable to create WebGLProgram.');
}
exports.createProgram = createProgram;
function linkProgram(gl, program) {
    callAndCheck(gl, function () { return gl.linkProgram(program); });
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Failed to link vertex and fragment shaders.');
    }
}
exports.linkProgram = linkProgram;
function validateProgram(gl, program) {
    callAndCheck(gl, function () { return gl.validateProgram(program); });
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Shader program validation failed.');
    }
}
exports.validateProgram = validateProgram;
function createStaticVertexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticVertexBuffer = createStaticVertexBuffer;
function createStaticIndexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticIndexBuffer = createStaticIndexBuffer;
function queryMaxTextureSize(gl) {
    if (MAX_TEXTURE_SIZE != null) {
        return MAX_TEXTURE_SIZE;
    }
    MAX_TEXTURE_SIZE =
        callAndCheck(gl, function () { return gl.getParameter(gl.MAX_TEXTURE_SIZE); });
    return MAX_TEXTURE_SIZE;
}
exports.queryMaxTextureSize = queryMaxTextureSize;
function getChannelsPerTexture() {
    if (isWebGL2Enabled()) {
        return 1;
    }
    return 4;
}
exports.getChannelsPerTexture = getChannelsPerTexture;
function createTexture(gl) {
    return throwIfNull(gl, function () { return gl.createTexture(); }, 'Unable to create WebGLTexture.');
}
exports.createTexture = createTexture;
function validateTextureSize(gl, width, height) {
    var maxTextureSize = queryMaxTextureSize(gl);
    if ((width <= 0) || (height <= 0)) {
        var requested = '[' + width + 'x' + height + ']';
        throw new Error('Requested texture size ' + requested + ' is invalid.');
    }
    if ((width > maxTextureSize) || (height > maxTextureSize)) {
        var requested = '[' + width + 'x' + height + ']';
        var max = '[' + maxTextureSize + 'x' + maxTextureSize + ']';
        throw new Error('Requested texture size ' + requested +
            ' greater than WebGL maximum on this browser / GPU ' + max + '.');
    }
}
exports.validateTextureSize = validateTextureSize;
function createFramebuffer(gl) {
    return throwIfNull(gl, function () { return gl.createFramebuffer(); }, 'Unable to create WebGLFramebuffer.');
}
exports.createFramebuffer = createFramebuffer;
function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
    var loc = gl.getAttribLocation(program, attribute);
    if (loc === -1) {
        var error = new Error('Unable to get attribute "' + attribute + '" on WebGLProgram.');
        error.namedVertexAttributeNotFound = attribute;
        throw error;
    }
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes); });
    callAndCheck(gl, function () { return gl.enableVertexAttribArray(loc); });
}
exports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;
function bindTextureUnit(gl, texture, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
}
exports.bindTextureUnit = bindTextureUnit;
function unbindTextureUnit(gl, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.unbindTextureUnit = unbindTextureUnit;
function getProgramUniformLocationOrThrow(gl, program, uniformName) {
    return throwIfNull(gl, function () { return gl.getUniformLocation(program, uniformName); }, 'uniform "' + uniformName + '" not present in program.');
}
exports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;
function bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerName, textureUnit) {
    callAndCheck(gl, function () { return bindTextureUnit(gl, texture, textureUnit); });
    var samplerLocation = getProgramUniformLocationOrThrow(gl, program, uniformSamplerName);
    callAndCheck(gl, function () { return gl.uniform1i(samplerLocation, textureUnit); });
}
exports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;
function bindCanvasToFramebuffer(gl) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
    callAndCheck(gl, function () { return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); });
    callAndCheck(gl, function () { return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height); });
}
exports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;
function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); });
}
exports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;
function unbindColorTextureFromFramebuffer(gl, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); });
}
exports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;
function validateFramebuffer(gl) {
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));
    }
}
exports.validateFramebuffer = validateFramebuffer;
function getFramebufferErrorMessage(gl, status) {
    switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';
        case gl.FRAMEBUFFER_UNSUPPORTED:
            return 'FRAMEBUFFER_UNSUPPORTED';
        default:
            return 'unknown error ' + status;
    }
}
exports.getFramebufferErrorMessage = getFramebufferErrorMessage;
function throwIfNull(gl, returnTOrNull, failureMessage) {
    var tOrNull = callAndCheck(gl, function () { return returnTOrNull(); });
    if (tOrNull == null) {
        throw new Error(failureMessage);
    }
    return tOrNull;
}
function validateTextureUnit(gl, textureUnit) {
    var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    var glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        var textureUnitRange = '[gl.TEXTURE0, gl.TEXTURE' + maxTextureUnit + ']';
        throw new Error('textureUnit must be in ' + textureUnitRange + '.');
    }
}
function getTextureShapeFromLogicalShape(gl, logicalShape, preferredTexShape) {
    var maxTexSize = queryMaxTextureSize(gl);
    var size = util.sizeFromShape(logicalShape);
    if (preferredTexShape != null) {
        var sizePreferred = util.sizeFromShape(preferredTexShape);
        util.assert(size === sizePreferred, "Size of shape (" + size + ") must match size of " +
            ("preferredShape (" + sizePreferred + ")"));
        if (preferredTexShape[0] <= maxTexSize &&
            preferredTexShape[1] <= maxTexSize) {
            return preferredTexShape;
        }
    }
    if (logicalShape.length <= 1 && size <= maxTexSize) {
        return [size, 1];
    }
    else if (logicalShape.length === 2 && logicalShape[0] <= maxTexSize &&
        logicalShape[1] <= maxTexSize) {
        return logicalShape;
    }
    else if (logicalShape.length === 3 && logicalShape[0] <= maxTexSize &&
        logicalShape[1] * logicalShape[2] <= maxTexSize) {
        return [logicalShape[0], logicalShape[1] * logicalShape[2]];
    }
    else {
        return util.sizeToSquarishShape(size);
    }
}
exports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape;

},{"../../util":81}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var graph_util = require("./graph_util");
var add_1 = require("./ops/add");
var argmax_1 = require("./ops/argmax");
var argmaxequals_1 = require("./ops/argmaxequals");
var concat3d_1 = require("./ops/concat3d");
var convolution_1 = require("./ops/convolution");
var divide_1 = require("./ops/divide");
var element_wise_activation_1 = require("./ops/element_wise_activation");
var element_wise_cost_1 = require("./ops/element_wise_cost");
var exp_1 = require("./ops/exp");
var linear_combination_1 = require("./ops/linear_combination");
var log_1 = require("./ops/log");
var matmul_1 = require("./ops/matmul");
var max_pool_1 = require("./ops/max_pool");
var multiply_1 = require("./ops/multiply");
var reduce_sum_1 = require("./ops/reduce_sum");
var reshape_1 = require("./ops/reshape");
var softmax_1 = require("./ops/softmax");
var split_1 = require("./ops/split");
var subtract_1 = require("./ops/subtract");
function emitFromGraphNodes(nodes) {
    var ops = [];
    nodes.forEach(function (node) { return Array.prototype.push.apply(ops, emitOpFromNode(node)); });
    return ops;
}
exports.emitFromGraphNodes = emitFromGraphNodes;
function emitOpFromNode(node) {
    if (node instanceof graph_1.ReshapeNode) {
        return [new reshape_1.Reshape(node.inputs[graph_1.ReshapeNode.X], node.output)];
    }
    else if (node instanceof graph_1.MatMulNode) {
        var x1 = node.inputs[graph_1.MatMulNode.X1];
        var x2 = node.inputs[graph_1.MatMulNode.X2];
        return [new matmul_1.MatMul(x1, x2, node.output)];
    }
    else if (node instanceof graph_1.Convolution2DNode) {
        var w = node.inputs[graph_1.Convolution2DNode.W];
        var x = node.inputs[graph_1.Convolution2DNode.X];
        var b = node.inputs[graph_1.Convolution2DNode.B];
        return [new convolution_1.Convolution2D(w, x, b, node.output, node.fieldSize, node.outputDepth, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.MaxPoolNode) {
        var x = node.inputs[graph_1.MaxPoolNode.X];
        return [new max_pool_1.MaxPool(x, node.output, node.fieldSize, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.ExpNode) {
        return [new exp_1.Exp(node.inputs[graph_1.ExpNode.X], node.output)];
    }
    else if (node instanceof graph_1.LogNode) {
        return [new log_1.Log(node.inputs[graph_1.LogNode.X], node.output)];
    }
    else if (node instanceof graph_1.ReLUNode) {
        return [new element_wise_activation_1.ReLU(node.inputs[graph_1.ReLUNode.X], node.output)];
    }
    else if (node instanceof graph_1.TanHNode) {
        return [new element_wise_activation_1.TanH(node.inputs[graph_1.TanHNode.X], node.output)];
    }
    else if (node instanceof graph_1.SigmoidNode) {
        return [new element_wise_activation_1.Sigmoid(node.inputs[graph_1.SigmoidNode.X], node.output)];
    }
    else if (node instanceof graph_1.SoftmaxCrossEntropyCostNode) {
        var x = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.X];
        var target = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.TARGET];
        return [new softmax_1.SoftmaxCrossEntropyCost(x, target, node.output)];
    }
    else if (node instanceof graph_1.SoftmaxNode) {
        return [new softmax_1.Softmax(node.inputs[graph_1.SoftmaxNode.X], node.output)];
    }
    else if (node instanceof graph_1.MeanSquaredCostNode) {
        var label = node.inputs[graph_1.MeanSquaredCostNode.LABEL];
        var prediction = node.inputs[graph_1.MeanSquaredCostNode.PREDICTION];
        return [new element_wise_cost_1.MeanSquaredCost(label, prediction, node.output)];
    }
    else if (node instanceof graph_1.ArgMaxEqualsNode) {
        return [new argmaxequals_1.ArgMaxEquals(node.inputs[graph_1.ArgMaxEqualsNode.X1], node.inputs[graph_1.ArgMaxEqualsNode.X2], node.output)];
    }
    else if (node instanceof graph_1.ArgMaxNode) {
        return [new argmax_1.ArgMax(node.x, node.output)];
    }
    else if (node instanceof graph_1.FusedLinearCombinationNode) {
        return [new linear_combination_1.LinearCombination(node.inputs[graph_1.FusedLinearCombinationNode.T1], node.inputs[graph_1.FusedLinearCombinationNode.T2], node.inputs[graph_1.FusedLinearCombinationNode.C1], node.inputs[graph_1.FusedLinearCombinationNode.C2], node.output)];
    }
    else if (node instanceof graph_1.Concat3DNode) {
        return [new concat3d_1.Concat3D(node.inputs[graph_1.Concat3DNode.X1], node.inputs[graph_1.Concat3DNode.X2], node.axis, node.output)];
    }
    else if (node instanceof graph_1.SquareNode) {
        return [new element_wise_activation_1.Square(node.inputs[graph_1.SquareNode.X], node.output)];
    }
    else if (node instanceof graph_1.AddNode) {
        return [new add_1.Add(node.inputs[graph_1.AddNode.T1], node.inputs[graph_1.AddNode.T2], node.output)];
    }
    else if (node instanceof graph_1.SubtractNode) {
        return [new subtract_1.Subtract(node.inputs[graph_1.SubtractNode.T1], node.inputs[graph_1.SubtractNode.T2], node.output)];
    }
    else if (node instanceof graph_1.MultiplyNode) {
        return [new multiply_1.Multiply(node.inputs[graph_1.MultiplyNode.T1], node.inputs[graph_1.MultiplyNode.T2], node.output)];
    }
    else if (node instanceof graph_1.DivideNode) {
        return [new divide_1.Divide(node.inputs[graph_1.DivideNode.T1], node.inputs[graph_1.DivideNode.T2], node.output)];
    }
    else if (node instanceof graph_1.SplitNode) {
        return [new split_1.Split(node.inputs[graph_1.SplitNode.X], node.outputs)];
    }
    else if (node instanceof graph_1.ReduceSumNode) {
        return [new reduce_sum_1.ReduceSum(node.inputs[graph_1.ReduceSumNode.X], node.output)];
    }
    else if (graph_util.isInputNode(node)) {
        return [];
    }
    else {
        throw Error('Unsupported node type: ' + node.constructor.name);
    }
}

},{"./graph":9,"./graph_util":12,"./ops/add":55,"./ops/argmax":56,"./ops/argmaxequals":57,"./ops/concat3d":58,"./ops/convolution":59,"./ops/divide":60,"./ops/element_wise_activation":61,"./ops/element_wise_cost":62,"./ops/exp":63,"./ops/linear_combination":64,"./ops/log":65,"./ops/matmul":66,"./ops/max_pool":67,"./ops/multiply":68,"./ops/reduce_sum":70,"./ops/reshape":71,"./ops/softmax":72,"./ops/split":73,"./ops/subtract":74}],55:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var op_1 = require("./op");
var Add = (function (_super) {
    __extends(Add, _super);
    function Add(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Add.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(x1.shape)) {
                result = math.scalarPlusArray(x1, x2);
            }
            else if (util.isScalarShape(x2.shape)) {
                result = math.scalarPlusArray(x2, x1);
            }
            else {
                result = math.add(x1, x2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Add.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.set(_this.x1Tensor, keep(math.divide(sum, _this.dySizeScalar)));
                }
                else {
                    gradientArrays.set(_this.x1Tensor, dy);
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.set(_this.x2Tensor, keep(math.divide(sum, _this.dySizeScalar)));
                }
                else {
                    gradientArrays.set(_this.x2Tensor, dy);
                }
            }
        });
    };
    Add.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Add;
}(op_1.Operation));
exports.Add = Add;

},{"../graph_util":12,"../math/ndarray":24,"../util":81,"./op":69}],56:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var op_1 = require("./op");
var ArgMax = (function (_super) {
    __extends(ArgMax, _super);
    function ArgMax(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.argMax(x)));
        });
    };
    ArgMax.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMax backprop unimplemented');
    };
    return ArgMax;
}(op_1.Operation));
exports.ArgMax = ArgMax;

},{"./op":69}],57:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var op_1 = require("./op");
var ArgMaxEquals = (function (_super) {
    __extends(ArgMaxEquals, _super);
    function ArgMaxEquals(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMaxEquals.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.argMaxEquals(x1, x2)));
        });
    };
    ArgMaxEquals.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMaxEquals backprop unimplemented');
    };
    return ArgMaxEquals;
}(op_1.Operation));
exports.ArgMaxEquals = ArgMaxEquals;

},{"./op":69}],58:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var concat3d_util = require("../math/concat3d_util");
var op_1 = require("./op");
var Concat3D = (function (_super) {
    __extends(Concat3D, _super);
    function Concat3D(x1Tensor, x2Tensor, axis, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.axis = axis;
        _this.yTensor = yTensor;
        concat3d_util.assertConcat3DShapesMatch(x1Tensor.shape, x2Tensor.shape, axis);
        return _this;
    }
    Concat3D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var concatResult = math.concat3D(x1, x2, _this.axis);
            inferenceArrays.set(_this.yTensor, keep(concatResult));
        });
    };
    Concat3D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('Concat3D backprop not implemented.');
    };
    return Concat3D;
}(op_1.Operation));
exports.Concat3D = Concat3D;

},{"../math/concat3d_util":17,"./op":69}],59:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../math/conv_util");
var util = require("../util");
var op_1 = require("./op");
var Convolution2D = (function (_super) {
    __extends(Convolution2D, _super);
    function Convolution2D(wTensor, xTensor, bTensor, yTensor, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.wTensor = wTensor;
        _this.xTensor = xTensor;
        _this.bTensor = bTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.assertWeightsShape(wTensor.shape);
        _this.zeroPad = zeroPad != null ?
            zeroPad :
            conv_util.computeDefaultPad(_this.xTensor.shape, _this.fieldSize, _this.stride);
        util.assert(util.isInt(_this.zeroPad), "The zero padding (" + _this.zeroPad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    Convolution2D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var weights = inferenceArrays.get(this.wTensor);
        var biases = inferenceArrays.get(this.bTensor);
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.conv2d(x, weights, biases, _this.stride, _this.zeroPad)));
        });
    };
    Convolution2D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var weights = inferenceArrays.get(this.wTensor);
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            var _a = math.conv2dBackProp(x, dy, weights, _this.stride, _this.zeroPad), dw = _a.dw, db = _a.db, dx = _a.dx;
            gradientArrays.set(_this.wTensor, keep(dw));
            gradientArrays.set(_this.bTensor, keep(db));
            gradientArrays.set(_this.xTensor, keep(dx));
        });
    };
    Convolution2D.prototype.assertWeightsShape = function (weightsShape) {
        util.assert(weightsShape[0] === this.fieldSize &&
            weightsShape[1] === this.fieldSize &&
            weightsShape[2] === this.xTensor.shape[2] &&
            weightsShape[3] === this.outputDepth, "weights must be of shape [" + this.fieldSize + "," + this.fieldSize + "," +
            (this.xTensor.shape[2] + "," + this.outputDepth + "] but they are of") +
            ("shape [" + weightsShape + "]"));
    };
    return Convolution2D;
}(op_1.Operation));
exports.Convolution2D = Convolution2D;

},{"../math/conv_util":18,"../util":81,"./op":69}],60:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var util = require("../util");
var op_1 = require("./op");
var Divide = (function (_super) {
    __extends(Divide, _super);
    function Divide(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Divide.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarDividedByArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayDividedByScalar(t1, t2);
            }
            else {
                result = math.divide(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Divide.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        var x1IsScalar = util.isScalarShape(x1.shape);
        var x2IsScalar = util.isScalarShape(x2.shape);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (x1IsScalar) {
                    var div = math.divide(dy, x2);
                    gradientArrays.set(_this.x1Tensor, keep(math.sum(div)));
                    div.dispose();
                }
                else if (x2IsScalar) {
                    gradientArrays.set(_this.x1Tensor, keep(math.arrayDividedByScalar(dy, x2)));
                }
                else {
                    gradientArrays.set(_this.x1Tensor, keep(math.divide(dy, x2)));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var x2Squared = math.elementWiseMul(x2, x2);
                var x1OverX2Squared = void 0;
                if (x2IsScalar) {
                    x1OverX2Squared = math.arrayDividedByScalar(x1, x2Squared);
                }
                else if (x1IsScalar) {
                    x1OverX2Squared = math.scalarDividedByArray(x1, x2Squared);
                }
                else {
                    x1OverX2Squared = math.divide(x1, x2Squared);
                }
                var dx2 = math.neg(x1OverX2Squared);
                var dyTimesDerivative = math.elementWiseMul(dy, dx2);
                if (x2IsScalar) {
                    gradientArrays.set(_this.x2Tensor, keep(math.sum(dyTimesDerivative)));
                }
                else {
                    gradientArrays.set(_this.x2Tensor, keep(dyTimesDerivative));
                }
            }
        });
    };
    return Divide;
}(op_1.Operation));
exports.Divide = Divide;

},{"../graph_util":12,"../util":81,"./op":69}],61:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var activation_functions_1 = require("../math/activation_functions");
var op_1 = require("./op");
var ElementWiseActivation = (function (_super) {
    __extends(ElementWiseActivation, _super);
    function ElementWiseActivation(xTensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.func = func;
        return _this;
    }
    ElementWiseActivation.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(_this.func.output(math, x)));
        });
    };
    ElementWiseActivation.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            var dydx = _this.func.der(math, x, y);
            gradientArrays.set(_this.xTensor, keep(math.elementWiseMul(dy, dydx)));
            dydx.dispose();
        });
    };
    return ElementWiseActivation;
}(op_1.Operation));
exports.ElementWiseActivation = ElementWiseActivation;
var ReLU = (function (_super) {
    __extends(ReLU, _super);
    function ReLU(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.ReLUFunc()) || this;
    }
    return ReLU;
}(ElementWiseActivation));
exports.ReLU = ReLU;
var TanH = (function (_super) {
    __extends(TanH, _super);
    function TanH(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.TanHFunc()) || this;
    }
    return TanH;
}(ElementWiseActivation));
exports.TanH = TanH;
var Sigmoid = (function (_super) {
    __extends(Sigmoid, _super);
    function Sigmoid(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SigmoidFunc()) || this;
    }
    return Sigmoid;
}(ElementWiseActivation));
exports.Sigmoid = Sigmoid;
var Square = (function (_super) {
    __extends(Square, _super);
    function Square(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SquareFunc()) || this;
    }
    return Square;
}(ElementWiseActivation));
exports.Square = Square;

},{"../math/activation_functions":16,"./op":69}],62:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var cost_functions_1 = require("../math/cost_functions");
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var op_1 = require("./op");
var ElementWiseCost = (function (_super) {
    __extends(ElementWiseCost, _super);
    function ElementWiseCost(x1Tensor, x2Tensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        _this.func = func;
        _this.oneOverNScalar = ndarray_1.Scalar.new(1 / util.sizeFromShape(x1Tensor.shape));
        return _this;
    }
    ElementWiseCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var elementWiseCost = _this.func.cost(math, x1, x2);
            var sum = math.sum(elementWiseCost);
            var result = math.scalarTimesArray(_this.oneOverNScalar, sum);
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    ElementWiseCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.set(_this.x1Tensor, keep(_this.func.der(math, x1, x2)));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.set(_this.x2Tensor, keep(_this.func.der(math, x2, x1)));
            }
        });
    };
    ElementWiseCost.prototype.dispose = function () {
        this.func.dispose();
        this.oneOverNScalar.dispose();
    };
    return ElementWiseCost;
}(op_1.Operation));
exports.ElementWiseCost = ElementWiseCost;
var MeanSquaredCost = (function (_super) {
    __extends(MeanSquaredCost, _super);
    function MeanSquaredCost(x1Tensor, x2Tensor, yTensor) {
        return _super.call(this, x1Tensor, x2Tensor, yTensor, new cost_functions_1.SquareCostFunc()) || this;
    }
    return MeanSquaredCost;
}(ElementWiseCost));
exports.MeanSquaredCost = MeanSquaredCost;

},{"../graph_util":12,"../math/cost_functions":20,"../math/ndarray":24,"../util":81,"./op":69}],63:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Exp = (function (_super) {
    __extends(Exp, _super);
    function Exp(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Exp.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.exp(x)));
        });
    };
    Exp.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.set(_this.xTensor, keep(math.elementWiseMul(y, dy)));
            }
        });
    };
    return Exp;
}(op_1.Operation));
exports.Exp = Exp;

},{"../graph_util":12,"./op":69}],64:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var LinearCombination = (function (_super) {
    __extends(LinearCombination, _super);
    function LinearCombination(x1Tensor, x2Tensor, c1Tensor, c2Tensor, outTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.c1Tensor = c1Tensor;
        _this.c2Tensor = c2Tensor;
        _this.outTensor = outTensor;
        return _this;
    }
    LinearCombination.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor).asScalar();
        var c2 = inferenceArrays.get(this.c2Tensor).asScalar();
        math.scope(function (keep) {
            inferenceArrays.set(_this.outTensor, keep(math.scaledArrayAdd(c1, x1, c2, x2)));
        });
    };
    LinearCombination.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor);
        var c2 = inferenceArrays.get(this.c2Tensor);
        var dy = gradientArrays.get(this.outTensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.set(_this.x1Tensor, keep(math.scalarTimesArray(c1, dy)));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.set(_this.x2Tensor, keep(math.scalarTimesArray(c2, dy)));
            }
            if (graph_util.shouldBackProp(_this.c1Tensor)) {
                var dotProduct1 = math.elementWiseMul(x1, dy);
                gradientArrays.set(_this.c1Tensor, keep(math.sum(dotProduct1)));
            }
            if (graph_util.shouldBackProp(_this.c2Tensor)) {
                var dotProduct2 = math.elementWiseMul(x2, dy);
                gradientArrays.set(_this.c2Tensor, keep(math.sum(dotProduct2)));
            }
        });
    };
    return LinearCombination;
}(op_1.Operation));
exports.LinearCombination = LinearCombination;

},{"../graph_util":12,"./op":69}],65:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Log = (function (_super) {
    __extends(Log, _super);
    function Log(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Log.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.log(x)));
        });
    };
    Log.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.set(_this.xTensor, keep(math.divide(dy, x)));
            }
        });
    };
    return Log;
}(op_1.Operation));
exports.Log = Log;

},{"../graph_util":12,"./op":69}],66:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var math_1 = require("../math/math");
var op_1 = require("./op");
var MatMul = (function (_super) {
    __extends(MatMul, _super);
    function MatMul(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    MatMul.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            if (x1.shape.length === 2 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, keep(math.matMul(x1, x2)));
            }
            else if (x1.shape.length === 2 && x2.shape.length === 1) {
                inferenceArrays.set(_this.yTensor, keep(math.matrixTimesVector(x1, x2)));
            }
            else if (x1.shape.length === 1 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, keep(math.vectorTimesMatrix(x1, x2)));
            }
        });
    };
    MatMul.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        if (x1.shape.length === 1) {
            x1 = x1.reshape([1, x1.size]);
            dy = dy.reshape([1, dy.size]);
        }
        if (x2.shape.length === 1) {
            x2 = x2.reshape([x2.size, 1]);
            dy = dy.reshape([dy.size, 1]);
        }
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                var dx1 = math.matMul(dy, x2, math_1.MatrixOrientation.REGULAR, math_1.MatrixOrientation.TRANSPOSED);
                gradientArrays.set(_this.x1Tensor, keep(_this.x1Tensor.shape.length === 1 ? dx1.as1D() : dx1));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var dx2 = math.matMul(x1, dy, math_1.MatrixOrientation.TRANSPOSED, math_1.MatrixOrientation.REGULAR);
                gradientArrays.set(_this.x2Tensor, keep(_this.x2Tensor.shape.length === 1 ? dx2.as1D() : dx2));
            }
        });
    };
    return MatMul;
}(op_1.Operation));
exports.MatMul = MatMul;

},{"../graph_util":12,"../math/math":21,"./op":69}],67:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../math/conv_util");
var util = require("../util");
var op_1 = require("./op");
var MaxPool = (function (_super) {
    __extends(MaxPool, _super);
    function MaxPool(xTensor, yTensor, fieldSize, stride, pad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        if (pad != null) {
            _this.pad = pad;
        }
        else {
            _this.pad = conv_util.computeDefaultPad(xTensor.shape, _this.fieldSize, _this.stride);
        }
        util.assert(util.isInt(_this.pad), "The zero padding (" + _this.pad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    MaxPool.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.maxPool(x, _this.fieldSize, _this.stride, _this.pad)));
        });
    };
    MaxPool.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            gradientArrays.set(_this.xTensor, keep(math.maxPoolBackprop(dy, x, _this.fieldSize, _this.stride, _this.pad)));
        });
    };
    return MaxPool;
}(op_1.Operation));
exports.MaxPool = MaxPool;

},{"../math/conv_util":18,"../util":81,"./op":69}],68:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var util = require("../util");
var op_1 = require("./op");
var Multiply = (function (_super) {
    __extends(Multiply, _super);
    function Multiply(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Multiply.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarTimesArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.scalarTimesArray(t2, t1);
            }
            else {
                result = math.elementWiseMul(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Multiply.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x2);
                    gradientArrays.set(_this.x1Tensor, keep(math.sum(mul)));
                }
                else if (util.isScalarShape(x2.shape)) {
                    gradientArrays.set(_this.x1Tensor, keep(math.scalarTimesArray(x2, dy)));
                }
                else {
                    gradientArrays.set(_this.x1Tensor, keep(math.elementWiseMul(x2, dy)));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x1);
                    gradientArrays.set(_this.x2Tensor, keep(math.sum(mul)));
                }
                else if (util.isScalarShape(x1.shape)) {
                    gradientArrays.set(_this.x2Tensor, keep(math.scalarTimesArray(x1, dy)));
                }
                else {
                    gradientArrays.set(_this.x2Tensor, keep(math.elementWiseMul(x1, dy)));
                }
            }
        });
    };
    return Multiply;
}(op_1.Operation));
exports.Multiply = Multiply;

},{"../graph_util":12,"../util":81,"./op":69}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Operation = (function () {
    function Operation() {
    }
    Operation.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) { };
    Operation.prototype.dispose = function () { };
    return Operation;
}());
exports.Operation = Operation;

},{}],70:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var op_1 = require("./op");
var ReduceSum = (function (_super) {
    __extends(ReduceSum, _super);
    function ReduceSum(x, outTensor) {
        var _this = _super.call(this) || this;
        _this.x = x;
        _this.outTensor = outTensor;
        util.assertShapesMatch(outTensor.shape, []);
        return _this;
    }
    ReduceSum.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.x);
        math.scope(function (keep) {
            inferenceArrays.set(_this.outTensor, keep(math.sum(x)));
        });
    };
    ReduceSum.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        if (!graph_util.shouldBackProp(this.x)) {
            return;
        }
        math.scope(function (keep) {
            var dy = gradientArrays.get(_this.outTensor);
            if (_this.ones == null) {
                var xArray = inferenceArrays.get(_this.x);
                _this.ones = ndarray_1.NDArray.zerosLike(xArray);
                _this.ones.fill(1);
            }
            gradientArrays.set(_this.x, keep(math.scalarTimesArray(dy, _this.ones)));
        });
    };
    return ReduceSum;
}(op_1.Operation));
exports.ReduceSum = ReduceSum;

},{"../graph_util":12,"../math/ndarray":24,"../util":81,"./op":69}],71:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var op_1 = require("./op");
var Reshape = (function (_super) {
    __extends(Reshape, _super);
    function Reshape(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        var xSize = util.sizeFromShape(xTensor.shape);
        var ySize = util.sizeFromShape(yTensor.shape);
        util.assert(xSize === ySize, "The input size (" + xSize + ") and output size (" + ySize + ") must match");
        return _this;
    }
    Reshape.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.reshape(x, _this.yTensor.shape)));
        });
    };
    Reshape.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            gradientArrays.set(_this.xTensor, keep(math.reshape(dy, _this.xTensor.shape)));
        });
    };
    return Reshape;
}(op_1.Operation));
exports.Reshape = Reshape;

},{"../util":81,"./op":69}],72:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("../graph");
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var op_1 = require("./op");
var Softmax = (function (_super) {
    __extends(Softmax, _super);
    function Softmax(logitsTensor, output) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.output = output;
        return _this;
    }
    Softmax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        return math.scope(function (keep) {
            inferenceArrays.set(_this.output, keep(math.softmax(logits)));
        });
    };
    Softmax.prototype.backProp = function () {
        throw Error('Softmax backprop is not yet implemented');
    };
    return Softmax;
}(op_1.Operation));
exports.Softmax = Softmax;
var SoftmaxCrossEntropyCost = (function (_super) {
    __extends(SoftmaxCrossEntropyCost, _super);
    function SoftmaxCrossEntropyCost(logitsTensor, labelTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.labelTensor = labelTensor;
        _this.yTensor = yTensor;
        _this.epsilon = ndarray_1.Scalar.new(1e-5);
        _this.softmaxTensor = new graph_1.Tensor(logitsTensor.shape);
        return _this;
    }
    SoftmaxCrossEntropyCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        var label = inferenceArrays.get(this.labelTensor);
        math.scope(function (keep) {
            var softmaxResult = math.softmax(logits);
            inferenceArrays.set(_this.softmaxTensor, keep(softmaxResult));
            inferenceArrays.set(_this.yTensor, keep(crossEntropyCost(math, softmaxResult, label, _this.epsilon)));
        });
    };
    SoftmaxCrossEntropyCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var softmax = inferenceArrays.get(this.softmaxTensor);
        var label = inferenceArrays.get(this.labelTensor);
        math.scope(function (keep) {
            gradientArrays.set(_this.logitsTensor, keep(math.sub(softmax, label)));
        });
    };
    SoftmaxCrossEntropyCost.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) {
        inferenceArrays.disposeArray(this.softmaxTensor);
    };
    SoftmaxCrossEntropyCost.prototype.dispose = function () {
        this.epsilon.dispose();
    };
    return SoftmaxCrossEntropyCost;
}(op_1.Operation));
exports.SoftmaxCrossEntropyCost = SoftmaxCrossEntropyCost;
function crossEntropyCost(math, y, target, epsilon) {
    util.assert(y.size === target.size, 'The output and target must be the same size');
    return math.scope(function () {
        var yPlusEps = math.scalarPlusArray(epsilon, y);
        var logOutput = math.log(yPlusEps);
        var tarLogOutput = math.elementWiseMul(target, logOutput);
        var costVector = math.neg(tarLogOutput);
        return math.sum(costVector);
    });
}
exports.crossEntropyCost = crossEntropyCost;

},{"../graph":9,"../math/ndarray":24,"../util":81,"./op":69}],73:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var util = require("../util");
var op_1 = require("./op");
var Split = (function (_super) {
    __extends(Split, _super);
    function Split(input, outputs) {
        var _this = _super.call(this) || this;
        _this.input = input;
        _this.outputs = outputs;
        outputs.forEach(function (output) {
            util.assertShapesMatch(input.shape, output.shape);
        });
        return _this;
    }
    Split.prototype.feedForward = function (math, inferenceArrays) {
        var inputArray = inferenceArrays.get(this.input);
        this.outputs.forEach(function (output) {
            inferenceArrays.set(output, inputArray);
        });
    };
    Split.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        if (!graph_util.shouldBackProp(this.input)) {
            return;
        }
        math.scope(function (keep) {
            var dx = math.add(gradientArrays.get(_this.outputs[0]), gradientArrays.get(_this.outputs[1]));
            _this.outputs.slice(2).forEach(function (output) {
                dx = math.add(dx, gradientArrays.get(output));
            });
            gradientArrays.set(_this.input, keep(dx));
        });
    };
    return Split;
}(op_1.Operation));
exports.Split = Split;

},{"../graph_util":12,"../util":81,"./op":69}],74:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var op_1 = require("./op");
var Subtract = (function (_super) {
    __extends(Subtract, _super);
    function Subtract(t1, t2, outTensor) {
        var _this = _super.call(this) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.outTensor = outTensor;
        util.assert(util.sizeFromShape(t1.shape) === 1 ||
            util.sizeFromShape(t2.shape) === 1 ||
            util.arraysEqual(t1.shape, t2.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Subtract.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.t1);
        var t2 = inferenceArrays.get(this.t2);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarMinusArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayMinusScalar(t1, t2);
            }
            else {
                result = math.sub(t1, t2);
            }
            inferenceArrays.set(_this.outTensor, keep(result));
        });
    };
    Subtract.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.outTensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.t1)) {
                if (util.isScalarShape(_this.t1.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.set(_this.t1, keep(math.divide(sum, _this.dySizeScalar)));
                }
                else {
                    gradientArrays.set(_this.t1, keep(dy));
                }
            }
            if (graph_util.shouldBackProp(_this.t2)) {
                if (util.isScalarShape(_this.t2.shape)) {
                    var sum = math.sum(dy);
                    var negSum = math.neg(sum);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.set(_this.t2, keep(math.divide(negSum, _this.dySizeScalar)));
                }
                else {
                    gradientArrays.set(_this.t2, keep(math.neg(dy)));
                }
            }
        });
    };
    Subtract.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Subtract;
}(op_1.Operation));
exports.Subtract = Subtract;

},{"../graph_util":12,"../math/ndarray":24,"../util":81,"./op":69}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Optimizer = (function () {
    function Optimizer(specifiedVariableList) {
        if (specifiedVariableList != null) {
            this.specifiedVariableNodes = specifiedVariableList;
        }
    }
    return Optimizer;
}());
exports.Optimizer = Optimizer;

},{}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function defaultCompare(a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
}
exports.defaultCompare = defaultCompare;
var PriorityQueue = (function () {
    function PriorityQueue(comparator, indexObserver) {
        this.comparator = comparator;
        this.indexObserver = indexObserver;
        this.heap = [];
    }
    PriorityQueue.prototype.enqueue = function (t) {
        this.heap.push(t);
        this.onIndexChanged(t, this.heap.length - 1);
        this.siftUp(this.heap.length - 1);
    };
    PriorityQueue.prototype.dequeue = function () {
        if (this.empty()) {
            throw new Error('dequeue called on empty priority queue.');
        }
        var t = this.heap[0];
        this.swap(0, this.heap.length - 1);
        this.heap.pop();
        this.siftDown(0);
        return t;
    };
    PriorityQueue.prototype.update = function (newT, index) {
        var last = (index === this.heap.length - 1);
        if (!last) {
            this.swap(index, this.heap.length - 1);
        }
        this.heap.pop();
        if (!last) {
            if (this.siftUpIndex(index) !== -1) {
                this.siftUp(index);
            }
            else if (this.siftDownIndex(index) !== -1) {
                this.siftDown(index);
            }
        }
        this.enqueue(newT);
    };
    PriorityQueue.prototype.empty = function () {
        return this.heap.length === 0;
    };
    PriorityQueue.prototype.onIndexChanged = function (t, newIndex) {
        if (this.indexObserver) {
            this.indexObserver(t, newIndex);
        }
    };
    PriorityQueue.prototype.getParentIndex = function (index) {
        if (index === 0) {
            return -1;
        }
        return Math.floor((index - 1) / 2);
    };
    PriorityQueue.prototype.getLeftChildIndex = function (index) {
        var candidate = index * 2 + 1;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.getRightChildIndex = function (index) {
        var candidate = index * 2 + 2;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.siftUpIndex = function (index) {
        var parentIndex = this.getParentIndex(index);
        if (parentIndex === -1) {
            return -1;
        }
        if (this.compare(parentIndex, index) > 0) {
            return parentIndex;
        }
        return -1;
    };
    PriorityQueue.prototype.siftUp = function (index) {
        var siftIndex = this.siftUpIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftUpIndex(index);
        }
    };
    PriorityQueue.prototype.siftDownIndex = function (index) {
        if (index >= this.heap.length) {
            return -1;
        }
        var largestChildIndex = index;
        var leftChildIndex = this.getLeftChildIndex(index);
        if ((leftChildIndex !== -1) &&
            (this.compare(leftChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = leftChildIndex;
        }
        var rightChildIndex = this.getRightChildIndex(index);
        if ((rightChildIndex !== -1) &&
            (this.compare(rightChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = rightChildIndex;
        }
        return (largestChildIndex === index) ? -1 : largestChildIndex;
    };
    PriorityQueue.prototype.siftDown = function (index) {
        var siftIndex = this.siftDownIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftDownIndex(index);
        }
    };
    PriorityQueue.prototype.compare = function (aIndex, bIndex) {
        return this.comparator(this.heap[aIndex], this.heap[bIndex]);
    };
    PriorityQueue.prototype.swap = function (a, b) {
        var temp = this.heap[a];
        this.heap[a] = this.heap[b];
        this.heap[b] = temp;
        this.onIndexChanged(this.heap[a], a);
        this.onIndexChanged(this.heap[b], b);
    };
    return PriorityQueue;
}());
exports.PriorityQueue = PriorityQueue;

},{}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var operation_emitter = require("./operation_emitter");
var session_util = require("./session_util");
var tensor_array_map_1 = require("./tensor_array_map");
var util = require("./util");
var FeedDictionary = (function () {
    function FeedDictionary(feedEntries) {
        var _this = this;
        this.dict = {};
        if (feedEntries) {
            feedEntries.forEach(function (entry) { return _this.dict[entry.tensor.id] = entry; });
        }
    }
    return FeedDictionary;
}());
exports.FeedDictionary = FeedDictionary;
var CostReduction;
(function (CostReduction) {
    CostReduction[CostReduction["NONE"] = 0] = "NONE";
    CostReduction[CostReduction["SUM"] = 1] = "SUM";
    CostReduction[CostReduction["MEAN"] = 2] = "MEAN";
})(CostReduction = exports.CostReduction || (exports.CostReduction = {}));
var Session = (function () {
    function Session(graph, math) {
        this.math = math;
        this.activationArrayMap = new tensor_array_map_1.TensorArrayMap();
        this.gradientArrayMap = new tensor_array_map_1.TensorArrayMap();
        this.runtimeCache = {};
        this.oneScalar = ndarray_1.Scalar.new(1);
    }
    Session.prototype.dispose = function () {
        var _this = this;
        this.activationArrayMap.dispose();
        Object.keys(this.runtimeCache).forEach(function (key) {
            var runtime = _this.runtimeCache[key];
            if (runtime.operations) {
                runtime.operations.forEach(function (op) { return op.dispose(); });
            }
        });
        this.runtimeCache = {};
        if (this.batchSizeScalar != null) {
            this.batchSizeScalar.dispose();
        }
        this.oneScalar.dispose();
    };
    Session.prototype.evalAll = function (tensors, feedEntries) {
        var _this = this;
        return this.math.scope(function () {
            var feed = new FeedDictionary(feedEntries);
            var runtime = _this.getOrCreateRuntime(tensors, feed);
            var activations = _this.activationArrayMap;
            session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
            session_util.disposeTransientOperationArrays(runtime.operations, _this.activationArrayMap, _this.gradientArrayMap);
            session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
            session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
            runtime.operations.forEach(function (op) { return op.feedForward(_this.math, activations); });
            var results = tensors.map(function (x) { return activations.get(x); });
            tensors.forEach(function (x) { return activations.delete(x); });
            session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
            return results;
        });
    };
    Session.prototype.eval = function (tensor, feedEntries) {
        return this.evalAll([tensor], feedEntries)[0];
    };
    Session.prototype.train = function (costTensor, feedEntries, batchSize, optimizer, costReduction) {
        var _this = this;
        if (costReduction === void 0) { costReduction = CostReduction.NONE; }
        util.assert(util.isScalarShape(costTensor.shape), 'Cost tensor for training must be a scalar value.');
        if (this.prevBatchSize !== batchSize) {
            this.prevBatchSize = batchSize;
            this.batchSizeScalar = ndarray_1.Scalar.new(batchSize);
        }
        var feed = new FeedDictionary(feedEntries);
        session_util.throwIfFeedDictionaryContainsNDArrays(feed);
        var runtime = this.getOrCreateRuntime([costTensor], feed);
        var inferenceOperations = runtime.operations;
        var backPropOperations = runtime.operations.slice().reverse();
        var activations = this.activationArrayMap;
        var gradients = this.gradientArrayMap;
        gradients.set(costTensor, this.oneScalar);
        session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
        optimizer.beforeBatch(this.math, batchSize, runtime, activations, gradients);
        return this.math.scope(function (keep, track) {
            var cost = track(ndarray_1.Scalar.new(0));
            for (var i = 0; i < batchSize; ++i) {
                session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
                session_util.disposeAndInitializeOperationInputGradients(runtime.nodes, gradients);
                session_util.disposeTransientOperationArrays(runtime.operations, activations, gradients);
                session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
                inferenceOperations.forEach(function (op) { return op.feedForward(_this.math, activations); });
                backPropOperations.forEach(function (op) { return op.backProp(_this.math, activations, gradients); });
                optimizer.afterExample(_this.math, runtime, activations, gradients);
                session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
                cost = _this.updateCostForExample(cost, activations.get(costTensor), costReduction);
            }
            optimizer.afterBatch(_this.math, batchSize, runtime, activations, gradients);
            return _this.updateCostForBatch(cost, costReduction);
        });
    };
    Session.prototype.updateCostForExample = function (totalCost, currCost, costReduction) {
        if (costReduction === CostReduction.MEAN ||
            costReduction === CostReduction.SUM) {
            return this.math.add(totalCost, currCost);
        }
        return totalCost;
    };
    Session.prototype.updateCostForBatch = function (totalCost, costReduction) {
        if (costReduction === CostReduction.MEAN) {
            return this.math.divide(totalCost, this.batchSizeScalar);
        }
        return totalCost;
    };
    Session.prototype.getOrCreateRuntime = function (tensors, feed) {
        var key = this.makeRuntimeCacheKey(tensors, feed);
        var runtime = this.runtimeCache[key];
        if (runtime === undefined) {
            var nodes = session_util.getOrderedEvaluationSetFromEvalTensor(tensors, feed);
            nodes = session_util.addSplitNodes(nodes);
            session_util.removeFeedDictionaryNodesFromEvaluationSet(feed, nodes);
            session_util.throwErrorIfEvaluationSetContainsPlaceholderNodes(nodes);
            var operations = operation_emitter.emitFromGraphNodes(nodes);
            runtime = { nodes: nodes, operations: operations };
            this.runtimeCache[key] = runtime;
        }
        return runtime;
    };
    Session.prototype.makeRuntimeCacheKey = function (tensors, feed) {
        return tensors.map(function (x) { return x.id; }).sort().join('_') + '__' +
            Object.keys(feed.dict).sort().join('_');
    };
    return Session;
}());
exports.Session = Session;

},{"./math/ndarray":24,"./operation_emitter":54,"./session_util":78,"./tensor_array_map":80,"./util":81}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var graph_util = require("./graph_util");
var ndarray_1 = require("./math/ndarray");
var util = require("./util");
function getTerminatingNodesFromFeedDictionary(feedDictionary) {
    return Object.keys(feedDictionary.dict)
        .map(function (tensorID) { return feedDictionary.dict[+tensorID].tensor.node; });
}
exports.getTerminatingNodesFromFeedDictionary = getTerminatingNodesFromFeedDictionary;
function getOrderedEvaluationSetFromEvalTensor(evalTensors, feedDictionary) {
    var terminatingNodes = getTerminatingNodesFromFeedDictionary(feedDictionary);
    var evalNodes = evalTensors.map(function (x) { return x.node; });
    var unorderedEvaluationSet = graph_util.getUnorderedEvaluationSet(evalNodes, terminatingNodes);
    var orderedEvaluationSet = graph_util.getOrderedEvaluationSet(unorderedEvaluationSet);
    return orderedEvaluationSet;
}
exports.getOrderedEvaluationSetFromEvalTensor = getOrderedEvaluationSetFromEvalTensor;
function addPersistentArraysToTensorArrayMap(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode || node instanceof graph_1.ConstantNode) {
            tensorArrayMap.set(node.output, node.data);
        }
    });
}
exports.addPersistentArraysToTensorArrayMap = addPersistentArraysToTensorArrayMap;
function getVariableNodesFromEvaluationSet(evaluationSet) {
    var nodes = [];
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode) {
            nodes.push(node);
        }
    });
    return nodes;
}
exports.getVariableNodesFromEvaluationSet = getVariableNodesFromEvaluationSet;
function throwIfFeedDictionaryContainsNDArrays(feedDictionary) {
    Object.keys(feedDictionary.dict).forEach(function (tensorID) {
        if (feedDictionary.dict[+tensorID].data instanceof ndarray_1.NDArray) {
            throw new Error('training requires FeedDictionary entries to be InputProviders' +
                'and not NDArrays.');
        }
    });
}
exports.throwIfFeedDictionaryContainsNDArrays = throwIfFeedDictionaryContainsNDArrays;
function loadInputsFromFeedDictionaryToTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        var data;
        if (feedEntry.data instanceof ndarray_1.NDArray) {
            data = feedEntry.data;
        }
        else {
            var provider = feedEntry.data;
            data = provider.getNextCopy(math);
        }
        util.assert(util.arraysEqual(feedEntry.tensor.shape, data.shape), "Error loading FeedEntry: feeding NDArray of shape " + data.shape + " " +
            ("does not match Tensor (id: " + feedEntry.tensor.id + ") shape: ") +
            (feedEntry.tensor.shape + "."));
        activations.set(feedEntry.tensor, data);
    });
}
exports.loadInputsFromFeedDictionaryToTensorArrayMap = loadInputsFromFeedDictionaryToTensorArrayMap;
function releaseFeedDictionaryInputsFromTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        if (!(feedEntry.data instanceof ndarray_1.NDArray)) {
            var provider = feedEntry.data;
            var feedEntryArray = activations.get(feedEntry.tensor);
            provider.disposeCopy(math, feedEntryArray);
        }
        activations.delete(feedEntry.tensor);
    });
}
exports.releaseFeedDictionaryInputsFromTensorArrayMap = releaseFeedDictionaryInputsFromTensorArrayMap;
function removeFeedDictionaryNodesFromEvaluationSet(feedDictionary, evaluationSet) {
    var i = 0;
    while (i < evaluationSet.length) {
        var node = evaluationSet[i];
        if (feedDictionary.dict[node.output.id] != null) {
            evaluationSet.splice(i, 1);
        }
        else {
            ++i;
        }
    }
}
exports.removeFeedDictionaryNodesFromEvaluationSet = removeFeedDictionaryNodesFromEvaluationSet;
function disposeAndInitializeOperationOutputs(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (!graph_util.isInputNode(node)) {
            if (!graph_util.isPassthroughNode(node, tensorArrayMap)) {
                tensorArrayMap.disposeArray(node.output);
            }
            tensorArrayMap.set(node.output, null);
        }
    });
}
exports.disposeAndInitializeOperationOutputs = disposeAndInitializeOperationOutputs;
function disposeAndInitializeOperationInputGradients(evaluationSet, gradients) {
    evaluationSet.forEach(function (node) {
        Object.keys(node.inputs).forEach(function (inputName) {
            var input = node.inputs[inputName];
            if (gradients.get(input, true) !== gradients.get(node.output, true)) {
                gradients.disposeArray(input);
            }
            gradients.set(input, null);
        });
    });
}
exports.disposeAndInitializeOperationInputGradients = disposeAndInitializeOperationInputGradients;
function disposeTransientOperationArrays(operations, activations, gradients) {
    operations.forEach(function (op) { return op.disposeTransientArrays(activations, gradients); });
}
exports.disposeTransientOperationArrays = disposeTransientOperationArrays;
function throwErrorIfEvaluationSetContainsPlaceholderNodes(evaluationSet) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.PlaceholderNode) {
            var shape = '[' + node.output.shape.join(', ') + ']';
            throw new Error('Placeholder node "' + node.name + '" ' + shape +
                ' not present in feed dictionary.');
        }
    });
}
exports.throwErrorIfEvaluationSetContainsPlaceholderNodes = throwErrorIfEvaluationSetContainsPlaceholderNodes;
function addSplitNodes(nodes) {
    var nodeIdToNumConsumers = [];
    var nodeIdToSplitNode = {};
    nodes.forEach(function (node) {
        var keys = Object.keys(node.inputs);
        keys.forEach(function (key) {
            var inputTensor = node.inputs[key];
            var input = inputTensor.node;
            if (nodeIdToNumConsumers[input.id] == null) {
                nodeIdToNumConsumers[input.id] = 0;
            }
            nodeIdToNumConsumers[input.id]++;
            if (nodeIdToNumConsumers[input.id] > 1 &&
                nodeIdToSplitNode[input.id] == null) {
                nodeIdToSplitNode[input.id] = new graph_1.SplitNode(input.graph, inputTensor);
            }
        });
    });
    var newNodes = [];
    nodes.forEach(function (node) {
        newNodes.push(node);
        if (node.id in nodeIdToSplitNode) {
            var splitNode = nodeIdToSplitNode[node.id];
            newNodes.push(splitNode);
        }
        var keys = Object.keys(node.inputs);
        keys.forEach(function (key) {
            var inputTensor = node.inputs[key];
            var inputId = inputTensor.node.id;
            if (inputId in nodeIdToSplitNode) {
                node.inputs[key] = nodeIdToSplitNode[inputId].getNewOutputTensor();
            }
        });
    });
    return newNodes;
}
exports.addSplitNodes = addSplitNodes;

},{"./graph":9,"./graph_util":12,"./math/ndarray":24,"./util":81}],79:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var optimizer_1 = require("./optimizer");
var session_util = require("./session_util");
var tensor_array_map_1 = require("./tensor_array_map");
var SGDOptimizer = (function (_super) {
    __extends(SGDOptimizer, _super);
    function SGDOptimizer(learningRate, specifiedVariableList) {
        var _this = _super.call(this, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.variableGradients = new tensor_array_map_1.TensorArrayMap();
        _this.one = ndarray_1.Scalar.new(1);
        return _this;
    }
    SGDOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        this.variableNodes = this.specifiedVariableNodes == null ?
            session_util.getVariableNodesFromEvaluationSet(runtime.nodes) :
            this.specifiedVariableNodes;
        if (batchSize !== this.prevBatchSize) {
            this.prevBatchSize = batchSize;
            this.c = ndarray_1.Scalar.new(-this.learningRate / batchSize);
        }
        this.variableNodes.forEach(function (node) { return _this.variableGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape)); });
    };
    SGDOptimizer.prototype.afterExample = function (math, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var gradient = gradientArrayMap.get(node.output);
                var accumulatedGradient = _this.variableGradients.get(node.output);
                _this.variableGradients.set(node.output, keep(math.add(gradient, accumulatedGradient)));
                accumulatedGradient.dispose();
            });
        });
    };
    SGDOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var variable = math.scaledArrayAdd(_this.c, gradient, _this.one, oldVariable);
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    SGDOptimizer.prototype.dispose = function () {
        if (this.c != null) {
            this.c.dispose();
        }
        this.one.dispose();
    };
    SGDOptimizer.prototype.setLearningRate = function (learningRate) {
        this.learningRate = learningRate;
    };
    return SGDOptimizer;
}(optimizer_1.Optimizer));
exports.SGDOptimizer = SGDOptimizer;

},{"./math/ndarray":24,"./optimizer":75,"./session_util":78,"./tensor_array_map":80}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TensorArrayMap = (function () {
    function TensorArrayMap() {
        this.dict = {};
    }
    TensorArrayMap.prototype.set = function (tensor, array) {
        this.dict[tensor.id] = array;
    };
    TensorArrayMap.prototype.get = function (tensor, skipChecks) {
        if (skipChecks === void 0) { skipChecks = false; }
        if (!skipChecks && this.dict[tensor.id] === undefined) {
            throw new Error('tensor ' + tensor.id + ' not in array map.');
        }
        var nda = this.dict[tensor.id];
        if (!skipChecks && nda === null) {
            throw new Error('tensor ' + tensor.id + ' has null array.');
        }
        return nda;
    };
    TensorArrayMap.prototype.delete = function (tensor) {
        delete this.dict[tensor.id];
    };
    TensorArrayMap.prototype.disposeArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            return;
        }
        var nda = this.dict[tensor.id];
        if (nda === null) {
            return;
        }
        nda.dispose();
        this.dict[tensor.id] = null;
    };
    TensorArrayMap.prototype.size = function () {
        return Object.keys(this.dict).length;
    };
    TensorArrayMap.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.dict).forEach(function (tensorID) {
            var nda = _this.dict[+tensorID];
            if (nda) {
                nda.dispose();
            }
        });
        this.dict = {};
    };
    TensorArrayMap.prototype.hasNullArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            throw new Error('tensor ' + tensor.id + ' not in array map.');
        }
        return this.dict[tensor.id] === null;
    };
    return TensorArrayMap;
}());
exports.TensorArrayMap = TensorArrayMap;

},{}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function shuffle(array) {
    var counter = array.length;
    var temp = 0;
    var index = 0;
    while (counter > 0) {
        index = (Math.random() * counter) | 0;
        counter--;
        temp = array[counter];
        array[counter] = array[index];
        array[index] = temp;
    }
}
exports.shuffle = shuffle;
function clamp(min, x, max) {
    return Math.max(min, Math.min(x, max));
}
exports.clamp = clamp;
function randUniform(a, b) {
    return Math.random() * (b - a) + a;
}
exports.randUniform = randUniform;
function randGauss(mean, stdDev, truncated) {
    if (mean === void 0) { mean = 0; }
    if (stdDev === void 0) { stdDev = 1; }
    if (truncated === void 0) { truncated = false; }
    var v1, v2, s;
    do {
        v1 = 2 * Math.random() - 1;
        v2 = 2 * Math.random() - 1;
        s = v1 * v1 + v2 * v2;
    } while (s > 1);
    var result = Math.sqrt(-2 * Math.log(s) / s) * v1;
    if (truncated && result > 2) {
        return randGauss(mean, stdDev, true);
    }
    return mean + stdDev * result;
}
exports.randGauss = randGauss;
function distSquared(a, b) {
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        var diff = a[i] - b[i];
        result += diff * diff;
    }
    return result;
}
exports.distSquared = distSquared;
function assert(expr, msg) {
    if (!expr) {
        throw new Error(msg);
    }
}
exports.assert = assert;
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
    assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + ("Shapes " + shapeA + " and " + shapeB + " must match"));
}
exports.assertShapesMatch = assertShapesMatch;
function flatten(arr, ret) {
    ret = (ret === undefined ? [] : ret);
    for (var i = 0; i < arr.length; ++i) {
        if (Array.isArray(arr[i])) {
            flatten(arr[i], ret);
        }
        else {
            ret.push(arr[i]);
        }
    }
    return ret;
}
exports.flatten = flatten;
function inferShape(arr) {
    var shape = [];
    while (arr instanceof Array) {
        shape.push(arr.length);
        arr = arr[0];
    }
    return shape;
}
exports.inferShape = inferShape;
function sizeFromShape(shape) {
    if (shape.length === 0) {
        return 1;
    }
    var size = shape[0];
    for (var i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}
exports.sizeFromShape = sizeFromShape;
function isScalarShape(shape) {
    return shape.length === 0;
}
exports.isScalarShape = isScalarShape;
function arraysEqual(n1, n2) {
    if (n1.length !== n2.length) {
        return false;
    }
    for (var i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
            return false;
        }
    }
    return true;
}
exports.arraysEqual = arraysEqual;
function isInt(a) {
    return a % 1 === 0;
}
exports.isInt = isInt;
function tanh(x) {
    if (Math.tanh != null) {
        return Math.tanh(x);
    }
    if (x === Infinity) {
        return 1;
    }
    else if (x === -Infinity) {
        return -1;
    }
    else {
        var e2x = Math.exp(2 * x);
        return (e2x - 1) / (e2x + 1);
    }
}
exports.tanh = tanh;
function sizeToSquarishShape(size) {
    for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {
        if (size % a === 0) {
            return [a, size / a];
        }
    }
    return [1, size];
}
exports.sizeToSquarishShape = sizeToSquarishShape;
function createShuffledIndices(n) {
    var shuffledIndices = new Uint32Array(n);
    for (var i = 0; i < n; ++i) {
        shuffledIndices[i] = i;
    }
    shuffle(shuffledIndices);
    return shuffledIndices;
}
exports.createShuffledIndices = createShuffledIndices;
function assertAndGetBroadcastedShape(shapeA, shapeB) {
    var result = [];
    var nextADimMustBeOne = false;
    var nextBDimMustBeOne = false;
    var errMsg = "Operands could not be broadcast together with shapes " +
        (shapeA + " and " + shapeB + ". Currently, we only support a ") +
        "stricter version of broadcasting than numpy.";
    var l = Math.max(shapeA.length, shapeB.length);
    shapeA = shapeA.slice().reverse();
    shapeB = shapeB.slice().reverse();
    for (var i = 0; i < l; i++) {
        var a = shapeA[i] || 1;
        var b = shapeB[i] || 1;
        if ((b > 1 && nextBDimMustBeOne) || (a > 1 && nextADimMustBeOne)) {
            throw Error(errMsg);
        }
        if (a > 1 && b === 1) {
            nextBDimMustBeOne = true;
        }
        if (b > 1 && a === 1) {
            nextADimMustBeOne = true;
        }
        if (a > 1 && b > 1 && a !== b) {
            throw Error(errMsg);
        }
        result.push(Math.max(a, b));
    }
    return result.reverse();
}
exports.assertAndGetBroadcastedShape = assertAndGetBroadcastedShape;

},{}]},{},[4])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkZW1vcy9kZWVwbGVhcm5qcy50cyIsImRlbW9zL3BlcmZvcm1hbmNlX3Jubi9qcy9FbGVtZW50LmpzIiwiZGVtb3MvcGVyZm9ybWFuY2Vfcm5uL2pzL05vdGUuanMiLCJkZW1vcy9wZXJmb3JtYW5jZV9ybm4vcGVyZm9ybWFuY2Vfcm5uLnRzIiwibm9kZV9tb2R1bGVzL3RvbmUtcGlhbm8vYnVpbGQvUGlhbm8uanMiLCJub2RlX21vZHVsZXMvdG9uZS9idWlsZC9Ub25lLmpzIiwic3JjL2NoZWNrcG9pbnRfbG9hZGVyLnRzIiwic3JjL2RhdGFzZXQudHMiLCJzcmMvZ3JhcGgudHMiLCJzcmMvZ3JhcGhfbGF5ZXJzLnRzIiwic3JjL2dyYXBoX3J1bm5lci50cyIsInNyYy9ncmFwaF91dGlsLnRzIiwic3JjL2luZGV4LnRzIiwic3JjL2luaXRpYWxpemVycy50cyIsInNyYy9pbnB1dF9wcm92aWRlci50cyIsInNyYy9tYXRoL2FjdGl2YXRpb25fZnVuY3Rpb25zLnRzIiwic3JjL21hdGgvY29uY2F0M2RfdXRpbC50cyIsInNyYy9tYXRoL2NvbnZfdXRpbC50cyIsInNyYy9tYXRoL2NvcHkyZF91dGlsLnRzIiwic3JjL21hdGgvY29zdF9mdW5jdGlvbnMudHMiLCJzcmMvbWF0aC9tYXRoLnRzIiwic3JjL21hdGgvbWF0aF9jcHUudHMiLCJzcmMvbWF0aC9tYXRoX2dwdS50cyIsInNyYy9tYXRoL25kYXJyYXkudHMiLCJzcmMvbWF0aC93ZWJnbC9hZGRzY2FsZWRtYXRfZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvYXJnbWF4ZXF1YWxzX2dwdS50cyIsInNyYy9tYXRoL3dlYmdsL2FyZ21pbm1heF9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC9hdmdfcG9vbF9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC9iYXRjaG5vcm1fZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvYmluYXJ5b3BfZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvY29uY2F0M2RfZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvY29udl9iYWNrcHJvcF9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC9jb252X2dwdS50cyIsInNyYy9tYXRoL3dlYmdsL2NvcHlfZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvZ3BncHVfY29udGV4dC50cyIsInNyYy9tYXRoL3dlYmdsL2dwZ3B1X21hdGgudHMiLCJzcmMvbWF0aC93ZWJnbC9ncGdwdV91dGlsLnRzIiwic3JjL21hdGgvd2ViZ2wvbG9nc3VtZXhwX2dwdS50cyIsInNyYy9tYXRoL3dlYmdsL21heF9wb29sX2JhY2twcm9wX2dwdS50cyIsInNyYy9tYXRoL3dlYmdsL21heF9wb29sX2dwdS50cyIsInNyYy9tYXRoL3dlYmdsL21pbl9wb29sX2dwdS50cyIsInNyYy9tYXRoL3dlYmdsL21pbm1heF9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC9tdWxtYXRfZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvcG9vbF9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC9yZWR1Y2VzdW1fZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvcmVuZGVyX25kYXJyYXlfZ3B1X3V0aWwudHMiLCJzcmMvbWF0aC93ZWJnbC9yZXNoYXBlX2dwdS50cyIsInNyYy9tYXRoL3dlYmdsL3Jlc2l6ZV9iaWxpbmVhcl9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC9zaGFkZXJfY29tcGlsZXIudHMiLCJzcmMvbWF0aC93ZWJnbC90ZXhfdXRpbC50cyIsInNyYy9tYXRoL3dlYmdsL3RleHR1cmVfbWFuYWdlci50cyIsInNyYy9tYXRoL3dlYmdsL3VuYXJ5b3BfZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvd2ViZ2xfdXRpbC50cyIsInNyYy9vcGVyYXRpb25fZW1pdHRlci50cyIsInNyYy9vcHMvYWRkLnRzIiwic3JjL29wcy9hcmdtYXgudHMiLCJzcmMvb3BzL2FyZ21heGVxdWFscy50cyIsInNyYy9vcHMvY29uY2F0M2QudHMiLCJzcmMvb3BzL2NvbnZvbHV0aW9uLnRzIiwic3JjL29wcy9kaXZpZGUudHMiLCJzcmMvb3BzL2VsZW1lbnRfd2lzZV9hY3RpdmF0aW9uLnRzIiwic3JjL29wcy9lbGVtZW50X3dpc2VfY29zdC50cyIsInNyYy9vcHMvZXhwLnRzIiwic3JjL29wcy9saW5lYXJfY29tYmluYXRpb24udHMiLCJzcmMvb3BzL2xvZy50cyIsInNyYy9vcHMvbWF0bXVsLnRzIiwic3JjL29wcy9tYXhfcG9vbC50cyIsInNyYy9vcHMvbXVsdGlwbHkudHMiLCJzcmMvb3BzL29wLnRzIiwic3JjL29wcy9yZWR1Y2Vfc3VtLnRzIiwic3JjL29wcy9yZXNoYXBlLnRzIiwic3JjL29wcy9zb2Z0bWF4LnRzIiwic3JjL29wcy9zcGxpdC50cyIsInNyYy9vcHMvc3VidHJhY3QudHMiLCJzcmMvb3B0aW1pemVyLnRzIiwic3JjL3ByaW9yaXR5X3F1ZXVlLnRzIiwic3JjL3Nlc3Npb24udHMiLCJzcmMvc2Vzc2lvbl91dGlsLnRzIiwic3JjL3NnZF9vcHRpbWl6ZXIudHMiLCJzcmMvdGVuc29yX2FycmF5X21hcC50cyIsInNyYy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUNpQkEsa0NBQTZCOzs7OztBQ0M3QiwrQkFBMkI7QUFFM0IsSUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFBO0FBRTlEO0lBRUMseUJBQVksU0FBUyxFQUFFLE1BQVMsRUFBRSxPQUFTO1FBQXBCLHVCQUFBLEVBQUEsV0FBUztRQUFFLHdCQUFBLEVBQUEsV0FBUztRQUMxQyxJQUFJLENBQUMsVUFBVSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUE7UUFDL0MsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLEdBQUcsVUFBVSxDQUFBO1FBQy9CLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFBO1FBRXRDLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFBO1FBRWYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUE7UUFFNUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUE7SUFDakIsQ0FBQztJQUVELGdDQUFNLEdBQU4sVUFBTyxNQUFNLEVBQUUsT0FBTztRQUNyQixJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQTtRQUVmLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQTtRQUU5QixJQUFNLFFBQVEsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUE7UUFDbEMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEdBQUcsT0FBTyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBQyxDQUFDO1lBQ3BELElBQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUE7WUFDdkMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUE7WUFDeEIsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDdkQsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLE9BQU8sR0FBRyxPQUFPLENBQUMsQ0FBQTtZQUM5QyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQTtZQUdoQyxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUMsQ0FBQTtZQUM3RCxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLFVBQVUsR0FBRyxDQUFDLENBQUE7WUFDN0MsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQU0sUUFBUSxHQUFHLEdBQUcsTUFBRyxDQUFBO1lBQ3RDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFNLE1BQU0sR0FBRyxRQUFRLEdBQUcsR0FBRyxNQUFHLENBQUE7WUFDOUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUE7WUFFckIsSUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQTtZQUMxQyxJQUFJLENBQUMsRUFBRSxHQUFHLE1BQU0sQ0FBQTtZQUNoQixHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFBO1lBQ3JCLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFBO1FBQ3BCLENBQUM7SUFDRixDQUFDO0lBRUQsaUNBQU8sR0FBUCxVQUFRLE9BQU87UUFDZCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFBLENBQUM7WUFDdkMsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQTtZQUMvQixHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQTtZQUU3QixJQUFNLElBQUksR0FBRyxJQUFJLFdBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUE7WUFDakQsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUEsQ0FBQztnQkFDMUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUE7WUFDMUIsQ0FBQztZQUNELElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO1FBQ2hDLENBQUM7SUFDRixDQUFDO0lBRUQsK0JBQUssR0FBTCxVQUFNLE9BQU87UUFDWixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFBLENBQUM7WUFDdkMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFBLENBQUM7Z0JBQzNELE9BQU8sQ0FBQyxJQUFJLENBQUMseUJBQXlCLENBQUMsQ0FBQTtZQUN4QyxDQUFDO1lBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ1AsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQTtZQUN2QyxDQUFDO1FBQ0YsQ0FBQztJQUNGLENBQUM7SUFDRixzQkFBQztBQUFELENBL0RBLEFBK0RDLElBQUE7QUFFTywwQ0FBZTs7Ozs7QUNyRXZCO0lBQ0MsY0FBWSxTQUFTLEVBQUUsRUFBRTtRQUN4QixJQUFJLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUE7UUFDNUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFBO1FBQ3ZDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUNwQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQSxDQUFDO1lBQ1AsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFBO1FBQ2pDLENBQUM7UUFDRCxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQTtJQUdwQyxDQUFDO0lBQ0Qsc0JBQU8sR0FBUDtRQUFBLGlCQU1DO1FBTEEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBRXZDLFVBQVUsQ0FBQztZQUNWLEtBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUE7UUFDdEIsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFBO0lBQ1QsQ0FBQztJQUNGLFdBQUM7QUFBRCxDQW5CQSxBQW1CQyxJQUFBO0FBbkJZLG9CQUFJOzs7OztBQ0hqQiw4Q0FDa0M7QUFDbEMsd0NBQTZDO0FBRTdDLElBQU0sS0FBSyxHQUFPLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFFOUMsSUFBSSxXQUFnQixDQUFDO0FBQ3JCLElBQUksU0FBYyxDQUFDO0FBQ25CLElBQUksV0FBZ0IsQ0FBQztBQUNyQixJQUFJLFNBQWMsQ0FBQztBQUNuQixJQUFJLFdBQWdCLENBQUM7QUFDckIsSUFBSSxTQUFjLENBQUM7QUFDbkIsSUFBSSxDQUFNLENBQUM7QUFDWCxJQUFJLENBQU0sQ0FBQztBQUNYLElBQUksb0JBQXlCLENBQUM7QUFDOUIsSUFBSSxxQkFBMEIsQ0FBQztBQUMvQixJQUFNLFVBQVUsR0FBRyxvQkFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUVuQyxJQUFJLFdBQVcsR0FBRyxDQUFDLENBQUM7QUFDcEIsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDO0FBQ3hCLElBQU0sSUFBSSxHQUFHLElBQUksNEJBQWMsRUFBRSxDQUFDO0FBRWxDLElBQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQztBQUN2QixJQUFNLFVBQVUsR0FBRyxHQUFHLENBQUM7QUFDdkIsSUFBSSxVQUFVLEdBQUcsVUFBVSxDQUFDO0FBRzVCLElBQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDdkQsSUFBSSxpQkFBaUIsR0FBRyxJQUFJLHlCQUFlLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUU3RCxJQUFNLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxFQUFDLFVBQVUsRUFBRyxDQUFDLEVBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQ3JELElBQUksTUFBVyxDQUFDO0FBRWhCLEtBQUssQ0FBQyxJQUFJLENBQUMsNkNBQTZDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDOUQsSUFBTSxNQUFNLEdBQUcsSUFBSSw4QkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN6QyxNQUFNLENBQUMsTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDO0FBQ2pDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFDLElBQVM7SUFDakIsUUFBUSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBRTFELFdBQVcsR0FBRyxJQUFJLENBQ2pCLGtEQUFrRCxDQUFZLENBQUM7SUFDaEUsU0FBUyxHQUFHLElBQUksQ0FDZixnREFBZ0QsQ0FBWSxDQUFDO0lBRTlELFdBQVcsR0FBRyxJQUFJLENBQ2pCLGtEQUFrRCxDQUFZLENBQUM7SUFDaEUsU0FBUyxHQUFHLElBQUksQ0FDZixnREFBZ0QsQ0FBWSxDQUFDO0lBRTlELFdBQVcsR0FBRyxJQUFJLENBQ2pCLGtEQUFrRCxDQUFZLENBQUM7SUFDaEUsU0FBUyxHQUFHLElBQUksQ0FDZixnREFBZ0QsQ0FBWSxDQUFDO0lBRTlELG9CQUFvQixHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBWSxDQUFDO0lBQ2pFLHFCQUFxQixHQUFHLElBQUksQ0FBQyx5QkFBeUIsQ0FBWSxDQUFDO0lBQ25FLENBQUMsR0FBRztRQUNILHFCQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDMUMscUJBQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUMxQyxxQkFBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQzFDLENBQUM7SUFDRixDQUFDLEdBQUc7UUFDSCxxQkFBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzFDLHFCQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDMUMscUJBQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztLQUMxQyxDQUFDO0lBRUYsV0FBVyxHQUFHLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUMxQixZQUFZLEVBQUUsQ0FBQztBQUNoQixDQUFDLENBQUMsQ0FBQztBQUVILE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFFMUM7SUFDQyxJQUFNLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDcEIsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDOUQsT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQy9CLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMvQixJQUFJLFFBQVEs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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USxDQUFZLENBQUM7WUFHcEQsSUFBTSxDQUFDLEdBQUcsS0FBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0RSxJQUFNLENBQUMsR0FBRyxLQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDakQsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0QyxJQUFNLENBQUMsR0FBRyxLQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDakQsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0QyxJQUFNLENBQUMsR0FBRyxLQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDakQsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUV0QyxJQUFNLElBQUksR0FBRyxLQUFJLENBQUMsR0FBRyxDQUNqQixLQUFJ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Q0FBQyxDQUFDO1FBQ3BFLElBQU0sRUFBRSxHQUFHLGlCQUFPLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRXZDLElBQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0IsSUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3QixJQUFNLFFBQVEsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVCLElBQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFNUIsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxLQUFLLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztZQUNsQyxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDOUQsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEdBQUcsT0FBTyxHQUFHLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO1lBRXJFLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7Z0JBQ2xDLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDOUQsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEdBQUcsT0FBTyxHQUFHLEVBQUUsQ0FBQyxH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LENBQUMsRUFBRSxDQUFDO1lBQy9CLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxDQUFDO2dCQUMzQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQztvQkFFM0MsSUFBTSxTQUFTLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztvQkFDNUIsSUFBTSxTQUFTLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztvQkFDNUIsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO29CQUNoQixHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO3dCQUNsQyxJQUFNLEdBQUcsR0FBRyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUM7d0JBQzFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksR0FBRyxJQUFJLE1BQU0sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7NEJBQ3hELFFBQVEsQ0FBQzt3QkFDWCxDQUFDO3dCQUNELEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7NEJBQ2xDLElBQU0sR0FBRyxHQUFHLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQzs0QkFDMUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLElBQUksTUFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxD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QyxNQUFNLENBQUMsRUFBQyxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVELHFCQUFHLEdBQUgsVUFBSSxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVMsRUFBRSxDQUFTO1FBQzVDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQ2xCLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRCxxQkFBRyxHQUFILFVBQUksS0FBYSxFQUFFLENBQVMsRUFBRSxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVM7UUFDM0QsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUNYLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUMzRSxDQUFDO0lBRUQscUJBQUcsR0FBSCxVQUFJLEtBQWEsRUFBRSxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVMsRUFBRSxDQUFTO1FBQzNELElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FDWCxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUM7SUFDNUUsQ0FBQztJQUVELDRCQUFVLEdBQVYsVUFBVyxJQUFzQztRQUMvQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2xELElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FB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QUM7UUFDM0IsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM5QixNQUFNLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN0QixDQUFDO1FBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFDRCxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQzFCLENBQUM7QUE5QkQsb0VBOEJDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuLy8gVGhpcyBmaWxlIGlzIGp1c3QgYW4gYWxpYXMgdGhhdCBwb2ludHMgdG8gdGhlIGN1cnJlbnQgZGVlcGxlYXJuanMgdmVyc2lvblxuLy8gYXQgdGhpcyBicmFuY2gsIHNvIGRlbW9zIGNhbiBpbXBvcnQgdGhlIGxpYnJhcnkgYXMgJy4uL2RlZXBsZWFybmpzJy5cbmV4cG9ydCAqIGZyb20gJy4uL3NyYy9pbmRleCc7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8vIGltcG9ydCAnLi4vc3R5bGUva2V5Ym9hcmQuY3NzJ1xuLy8gaW1wb3J0IHtSb2xsfSBmcm9tICcuL1JvbGwnXG5pbXBvcnQge05vdGV9IGZyb20gJy4vTm90ZSdcblxuY29uc3Qgb2Zmc2V0cyA9IFswLCAwLjUsIDEsIDEuNSwgMiwgMywgMy41LCA0LCA0LjUsIDUsIDUuNSwgNl1cblxuY2xhc3MgS2V5Ym9hcmRFbGVtZW50IHtcblxuXHRjb25zdHJ1Y3Rvcihjb250YWluZXIsIGxvd2VzdD0zNiwgb2N0YXZlcz00KXtcblx0XHR0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXHRcdHRoaXMuX2NvbnRhaW5lci5pZCA9ICdrZXlib2FyZCdcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKVxuXG5cdFx0dGhpcy5fa2V5cyA9IHt9XG5cblx0XHR0aGlzLnJlc2l6ZShsb3dlc3QsIG9jdGF2ZXMpXG5cdFx0Ly8gUm9sbC5hcHBlbmRUbyhjb250YWluZXIpXG5cdFx0dGhpcy5fbm90ZXMgPSB7fVxuXHR9XG5cblx0cmVzaXplKGxvd2VzdCwgb2N0YXZlcyl7XG5cdFx0dGhpcy5fa2V5cyA9IHt9XG5cdFx0Ly8gY2xlYXIgdGhlIHByZXZpb3VzIG9uZXNcblx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gJydcblx0XHQvLyBlYWNoIG9mIHRoZSBrZXlzXG5cdFx0Y29uc3Qga2V5V2lkdGggPSAoMSAvIDcpIC8gb2N0YXZlc1xuXHRcdGZvciAobGV0IGkgPSBsb3dlc3Q7IGkgPCBsb3dlc3QgKyBvY3RhdmVzICogMTI7IGkrKyl7XG5cdFx0XHRsZXQga2V5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jylcblx0XHRcdGtleS5jbGFzc0xpc3QuYWRkKCdrZXknKVxuXHRcdFx0bGV0IGlzU2hhcnAgPSAoWzEsIDMsIDYsIDgsIDEwXS5pbmRleE9mKGkgJSAxMikgIT09IC0xKVxuXHRcdFx0a2V5LmNsYXNzTGlzdC5hZGQoaXNTaGFycCA/ICdibGFjaycgOiAnd2hpdGUnKVxuXHRcdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGtleSlcblx0XHRcdC8vIHBvc2l0aW9uIHRoZSBlbGVtZW50XG5cdFx0XHRcblx0XHRcdGxldCBub3RlT2N0YXZlID0gTWF0aC5mbG9vcihpIC8gMTIpIC0gTWF0aC5mbG9vcihsb3dlc3QgLyAxMilcblx0XHRcdGxldCBvZmZzZXQgPSBvZmZzZXRzW2kgJSAxMl0gKyBub3RlT2N0YXZlICogN1xuXHRcdFx0a2V5LnN0eWxlLndpZHRoID0gYCR7a2V5V2lkdGggKiAxMDB9JWBcblx0XHRcdGtleS5zdHlsZS5sZWZ0ID0gYCR7b2Zmc2V0ICoga2V5V2lkdGggKiAxMDB9JWBcblx0XHRcdGtleS5pZCA9IGkudG9TdHJpbmcoKVxuXG5cdFx0XHRjb25zdCBmaWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jylcblx0XHRcdGZpbGwuaWQgPSAnZmlsbCdcblx0XHRcdGtleS5hcHBlbmRDaGlsZChmaWxsKVxuXHRcdFx0dGhpcy5fa2V5c1tpXSA9IGtleVxuXHRcdH1cblx0fVxuXG5cdGtleURvd24obm90ZU51bSl7XG5cdFx0aWYgKHRoaXMuX2tleXMuaGFzT3duUHJvcGVydHkobm90ZU51bSkpe1xuXHRcdFx0Y29uc3Qga2V5ID0gdGhpcy5fa2V5c1tub3RlTnVtXVxuXHRcdFx0a2V5LmNsYXNzTGlzdC5yZW1vdmUoJ2hvdmVyJylcblxuXHRcdFx0Y29uc3Qgbm90ZSA9IG5ldyBOb3RlKGtleS5xdWVyeVNlbGVjdG9yKCcjZmlsbCcpKVxuXHRcdFx0aWYgKCF0aGlzLl9ub3Rlc1tub3RlTnVtXSl7XG5cdFx0XHRcdHRoaXMuX25vdGVzW25vdGVOdW1dID0gW11cblx0XHRcdH1cblx0XHRcdHRoaXMuX25vdGVzW25vdGVOdW1dLnB1c2gobm90ZSlcblx0XHR9XG5cdH1cblxuXHRrZXlVcChub3RlTnVtKXtcblx0XHRpZiAodGhpcy5fa2V5cy5oYXNPd25Qcm9wZXJ0eShub3RlTnVtKSl7XG5cdFx0XHRpZiAoISh0aGlzLl9ub3Rlc1tub3RlTnVtXSAmJiB0aGlzLl9ub3Rlc1tub3RlTnVtXS5sZW5ndGgpKXtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdub3RlIG9mZiBiZWZvcmUgbm90ZSBvbicpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9ub3Rlc1tub3RlTnVtXS5zaGlmdCgpLm5vdGVPZmYoKVxuXHRcdFx0fVxuXHRcdH1cdFxuXHR9XG59XG5cbmV4cG9ydCB7S2V5Ym9hcmRFbGVtZW50fSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtSb2xsTm90ZX0gZnJvbSAnLi9Sb2xsTm90ZSdcblxuZXhwb3J0IGNsYXNzIE5vdGV7XG5cdGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgYWkpe1xuXHRcdHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cdFx0dGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2hpZ2hsaWdodCcpXG5cdFx0dGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXG5cdFx0aWYgKGFpKXtcblx0XHRcdHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdhaScpXG5cdFx0fVxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpXG5cblx0XHQvLyB0aGlzLnJvbGxOb3RlID0gbmV3IFJvbGxOb3RlKGNvbnRhaW5lciwgYWkpXG5cdH1cblx0bm90ZU9mZigpe1xuXHRcdHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKVxuXHRcdC8vIHRoaXMucm9sbE5vdGUubm90ZU9mZigpXG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlKClcblx0XHR9LCAxMDAwKVxuXHR9XG59IiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0FycmF5MUQsIEFycmF5MkQsIENoZWNrcG9pbnRMb2FkZXIsIE5EQXJyYXlNYXRoLCBOREFycmF5TWF0aEdQVSxcbiAgICBTY2FsYXJ9IGZyb20gJy4uL2RlZXBsZWFybmpzJztcbmltcG9ydCB7S2V5Ym9hcmRFbGVtZW50fSBmcm9tICcuL2pzL0VsZW1lbnQnO1xuXG5jb25zdCBQaWFubzphbnkgPSByZXF1aXJlKCd0b25lLXBpYW5vJykuUGlhbm87XG5cbmxldCBsc3RtS2VybmVsMTogYW55O1xubGV0IGxzdG1CaWFzMTogYW55O1xubGV0IGxzdG1LZXJuZWwyOiBhbnk7XG5sZXQgbHN0bUJpYXMyOiBhbnk7XG5sZXQgbHN0bUtlcm5lbDM6IGFueTtcbmxldCBsc3RtQmlhczM6IGFueTtcbmxldCBjOiBhbnk7XG5sZXQgaDogYW55O1xubGV0IGZ1bGx5Q29ubmVjdGVkQmlhc2VzOiBhbnk7XG5sZXQgZnVsbHlDb25uZWN0ZWRXZWlnaHRzOiBhbnk7XG5jb25zdCBmb3JnZXRCaWFzID0gU2NhbGFyLm5ldygxLjApO1xuXG5sZXQgY3VycmVudFRpbWUgPSAwO1xubGV0IGN1cnJlbnRWZWxvY2l0eSA9IDE7XG5jb25zdCBtYXRoID0gbmV3IE5EQXJyYXlNYXRoR1BVKCk7XG5cbmNvbnN0IElOUFVUX1NJWkUgPSAzODg7XG5jb25zdCBQUklNRVJfSURYID0gMzU1OyAvLyBzaGlmdCAxcy5cbmxldCBsYXN0U2FtcGxlID0gUFJJTUVSX0lEWDtcblxuXG5jb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY29udGFpbmVyJyk7XG5sZXQga2V5Ym9hcmRJbnRlcmZhY2UgPSBuZXcgS2V5Ym9hcmRFbGVtZW50KGNvbnRhaW5lciwgMCwgNCk7XG5cbmNvbnN0IHBpYW5vID0gbmV3IFBpYW5vKHt2ZWxvY2l0aWVzIDogNH0pLnRvTWFzdGVyKCk7XG5sZXQgb3V0cHV0OiBhbnk7XG5cbnBpYW5vLmxvYWQoJ2h0dHBzOi8vdGFtYmllbi5naXRodWIuaW8vUGlhbm8vU2FsYW1hbmRlci8nKS50aGVuKCgpID0+IHtcblx0Y29uc3QgcmVhZGVyID0gbmV3IENoZWNrcG9pbnRMb2FkZXIoJy4nKTtcblx0cmV0dXJuIHJlYWRlci5nZXRBbGxWYXJpYWJsZXMoKTtcbn0pLnRoZW4oKHZhcnM6IGFueSkgPT4ge1xuXHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3RhdHVzJykuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG5cblx0bHN0bUtlcm5lbDEgPSB2YXJzW1xuXHRcdCdybm4vbXVsdGlfcm5uX2NlbGwvY2VsbF8wL2Jhc2ljX2xzdG1fY2VsbC9rZXJuZWwnXSBhcyBBcnJheTJEO1xuXHRsc3RtQmlhczEgPSB2YXJzW1xuXHRcdCdybm4vbXVsdGlfcm5uX2NlbGwvY2VsbF8wL2Jhc2ljX2xzdG1fY2VsbC9iaWFzJ10gYXMgQXJyYXkxRDtcblxuXHRsc3RtS2VybmVsMiA9IHZhcnNbXG5cdFx0J3Jubi9tdWx0aV9ybm5fY2VsbC9jZWxsXzEvYmFzaWNfbHN0bV9jZWxsL2tlcm5lbCddIGFzIEFycmF5MkQ7XG5cdGxzdG1CaWFzMiA9IHZhcnNbXG5cdFx0J3Jubi9tdWx0aV9ybm5fY2VsbC9jZWxsXzEvYmFzaWNfbHN0bV9jZWxsL2JpYXMnXSBhcyBBcnJheTFEO1xuXG5cdGxzdG1LZXJuZWwzID0gdmFyc1tcblx0XHQncm5uL211bHRpX3Jubl9jZWxsL2NlbGxfMi9iYXNpY19sc3RtX2NlbGwva2VybmVsJ10gYXMgQXJyYXkyRDtcblx0bHN0bUJpYXMzID0gdmFyc1tcblx0XHQncm5uL211bHRpX3Jubl9jZWxsL2NlbGxfMi9iYXNpY19sc3RtX2NlbGwvYmlhcyddIGFzIEFycmF5MUQ7XG5cblx0ZnVsbHlDb25uZWN0ZWRCaWFzZXMgPSB2YXJzWydmdWxseV9jb25uZWN0ZWQvYmlhc2VzJ10gYXMgQXJyYXkxRDtcblx0ZnVsbHlDb25uZWN0ZWRXZWlnaHRzID0gdmFyc1snZnVsbHlfY29ubmVjdGVkL3dlaWdodHMnXSBhcyBBcnJheTJEO1xuXHRjID0gW1xuXHRcdEFycmF5MkQuemVyb3MoWzEsIGxzdG1CaWFzMS5zaGFwZVswXSAvIDRdKSxcblx0XHRBcnJheTJELnplcm9zKFsxLCBsc3RtQmlhczIuc2hhcGVbMF0gLyA0XSksXG5cdFx0QXJyYXkyRC56ZXJvcyhbMSwgbHN0bUJpYXMzLnNoYXBlWzBdIC8gNF0pLFxuXHRdO1xuXHRoID0gW1xuXHRcdEFycmF5MkQuemVyb3MoWzEsIGxzdG1CaWFzMS5zaGFwZVswXSAvIDRdKSxcblx0XHRBcnJheTJELnplcm9zKFsxLCBsc3RtQmlhczIuc2hhcGVbMF0gLyA0XSksXG5cdFx0QXJyYXkyRC56ZXJvcyhbMSwgbHN0bUJpYXMzLnNoYXBlWzBdIC8gNF0pLFxuXHRdO1xuXHQvL3N0YXJ0IGl0IGF0IHRoZSBhdWRpbyBjb250ZXh0IGN1cnJlbnQgdGltZVxuXHRjdXJyZW50VGltZSA9IHBpYW5vLm5vdygpO1xuXHRnZW5lcmF0ZVN0ZXAoKTtcbn0pO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplKTtcblxuZnVuY3Rpb24gcmVzaXplKCkge1xuXHRjb25zdCBrZXlXaWR0aCA9IDIwO1xuXHRsZXQgb2N0YXZlcyA9IE1hdGgucm91bmQoKHdpbmRvdy5pbm5lcldpZHRoIC8ga2V5V2lkdGgpIC8gMTIpO1xuXHRvY3RhdmVzID0gTWF0aC5tYXgob2N0YXZlcywgMik7XG5cdG9jdGF2ZXMgPSBNYXRoLm1pbihvY3RhdmVzLCA3KTtcblx0bGV0IGJhc2VOb3RlID0gNDg7XG5cdGlmIChvY3RhdmVzID4gNSl7XG5cdFx0YmFzZU5vdGUgLT0gKG9jdGF2ZXMgLSA1KSAqIDEyO1xuXHR9XG5cdGtleWJvYXJkSW50ZXJmYWNlLnJlc2l6ZShiYXNlTm90ZSwgb2N0YXZlcylcbn1cblxucmVzaXplKCk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU3RlcCgpe1xuXG5cdG1hdGguc2NvcGUoKGtlZXAsIHRyYWNrKSA9PiB7XG5cdFx0XG5cdFx0Y29uc3QgbHN0bTEgPSBtYXRoLmJhc2ljTFNUTUNlbGwuYmluZChtYXRoLCBmb3JnZXRCaWFzLCBsc3RtS2VybmVsMSxcblx0XHQgIGxzdG1CaWFzMSk7XG5cdFx0Y29uc3QgbHN0bTIgPSBtYXRoLmJhc2ljTFNUTUNlbGwuYmluZChtYXRoLCBmb3JnZXRCaWFzLCBsc3RtS2VybmVsMixcblx0XHQgIGxzdG1CaWFzMik7XG5cdFx0Y29uc3QgbHN0bTMgPSBtYXRoLmJhc2ljTFNUTUNlbGwuYmluZChtYXRoLCBmb3JnZXRCaWFzLCBsc3RtS2VybmVsMyxcblx0XHQgIGxzdG1CaWFzMyk7XHRcblxuXHRcdGxldCBpbnB1dCA9IHRyYWNrKEFycmF5MkQuemVyb3MoWzEsIElOUFVUX1NJWkVdKSk7XG5cdFx0aW5wdXQuc2V0KDEuMCwgMCwgbGFzdFNhbXBsZSk7XG5cdFx0Ly9nZW5lcmF0ZSBzb21lIG5vdGVzXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cblx0XHRcdG91dHB1dCA9IG1hdGgubXVsdGlSTk5DZWxsKFtsc3RtMSwgbHN0bTIsIGxzdG0zXSwgaW5wdXQsIGMsIGgpO1xuXHRcdFx0b3V0cHV0WzBdLm1hcCgodmFsOkFycmF5MkQpID0+IHtcblx0XHRcdFx0a2VlcCh2YWwpO1xuXHRcdFx0fSk7XG5cdFx0XHRvdXRwdXRbMV0ubWFwKCh2YWw6QXJyYXkyRCkgPT4ge1xuXHRcdFx0XHRrZWVwKHZhbCk7XG5cdFx0XHR9KTtcblx0XHRcdGMgPSBvdXRwdXRbMF07XG5cdFx0XHRoID0gb3V0cHV0WzFdO1xuXG5cdFx0XHRjb25zdCBvdXRwdXRIID0gaFsyXTtcblx0XHRcdGNvbnN0IHdlaWdodGVkUmVzdWx0ID0gbWF0aC5tYXRNdWwob3V0cHV0SCwgZnVsbHlDb25uZWN0ZWRXZWlnaHRzKTtcblx0XHRcdGNvbnN0IGxvZ2l0cyA9IG1hdGguYWRkKHdlaWdodGVkUmVzdWx0LCBmdWxseUNvbm5lY3RlZEJpYXNlcyk7XG5cblx0XHRcdGNvbnN0IHNvZnRtYXggPSBtYXRoLnNvZnRtYXgobG9naXRzLmFzMUQoKSk7XG5cdFx0XHRjb25zdCBzYW1wbGVkT3V0cHV0ID0gc2FtcGxlRnJvbVNvZnRtYXgobWF0aCwgc29mdG1heCk7XG5cblx0XHRcdHBsYXlPdXRwdXQoc2FtcGxlZE91dHB1dCk7XG5cdFx0XHRsYXN0U2FtcGxlID0gc2FtcGxlZE91dHB1dFxuXG5cdFx0XHQvLyB1c2Ugb3V0cHV0IGFzIHRoZSBuZXh0IGlucHV0LlxuXHRcdFx0aW5wdXQgPSB0cmFjayhBcnJheTJELnplcm9zKFsxLCBJTlBVVF9TSVpFXSkpO1xuXHRcdFx0aW5wdXQuc2V0KDEuMCwgMCwgbGFzdFNhbXBsZSk7XG5cdFx0fVxuXHR9KTtcblx0Ly8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3N0YXR1cycpLnRleHRDb250ZW50ID0gYFBsYXlpbmcgJHtjdXJyZW50VGltZX0gJHtwaWFuby5ub3coKX1gXG5cdGNvbnN0IGRlbHRhID0gY3VycmVudFRpbWUgLSBwaWFuby5ub3coKVxuXHRzZXRUaW1lb3V0KCgpID0+IGdlbmVyYXRlU3RlcCgpLCBkZWx0YSAqIDEwMDApXG59XG5cblxuY29uc3QgTUlOX01JRElfUElUQ0ggPSAwO1xuY29uc3QgTUFYX01JRElfUElUQ0ggPSAxMjc7XG5jb25zdCBWRUxPQ0lUWV9CSU5TID0gMzI7XG5jb25zdCBNQVhfU0hJRlRfU1RFUFMgPSAxMDA7XG5jb25zdCBTVEVQU19QRVJfU0VDT05EID0gMTAwO1xuXG5jb25zdCBFVkVOVF9SQU5HRVMgPSBbXG4gICAgWydub3RlX29uJywgTUlOX01JRElfUElUQ0gsIE1BWF9NSURJX1BJVENIXSxcbiAgICBbJ25vdGVfb2ZmJywgTUlOX01JRElfUElUQ0gsIE1BWF9NSURJX1BJVENIXSxcbiAgICBbJ3RpbWVfc2hpZnQnLCAxLCBNQVhfU0hJRlRfU1RFUFNdLFxuICAgIFsndmVsb2NpdHlfY2hhbmdlJywgMSwgVkVMT0NJVFlfQklOU10sXG5dO1xuXG5mdW5jdGlvbiBwbGF5T3V0cHV0KGluZGV4OiBudW1iZXIpIHtcblx0bGV0IG9mZnNldCA9IDA7XG5cdGZvcihjb25zdCBldmVudFJhbmdlIG9mIEVWRU5UX1JBTkdFUykge1xuXHRcdGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50UmFuZ2VbMF0gYXMgc3RyaW5nO1xuXHRcdGNvbnN0IG1pblZhbHVlID0gZXZlbnRSYW5nZVsxXSBhcyBudW1iZXI7XG5cdFx0Y29uc3QgbWF4VmFsdWUgPSBldmVudFJhbmdlWzJdIGFzIG51bWJlcjtcblx0XHRpZiAob2Zmc2V0IDw9IGluZGV4ICYmIGluZGV4IDw9IG9mZnNldCArIG1heFZhbHVlIC0gbWluVmFsdWUpIHtcblx0XHRcdGlmIChldmVudFR5cGUgPT09ICdub3RlX29uJykge1xuXHRcdFx0XHRjb25zdCBub3RlTnVtID0gaW5kZXggLSBvZmZzZXQ7XG5cdFx0XHRcdC8vIGtleWJvYXJkSW50ZXJmYWNlLmtleURvd24obm90ZU51bSk7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IFxuXHRcdFx0XHRcdGtleWJvYXJkSW50ZXJmYWNlLmtleURvd24obm90ZU51bSk7IFxuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRrZXlib2FyZEludGVyZmFjZS5rZXlVcChub3RlTnVtKTtcblx0XHRcdFx0XHR9LCAxMDApO1xuXHRcdFx0XHR9LCAoY3VycmVudFRpbWUgLSBwaWFuby5ub3coKSkqMTAwMCk7XG5cdFx0XHRcdHJldHVybiBwaWFuby5rZXlEb3duKG5vdGVOdW0sIGN1cnJlbnRUaW1lLCBjdXJyZW50VmVsb2NpdHkpXG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gJ25vdGVfb2ZmJykge1xuXHRcdFx0XHRjb25zdCBub3RlTnVtID0gaW5kZXggLSBvZmZzZXQ7XG5cdFx0XHRcdC8vIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGtleWJvYXJkSW50ZXJmYWNlLmtleVVwKG5vdGVOdW0pOyB9LCAoY3VycmVudFRpbWUgLSBwaWFuby5ub3coKSkqMTAwMCk7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdOb3RlOiAnICsgaW5kZXggKyAnIG9mZjogJyArIChjdXJyZW50VGltZSAtIHBpYW5vLm5vdygpKSk7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCd1cCcgKyBub3RlTnVtICk7XG5cdFx0XHRcdHJldHVybiBcdHBpYW5vLmtleVVwKG5vdGVOdW0sIGN1cnJlbnRUaW1lKVxuXHRcdFx0fSBlbHNlIGlmIChldmVudFR5cGUgPT09ICd0aW1lX3NoaWZ0Jykge1xuXHRcdFx0XHRjdXJyZW50VGltZSArPSAoaW5kZXggLSBvZmZzZXQgKyAxKSAvIFNURVBTX1BFUl9TRUNPTkRcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRUaW1lXG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gJ3ZlbG9jaXR5X2NoYW5nZScpIHtcblx0XHRcdFx0Y3VycmVudFZlbG9jaXR5ID0gKGluZGV4IC0gb2Zmc2V0ICsgMSkgKiBNYXRoLmNlaWwoMTI3IC8gVkVMT0NJVFlfQklOUylcblx0XHRcdFx0Y3VycmVudFZlbG9jaXR5ID0gY3VycmVudFZlbG9jaXR5LzEyN1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudFZlbG9jaXR5XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgZXZlbnRUeXBlOiAnICsgZXZlbnRUeXBlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0b2Zmc2V0ICs9IG1heFZhbHVlIC0gbWluVmFsdWUgKyAxO1xuXHR9XG5cdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRlY29kZSBpbmRleDogJyArIGluZGV4KTtcbn1cblxuXG4vKipcbiogU2FtcGxlIGZyb20gYSBzb2Z0bWF4LlxuKi9cbmZ1bmN0aW9uIHNhbXBsZUZyb21Tb2Z0bWF4KG1hdGg6IE5EQXJyYXlNYXRoLCBzb2Z0bWF4OiBBcnJheTFEKTogbnVtYmVyIHtcblx0Y29uc3Qgc29mdG1heFZhbHVlcyA9IHNvZnRtYXguZ2V0VmFsdWVzKCk7XG5cdGNvbnN0IHJhbmQgPSBTY2FsYXIucmFuZFVuaWZvcm0oW10sIDAsIDEpLmdldCgpO1xuXHRsZXQgY2RmID0gMDtcblx0Zm9yKGxldCBpID0gMDsgaSA8IHNvZnRtYXhWYWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRjZGYgKz0gc29mdG1heFZhbHVlc1tpXTtcblx0XHRpZiAoY2RmID4gcmFuZCkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHNhbXBsZSBmcm9tIHNvZnRtYXguJyk7XG59XG4iLCIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KHJlcXVpcmUoXCJ0b25lXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcInRvbmVcIl0sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5QaWFubz10KHJlcXVpcmUoXCJ0b25lXCIpKTplLlBpYW5vPXQoZS50b25lKX0odGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChvKXtpZihuW29dKXJldHVybiBuW29dLmV4cG9ydHM7dmFyIHI9bltvXT17aTpvLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbb10uY2FsbChyLmV4cG9ydHMscixyLmV4cG9ydHMsdCksci5sPSEwLHIuZXhwb3J0c312YXIgbj17fTtyZXR1cm4gdC5tPWUsdC5jPW4sdC5pPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LmQ9ZnVuY3Rpb24oZSxuLG8pe3QubyhlLG4pfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6b30pfSx0Lm49ZnVuY3Rpb24oZSl7dmFyIG49ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIHQuZChuLFwiYVwiLG4pLG59LHQubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sdC5wPVwiXCIsdCh0LnM9OCl9KFtmdW5jdGlvbih0LG4pe3QuZXhwb3J0cz1lfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bigyKTt0LmRlZmF1bHQ9e2dldFJlbGVhc2VzVXJsOmZ1bmN0aW9uKGUpe3JldHVyblwicmVsXCIrKGUtMjApK1wiLm1wMz9cIisoMTAwKk1hdGgucmFuZG9tKCkpLnRvRml4ZWQoMCl9LGdldEhhcm1vbmljc1VybDpmdW5jdGlvbihlKXtyZXR1cm5cImhhcm1MXCIrKDAsby5taWRpVG9Ob3RlKShlKS5yZXBsYWNlKFwiI1wiLFwic1wiKStcIi5tcDM/XCIrKDEwMCpNYXRoLnJhbmRvbSgpKS50b0ZpeGVkKDApfSxnZXROb3Rlc1VybDpmdW5jdGlvbihlLHQpe3JldHVybigwLG8ubWlkaVRvTm90ZSkoZSkucmVwbGFjZShcIiNcIixcInNcIikrXCJ2XCIrdCtcIi5tcDM/XCIrKDEwMCpNYXRoLnJhbmRvbSgpKS50b0ZpeGVkKDApfX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybigwLHMuRnJlcXVlbmN5KShlKS50b01pZGkoKX1mdW5jdGlvbiByKGUpe3JldHVybigwLHMuRnJlcXVlbmN5KShlLFwibWlkaVwiKS50b05vdGUoKX1mdW5jdGlvbiBpKGUpe3ZhciB0PWUlMztyZXR1cm4gMT09PXQ/W2UtMSxjLmRlZmF1bHQuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKDEpXToyPT09dD9bZSsxLGMuZGVmYXVsdC5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8oLTEpXTpbZSwxXX1mdW5jdGlvbiB1KGUpe3JldHVybiBuZXcgcy5CdWZmZXJTb3VyY2UoZSl9ZnVuY3Rpb24gYShlLHQpe3JldHVybiBNYXRoLnJhbmRvbSgpKih0LWUpK2V9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5yYW5kb21CZXR3ZWVuPXQubWlkaVRvRnJlcXVlbmN5UmF0aW89dC5jcmVhdGVTb3VyY2U9dC5ub3RlVG9NaWRpPXQubWlkaVRvTm90ZT12b2lkIDA7dmFyIHM9bigwKSxjPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX0ocyk7dC5taWRpVG9Ob3RlPXIsdC5ub3RlVG9NaWRpPW8sdC5jcmVhdGVTb3VyY2U9dSx0Lm1pZGlUb0ZyZXF1ZW5jeVJhdGlvPWksdC5yYW5kb21CZXR3ZWVuPWF9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiByKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gaShlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCksYT1uKDApLHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fShhKSxjPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MDtvKHRoaXMsdCk7dmFyIG49cih0aGlzLCh0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsKHRoaXMpKTtyZXR1cm4gbi5jcmVhdGVJbnNPdXRzKDAsMSksbi52b2x1bWU9ZSxufXJldHVybiBpKHQsZSksdSh0LFt7a2V5Olwidm9sdW1lXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuZGVmYXVsdC5nYWluVG9EYih0aGlzLm91dHB1dC5nYWluLnZhbHVlKX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMub3V0cHV0LmdhaW4udmFsdWU9cy5kZWZhdWx0LmRiVG9HYWluKGUpfX1dKSx0fShhLkF1ZGlvTm9kZSk7dC5kZWZhdWx0PWN9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiByKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gdShlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCkscz1uKDEpLGM9byhzKSxsPW4oMyksZj1vKGwpLHA9bigyKSxoPW4oMCksZD1bMjEsMjQsMjcsMzAsMzMsMzYsMzksNDIsNDUsNDgsNTEsNTQsNTcsNjAsNjMsNjYsNjksNzIsNzUsNzgsODEsODQsODddLF89ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpbMjEsMTA4XTtyKHRoaXMsdCk7dmFyIG49aSh0aGlzLCh0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsKHRoaXMpKSxvPWQuZmluZEluZGV4KGZ1bmN0aW9uKHQpe3JldHVybiB0Pj1lWzBdfSksdT1kLmZpbmRJbmRleChmdW5jdGlvbih0KXtyZXR1cm4gdD49ZVsxXX0pO3U9LTE9PT11P3U9ZC5sZW5ndGg6dTt2YXIgYT1kLnNsaWNlKG8sdSk7bi5fc2FtcGxlcz17fTt2YXIgcz0hMCxsPSExLGY9dm9pZCAwO3RyeXtmb3IodmFyIHAsaD1hW1N5bWJvbC5pdGVyYXRvcl0oKTshKHM9KHA9aC5uZXh0KCkpLmRvbmUpO3M9ITApe3ZhciBfPXAudmFsdWU7bi5fc2FtcGxlc1tfXT1jLmRlZmF1bHQuZ2V0SGFybW9uaWNzVXJsKF8pfX1jYXRjaChlKXtsPSEwLGY9ZX1maW5hbGx5e3RyeXshcyYmaC5yZXR1cm4mJmgucmV0dXJuKCl9ZmluYWxseXtpZihsKXRocm93IGZ9fXJldHVybiBufXJldHVybiB1KHQsZSksYSh0LFt7a2V5Olwic3RhcnRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dGhpcy5fc2FtcGxlci50cmlnZ2VyQXR0YWNrKCgwLHAubWlkaVRvTm90ZSkoZSksdCxuKigwLHAucmFuZG9tQmV0d2VlbikoLjUsMSkpfX0se2tleTpcImxvYWRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihuLG8pe3QuX3NhbXBsZXI9bmV3IGguU2FtcGxlcih0Ll9zYW1wbGVzLG4sZSkuY29ubmVjdCh0Lm91dHB1dCksdC5fc2FtcGxlci5yZWxlYXNlPTF9KX19XSksdH0oZi5kZWZhdWx0KTt0LmRlZmF1bHQ9X30sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIHIoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkoZSx0KXtpZighZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2U6dH1mdW5jdGlvbiB1KGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHQpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsdCk6ZS5fX3Byb3RvX189dCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Ob3Rlcz12b2lkIDA7dmFyIGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dmFyIG49W10sbz0hMCxyPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIHUsYT1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKG89KHU9YS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKHUudmFsdWUpLCF0fHxuLmxlbmd0aCE9PXQpO289ITApO31jYXRjaChlKXtyPSEwLGk9ZX1maW5hbGx5e3RyeXshbyYmYS5yZXR1cm4mJmEucmV0dXJuKCl9ZmluYWxseXtpZihyKXRocm93IGl9fXJldHVybiBufXJldHVybiBmdW5jdGlvbih0LG4pe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHQ7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KSlyZXR1cm4gZSh0LG4pO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfX0oKSxzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCksYz1uKDApLGw9KG8oYyksbigxKSksZj1vKGwpLHA9bigzKSxoPW8ocCksZD1uKDIpLF89ezE6WzhdLDI6WzYsMTJdLDM6WzEsOCwxNV0sNDpbMSw1LDEwLDE1XSw1OlsxLDQsOCwxMiwxNl0sNjpbMSwzLDcsMTAsMTMsMTZdLDc6WzEsMyw2LDksMTEsMTMsMTZdLDg6WzEsMyw1LDcsOSwxMSwxMywxNV0sOTpbMSwzLDUsNyw5LDExLDEzLDE1LDE2XSwxMDpbMSwyLDMsNSw3LDksMTEsMTMsMTUsMTZdLDExOlsxLDIsMyw1LDcsOSwxMSwxMywxNCwxNSwxNl0sMTI6WzEsMiwzLDQsNSw3LDksMTEsMTMsMTQsMTUsMTZdLDEzOlsxLDIsMyw0LDUsNyw5LDExLDEyLDEzLDE0LDE1LDE2XSwxNDpbMSwyLDMsNCw1LDYsNyw5LDExLDEyLDEzLDE0LDE1LDE2XSwxNTpbMSwyLDMsNCw1LDYsNyw5LDEwLDExLDEyLDEzLDE0LDE1LDE2XSwxNjpbMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTZdfSx5PVsyMSwyNCwyNywzMCwzMywzNiwzOSw0Miw0NSw0OCw1MSw1NCw1Nyw2MCw2Myw2Niw2OSw3Miw3NSw3OCw4MSw4NCw4Nyw5MCw5Myw5Niw5OSwxMDIsMTA1LDEwOF07dC5Ob3Rlcz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOlsyMSwxMDhdLG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjE7cih0aGlzLHQpO3ZhciBvPWkodGhpcywodC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbCh0aGlzKSksdT15LmZpbmRJbmRleChmdW5jdGlvbih0KXtyZXR1cm4gdD49ZVswXX0pLGE9eS5maW5kSW5kZXgoZnVuY3Rpb24odCl7cmV0dXJuIHQ+PWVbMV19KTthPS0xPT09YT9hPXkubGVuZ3RoOmErMTt2YXIgcz15LnNsaWNlKHUsYSk7cmV0dXJuIG8uX3NhbXBsZXJzPV9bbl0uc2xpY2UoKSxvLl9hY3RpdmVOb3Rlcz1uZXcgTWFwLG8uX3NhbXBsZXJzLmZvckVhY2goZnVuY3Rpb24oZSx0KXtvLl9zYW1wbGVyc1t0XT17fSxzLmZvckVhY2goZnVuY3Rpb24obil7by5fc2FtcGxlcnNbdF1bbl09Zi5kZWZhdWx0LmdldE5vdGVzVXJsKG4sZSl9KX0pLG99cmV0dXJuIHUodCxlKSxzKHQsW3trZXk6XCJfaGFzTm90ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX3NhbXBsZXJzLmhhc093blByb3BlcnR5KHQpJiZ0aGlzLl9zYW1wbGVyc1t0XS5oYXMoZSl9fSx7a2V5OlwiX2dldE5vdGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9zYW1wbGVyc1t0XS5nZXQoZSl9fSx7a2V5Olwic3RvcFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt0aGlzLl9hY3RpdmVOb3Rlcy5oYXMoZSkmJih0aGlzLl9hY3RpdmVOb3Rlcy5nZXQoZSkuZm9yRWFjaChmdW5jdGlvbihlKXtlLnN0b3AodCsuMjUsLjI1KX0pLHRoaXMuX2FjdGl2ZU5vdGVzLmRlbGV0ZShlKSl9fSx7a2V5Olwic3RhcnRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIG89bioodGhpcy5fc2FtcGxlcnMubGVuZ3RoLTEpLHI9TWF0aC5yb3VuZChvKSxpPXItbyx1PTEtLjUqaSxzPSgwLGQubWlkaVRvRnJlcXVlbmN5UmF0aW8pKGUpLGM9YShzLDIpLGw9Y1swXSxmPWNbMV07aWYodGhpcy5faGFzTm90ZShsLHIpKXt2YXIgcD0oMCxkLmNyZWF0ZVNvdXJjZSkodGhpcy5fZ2V0Tm90ZShsLHIpKTtwLnBsYXliYWNrUmF0ZS52YWx1ZT1mLHAuY29ubmVjdCh0aGlzLm91dHB1dCkscC5zdGFydCh0LDAsdm9pZCAwLHUsMCksdGhpcy5fYWN0aXZlTm90ZXMuaGFzKGUpfHx0aGlzLl9hY3RpdmVOb3Rlcy5zZXQoZSxbXSksdGhpcy5fYWN0aXZlTm90ZXMuZ2V0KGUpLnB1c2gocCl9fX0se2tleTpcImxvYWRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLG49W107cmV0dXJuIHRoaXMuX3NhbXBsZXJzLmZvckVhY2goZnVuY3Rpb24obyxyKXt2YXIgaT1uZXcgUHJvbWlzZShmdW5jdGlvbihuKXt0Ll9zYW1wbGVyc1tyXT1uZXcgYy5CdWZmZXJzKG8sbixlKX0pO24ucHVzaChpKX0pLFByb21pc2UuYWxsKG4pfX1dKSx0fShoLmRlZmF1bHQpfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gcihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaShlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIHUoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtvLmVudW1lcmFibGU9by5lbnVtZXJhYmxlfHwhMSxvLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBvJiYoby53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsby5rZXksbyl9fXJldHVybiBmdW5jdGlvbih0LG4sbyl7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksbyYmZSh0LG8pLHR9fSgpLHM9bigzKSxjPW8ocyksbD1uKDEpLGY9KG8obCksbigyKSkscD1uKDApLGg9KG8ocCksZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3IodGhpcyx0KTt2YXIgZT1pKHRoaXMsKHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwodGhpcykpO3JldHVybiBlLl9kb3duVGltZT0xLzAsZS5fY3VycmVudFNvdW5kPW51bGwsZS5fYnVmZmVycz1udWxsLGV9cmV0dXJuIHUodCxlKSxhKHQsW3trZXk6XCJsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obil7dC5fYnVmZmVycz1uZXcgcC5CdWZmZXJzKHt1cDpcInBlZGFsVTEubXAzXCIsZG93bjpcInBlZGFsRDEubXAzXCJ9LG4sZSl9KX19LHtrZXk6XCJfc3F1YXNoXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fY3VycmVudFNvdW5kJiZ0aGlzLl9jdXJyZW50U291bmQuc3RvcChlLC4xKSx0aGlzLl9jdXJyZW50U291bmQ9bnVsbH19LHtrZXk6XCJfcGxheVNhbXBsZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5fY3VycmVudFNvdW5kPSgwLGYuY3JlYXRlU291cmNlKSh0aGlzLl9idWZmZXJzLmdldCh0KSksdGhpcy5fY3VycmVudFNvdW5kLmNvbm5lY3QodGhpcy5vdXRwdXQpLnN0YXJ0KGUsKDAsZi5yYW5kb21CZXR3ZWVuKSgwLC4xKSx2b2lkIDAsLjIqKDAsZi5yYW5kb21CZXR3ZWVuKSguNSwxKSwuMDUpfX0se2tleTpcImRvd25cIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLl9zcXVhc2goZSksdGhpcy5fZG93blRpbWU9ZSx0aGlzLl9wbGF5U2FtcGxlKGUsXCJkb3duXCIpfX0se2tleTpcInVwXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fc3F1YXNoKGUpLHRoaXMuX2Rvd25UaW1lPTEvMCx0aGlzLl9wbGF5U2FtcGxlKGUsXCJ1cFwiKX19LHtrZXk6XCJpc0Rvd25cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZT50aGlzLl9kb3duVGltZX19XSksdH0oYy5kZWZhdWx0KSk7dC5kZWZhdWx0PWh9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiByKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gdShlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgbz10W25dO28uZW51bWVyYWJsZT1vLmVudW1lcmFibGV8fCExLG8uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixvKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxvJiZlKHQsbyksdH19KCkscz1uKDEpLGM9byhzKSxsPW4oMyksZj1vKGwpLHA9bigyKSxoPW4oMCksZD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUpe3IodGhpcyx0KTt2YXIgbj1pKHRoaXMsKHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwodGhpcykpO24uX2J1ZmZlcnM9e307Zm9yKHZhciBvPWVbMF07bzw9ZVsxXTtvKyspbi5fYnVmZmVyc1tvXT1jLmRlZmF1bHQuZ2V0UmVsZWFzZXNVcmwobyk7cmV0dXJuIG59cmV0dXJuIHUodCxlKSxhKHQsW3trZXk6XCJsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obil7dC5fYnVmZmVycz1uZXcgaC5CdWZmZXJzKHQuX2J1ZmZlcnMsbixlKX0pfX0se2tleTpcInN0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe2lmKHRoaXMuX2J1ZmZlcnMuaGFzKGUpKXt2YXIgbz0oMCxwLmNyZWF0ZVNvdXJjZSkodGhpcy5fYnVmZmVycy5nZXQoZSkpLmNvbm5lY3QodGhpcy5vdXRwdXQpO24qPSgwLHAucmFuZG9tQmV0d2VlbikoLjUsMSksby5zdGFydCh0LDAsdm9pZCAwLC4wMSpuLDApfX19XSksdH0oZi5kZWZhdWx0KTt0LmRlZmF1bHQ9ZH0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIHIoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkoZSx0KXtpZighZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2U6dH1mdW5jdGlvbiB1KGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHQpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsdCk6ZS5fX3Byb3RvX189dCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5QaWFubz12b2lkIDA7dmFyIGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBvPXRbbl07by5lbnVtZXJhYmxlPW8uZW51bWVyYWJsZXx8ITEsby5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbyYmKG8ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG8ua2V5LG8pfX1yZXR1cm4gZnVuY3Rpb24odCxuLG8pe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLG8mJmUodCxvKSx0fX0oKSxzPW4oMCksYz1vKHMpLGw9big2KSxmPW8obCkscD1uKDUpLGg9big0KSxkPW8oaCksXz1uKDcpLHk9byhfKSx2PW4oMSk7byh2KSx0LlBpYW5vPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyKHRoaXMsdCk7dmFyIGU9Yy5kZWZhdWx0LmRlZmF1bHRzKGFyZ3VtZW50cyxbXCJyYW5nZVwiLFwidmVsb2NpdGllc1wiXSx7dmVsb2NpdGllczoxLHJhbmdlOlsyMSwxMDhdLHJlbGVhc2U6ITB9KSxuPWkodGhpcywodC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbCh0aGlzKSk7cmV0dXJuIG4uY3JlYXRlSW5zT3V0cygwLDEpLG4uX2xvYWRlZD0hMSxuLl9oZWxkTm90ZXM9bmV3IE1hcCxuLl9zdXN0YWluZWROb3Rlcz1uZXcgTWFwLG4uX25vdGVzPW5ldyBwLk5vdGVzKGUucmFuZ2UsZS52ZWxvY2l0aWVzKS5jb25uZWN0KG4ub3V0cHV0KSxuLl9wZWRhbD0obmV3IGYuZGVmYXVsdCkuY29ubmVjdChuLm91dHB1dCksZS5yZWxlYXNlJiYobi5faGFybW9uaWNzPW5ldyBkLmRlZmF1bHQoZS5yYW5nZSkuY29ubmVjdChuLm91dHB1dCksbi5fcmVsZWFzZT1uZXcgeS5kZWZhdWx0KGUucmFuZ2UpLmNvbm5lY3Qobi5vdXRwdXQpKSxufXJldHVybiB1KHQsZSksYSh0LFt7a2V5OlwibG9hZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbj1bdGhpcy5fbm90ZXMubG9hZChlKSx0aGlzLl9wZWRhbC5sb2FkKGUpXTtyZXR1cm4gdGhpcy5faGFybW9uaWNzJiZuLnB1c2godGhpcy5faGFybW9uaWNzLmxvYWQoZSkpLHRoaXMuX3JlbGVhc2UmJm4ucHVzaCh0aGlzLl9yZWxlYXNlLmxvYWQoZSkpLFByb21pc2UuYWxsKG4pLnRoZW4oZnVuY3Rpb24oKXt0Ll9sb2FkZWQ9ITB9KX19LHtrZXk6XCJwZWRhbERvd25cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sb2FkZWQmJihlPXRoaXMudG9TZWNvbmRzKGUpLHRoaXMuX3BlZGFsLmlzRG93bihlKXx8dGhpcy5fcGVkYWwuZG93bihlKSksdGhpc319LHtrZXk6XCJwZWRhbFVwXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGhpcy5sb2FkZWQmJihlPXRoaXMudG9TZWNvbmRzKGUpLHRoaXMuX3BlZGFsLmlzRG93bihlKSYmKHRoaXMuX3BlZGFsLnVwKGUpLHRoaXMuX3N1c3RhaW5lZE5vdGVzLmZvckVhY2goZnVuY3Rpb24obixvKXt0Ll9oZWxkTm90ZXMuaGFzKG8pfHx0Ll9ub3Rlcy5zdG9wKG8sZSl9KSx0aGlzLl9zdXN0YWluZWROb3Rlcy5jbGVhcigpKSksdGhpc319LHtrZXk6XCJrZXlEb3duXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOmMuZGVmYXVsdC5ub3coKSxuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTouODtyZXR1cm4gdGhpcy5sb2FkZWQmJih0PXRoaXMudG9TZWNvbmRzKHQpLGMuZGVmYXVsdC5pc1N0cmluZyhlKSYmKGU9TWF0aC5yb3VuZCgoMCxzLkZyZXF1ZW5jeSkoZSkudG9NaWRpKCkpKSx0aGlzLl9oZWxkTm90ZXMuaGFzKGUpfHwodGhpcy5faGVsZE5vdGVzLnNldChlLHt0aW1lOnQsdmVsb2NpdHk6bn0pLHRoaXMuX25vdGVzLnN0YXJ0KGUsdCxuKSkpLHRoaXN9fSx7a2V5Olwia2V5VXBcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06Yy5kZWZhdWx0Lm5vdygpLG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOi44O2lmKHRoaXMubG9hZGVkJiYodD10aGlzLnRvU2Vjb25kcyh0KSxjLmRlZmF1bHQuaXNTdHJpbmcoZSkmJihlPU1hdGgucm91bmQoKDAscy5GcmVxdWVuY3kpKGUpLnRvTWlkaSgpKSksdGhpcy5faGVsZE5vdGVzLmhhcyhlKSkpe3ZhciBvPXRoaXMuX2hlbGROb3Rlcy5nZXQoZSk7dGhpcy5faGVsZE5vdGVzLmRlbGV0ZShlKSx0aGlzLl9yZWxlYXNlJiZ0aGlzLl9yZWxlYXNlLnN0YXJ0KGUsdCxuKTt2YXIgcj10LW8udGltZSxpPW8udmVsb2NpdHksdT0uNS9NYXRoLm1heChyLC4xKStpK247dT1NYXRoLnBvdyhNYXRoLmxvZyhNYXRoLm1heCh1LDEpKSwyKS8yLHRoaXMuX3BlZGFsLmlzRG93bih0KT90aGlzLl9zdXN0YWluZWROb3Rlcy5oYXMoZSl8fHRoaXMuX3N1c3RhaW5lZE5vdGVzLnNldChlLHQpOih0aGlzLl9ub3Rlcy5zdG9wKGUsdCxuKSx0aGlzLl9oYXJtb25pY3MmJnRoaXMuX2hhcm1vbmljcy5zdGFydChlLHQsdSkpfXJldHVybiB0aGlzfX0se2tleTpcInNldFZvbHVtZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7c3dpdGNoKGUpe2Nhc2VcIm5vdGVcIjp0aGlzLl9ub3Rlcy52b2x1bWU9dDticmVhaztjYXNlXCJwZWRhbFwiOnRoaXMuX3BlZGFsLnZvbHVtZT10O2JyZWFrO2Nhc2VcInJlbGVhc2VcIjp0aGlzLl9yZWxlYXNlJiYodGhpcy5fcmVsZWFzZS52b2x1bWU9dCk7YnJlYWs7Y2FzZVwiaGFybW9uaWNzXCI6dGhpcy5faGFybW9uaWNzJiYodGhpcy5faGFybW9uaWNzLnZvbHVtZT10KX1yZXR1cm4gdGhpc319LHtrZXk6XCJsb2FkZWRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbG9hZGVkfX1dKSx0fShzLkF1ZGlvTm9kZSl9XSl9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBpYW5vLmpzLm1hcCIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KXtcblxuXHQvL1VNRFxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmYWN0b3J5KCk7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuIFx0fSBlbHNlIHtcblx0XHRyb290LlRvbmUgPSBmYWN0b3J5KCk7XG5cdH1cblxufSh0aGlzLCBmdW5jdGlvbigpe1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblx0dmFyIFRvbmU7XG5cdC8vY29uc3RydWN0cyB0aGUgbWFpbiBUb25lIG9iamVjdFxuXHRmdW5jdGlvbiBNYWluKGZ1bmMpe1xuXHRcdFRvbmUgPSBmdW5jKCk7XG5cdH1cblx0Ly9pbnZva2VzIGVhY2ggb2YgdGhlIG1vZHVsZXMgd2l0aCB0aGUgbWFpbiBUb25lIG9iamVjdCBhcyB0aGUgYXJndW1lbnRcblx0ZnVuY3Rpb24gTW9kdWxlKGZ1bmMpe1xuXHRcdGZ1bmMoVG9uZSk7XG5cdH1cdC8qKlxuXHQgKiAgVG9uZS5qc1xuXHQgKiAgQGF1dGhvciBZb3RhbSBNYW5uXG5cdCAqICBAbGljZW5zZSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUIE1JVCBMaWNlbnNlXG5cdCAqICBAY29weXJpZ2h0IDIwMTQtMjAxNyBZb3RhbSBNYW5uXG5cdCAqL1xuXHRNYWluKGZ1bmN0aW9uICgpIHtcblx0ICAgIFxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0VE9ORVxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lIGlzIHRoZSBiYXNlIGNsYXNzIG9mIGFsbCBvdGhlciBjbGFzc2VzLlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0ICAgIHZhciBUb25lID0gZnVuY3Rpb24gKCkge1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZSNcblx0XHQgKiAgQHJldHVybnMge3N0cmluZ30gcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY2xhc3MgYXMgYSBzdHJpbmdcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGNsYXNzTmFtZSBpbiBUb25lKSB7XG5cdCAgICAgICAgICAgIHZhciBpc0xldHRlciA9IGNsYXNzTmFtZVswXS5tYXRjaCgvXltBLVpdJC8pO1xuXHQgICAgICAgICAgICB2YXIgc2FtZUNvbnN0cnVjdG9yID0gVG9uZVtjbGFzc05hbWVdID09PSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgICAgICBpZiAoVG9uZS5pc0Z1bmN0aW9uKFRvbmVbY2xhc3NOYW1lXSkgJiYgaXNMZXR0ZXIgJiYgc2FtZUNvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAnVG9uZSc7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lI1xuXHRcdCAqICBkaXNjb25uZWN0IGFuZCBkaXNwb3NlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEdFVC9TRVRcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCB0aGUgcGFyYW1ldGVycyBhdCBvbmNlLiBFaXRoZXIgcGFzcyBpbiBhblxuXHRcdCAqICBvYmplY3QgbWFwcGluZyBwYXJhbWV0ZXJzIHRvIHZhbHVlcywgb3IgdG8gc2V0IGFcblx0XHQgKiAgc2luZ2xlIHBhcmFtZXRlciwgYnkgcGFzc2luZyBpbiBhIHN0cmluZyBhbmQgdmFsdWUuXG5cdFx0ICogIFRoZSBsYXN0IGFyZ3VtZW50IGlzIGFuIG9wdGlvbmFsIHJhbXAgdGltZSB3aGljaFxuXHRcdCAqICB3aWxsIHJhbXAgYW55IHNpZ25hbCB2YWx1ZXMgdG8gdGhlaXIgZGVzdGluYXRpb24gdmFsdWVcblx0XHQgKiAgb3ZlciB0aGUgZHVyYXRpb24gb2YgdGhlIHJhbXBUaW1lLlxuXHRcdCAqICBAcGFyYW0ge09iamVjdHxzdHJpbmd9IHBhcmFtc1xuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IHZhbHVlXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IHJhbXBUaW1lXG5cdFx0ICogIEByZXR1cm5zIHtUb25lfSB0aGlzXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lI1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vc2V0IHZhbHVlcyB1c2luZyBhbiBvYmplY3Rcblx0XHQgKiBmaWx0ZXIuc2V0KHtcblx0XHQgKiBcdFwiZnJlcXVlbmN5XCIgOiAzMDAsXG5cdFx0ICogXHRcInR5cGVcIiA6IGhpZ2hwYXNzXG5cdFx0ICogfSk7XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogZmlsdGVyLnNldChcInR5cGVcIiwgXCJoaWdocGFzc1wiKTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3JhbXAgdG8gdGhlIHZhbHVlIDIyMCBvdmVyIDMgc2Vjb25kcy5cblx0XHQgKiBvc2NpbGxhdG9yLnNldCh7XG5cdFx0ICogXHRcImZyZXF1ZW5jeVwiIDogMjIwXG5cdFx0ICogfSwgMyk7XG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZSwgcmFtcFRpbWUpIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc09iamVjdChwYXJhbXMpKSB7XG5cdCAgICAgICAgICAgIHJhbXBUaW1lID0gdmFsdWU7XG5cdCAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzU3RyaW5nKHBhcmFtcykpIHtcblx0ICAgICAgICAgICAgdmFyIHRtcE9iaiA9IHt9O1xuXHQgICAgICAgICAgICB0bXBPYmpbcGFyYW1zXSA9IHZhbHVlO1xuXHQgICAgICAgICAgICBwYXJhbXMgPSB0bXBPYmo7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBhcmFtTG9vcDpcblx0ICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBwYXJhbXMpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyYW1zW2F0dHJdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICBpZiAoYXR0ci5pbmRleE9mKCcuJykgIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJTcGxpdCA9IGF0dHIuc3BsaXQoJy4nKTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJTcGxpdC5sZW5ndGggLSAxOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50W2F0dHJTcGxpdFtpXV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBUb25lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyU3BsaXQuc3BsaWNlKDAsIGkgKyAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbm5lclBhcmFtID0gYXR0clNwbGl0LmpvaW4oJy4nKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5zZXQoaW5uZXJQYXJhbSwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgcGFyYW1Mb29wO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyU3BsaXRbYXR0clNwbGl0Lmxlbmd0aCAtIDFdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyZW50W2F0dHJdO1xuXHQgICAgICAgICAgICAgICAgaWYgKFRvbmUuaXNVbmRlZihwYXJhbSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChUb25lLlNpZ25hbCAmJiBwYXJhbSBpbnN0YW5jZW9mIFRvbmUuU2lnbmFsIHx8IFRvbmUuUGFyYW0gJiYgcGFyYW0gaW5zdGFuY2VvZiBUb25lLlBhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnZhbHVlICE9PSB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKHJhbXBUaW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0udmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLnJhbXBUbyh2YWx1ZSwgcmFtcFRpbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbSBpbnN0YW5jZW9mIEF1ZGlvUGFyYW0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0udmFsdWUgIT09IHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLnZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbSBpbnN0YW5jZW9mIFRvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbS5zZXQodmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbSAhPT0gdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJlbnRbYXR0cl0gPSB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgdGhlIG9iamVjdCdzIGF0dHJpYnV0ZXMuIEdpdmVuIG5vIGFyZ3VtZW50cyBnZXRcblx0XHQgKiAgd2lsbCByZXR1cm4gYWxsIGF2YWlsYWJsZSBvYmplY3QgcHJvcGVydGllcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZ1xuXHRcdCAqICB2YWx1ZXMuIFBhc3MgaW4gYSBzaW5nbGUgYXR0cmlidXRlIHRvIHJldHJpZXZlIG9yIGFuIGFycmF5XG5cdFx0ICogIG9mIGF0dHJpYnV0ZXMuIFRoZSBhdHRyaWJ1dGUgc3RyaW5ncyBjYW4gYWxzbyBpbmNsdWRlIGEgXCIuXCJcblx0XHQgKiAgdG8gYWNjZXNzIGRlZXBlciBwcm9wZXJ0aWVzLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZSNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBvc2MuZ2V0KCk7XG5cdFx0ICogLy9yZXR1cm5zIHtcInR5cGVcIiA6IFwic2luZVwiLCBcImZyZXF1ZW5jeVwiIDogNDQwLCAuLi5ldGN9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogb3NjLmdldChcInR5cGVcIik7XG5cdFx0ICogLy9yZXR1cm5zIHsgXCJ0eXBlXCIgOiBcInNpbmVcIn1cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vdXNlIGRvdCBub3RhdGlvbiB0byBhY2Nlc3MgZGVlcCBwcm9wZXJ0aWVzXG5cdFx0ICogc3ludGguZ2V0KFtcImVudmVsb3BlLmF0dGFja1wiLCBcImVudmVsb3BlLnJlbGVhc2VcIl0pO1xuXHRcdCAqIC8vcmV0dXJucyB7XCJlbnZlbG9wZVwiIDoge1wiYXR0YWNrXCIgOiAwLjIsIFwicmVsZWFzZVwiIDogMC40fX1cblx0XHQgKiAgQHBhcmFtIHtBcnJheT18c3RyaW5nfHVuZGVmaW5lZH0gcGFyYW1zIHRoZSBwYXJhbWV0ZXJzIHRvIGdldCwgb3RoZXJ3aXNlIHdpbGwgcmV0dXJuXG5cdFx0ICogIFx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICBhbGwgYXZhaWxhYmxlLlxuXHRcdCAqICBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuXHQgICAgICAgIGlmIChUb25lLmlzVW5kZWYocGFyYW1zKSkge1xuXHQgICAgICAgICAgICBwYXJhbXMgPSB0aGlzLl9jb2xsZWN0RGVmYXVsdHModGhpcy5jb25zdHJ1Y3Rvcik7XG5cdCAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzU3RyaW5nKHBhcmFtcykpIHtcblx0ICAgICAgICAgICAgcGFyYW1zID0gW3BhcmFtc107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXQgPSB7fTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgYXR0ciA9IHBhcmFtc1tpXTtcblx0ICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBzdWJSZXQgPSByZXQ7XG5cdCAgICAgICAgICAgIGlmIChhdHRyLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBhdHRyU3BsaXQgPSBhdHRyLnNwbGl0KCcuJyk7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGF0dHJTcGxpdC5sZW5ndGggLSAxOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3ViQXR0ciA9IGF0dHJTcGxpdFtqXTtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJSZXRbc3ViQXR0cl0gPSBzdWJSZXRbc3ViQXR0cl0gfHwge307XG5cdCAgICAgICAgICAgICAgICAgICAgc3ViUmV0ID0gc3ViUmV0W3N1YkF0dHJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFtzdWJBdHRyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyU3BsaXRbYXR0clNwbGl0Lmxlbmd0aCAtIDFdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmVudFthdHRyXTtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNPYmplY3QocGFyYW1zW2F0dHJdKSkge1xuXHQgICAgICAgICAgICAgICAgc3ViUmV0W2F0dHJdID0gcGFyYW0uZ2V0KCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5TaWduYWwgJiYgcGFyYW0gaW5zdGFuY2VvZiBUb25lLlNpZ25hbCkge1xuXHQgICAgICAgICAgICAgICAgc3ViUmV0W2F0dHJdID0gcGFyYW0udmFsdWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5QYXJhbSAmJiBwYXJhbSBpbnN0YW5jZW9mIFRvbmUuUGFyYW0pIHtcblx0ICAgICAgICAgICAgICAgIHN1YlJldFthdHRyXSA9IHBhcmFtLnZhbHVlO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtIGluc3RhbmNlb2YgQXVkaW9QYXJhbSkge1xuXHQgICAgICAgICAgICAgICAgc3ViUmV0W2F0dHJdID0gcGFyYW0udmFsdWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0gaW5zdGFuY2VvZiBUb25lKSB7XG5cdCAgICAgICAgICAgICAgICBzdWJSZXRbYXR0cl0gPSBwYXJhbS5nZXQoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICghVG9uZS5pc0Z1bmN0aW9uKHBhcmFtKSAmJiAhVG9uZS5pc1VuZGVmKHBhcmFtKSkge1xuXHQgICAgICAgICAgICAgICAgc3ViUmV0W2F0dHJdID0gcGFyYW07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY29sbGVjdCBhbGwgb2YgdGhlIGRlZmF1bHQgYXR0cmlidXRlcyBpbiBvbmVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gY29uc3RyIHRoZSBjb25zdHJ1Y3RvciB0byBmaW5kIHRoZSBkZWZhdWx0cyBmcm9tXG5cdFx0ICogIEByZXR1cm4ge0FycmF5fSBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgd2hpY2ggYmVsb25nIHRvIHRoZSBjbGFzc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuX2NvbGxlY3REZWZhdWx0cyA9IGZ1bmN0aW9uIChjb25zdHIpIHtcblx0ICAgICAgICB2YXIgcmV0ID0gW107XG5cdCAgICAgICAgaWYgKCFUb25lLmlzVW5kZWYoY29uc3RyLmRlZmF1bHRzKSkge1xuXHQgICAgICAgICAgICByZXQgPSBPYmplY3Qua2V5cyhjb25zdHIuZGVmYXVsdHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIVRvbmUuaXNVbmRlZihjb25zdHIuX3N1cGVyKSkge1xuXHQgICAgICAgICAgICB2YXIgc3VwZXJEZWZzID0gdGhpcy5fY29sbGVjdERlZmF1bHRzKGNvbnN0ci5fc3VwZXIpO1xuXHQgICAgICAgICAgICAvL2ZpbHRlciBvdXQgcmVwZWF0c1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1cGVyRGVmcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHJldC5pbmRleE9mKHN1cGVyRGVmc1tpXSkgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goc3VwZXJEZWZzW2ldKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdERFRkFVTFRTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqICBAcGFyYW0gIHtBcnJheX0gIHZhbHVlcyAgVGhlIGFyZ3VtZW50cyBhcnJheVxuXHRcdCAqICBAcGFyYW0gIHtBcnJheX0gIGtleXMgICAgVGhlIG5hbWVzIG9mIHRoZSBhcmd1bWVudHNcblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGNvbnN0ciBUaGUgY2xhc3MgY29uc3RydWN0b3Jcblx0XHQgKiAgQHJldHVybiAge09iamVjdH0gIEFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgIGRlZmF1bHRzIGJldHdlZW4gdGhlIGNsYXNzJyBkZWZhdWx0c1xuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHRoZSBwYXNzZWQgaW4gYXJndW1lbnRzLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5kZWZhdWx0cyA9IGZ1bmN0aW9uICh2YWx1ZXMsIGtleXMsIGNvbnN0cikge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0ge307XG5cdCAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEgJiYgVG9uZS5pc09iamVjdCh2YWx1ZXNbMF0pKSB7XG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSB2YWx1ZXNbMF07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zW2tleXNbaV1dID0gdmFsdWVzW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKGNvbnN0ci5kZWZhdWx0cykpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBjb25zdHIuZGVmYXVsdHMpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc09iamVjdChjb25zdHIpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgY29uc3RyKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIElmIHRoZSBgZ2l2ZW5gIHBhcmFtZXRlciBpcyB1bmRlZmluZWQsIHVzZSB0aGUgYGZhbGxiYWNrYC5cblx0XHQgKiAgSWYgYm90aCBgZ2l2ZW5gIGFuZCBgZmFsbGJhY2tgIGFyZSBvYmplY3QgbGl0ZXJhbHMsIGl0IHdpbGxcblx0XHQgKiAgcmV0dXJuIGEgZGVlcCBjb3B5IHdoaWNoIGluY2x1ZGVzIGFsbCBvZiB0aGUgcGFyYW1ldGVycyBmcm9tIGJvdGhcblx0XHQgKiAgb2JqZWN0cy4gSWYgYSBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIGluIGdpdmVuLCBpdCB3aWxsIHJldHVyblxuXHRcdCAqICB0aGUgZmFsbGJhY2sgcHJvcGVydHkuXG5cdFx0ICogIDxicj48YnI+XG5cdFx0ICogIFdBUk5JTkc6IGlmIG9iamVjdCBpcyBzZWxmIHJlZmVyZW50aWFsLCBpdCB3aWxsIGdvIGludG8gYW4gYW5cblx0XHQgKiAgaW5maW5pdGUgcmVjdXJzaXZlIGxvb3AuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICogIEBwYXJhbSAgeyp9IGdpdmVuXG5cdFx0ICogIEBwYXJhbSAgeyp9IGZhbGxiYWNrXG5cdFx0ICogIEByZXR1cm4geyp9XG5cdFx0ICovXG5cdCAgICBUb25lLmRlZmF1bHRBcmcgPSBmdW5jdGlvbiAoZ2l2ZW4sIGZhbGxiYWNrKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNPYmplY3QoZ2l2ZW4pICYmIFRvbmUuaXNPYmplY3QoZmFsbGJhY2spKSB7XG5cdCAgICAgICAgICAgIHZhciByZXQgPSB7fTtcblx0ICAgICAgICAgICAgLy9tYWtlIGEgZGVlcCBjb3B5IG9mIHRoZSBnaXZlbiBvYmplY3Rcblx0ICAgICAgICAgICAgZm9yICh2YXIgZ2l2ZW5Qcm9wIGluIGdpdmVuKSB7XG5cdCAgICAgICAgICAgICAgICByZXRbZ2l2ZW5Qcm9wXSA9IFRvbmUuZGVmYXVsdEFyZyhmYWxsYmFja1tnaXZlblByb3BdLCBnaXZlbltnaXZlblByb3BdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmb3IgKHZhciBmYWxsYmFja1Byb3AgaW4gZmFsbGJhY2spIHtcblx0ICAgICAgICAgICAgICAgIHJldFtmYWxsYmFja1Byb3BdID0gVG9uZS5kZWZhdWx0QXJnKGdpdmVuW2ZhbGxiYWNrUHJvcF0sIGZhbGxiYWNrW2ZhbGxiYWNrUHJvcF0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuaXNVbmRlZihnaXZlbikgPyBmYWxsYmFjayA6IGdpdmVuO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRDT05ORUNUSU9OU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgY29ubmVjdCB0b2dldGhlciBhbGwgb2YgdGhlIGFyZ3VtZW50cyBpbiBzZXJpZXNcblx0XHQgKiAgQHBhcmFtIHsuLi5BdWRpb1BhcmFtfFRvbmV8QXVkaW9Ob2RlfSBub2Rlc1xuXHRcdCAqICBAcmV0dXJucyB7VG9uZX1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5jb25uZWN0U2VyaWVzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBjdXJyZW50VW5pdCA9IGFyZ3VtZW50c1swXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgdG9Vbml0ID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgICAgICBjdXJyZW50VW5pdC5jb25uZWN0KHRvVW5pdCk7XG5cdCAgICAgICAgICAgIGN1cnJlbnRVbml0ID0gdG9Vbml0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gVG9uZTtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIFRZUEUgQ0hFQ0tJTkdcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIHRlc3QgaWYgdGhlIGFyZyBpcyB1bmRlZmluZWRcblx0XHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyB1bmRlZmluZWRcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5pc1VuZGVmID0gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgdGVzdCBpZiB0aGUgYXJnIGlzIGEgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhIGZ1bmN0aW9uXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIFRvbmUuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGVzdCBpZiB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIuXG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgYSBudW1iZXJcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5pc051bWJlciA9IGZ1bmN0aW9uIChhcmcpIHtcblx0ICAgICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRlc3QgaWYgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIGFuIG9iamVjdCBsaXRlcmFsIChpLmUuIGB7fWApO1xuXHRcdCAqICBAcGFyYW0geyp9IGFyZyB0aGUgYXJndW1lbnQgdG8gdGVzdFxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXJnIGlzIGFuIG9iamVjdCBsaXRlcmFsLlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLmlzT2JqZWN0ID0gZnVuY3Rpb24gKGFyZykge1xuXHQgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgYXJnLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRlc3QgaWYgdGhlIGFyZ3VtZW50IGlzIGEgYm9vbGVhbi5cblx0XHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhIGJvb2xlYW5cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGVzdCBpZiB0aGUgYXJndW1lbnQgaXMgYW4gQXJyYXlcblx0XHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhbiBhcnJheVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLmlzQXJyYXkgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGVzdCBpZiB0aGUgYXJndW1lbnQgaXMgYSBzdHJpbmcuXG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgYSBzdHJpbmdcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5pc1N0cmluZyA9IGZ1bmN0aW9uIChhcmcpIHtcblx0ICAgICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRlc3QgaWYgdGhlIGFyZ3VtZW50IGlzIGluIHRoZSBmb3JtIG9mIGEgbm90ZSBpbiBzY2llbnRpZmljIHBpdGNoIG5vdGF0aW9uLlxuXHRcdCAqICBlLmcuIFwiQzRcIlxuXHRcdCAqICBAcGFyYW0geyp9IGFyZyB0aGUgYXJndW1lbnQgdG8gdGVzdFxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXJnIGlzIGEgc3RyaW5nXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIFRvbmUuaXNOb3RlID0gZnVuY3Rpb24gKGFyZykge1xuXHQgICAgICAgIHJldHVybiBUb25lLmlzU3RyaW5nKGFyZykgJiYgL14oW2EtZ117MX0oPzpifCN8eHxiYik/KSgtP1swLTldKykvaS50ZXN0KGFyZyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFuIGVtcHR5IGZ1bmN0aW9uLlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLm5vT3AgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE1ha2UgdGhlIHByb3BlcnR5IG5vdCB3cml0YWJsZS4gSW50ZXJuYWwgdXNlIG9ubHkuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEBwYXJhbSAge3N0cmluZ30gIHByb3BlcnR5ICB0aGUgcHJvcGVydHkgdG8gbWFrZSBub3Qgd3JpdGFibGVcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLl9yZWFkT25seSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuXHQgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5KSkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yZWFkT25seShwcm9wZXJ0eVtpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHksIHtcblx0ICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBNYWtlIGFuIGF0dHJpYnV0ZSB3cml0ZWFibGUuIEludGVyYWwgdXNlIG9ubHkuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEBwYXJhbSAge3N0cmluZ30gIHByb3BlcnR5ICB0aGUgcHJvcGVydHkgdG8gbWFrZSB3cml0YWJsZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuX3dyaXRhYmxlID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHkpKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRhYmxlKHByb3BlcnR5W2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wZXJ0eSwgeyB3cml0YWJsZTogdHJ1ZSB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogUG9zc2libGUgcGxheSBzdGF0ZXMuXG5cdFx0ICogQGVudW0ge3N0cmluZ31cblx0XHQgKi9cblx0ICAgIFRvbmUuU3RhdGUgPSB7XG5cdCAgICAgICAgU3RhcnRlZDogJ3N0YXJ0ZWQnLFxuXHQgICAgICAgIFN0b3BwZWQ6ICdzdG9wcGVkJyxcblx0ICAgICAgICBQYXVzZWQ6ICdwYXVzZWQnXG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBDT05WRVJTSU9OU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgRXF1YWwgcG93ZXIgZ2FpbiBzY2FsZS4gR29vZCBmb3IgY3Jvc3MtZmFkaW5nLlxuXHRcdCAqICBAcGFyYW0gIHtOb3JtYWxSYW5nZX0gcGVyY2VudCAoMC0xKVxuXHRcdCAqICBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgb3V0cHV0IGdhaW4gKDAtMSlcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5lcXVhbFBvd2VyU2NhbGUgPSBmdW5jdGlvbiAocGVyY2VudCkge1xuXHQgICAgICAgIHZhciBwaUZhY3RvciA9IDAuNSAqIE1hdGguUEk7XG5cdCAgICAgICAgcmV0dXJuIE1hdGguc2luKHBlcmNlbnQgKiBwaUZhY3Rvcik7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgZGVjaWJlbHMgaW50byBnYWluLlxuXHRcdCAqICBAcGFyYW0gIHtEZWNpYmVsc30gZGJcblx0XHQgKiAgQHJldHVybiB7TnVtYmVyfVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLmRiVG9HYWluID0gZnVuY3Rpb24gKGRiKSB7XG5cdCAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsIGRiIC8gNik7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgZ2FpbiB0byBkZWNpYmVscy5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSBnYWluICgwLTEpXG5cdFx0ICogIEByZXR1cm4ge0RlY2liZWxzfVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLmdhaW5Ub0RiID0gZnVuY3Rpb24gKGdhaW4pIHtcblx0ICAgICAgICByZXR1cm4gMjAgKiAoTWF0aC5sb2coZ2FpbikgLyBNYXRoLkxOMTApO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGFuIGludGVydmFsIChpbiBzZW1pdG9uZXMpIHRvIGEgZnJlcXVlbmN5IHJhdGlvLlxuXHRcdCAqICBAcGFyYW0gIHtJbnRlcnZhbH0gaW50ZXJ2YWwgdGhlIG51bWJlciBvZiBzZW1pdG9uZXMgYWJvdmUgdGhlIGJhc2Ugbm90ZVxuXHRcdCAqICBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgIHRoZSBmcmVxdWVuY3kgcmF0aW9cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKDApOyAvLyAxXG5cdFx0ICogdG9uZS5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8oMTIpOyAvLyAyXG5cdFx0ICogdG9uZS5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8oLTEyKTsgLy8gMC41XG5cdFx0ICovXG5cdCAgICBUb25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbyA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuXHQgICAgICAgIHJldHVybiBNYXRoLnBvdygyLCBpbnRlcnZhbCAvIDEyKTtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRUSU1JTkdcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgY3VycmVudCB0aW1lIG9mIHRoZSBBdWRpb0NvbnRleHQgY2xvY2suXG5cdFx0ICogIEByZXR1cm4ge051bWJlcn0gdGhlIGN1cnJlbnRUaW1lIGZyb20gdGhlIEF1ZGlvQ29udGV4dFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZSNcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gVG9uZS5jb250ZXh0Lm5vdygpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIGN1cnJlbnQgdGltZSBvZiB0aGUgQXVkaW9Db250ZXh0IGNsb2NrLlxuXHRcdCAqICBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjdXJyZW50VGltZSBmcm9tIHRoZSBBdWRpb0NvbnRleHRcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIFRvbmUuY29udGV4dC5ub3coKTtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRJTkhFUklUQU5DRVxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgaGF2ZSBhIGNoaWxkIGluaGVyaXQgYWxsIG9mIFRvbmUncyAob3IgYSBwYXJlbnQncykgcHJvdG90eXBlXG5cdFx0ICogIHRvIGluaGVyaXQgdGhlIHBhcmVudCdzIHByb3BlcnRpZXMsIG1ha2Ugc3VyZSB0byBjYWxsXG5cdFx0ICogIFBhcmVudC5jYWxsKHRoaXMpIGluIHRoZSBjaGlsZCdzIGNvbnN0cnVjdG9yXG5cdFx0ICpcblx0XHQgKiAgYmFzZWQgb24gY2xvc3VyZSBsaWJyYXJ5J3MgaW5oZXJpdCBmdW5jdGlvblxuXHRcdCAqXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHBhcmFtICB7ZnVuY3Rpb259IFx0Y2hpbGRcblx0XHQgKiAgQHBhcmFtICB7ZnVuY3Rpb249fSBwYXJlbnQgKG9wdGlvbmFsKSBwYXJlbnQgdG8gaW5oZXJpdCBmcm9tXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vIHBhcmVudCBpcyBzdXBwbGllZCwgdGhlIGNoaWxkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgaW5oZXJpdCBmcm9tIFRvbmVcblx0XHQgKi9cblx0ICAgIFRvbmUuZXh0ZW5kID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKHBhcmVudCkpIHtcblx0ICAgICAgICAgICAgcGFyZW50ID0gVG9uZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gVGVtcENvbnN0cnVjdG9yKCkge1xuXHQgICAgICAgIH1cblx0ICAgICAgICBUZW1wQ29uc3RydWN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcblx0ICAgICAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgVGVtcENvbnN0cnVjdG9yKCk7XG5cdCAgICAgICAgLyoqIEBvdmVycmlkZSAqL1xuXHQgICAgICAgIGNoaWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuXHQgICAgICAgIGNoaWxkLl9zdXBlciA9IHBhcmVudDtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRDT05URVhUXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgcHJpdmF0ZSBhdWRpbyBjb250ZXh0IHNoYXJlZCBieSBhbGwgVG9uZSBOb2Rlcy5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHR5cGUge1RvbmUuQ29udGV4dH1cblx0XHQgKi9cblx0ICAgIHZhciBhdWRpb0NvbnRleHQgPSBudWxsO1xuXHQgICAgLyoqXG5cdFx0ICogIEEgc3RhdGljIHBvaW50ZXIgdG8gdGhlIGF1ZGlvIGNvbnRleHQgYWNjZXNzaWJsZSBhcyBUb25lLmNvbnRleHQuXG5cdFx0ICogIEB0eXBlIHtUb25lLkNvbnRleHR9XG5cdFx0ICogIEBuYW1lIGNvbnRleHRcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLCAnY29udGV4dCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGF1ZGlvQ29udGV4dDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuQ29udGV4dCAmJiBjb250ZXh0IGluc3RhbmNlb2YgVG9uZS5Db250ZXh0KSB7XG5cdCAgICAgICAgICAgICAgICBhdWRpb0NvbnRleHQgPSBjb250ZXh0O1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgYXVkaW9Db250ZXh0ID0gbmV3IFRvbmUuQ29udGV4dChjb250ZXh0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL2luaXRpYWxpemUgdGhlIG5ldyBhdWRpbyBjb250ZXh0XG5cdCAgICAgICAgICAgIFRvbmUuQ29udGV4dC5lbWl0KCdpbml0JywgYXVkaW9Db250ZXh0KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgQXVkaW9Db250ZXh0XG5cdFx0ICogIEB0eXBlIHtUb25lLkNvbnRleHR9XG5cdFx0ICogIEBuYW1lIGNvbnRleHRcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUjXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUucHJvdG90eXBlLCAnY29udGV4dCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuY29udGV4dDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUb25lIGF1dG9tYXRpY2FsbHkgY3JlYXRlcyBhIGNvbnRleHQgb24gaW5pdCwgYnV0IGlmIHlvdSBhcmUgd29ya2luZ1xuXHRcdCAqICB3aXRoIG90aGVyIGxpYnJhcmllcyB3aGljaCBhbHNvIGNyZWF0ZSBhbiBBdWRpb0NvbnRleHQsIGl0IGNhbiBiZVxuXHRcdCAqICB1c2VmdWwgdG8gc2V0IHlvdXIgb3duLiBJZiB5b3UgYXJlIGdvaW5nIHRvIHNldCB5b3VyIG93biBjb250ZXh0LFxuXHRcdCAqICBiZSBzdXJlIHRvIGRvIGl0IGF0IHRoZSBzdGFydCBvZiB5b3VyIGNvZGUsIGJlZm9yZSBjcmVhdGluZyBhbnkgb2JqZWN0cy5cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY3R4IFRoZSBuZXcgYXVkaW8gY29udGV4dCB0byBzZXRcblx0XHQgKi9cblx0ICAgIFRvbmUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uIChjdHgpIHtcblx0ICAgICAgICBUb25lLmNvbnRleHQgPSBjdHg7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0QVRUUklCVVRFU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgVGhlIG51bWJlciBvZiBzZWNvbmRzIG9mIDEgcHJvY2Vzc2luZyBibG9jayAoMTI4IHNhbXBsZXMpXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBuYW1lIGJsb2NrVGltZVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUucHJvdG90eXBlLCAnYmxvY2tUaW1lJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gMTI4IC8gdGhpcy5jb250ZXh0LnNhbXBsZVJhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGR1cmF0aW9uIGluIHNlY29uZHMgb2Ygb25lIHNhbXBsZS5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG5hbWUgc2FtcGxlVGltZVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUucHJvdG90eXBlLCAnc2FtcGxlVGltZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIDEgLyB0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBXaGV0aGVyIG9yIG5vdCBhbGwgdGhlIHRlY2hub2xvZ2llcyB0aGF0IFRvbmUuanMgcmVsaWVzIG9uIGFyZSBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgYnJvd3Nlci5cblx0XHQgKiAgQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogIEBuYW1lIHN1cHBvcnRlZFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUsICdzdXBwb3J0ZWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBoYXNBdWRpb0NvbnRleHQgPSB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ0F1ZGlvQ29udGV4dCcpIHx8IHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnd2Via2l0QXVkaW9Db250ZXh0Jyk7XG5cdCAgICAgICAgICAgIHZhciBoYXNQcm9taXNlcyA9IHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnUHJvbWlzZScpO1xuXHQgICAgICAgICAgICB2YXIgaGFzV29ya2VycyA9IHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnV29ya2VyJyk7XG5cdCAgICAgICAgICAgIHJldHVybiBoYXNBdWRpb0NvbnRleHQgJiYgaGFzUHJvbWlzZXMgJiYgaGFzV29ya2Vycztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBCb29sZWFuIHZhbHVlIGlmIHRoZSBhdWRpbyBjb250ZXh0IGhhcyBiZWVuIGluaXRpYWxpemVkLlxuXHRcdCAqICBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbmFtZSBpbml0aWFsaXplZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUsICdpbml0aWFsaXplZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGF1ZGlvQ29udGV4dCAhPT0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgdGhlIGNvbnRleHQgd2hlbiBpdCBiZWNvbWVzIGF2YWlsYWJsZVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIHJlc29sdmUgIENhbGxiYWNrIHdoZW4gdGhlIGNvbnRleHQgaXMgaW5pdGlhbGl6ZWRcblx0XHQgKiAgQHJldHVybiAge1RvbmV9XG5cdFx0ICovXG5cdCAgICBUb25lLmdldENvbnRleHQgPSBmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHQgICAgICAgIGlmIChUb25lLmluaXRpYWxpemVkKSB7XG5cdCAgICAgICAgICAgIHJlc29sdmUoVG9uZS5jb250ZXh0KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgcmVzQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXNvbHZlKFRvbmUuY29udGV4dCk7XG5cdCAgICAgICAgICAgICAgICBUb25lLkNvbnRleHQub2ZmKCdpbml0JywgcmVzQ2FsbGJhY2spO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBUb25lLkNvbnRleHQub24oJ2luaXQnLCByZXNDYWxsYmFjayk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBUb25lO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB2ZXJzaW9uIG51bWJlclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS52ZXJzaW9uID0gJ3IxMSc7XG5cdCAgICAvLyBhbGxvdyBvcHRpb25hbCBzaWxlbmNpbmcgb2YgdGhpcyBsb2dcblx0ICAgIGlmICghd2luZG93LlRPTkVfU0lMRU5DRV9WRVJTSU9OX0xPR0dJTkcpIHtcblx0ICAgICAgICBjb25zb2xlLmxvZygnJWMgKiBUb25lLmpzICcgKyBUb25lLnZlcnNpb24gKyAnICogJywgJ2JhY2tncm91bmQ6ICMwMDA7IGNvbG9yOiAjZmZmJyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVG9uZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuRW1pdHRlciBnaXZlcyBjbGFzc2VzIHdoaWNoIGV4dGVuZCBpdFxuXHRcdCAqICAgICAgICAgdGhlIGFiaWxpdHkgdG8gbGlzdGVuIGZvciBhbmQgZW1pdCBldmVudHMuIFxuXHRcdCAqICAgICAgICAgSW5zcGlyYXRpb24gYW5kIHJlZmVyZW5jZSBmcm9tIEplcm9tZSBFdGllbm5lJ3MgW01pY3JvRXZlbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9qZXJvbWVldGllbm5lL21pY3JvZXZlbnQuanMpLlxuXHRcdCAqICAgICAgICAgTUlUIChjKSAyMDExIEplcm9tZSBFdGllbm5lLlxuXHRcdCAqICAgICAgICAgXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FbWl0dGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBDb250YWlucyBhbGwgb2YgdGhlIGV2ZW50cy5cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5FbWl0dGVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICBCaW5kIGEgY2FsbGJhY2sgdG8gYSBzcGVjaWZpYyBldmVudC5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgICBldmVudCAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3IuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgaXMgZW1pdHRlZFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FbWl0dGVyfSAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuXHQgICAgICAgIC8vc3BsaXQgdGhlIGV2ZW50XG5cdCAgICAgICAgdmFyIGV2ZW50cyA9IGV2ZW50LnNwbGl0KC9cXFcrLyk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50c1tpXTtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXIuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gICAgZXZlbnQgICAgIFRoZSBldmVudCB0byBzdG9wIGxpc3RlbmluZyB0by5cblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb249fSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB3aGljaCB3YXMgYm91bmQgdG8gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBldmVudCB3aXRoIFRvbmUuRW1pdHRlci5vbi5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm8gY2FsbGJhY2sgaXMgZ2l2ZW4sIGFsbCBjYWxsYmFja3Ncblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzIGFyZSByZW1vdmVkLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FbWl0dGVyfSAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcblx0ICAgICAgICB2YXIgZXZlbnRzID0gZXZlbnQuc3BsaXQoL1xcVysvKTtcblx0ICAgICAgICBmb3IgKHZhciBldiA9IDA7IGV2IDwgZXZlbnRzLmxlbmd0aDsgZXYrKykge1xuXHQgICAgICAgICAgICBldmVudCA9IGV2ZW50c1tldl07XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKGNhbGxiYWNrKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBbXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TGlzdCA9IHRoaXMuX2V2ZW50c1tldmVudF07XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExpc3QubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TGlzdFtpXSA9PT0gY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdC5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEludm9rZSBhbGwgb2YgdGhlIGNhbGxiYWNrcyBib3VuZCB0byB0aGUgZXZlbnRcblx0XHQgKiAgd2l0aCBhbnkgYXJndW1lbnRzIHBhc3NlZCBpbi4gXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIGV2ZW50ICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJncy4uLiBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9ucyBsaXN0ZW5pbmcuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkVtaXR0ZXJ9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICBpZiAodGhpcy5fZXZlbnRzKSB7XG5cdCAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5zbGljZSgxKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBldmVudExpc3QgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2ZW50TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdFtpXS5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWRkIEVtaXR0ZXIgZnVuY3Rpb25zIChvbi9vZmYvZW1pdCkgdG8gdGhlIG9iamVjdFxuXHRcdCAqICBAcGFyYW0gIHtPYmplY3R8RnVuY3Rpb259ICBvYmplY3QgIFRoZSBvYmplY3Qgb3IgY2xhc3MgdG8gZXh0ZW5kLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FbWl0dGVyfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FbWl0dGVyLm1peGluID0gZnVuY3Rpb24gKG9iamVjdCkge1xuXHQgICAgICAgIHZhciBmdW5jdGlvbnMgPSBbXG5cdCAgICAgICAgICAgICdvbicsXG5cdCAgICAgICAgICAgICdvZmYnLFxuXHQgICAgICAgICAgICAnZW1pdCdcblx0ICAgICAgICBdO1xuXHQgICAgICAgIG9iamVjdC5fZXZlbnRzID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbnNbaV07XG5cdCAgICAgICAgICAgIHZhciBlbWl0dGVyRnVuYyA9IFRvbmUuRW1pdHRlci5wcm90b3R5cGVbZnVuY107XG5cdCAgICAgICAgICAgIG9iamVjdFtmdW5jXSA9IGVtaXR0ZXJGdW5jO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gVG9uZS5FbWl0dGVyO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FbWl0dGVyfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbWl0dGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkVtaXR0ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBIFRpbWVsaW5lIGNsYXNzIGZvciBzY2hlZHVsaW5nIGFuZCBtYWludGFpbmluZyBzdGF0ZVxuXHRcdCAqICAgICAgICAgYWxvbmcgYSB0aW1lbGluZS4gQWxsIGV2ZW50cyBtdXN0IGhhdmUgYSBcInRpbWVcIiBwcm9wZXJ0eS4gXG5cdFx0ICogICAgICAgICBJbnRlcm5hbGx5LCBldmVudHMgYXJlIHN0b3JlZCBpbiB0aW1lIG9yZGVyIGZvciBmYXN0IFxuXHRcdCAqICAgICAgICAgcmV0cmlldmFsLlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHBhcmFtIHtQb3NpdGl2ZX0gW21lbW9yeT1JbmZpbml0eV0gVGhlIG51bWJlciBvZiBwcmV2aW91cyBldmVudHMgdGhhdCBhcmUgcmV0YWluZWQuXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsnbWVtb3J5J10sIFRvbmUuVGltZWxpbmUpO1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYXJyYXkgb2Ygc2NoZWR1bGVkIHRpbWVsaW5lIGV2ZW50c1xuXHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQW4gYXJyYXkgb2YgaXRlbXMgdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3QuIFxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdG9SZW1vdmUgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBGbGFnIGlmIHRoZSB0aW1lbGluZSBpcyBtaWQgaXRlcmF0aW9uXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2l0ZXJhdGluZyA9IGZhbHNlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtZW1vcnkgb2YgdGhlIHRpbWVsaW5lLCBpLmUuXG5cdFx0XHQgKiAgaG93IG1hbnkgZXZlbnRzIGluIHRoZSBwYXN0IGl0IHdpbGwgcmV0YWluXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tZW1vcnkgPSBvcHRpb25zLm1lbW9yeTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlRpbWVsaW5lKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLmRlZmF1bHRzID0geyAnbWVtb3J5JzogSW5maW5pdHkgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSB0aW1lbGluZS5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVGltZWxpbmUjXG5cdFx0ICogIEBuYW1lIGxlbmd0aFxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRpbWVsaW5lLnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lLmxlbmd0aDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnNlcnQgYW4gZXZlbnQgb2JqZWN0IG9udG8gdGhlIHRpbWVsaW5lLiBFdmVudHMgbXVzdCBoYXZlIGEgXCJ0aW1lXCIgYXR0cmlidXRlLlxuXHRcdCAqICBAcGFyYW0gIHtPYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IG9iamVjdCB0byBpbnNlcnQgaW50byB0aGUgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAvL3RoZSBldmVudCBuZWVkcyB0byBoYXZlIGEgdGltZSBhdHRyaWJ1dGVcblx0ICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKGV2ZW50LnRpbWUpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5UaW1lbGluZTogZXZlbnRzIG11c3QgaGF2ZSBhIHRpbWUgYXR0cmlidXRlJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0aGlzLl90aW1lbGluZS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fc2VhcmNoKGV2ZW50LnRpbWUpO1xuXHQgICAgICAgICAgICB0aGlzLl90aW1lbGluZS5zcGxpY2UoaW5kZXggKyAxLCAwLCBldmVudCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUucHVzaChldmVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vaWYgdGhlIGxlbmd0aCBpcyBtb3JlIHRoYW4gdGhlIG1lbW9yeSwgcmVtb3ZlIHRoZSBwcmV2aW91cyBvbmVzXG5cdCAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gdGhpcy5tZW1vcnkpIHtcblx0ICAgICAgICAgICAgdmFyIGRpZmYgPSB0aGlzLmxlbmd0aCAtIHRoaXMubWVtb3J5O1xuXHQgICAgICAgICAgICB0aGlzLl90aW1lbGluZS5zcGxpY2UoMCwgZGlmZik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgYW4gZXZlbnQgZnJvbSB0aGUgdGltZWxpbmUuXG5cdFx0ICogIEBwYXJhbSAge09iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgb2JqZWN0IHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2l0ZXJhdGluZykge1xuXHQgICAgICAgICAgICB0aGlzLl90b1JlbW92ZS5wdXNoKGV2ZW50KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl90aW1lbGluZS5pbmRleE9mKGV2ZW50KTtcblx0ICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBuZWFyZXN0IGV2ZW50IHdob3NlIHRpbWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgY29tcGFyaXRvciBXaGljaCB2YWx1ZSBpbiB0aGUgb2JqZWN0IHRvIGNvbXBhcmVcblx0XHQgKiAgQHJldHVybnMge09iamVjdH0gVGhlIGV2ZW50IG9iamVjdCBzZXQgYWZ0ZXIgdGhhdCB0aW1lLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRpbWUsIGNvbXBhcml0b3IpIHtcblx0ICAgICAgICBjb21wYXJpdG9yID0gVG9uZS5kZWZhdWx0QXJnKGNvbXBhcml0b3IsICd0aW1lJyk7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fc2VhcmNoKHRpbWUsIGNvbXBhcml0b3IpO1xuXHQgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lW2luZGV4XTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgZmlyc3QgZXZlbnQgaW4gdGhlIHRpbWVsaW5lIHdpdGhvdXQgcmVtb3ZpbmcgaXRcblx0XHQgKiAgQHJldHVybnMge09iamVjdH0gVGhlIGZpcnN0IGV2ZW50IG9iamVjdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmVbMF07XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgZmlyc3QgZXZlbnQgaW4gdGhlIHRpbWVsaW5lIGFuZCByZW1vdmUgaXRcblx0XHQgKiAgQHJldHVybnMge09iamVjdH0gVGhlIGZpcnN0IGV2ZW50IG9iamVjdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lLnNoaWZ0KCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCB0aGUgZXZlbnQgd2hpY2ggaXMgc2NoZWR1bGVkIGFmdGVyIHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgY29tcGFyaXRvciBXaGljaCB2YWx1ZSBpbiB0aGUgb2JqZWN0IHRvIGNvbXBhcmVcblx0XHQgKiAgQHJldHVybnMge09iamVjdH0gVGhlIGV2ZW50IG9iamVjdCBhZnRlciB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuZ2V0QWZ0ZXIgPSBmdW5jdGlvbiAodGltZSwgY29tcGFyaXRvcikge1xuXHQgICAgICAgIGNvbXBhcml0b3IgPSBUb25lLmRlZmF1bHRBcmcoY29tcGFyaXRvciwgJ3RpbWUnKTtcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9zZWFyY2godGltZSwgY29tcGFyaXRvcik7XG5cdCAgICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX3RpbWVsaW5lLmxlbmd0aCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmVbaW5kZXggKyAxXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCB0aGUgZXZlbnQgYmVmb3JlIHRoZSBldmVudCBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIGNvbXBhcml0b3IgV2hpY2ggdmFsdWUgaW4gdGhlIG9iamVjdCB0byBjb21wYXJlXG5cdFx0ICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBldmVudCBvYmplY3QgYmVmb3JlIHRoZSBnaXZlbiB0aW1lXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5nZXRCZWZvcmUgPSBmdW5jdGlvbiAodGltZSwgY29tcGFyaXRvcikge1xuXHQgICAgICAgIGNvbXBhcml0b3IgPSBUb25lLmRlZmF1bHRBcmcoY29tcGFyaXRvciwgJ3RpbWUnKTtcblx0ICAgICAgICB2YXIgbGVuID0gdGhpcy5fdGltZWxpbmUubGVuZ3RoO1xuXHQgICAgICAgIC8vaWYgaXQncyBhZnRlciB0aGUgbGFzdCBpdGVtLCByZXR1cm4gdGhlIGxhc3QgaXRlbVxuXHQgICAgICAgIGlmIChsZW4gPiAwICYmIHRoaXMuX3RpbWVsaW5lW2xlbiAtIDFdW2NvbXBhcml0b3JdIDwgdGltZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmVbbGVuIC0gMV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3NlYXJjaCh0aW1lLCBjb21wYXJpdG9yKTtcblx0ICAgICAgICBpZiAoaW5kZXggLSAxID49IDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lW2luZGV4IC0gMV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYW5jZWwgZXZlbnRzIGFmdGVyIHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIHRvIHF1ZXJ5LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fc2VhcmNoKGFmdGVyKTtcblx0ICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl90aW1lbGluZVtpbmRleF0udGltZSA9PT0gYWZ0ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgZmlyc3QgaXRlbSB3aXRoIHRoYXQgdGltZVxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleDsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lW2ldLnRpbWUgPT09IGFmdGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lbGluZSA9IHRoaXMuX3RpbWVsaW5lLnNsaWNlKDAsIGluZGV4KTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUgPSB0aGlzLl90aW1lbGluZS5zbGljZSgwLCBpbmRleCArIDEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUgPSBbXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdGltZWxpbmUubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgIC8vdGhlIGZpcnN0IGl0ZW0ncyB0aW1lXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl90aW1lbGluZVswXS50aW1lID49IGFmdGVyKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl90aW1lbGluZSA9IFtdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYW5jZWwgZXZlbnRzIGJlZm9yZSBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gY2FuY2VsIGJlZm9yZS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmNhbmNlbEJlZm9yZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9zZWFyY2godGltZSk7XG5cdCAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl90aW1lbGluZSA9IHRoaXMuX3RpbWVsaW5lLnNsaWNlKGluZGV4ICsgMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogUmV0dXJucyB0aGUgcHJldmlvdXMgZXZlbnQgaWYgdGhlcmUgaXMgb25lLiBudWxsIG90aGVyd2lzZVxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHRvIGZpbmQgdGhlIHByZXZpb3VzIG9uZSBvZlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gICAgICAgVGhlIGV2ZW50IHJpZ2h0IGJlZm9yZSB0aGUgZ2l2ZW4gZXZlbnRcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLnByZXZpb3VzRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl90aW1lbGluZS5pbmRleE9mKGV2ZW50KTtcblx0ICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZVtpbmRleCAtIDFdO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRG9lcyBhIGJpbmFyeSBzZXJhY2ggb24gdGhlIHRpbWVsaW5lIGFycmF5IGFuZCByZXR1cm5zIHRoZSBcblx0XHQgKiAgbmVhcmVzdCBldmVudCBpbmRleCB3aG9zZSB0aW1lIGlzIGFmdGVyIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBJZiBhIHRpbWUgaXMgc2VhcmNoZWQgYmVmb3JlIHRoZSBmaXJzdCBpbmRleCBpbiB0aGUgdGltZWxpbmUsIC0xIGlzIHJldHVybmVkLlxuXHRcdCAqICBJZiB0aGUgdGltZSBpcyBhZnRlciB0aGUgZW5kLCB0aGUgaW5kZXggb2YgdGhlIGxhc3QgaXRlbSBpcyByZXR1cm5lZC5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIGNvbXBhcml0b3IgV2hpY2ggdmFsdWUgaW4gdGhlIG9iamVjdCB0byBjb21wYXJlXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9IHRoZSBpbmRleCBpbiB0aGUgdGltZWxpbmUgYXJyYXkgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5fc2VhcmNoID0gZnVuY3Rpb24gKHRpbWUsIGNvbXBhcml0b3IpIHtcblx0ICAgICAgICBjb21wYXJpdG9yID0gVG9uZS5kZWZhdWx0QXJnKGNvbXBhcml0b3IsICd0aW1lJyk7XG5cdCAgICAgICAgdmFyIGJlZ2lubmluZyA9IDA7XG5cdCAgICAgICAgdmFyIGxlbiA9IHRoaXMuX3RpbWVsaW5lLmxlbmd0aDtcblx0ICAgICAgICB2YXIgZW5kID0gbGVuO1xuXHQgICAgICAgIGlmIChsZW4gPiAwICYmIHRoaXMuX3RpbWVsaW5lW2xlbiAtIDFdW2NvbXBhcml0b3JdIDw9IHRpbWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxlbiAtIDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHdoaWxlIChiZWdpbm5pbmcgPCBlbmQpIHtcblx0ICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBtaWRwb2ludCBmb3Igcm91Z2hseSBlcXVhbCBwYXJ0aXRpb25cblx0ICAgICAgICAgICAgdmFyIG1pZFBvaW50ID0gTWF0aC5mbG9vcihiZWdpbm5pbmcgKyAoZW5kIC0gYmVnaW5uaW5nKSAvIDIpO1xuXHQgICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLl90aW1lbGluZVttaWRQb2ludF07XG5cdCAgICAgICAgICAgIHZhciBuZXh0RXZlbnQgPSB0aGlzLl90aW1lbGluZVttaWRQb2ludCArIDFdO1xuXHQgICAgICAgICAgICBpZiAoZXZlbnRbY29tcGFyaXRvcl0gPT09IHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgIC8vY2hvb3NlIHRoZSBsYXN0IG9uZSB0aGF0IGhhcyB0aGUgc2FtZSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbWlkUG9pbnQ7IGkgPCB0aGlzLl90aW1lbGluZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0RXZlbnQgPSB0aGlzLl90aW1lbGluZVtpXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGVzdEV2ZW50W2NvbXBhcml0b3JdID09PSB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1pZFBvaW50ID0gaTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbWlkUG9pbnQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRbY29tcGFyaXRvcl0gPCB0aW1lICYmIG5leHRFdmVudFtjb21wYXJpdG9yXSA+IHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBtaWRQb2ludDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudFtjb21wYXJpdG9yXSA+IHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgIC8vc2VhcmNoIGxvd2VyXG5cdCAgICAgICAgICAgICAgICBlbmQgPSBtaWRQb2ludDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vc2VhcmNoIHVwcGVyXG5cdCAgICAgICAgICAgICAgICBiZWdpbm5pbmcgPSBtaWRQb2ludCArIDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBpdGVyYXRvci4gQXBwbGllcyBleHRyYSBzYWZldHkgY2hlY2tzIGZvciBcblx0XHQgKiAgcmVtb3ZpbmcgaXRlbXMgZnJvbSB0aGUgYXJyYXkuIFxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXI9fSAgICBsb3dlckJvdW5kICAgICBcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyPX0gICAgdXBwZXJCb3VuZCAgICBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLl9pdGVyYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG5cdCAgICAgICAgdGhpcy5faXRlcmF0aW5nID0gdHJ1ZTtcblx0ICAgICAgICBsb3dlckJvdW5kID0gVG9uZS5kZWZhdWx0QXJnKGxvd2VyQm91bmQsIDApO1xuXHQgICAgICAgIHVwcGVyQm91bmQgPSBUb25lLmRlZmF1bHRBcmcodXBwZXJCb3VuZCwgdGhpcy5fdGltZWxpbmUubGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IGxvd2VyQm91bmQ7IGkgPD0gdXBwZXJCb3VuZDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fdGltZWxpbmVbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9pdGVyYXRpbmcgPSBmYWxzZTtcblx0ICAgICAgICBpZiAodGhpcy5fdG9SZW1vdmUubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3RvUmVtb3ZlLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl90aW1lbGluZS5pbmRleE9mKHRoaXMuX3RvUmVtb3ZlW2pdKTtcblx0ICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lbGluZS5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3RvUmVtb3ZlID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgZXZlcnl0aGluZyBpbiB0aGUgYXJyYXlcblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZXZlcnkgaXRlbVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgIHRoaXMuX2l0ZXJhdGUoY2FsbGJhY2spO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgZXZlcnl0aGluZyBpbiB0aGUgYXJyYXkgYXQgb3IgYmVmb3JlIHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lIFRoZSB0aW1lIHRvIGNoZWNrIGlmIGl0ZW1zIGFyZSBiZWZvcmVcblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZXZlcnkgaXRlbVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuZm9yRWFjaEJlZm9yZSA9IGZ1bmN0aW9uICh0aW1lLCBjYWxsYmFjaykge1xuXHQgICAgICAgIC8vaXRlcmF0ZSBvdmVyIHRoZSBpdGVtcyBpbiByZXZlcnNlIHNvIHRoYXQgcmVtb3ZpbmcgYW4gaXRlbSBkb2Vzbid0IGJyZWFrIHRoaW5nc1xuXHQgICAgICAgIHZhciB1cHBlckJvdW5kID0gdGhpcy5fc2VhcmNoKHRpbWUpO1xuXHQgICAgICAgIGlmICh1cHBlckJvdW5kICE9PSAtMSkge1xuXHQgICAgICAgICAgICB0aGlzLl9pdGVyYXRlKGNhbGxiYWNrLCAwLCB1cHBlckJvdW5kKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEl0ZXJhdGUgb3ZlciBldmVyeXRoaW5nIGluIHRoZSBhcnJheSBhZnRlciB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSBUaGUgdGltZSB0byBjaGVjayBpZiBpdGVtcyBhcmUgYmVmb3JlXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2hBZnRlciA9IGZ1bmN0aW9uICh0aW1lLCBjYWxsYmFjaykge1xuXHQgICAgICAgIC8vaXRlcmF0ZSBvdmVyIHRoZSBpdGVtcyBpbiByZXZlcnNlIHNvIHRoYXQgcmVtb3ZpbmcgYW4gaXRlbSBkb2Vzbid0IGJyZWFrIHRoaW5nc1xuXHQgICAgICAgIHZhciBsb3dlckJvdW5kID0gdGhpcy5fc2VhcmNoKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2l0ZXJhdGUoY2FsbGJhY2ssIGxvd2VyQm91bmQgKyAxKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5IGF0IG9yIGFmdGVyIHRoZSBnaXZlbiB0aW1lLiBTaW1pbGFyIHRvIFxuXHRcdCAqICBmb3JFYWNoQWZ0ZXIsIGJ1dCBpbmNsdWRlcyB0aGUgaXRlbShzKSBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSBUaGUgdGltZSB0byBjaGVjayBpZiBpdGVtcyBhcmUgYmVmb3JlXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2hGcm9tID0gZnVuY3Rpb24gKHRpbWUsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgLy9pdGVyYXRlIG92ZXIgdGhlIGl0ZW1zIGluIHJldmVyc2Ugc28gdGhhdCByZW1vdmluZyBhbiBpdGVtIGRvZXNuJ3QgYnJlYWsgdGhpbmdzXG5cdCAgICAgICAgdmFyIGxvd2VyQm91bmQgPSB0aGlzLl9zZWFyY2godGltZSk7XG5cdCAgICAgICAgLy93b3JrIGJhY2t3YXJkcyB1bnRpbCB0aGUgZXZlbnQgdGltZSBpcyBsZXNzIHRoYW4gdGltZVxuXHQgICAgICAgIHdoaWxlIChsb3dlckJvdW5kID49IDAgJiYgdGhpcy5fdGltZWxpbmVbbG93ZXJCb3VuZF0udGltZSA+PSB0aW1lKSB7XG5cdCAgICAgICAgICAgIGxvd2VyQm91bmQtLTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5faXRlcmF0ZShjYWxsYmFjaywgbG93ZXJCb3VuZCArIDEpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgZXZlcnl0aGluZyBpbiB0aGUgYXJyYXkgYXQgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSBUaGUgdGltZSB0byBjaGVjayBpZiBpdGVtcyBhcmUgYmVmb3JlXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2hBdFRpbWUgPSBmdW5jdGlvbiAodGltZSwgY2FsbGJhY2spIHtcblx0ICAgICAgICAvL2l0ZXJhdGUgb3ZlciB0aGUgaXRlbXMgaW4gcmV2ZXJzZSBzbyB0aGF0IHJlbW92aW5nIGFuIGl0ZW0gZG9lc24ndCBicmVhayB0aGluZ3Ncblx0ICAgICAgICB2YXIgdXBwZXJCb3VuZCA9IHRoaXMuX3NlYXJjaCh0aW1lKTtcblx0ICAgICAgICBpZiAodXBwZXJCb3VuZCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgdGhpcy5faXRlcmF0ZShmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChldmVudC50aW1lID09PSB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBldmVudCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sIDAsIHVwcGVyQm91bmQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlRpbWVsaW5lfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fdGltZWxpbmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3RvUmVtb3ZlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5UaW1lbGluZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIHNoaW1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIGlmICghd2luZG93Lmhhc093blByb3BlcnR5KCdBdWRpb0NvbnRleHQnKSAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ3dlYmtpdEF1ZGlvQ29udGV4dCcpKSB7XG5cdCAgICAgICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG5cdCAgICB9XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgQXVkaW9Db250ZXh0LlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FbWl0dGVyfVxuXHRcdCAqICBAcGFyYW0ge0F1ZGlvQ29udGV4dD19IGNvbnRleHQgb3B0aW9uYWxseSBwYXNzIGluIGEgY29udGV4dFxuXHRcdCAqL1xuXHQgICAgVG9uZS5Db250ZXh0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRW1pdHRlci5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsnY29udGV4dCddLCBUb25lLkNvbnRleHQpO1xuXHQgICAgICAgIGlmICghb3B0aW9ucy5jb250ZXh0KSB7XG5cdCAgICAgICAgICAgIG9wdGlvbnMuY29udGV4dCA9IG5ldyB3aW5kb3cuQXVkaW9Db250ZXh0KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2NvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG5cdCAgICAgICAgLy8gZXh0ZW5kIGFsbCBvZiB0aGUgbWV0aG9kc1xuXHQgICAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5fY29udGV4dCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLl9jb250ZXh0LCBwcm9wKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlZmF1bHQgbGF0ZW5jeSBoaW50XG5cdFx0XHQgKiAgQHR5cGUgIHtTdHJpbmd9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xhdGVuY3lIaW50ID0gb3B0aW9ucy5sYXRlbmN5SGludDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgb2YgdGhlIGNvbnN0YW50cyBBdWRpb0J1ZmZlclNvdXJjZU5vZGVzXG5cdFx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NvbnN0YW50cyA9IHt9O1xuXHQgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgLy8gV09SS0VSXG5cdCAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIHRpbWUgZXZlbnRzIGFyZSBzY2hlZHVsZWRcblx0XHRcdCAqICBpbnRvIHRoZSBmdXR1cmVcblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBvcHRpb25zLmxvb2tBaGVhZDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIHJlZmVyZW5jZSB0byB0aGUgYWN0dWFsIGNvbXB1dGVkIHVwZGF0ZSBpbnRlcnZhbFxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jb21wdXRlZFVwZGF0ZUludGVydmFsID0gMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIHJlbGlhYmxlIGNhbGxiYWNrIG1ldGhvZFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUgIHtUaWNrZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90aWNrZXIgPSBuZXcgVGlja2VyKHRoaXMuZW1pdC5iaW5kKHRoaXMsICd0aWNrJyksIG9wdGlvbnMuY2xvY2tTb3VyY2UsIG9wdGlvbnMudXBkYXRlSW50ZXJ2YWwpO1xuXHQgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgLy8gVElNRU9VVFNcblx0ICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFsbCBvZiB0aGUgc2V0VGltZW91dCBldmVudHMuXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLlRpbWVsaW5lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90aW1lb3V0cyA9IG5ldyBUb25lLlRpbWVsaW5lKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHRpbWVvdXQgaWQgY291bnRlclxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3RpbWVvdXRJZHMgPSAwO1xuXHQgICAgICAgIHRoaXMub24oJ3RpY2snLCB0aGlzLl90aW1lb3V0TG9vcC5iaW5kKHRoaXMpKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkNvbnRleHQsIFRvbmUuRW1pdHRlcik7XG5cdCAgICBUb25lLkVtaXR0ZXIubWl4aW4oVG9uZS5Db250ZXh0KTtcblx0ICAgIC8qKlxuXHRcdCAqIGRlZmF1bHRzXG5cdFx0ICogQHN0YXRpY1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnRleHQuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2Nsb2NrU291cmNlJzogJ3dvcmtlcicsXG5cdCAgICAgICAgJ2xhdGVuY3lIaW50JzogJ2ludGVyYWN0aXZlJyxcblx0ICAgICAgICAnbG9va0FoZWFkJzogMC4xLFxuXHQgICAgICAgICd1cGRhdGVJbnRlcnZhbCc6IDAuMDNcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRGVmaW5lIGEgcHJvcGVydHkgb24gdGhpcyBUb25lLkNvbnRleHQuIFxuXHRcdCAqICBUaGlzIGlzIHVzZWQgdG8gZXh0ZW5kIHRoZSBuYXRpdmUgQXVkaW9Db250ZXh0XG5cdFx0ICogIEBwYXJhbSAge0F1ZGlvQ29udGV4dH0gIGNvbnRleHRcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgcHJvcCBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udGV4dC5wcm90b3R5cGUuX2RlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKGNvbnRleHQsIHByb3ApIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKHRoaXNbcHJvcF0pKSB7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wLCB7XG5cdCAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHRbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRbcHJvcF0uYmluZChjb250ZXh0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dFtwcm9wXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29udGV4dFtwcm9wXSA9IHZhbDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgY3VycmVudCBhdWRpbyBjb250ZXh0IHRpbWVcblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udGV4dC5wcm90b3R5cGUubm93ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy5sb29rQWhlYWQ7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdlbmVyYXRlIGEgbG9vcGVkIGJ1ZmZlciBhdCBzb21lIGNvbnN0YW50IHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB2YWxcblx0XHQgKiAgQHJldHVybiAge0J1ZmZlclNvdXJjZU5vZGV9XG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnRleHQucHJvdG90eXBlLmdldENvbnN0YW50ID0gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9jb25zdGFudHNbdmFsXSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29uc3RhbnRzW3ZhbF07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDEyOCwgdGhpcy5fY29udGV4dC5zYW1wbGVSYXRlKTtcblx0ICAgICAgICAgICAgdmFyIGFyciA9IGJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGFycltpXSA9IHZhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgY29uc3RhbnQgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXHQgICAgICAgICAgICBjb25zdGFudC5jaGFubmVsQ291bnQgPSAxO1xuXHQgICAgICAgICAgICBjb25zdGFudC5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0Jztcblx0ICAgICAgICAgICAgY29uc3RhbnQuYnVmZmVyID0gYnVmZmVyO1xuXHQgICAgICAgICAgICBjb25zdGFudC5sb29wID0gdHJ1ZTtcblx0ICAgICAgICAgICAgY29uc3RhbnQuc3RhcnQoMCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2NvbnN0YW50c1t2YWxdID0gY29uc3RhbnQ7XG5cdCAgICAgICAgICAgIHJldHVybiBjb25zdGFudDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwcml2YXRlIGxvb3Agd2hpY2gga2VlcHMgdHJhY2sgb2YgdGhlIGNvbnRleHQgc2NoZWR1bGVkIHRpbWVvdXRzXG5cdFx0ICogIElzIGludm9rZWQgZnJvbSB0aGUgY2xvY2sgc291cmNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnRleHQucHJvdG90eXBlLl90aW1lb3V0TG9vcCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICB3aGlsZSAodGhpcy5fdGltZW91dHMgJiYgdGhpcy5fdGltZW91dHMubGVuZ3RoICYmIHRoaXMuX3RpbWVvdXRzLnBlZWsoKS50aW1lIDw9IG5vdykge1xuXHQgICAgICAgICAgICB0aGlzLl90aW1lb3V0cy5zaGlmdCgpLmNhbGxiYWNrKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBIHNldFRpbWVvdXQgd2hpY2ggaXMgZ2F1cmVudGVlZCBieSB0aGUgY2xvY2sgc291cmNlLiBcblx0XHQgKiAgQWxzbyBydW5zIGluIHRoZSBvZmZsaW5lIGNvbnRleHQuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgZm4gICAgICAgVGhlIGNhbGxiYWNrIHRvIGludm9rZVxuXHRcdCAqICBAcGFyYW0gIHtTZWNvbmRzfSAgICB0aW1lb3V0ICBUaGUgdGltZW91dCBpbiBzZWNvbmRzXG5cdFx0ICogIEByZXR1cm5zIHtOdW1iZXJ9IElEIHRvIHVzZSB3aGVuIGludm9raW5nIFRvbmUuQ29udGV4dC5jbGVhclRpbWVvdXRcblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udGV4dC5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChmbiwgdGltZW91dCkge1xuXHQgICAgICAgIHRoaXMuX3RpbWVvdXRJZHMrKztcblx0ICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICB0aGlzLl90aW1lb3V0cy5hZGQoe1xuXHQgICAgICAgICAgICBjYWxsYmFjazogZm4sXG5cdCAgICAgICAgICAgIHRpbWU6IG5vdyArIHRpbWVvdXQsXG5cdCAgICAgICAgICAgIGlkOiB0aGlzLl90aW1lb3V0SWRzXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVvdXRJZHM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFycyBhIHByZXZpb3VzbHkgc2NoZWR1bGVkIHRpbWVvdXQgd2l0aCBUb25lLmNvbnRleHQuc2V0VGltZW91dFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICBpZCAgVGhlIElEIHJldHVybmVkIGZyb20gc2V0VGltZW91dFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5Db250ZXh0fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Db250ZXh0LnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgICB0aGlzLl90aW1lb3V0cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBpZiAoZXZlbnQuaWQgPT09IGlkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShldmVudCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSG93IG9mdGVuIHRoZSBXZWIgV29ya2VyIGNhbGxiYWNrIGlzIGludm9rZWQuXG5cdFx0ICogIFRoaXMgbnVtYmVyIGNvcnJlc3BvbmRzIHRvIGhvdyByZXNwb25zaXZlIHRoZSBzY2hlZHVsaW5nXG5cdFx0ICogIGNhbiBiZS4gQ29udGV4dC51cGRhdGVJbnRlcnZhbCArIENvbnRleHQubG9va0FoZWFkIGdpdmVzIHlvdSB0aGVcblx0XHQgKiAgdG90YWwgbGF0ZW5jeSBiZXR3ZWVuIHNjaGVkdWxpbmcgYW4gZXZlbnQgYW5kIGhlYXJpbmcgaXQuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkNvbnRleHQjXG5cdFx0ICogIEBuYW1lIHVwZGF0ZUludGVydmFsXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Db250ZXh0LnByb3RvdHlwZSwgJ3VwZGF0ZUludGVydmFsJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGlja2VyLnVwZGF0ZUludGVydmFsO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdGlja2VyLnVwZGF0ZUludGVydmFsID0gaW50ZXJ2YWw7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgV2hhdCB0aGUgc291cmNlIG9mIHRoZSBjbG9jayBpcywgZWl0aGVyIFwid29ya2VyXCIgKFdlYiBXb3JrZXIgW2RlZmF1bHRdKSwgXG5cdFx0ICogIFwidGltZW91dFwiIChzZXRUaW1lb3V0KSwgb3IgXCJvZmZsaW5lXCIgKG5vbmUpLiBcblx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQ29udGV4dCNcblx0XHQgKiAgQG5hbWUgY2xvY2tTb3VyY2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNvbnRleHQucHJvdG90eXBlLCAnY2xvY2tTb3VyY2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWNrZXIudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdGlja2VyLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB0eXBlIG9mIHBsYXliYWNrLCB3aGljaCBhZmZlY3RzIHRyYWRlb2ZmcyBiZXR3ZWVuIGF1ZGlvIFxuXHRcdCAqICBvdXRwdXQgbGF0ZW5jeSBhbmQgcmVzcG9uc2l2ZW5lc3MuIFxuXHRcdCAqICBcblx0XHQgKiAgSW4gYWRkaXRpb24gdG8gc2V0dGluZyB0aGUgdmFsdWUgaW4gc2Vjb25kcywgdGhlIGxhdGVuY3lIaW50IGFsc29cblx0XHQgKiAgYWNjZXB0cyB0aGUgc3RyaW5ncyBcImludGVyYWN0aXZlXCIgKHByaW9yaXRpemVzIGxvdyBsYXRlbmN5KSwgXG5cdFx0ICogIFwicGxheWJhY2tcIiAocHJpb3JpdGl6ZXMgc3VzdGFpbmVkIHBsYXliYWNrKSwgXCJiYWxhbmNlZFwiIChiYWxhbmNlc1xuXHRcdCAqICBsYXRlbmN5IGFuZCBwZXJmb3JtYW5jZSksIGFuZCBcImZhc3Rlc3RcIiAobG93ZXN0IGxhdGVuY3ksIG1pZ2h0IGdsaXRjaCBtb3JlIG9mdGVuKS4gXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd8U2Vjb25kc31cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQ29udGV4dCNcblx0XHQgKiAgQG5hbWUgbGF0ZW5jeUhpbnRcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3NldCB0aGUgbG9va0FoZWFkIHRvIDAuMyBzZWNvbmRzXG5cdFx0ICogVG9uZS5jb250ZXh0LmxhdGVuY3lIaW50ID0gMC4zO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ29udGV4dC5wcm90b3R5cGUsICdsYXRlbmN5SGludCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVuY3lIaW50O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoaGludCkge1xuXHQgICAgICAgICAgICB2YXIgbG9va0FoZWFkID0gaGludDtcblx0ICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeUhpbnQgPSBoaW50O1xuXHQgICAgICAgICAgICBpZiAoVG9uZS5pc1N0cmluZyhoaW50KSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChoaW50KSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdpbnRlcmFjdGl2ZSc6XG5cdCAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gMC4xO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGF0ZW5jeUhpbnQgPSBoaW50O1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAncGxheWJhY2snOlxuXHQgICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IDAuODtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxhdGVuY3lIaW50ID0gaGludDtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2JhbGFuY2VkJzpcblx0ICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSAwLjI1O1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGF0ZW5jeUhpbnQgPSBoaW50O1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnZmFzdGVzdCc6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5sYXRlbmN5SGludCA9ICdpbnRlcmFjdGl2ZSc7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gMC4wMTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcblx0ICAgICAgICAgICAgdGhpcy51cGRhdGVJbnRlcnZhbCA9IGxvb2tBaGVhZCAvIDM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ29udGV4dH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Db250ZXh0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQ29udGV4dC5lbWl0KCdjbG9zZScsIHRoaXMpO1xuXHQgICAgICAgIFRvbmUuRW1pdHRlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3RpY2tlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdGlja2VyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl90aW1lb3V0cy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdGltZW91dHMgPSBudWxsO1xuXHQgICAgICAgIGZvciAodmFyIGNvbiBpbiB0aGlzLl9jb25zdGFudHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY29uc3RhbnRzW2Nvbl0uZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9jb25zdGFudHMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuY2xvc2UoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBAY2xhc3MgQSBjbGFzcyB3aGljaCBwcm92aWRlcyBhIHJlbGlhYmxlIGNhbGxiYWNrIHVzaW5nIGVpdGhlclxuXHRcdCAqICAgICAgICBhIFdlYiBXb3JrZXIsIG9yIGlmIHRoYXQgaXNuJ3Qgc3VwcG9ydGVkLCBmYWxscyBiYWNrIHRvIHNldFRpbWVvdXQuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIHZhciBUaWNrZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHR5cGUsIHVwZGF0ZUludGVydmFsKSB7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBFaXRoZXIgXCJ3b3JrZXJcIiBvciBcInRpbWVvdXRcIlxuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSB1cGRhdGUgaW50ZXJ2YWwgb2YgdGhlIHdvcmtlclxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl91cGRhdGVJbnRlcnZhbCA9IHVwZGF0ZUludGVydmFsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGNhbGxiYWNrIHRvIGludm9rZSBhdCByZWd1bGFyIGludGVydmFsc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NhbGxiYWNrID0gVG9uZS5kZWZhdWx0QXJnKGNhbGxiYWNrLCBUb25lLm5vT3ApO1xuXHQgICAgICAgIC8vY3JlYXRlIHRoZSBjbG9jayBzb3VyY2UgZm9yIHRoZSBmaXJzdCB0aW1lXG5cdCAgICAgICAgdGhpcy5fY3JlYXRlQ2xvY2soKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcG9zc2libGUgdGlja2VyIHR5cGVzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVGlja2VyLlR5cGUgPSB7XG5cdCAgICAgICAgV29ya2VyOiAnd29ya2VyJyxcblx0ICAgICAgICBUaW1lb3V0OiAndGltZW91dCcsXG5cdCAgICAgICAgT2ZmbGluZTogJ29mZmxpbmUnXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdlbmVyYXRlIGEgd2ViIHdvcmtlclxuXHRcdCAqICBAcmV0dXJuICB7V2ViV29ya2VyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVGlja2VyLnByb3RvdHlwZS5fY3JlYXRlV29ya2VyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vVVJMIFNoaW1cblx0ICAgICAgICB3aW5kb3cuVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuXHQgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoWy8vdGhlIGluaXRpYWwgdGltZW91dCB0aW1lXG5cdCAgICAgICAgICAgICd2YXIgdGltZW91dFRpbWUgPSAnICsgKHRoaXMuX3VwZGF0ZUludGVydmFsICogMTAwMCkudG9GaXhlZCgxKSArICc7JyArIC8vb25tZXNzYWdlIGNhbGxiYWNrXG5cdCAgICAgICAgICAgICdzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZyl7JyArICdcXHR0aW1lb3V0VGltZSA9IHBhcnNlSW50KG1zZy5kYXRhKTsnICsgJ307JyArIC8vdGhlIHRpY2sgZnVuY3Rpb24gd2hpY2ggcG9zdHMgYSBtZXNzYWdlXG5cdCAgICAgICAgICAgIC8vYW5kIHNjaGVkdWxlcyBhIG5ldyB0aWNrXG5cdCAgICAgICAgICAgICdmdW5jdGlvbiB0aWNrKCl7JyArICdcXHRzZXRUaW1lb3V0KHRpY2ssIHRpbWVvdXRUaW1lKTsnICsgJ1xcdHNlbGYucG9zdE1lc3NhZ2UoXFwndGlja1xcJyk7JyArICd9JyArIC8vY2FsbCB0aWNrIGluaXRpYWxseVxuXHQgICAgICAgICAgICAndGljaygpOyddKTtcblx0ICAgICAgICB2YXIgYmxvYlVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cdCAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVybCk7XG5cdCAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd29ya2VyID0gd29ya2VyO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIENyZWF0ZSBhIHRpbWVvdXQgbG9vcFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUaWNrZXIucHJvdG90eXBlLl9jcmVhdGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY3JlYXRlVGltZW91dCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9jYWxsYmFjaygpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5fdXBkYXRlSW50ZXJ2YWwgKiAxMDAwKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBDcmVhdGUgdGhlIGNsb2NrIHNvdXJjZS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVGlja2VyLnByb3RvdHlwZS5fY3JlYXRlQ2xvY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09IFRpY2tlci5UeXBlLldvcmtlcikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlV29ya2VyKCk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIC8vIHdvcmtlcnMgbm90IHN1cHBvcnRlZCwgZmFsbGJhY2sgdG8gdGltZW91dFxuXHQgICAgICAgICAgICAgICAgdGhpcy5fdHlwZSA9IFRpY2tlci5UeXBlLlRpbWVvdXQ7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVDbG9jaygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBUaWNrZXIuVHlwZS5UaW1lb3V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVRpbWVvdXQoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogQG1lbWJlck9mIFRpY2tlciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIHVwZGF0ZUludGVydmFsXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaWNrZXIucHJvdG90eXBlLCAndXBkYXRlSW50ZXJ2YWwnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVJbnRlcnZhbDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGludGVydmFsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUludGVydmFsID0gTWF0aC5tYXgoaW50ZXJ2YWwsIDEyOCAvIDQ0MTAwKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09IFRpY2tlci5UeXBlLldvcmtlcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fd29ya2VyLnBvc3RNZXNzYWdlKE1hdGgubWF4KGludGVydmFsICogMTAwMCwgMSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgdGlja2VyLCBlaXRoZXIgYSB3b3JrZXIgb3IgYSB0aW1lb3V0XG5cdFx0ICogQG1lbWJlck9mIFRpY2tlciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpY2tlci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZGlzcG9zZUNsb2NrKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB0aGlzLl9jcmVhdGVDbG9jaygpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogQ2xlYW4gdXAgdGhlIGN1cnJlbnQgY2xvY2sgc291cmNlXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRpY2tlci5wcm90b3R5cGUuX2Rpc3Bvc2VDbG9jayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5fdGltZW91dCkge1xuXHQgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5fd29ya2VyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3dvcmtlci50ZXJtaW5hdGUoKTtcblx0ICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9ubWVzc2FnZSA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIENsZWFuIHVwXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRpY2tlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9kaXNwb3NlQ2xvY2soKTtcblx0ICAgICAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNoaW0gYWxsIGNvbm5lY3QvZGlzY29ubmVjdCBhbmQgc29tZSBkZXByZWNhdGVkIG1ldGhvZHMgd2hpY2ggYXJlIHN0aWxsIGluXG5cdFx0ICogIHNvbWUgb2xkZXIgaW1wbGVtZW50YXRpb25zLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5nZXRDb250ZXh0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbmF0aXZlQ29ubmVjdCA9IEF1ZGlvTm9kZS5wcm90b3R5cGUuY29ubmVjdDtcblx0ICAgICAgICB2YXIgbmF0aXZlRGlzY29ubmVjdCA9IEF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdDtcblx0ICAgICAgICAvL3JlcGxhY2UgdGhlIG9sZCBjb25uZWN0IG1ldGhvZFxuXHQgICAgICAgIGZ1bmN0aW9uIHRvbmVDb25uZWN0KEIsIG91dE51bSwgaW5OdW0pIHtcblx0ICAgICAgICAgICAgaWYgKEIuaW5wdXQpIHtcblx0ICAgICAgICAgICAgICAgIGluTnVtID0gVG9uZS5kZWZhdWx0QXJnKGluTnVtLCAwKTtcblx0ICAgICAgICAgICAgICAgIGlmIChUb25lLmlzQXJyYXkoQi5pbnB1dCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoQi5pbnB1dFtpbk51bV0pO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoQi5pbnB1dCwgb3V0TnVtLCBpbk51bSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChCIGluc3RhbmNlb2YgQXVkaW9Ob2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUNvbm5lY3QuY2FsbCh0aGlzLCBCLCBvdXROdW0sIGluTnVtKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDb25uZWN0LmNhbGwodGhpcywgQiwgb3V0TnVtKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcnJvciBjb25uZWN0aW5nIHRvIG5vZGU6ICcgKyBCICsgJ1xcbicgKyBlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvL3JlcGxhY2UgdGhlIG9sZCBkaXNjb25uZWN0IG1ldGhvZFxuXHQgICAgICAgIGZ1bmN0aW9uIHRvbmVEaXNjb25uZWN0KEIsIG91dE51bSwgaW5OdW0pIHtcblx0ICAgICAgICAgICAgaWYgKEIgJiYgQi5pbnB1dCAmJiBUb25lLmlzQXJyYXkoQi5pbnB1dCkpIHtcblx0ICAgICAgICAgICAgICAgIGluTnVtID0gVG9uZS5kZWZhdWx0QXJnKGluTnVtLCAwKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdChCLmlucHV0W2luTnVtXSwgb3V0TnVtLCAwKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChCICYmIEIuaW5wdXQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdChCLmlucHV0LCBvdXROdW0sIGluTnVtKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbmF0aXZlRGlzY29ubmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXJyb3IgZGlzY29ubmVjdGluZyBub2RlOiAnICsgQiArICdcXG4nICsgZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKEF1ZGlvTm9kZS5wcm90b3R5cGUuY29ubmVjdCAhPT0gdG9uZUNvbm5lY3QpIHtcblx0ICAgICAgICAgICAgQXVkaW9Ob2RlLnByb3RvdHlwZS5jb25uZWN0ID0gdG9uZUNvbm5lY3Q7XG5cdCAgICAgICAgICAgIEF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IHRvbmVEaXNjb25uZWN0O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLy8gc2V0IHRoZSBhdWRpbyBjb250ZXh0IGluaXRpYWxseVxuXHQgICAgaWYgKFRvbmUuc3VwcG9ydGVkKSB7XG5cdCAgICAgICAgVG9uZS5jb250ZXh0ID0gbmV3IFRvbmUuQ29udGV4dCgpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBjb25zb2xlLndhcm4oJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFRvbmUuanMnKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBUb25lLkNvbnRleHQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5BdWRpb05vZGUgaXMgYSBiYXNlIGNsYXNzIGZvciBjbGFzc2VzIHdoaWNoIHByb2Nlc3MgYXVkaW8uXG5cdFx0ICogICAgICAgICBBdWRpb05vZGVzIGhhdmUgaW5wdXRzIGFuZCBvdXRwdXRzLlxuXHRcdCAqICBAcGFyYW1cdHtBdWRpb0NvbnRleHQ9fSBjb250ZXh0XHRUaGUgYXVkaW8gY29udGV4dCB0byB1c2Ugd2l0aCB0aGUgY2xhc3Ncblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICovXG5cdCAgICBUb25lLkF1ZGlvTm9kZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLy91c2UgdGhlIGRlZmF1bHQgY29udGV4dCBpZiBvbmUgaXMgbm90IHBhc3NlZCBpblxuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsnY29udGV4dCddLCB7ICdjb250ZXh0JzogVG9uZS5jb250ZXh0IH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIEF1ZGlvQ29udGV4dCBvZiB0aGlzIGluc3RhbmNlXG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICogQHR5cGUge0F1ZGlvQ29udGV4dH1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogR2V0IHRoZSBhdWRpbyBjb250ZXh0IGJlbG9uZ2luZyB0byB0aGlzIGluc3RhbmNlLlxuXHRcdCAqIEB0eXBlIHtBdWRpb05vZGV9XG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXVkaW9Ob2RlI1xuXHRcdCAqIEBuYW1lIGNvbnRleHRcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUsICdjb250ZXh0Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDcmVhdGUgaW5wdXQgYW5kIG91dHB1dHMgZm9yIHRoaXMgb2JqZWN0LlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICBbaW5wdXQ9MF0gICBUaGUgbnVtYmVyIG9mIGlucHV0c1xuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICBbb3V0cHV0cz0wXSAgVGhlIG51bWJlciBvZiBvdXRwdXRzXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkF1ZGlvTm9kZX0gIHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5jcmVhdGVJbnNPdXRzID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0cykge1xuXHQgICAgICAgIGlmIChpbnB1dHMgPT09IDEpIHtcblx0ICAgICAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChpbnB1dHMgPiAxKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgQXJyYXkoaW5wdXRzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG91dHB1dHMgPT09IDEpIHtcblx0ICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAob3V0cHV0cyA+IDEpIHtcblx0ICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSBuZXcgQXJyYXkob3V0cHV0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbnVtYmVyIG9mIGlucHV0cyBmZWVkaW5nIGludG8gdGhlIEF1ZGlvTm9kZS5cblx0XHQgKiAgRm9yIHNvdXJjZSBub2RlcywgdGhpcyB3aWxsIGJlIDAuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBuYW1lIG51bWJlck9mSW5wdXRzXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZSwgJ251bWJlck9mSW5wdXRzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pbnB1dCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKFRvbmUuaXNBcnJheSh0aGlzLmlucHV0KSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0Lmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBudW1iZXIgb2Ygb3V0cHV0cyBjb21pbmcgb3V0IG9mIHRoZSBBdWRpb05vZGUuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBuYW1lIG51bWJlck9mT3V0cHV0c1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUsICdudW1iZXJPZk91dHB1dHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKFRvbmUuaXNBcnJheSh0aGlzLm91dHB1dCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXQubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgY29ubmVjdCB0aGUgb3V0cHV0IG9mIGEgVG9uZU5vZGUgdG8gYW4gQXVkaW9QYXJhbSwgQXVkaW9Ob2RlLCBvciBUb25lTm9kZVxuXHRcdCAqICBAcGFyYW0gIHtUb25lIHwgQXVkaW9QYXJhbSB8IEF1ZGlvTm9kZX0gdW5pdFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW291dHB1dE51bT0wXSBvcHRpb25hbGx5IHdoaWNoIG91dHB1dCB0byBjb25uZWN0IGZyb21cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtpbnB1dE51bT0wXSBvcHRpb25hbGx5IHdoaWNoIGlucHV0IHRvIGNvbm5lY3QgdG9cblx0XHQgKiAgQHJldHVybnMge1RvbmUuQXVkaW9Ob2RlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1bml0LCBvdXRwdXROdW0sIGlucHV0TnVtKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNBcnJheSh0aGlzLm91dHB1dCkpIHtcblx0ICAgICAgICAgICAgb3V0cHV0TnVtID0gVG9uZS5kZWZhdWx0QXJnKG91dHB1dE51bSwgMCk7XG5cdCAgICAgICAgICAgIHRoaXMub3V0cHV0W291dHB1dE51bV0uY29ubmVjdCh1bml0LCAwLCBpbnB1dE51bSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5vdXRwdXQuY29ubmVjdCh1bml0LCBvdXRwdXROdW0sIGlucHV0TnVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGRpc2Nvbm5lY3QgdGhlIG91dHB1dFxuXHRcdCAqICBAcGFyYW0ge051bWJlcnxBdWRpb05vZGV9IG91dHB1dCBFaXRoZXIgdGhlIG91dHB1dCBpbmRleCB0byBkaXNjb25uZWN0XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHRoZSBvdXRwdXQgaXMgYW4gYXJyYXksIG9yIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlIHRvIGRpc2Nvbm5lY3QgZnJvbS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuQXVkaW9Ob2RlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvbiwgb3V0cHV0TnVtLCBpbnB1dE51bSkge1xuXHQgICAgICAgIGlmIChUb25lLmlzQXJyYXkodGhpcy5vdXRwdXQpKSB7XG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzTnVtYmVyKGRlc3RpbmF0aW9uKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRbZGVzdGluYXRpb25dLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG91dHB1dE51bSA9IFRvbmUuZGVmYXVsdEFyZyhvdXRwdXROdW0sIDApO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRbb3V0cHV0TnVtXS5kaXNjb25uZWN0KGRlc3RpbmF0aW9uLCAwLCBpbnB1dE51bSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0LmFwcGx5KHRoaXMub3V0cHV0LCBhcmd1bWVudHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29ubmVjdCB0aGUgb3V0cHV0IG9mIHRoaXMgbm9kZSB0byB0aGUgcmVzdCBvZiB0aGUgbm9kZXMgaW4gc2VyaWVzLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAvL2Nvbm5lY3QgYSBub2RlIHRvIGFuIGVmZmVjdCwgcGFuVm9sIGFuZCB0aGVuIHRvIHRoZSBtYXN0ZXIgb3V0cHV0XG5cdFx0ICogIG5vZGUuY2hhaW4oZWZmZWN0LCBwYW5Wb2wsIFRvbmUuTWFzdGVyKTtcblx0XHQgKiAgQHBhcmFtIHsuLi5BdWRpb1BhcmFtfFRvbmV8QXVkaW9Ob2RlfSBub2Rlc1xuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BdWRpb05vZGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgY3VycmVudFVuaXQgPSB0aGlzO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciB0b1VuaXQgPSBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgICAgIGN1cnJlbnRVbml0LmNvbm5lY3QodG9Vbml0KTtcblx0ICAgICAgICAgICAgY3VycmVudFVuaXQgPSB0b1VuaXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjb25uZWN0IHRoZSBvdXRwdXQgb2YgdGhpcyBub2RlIHRvIHRoZSByZXN0IG9mIHRoZSBub2RlcyBpbiBwYXJhbGxlbC5cblx0XHQgKiAgQHBhcmFtIHsuLi5BdWRpb1BhcmFtfFRvbmV8QXVkaW9Ob2RlfSBub2Rlc1xuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BdWRpb05vZGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5mYW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5jb25uZWN0KGFyZ3VtZW50c1tpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIGlmICh3aW5kb3cuQXVkaW9Ob2RlKSB7XG5cdCAgICAgICAgLy9naXZlIG5hdGl2ZSBub2RlcyBjaGFpbiBhbmQgZmFuIG1ldGhvZHNcblx0ICAgICAgICBBdWRpb05vZGUucHJvdG90eXBlLmNoYWluID0gVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmNoYWluO1xuXHQgICAgICAgIEF1ZGlvTm9kZS5wcm90b3R5cGUuZmFuID0gVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmZhbjtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHRcdCAqIERpc3Bvc2UgYW5kIGRpc2Nvbm5lY3Rcblx0XHQgKiBAcmV0dXJuIHtUb25lLkF1ZGlvTm9kZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKCFUb25lLmlzVW5kZWYodGhpcy5pbnB1dCkpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQgaW5zdGFuY2VvZiBBdWRpb05vZGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIVRvbmUuaXNVbmRlZih0aGlzLm91dHB1dCkpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0IGluc3RhbmNlb2YgQXVkaW9Ob2RlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5BdWRpb05vZGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQmFzZSBjbGFzcyBmb3IgYWxsIFNpZ25hbHMuIFVzZWQgSW50ZXJuYWxseS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICovXG5cdCAgICBUb25lLlNpZ25hbEJhc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlNpZ25hbEJhc2UsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBXaGVuIHNpZ25hbHMgY29ubmVjdCB0byBvdGhlciBzaWduYWxzIG9yIEF1ZGlvUGFyYW1zLFxuXHRcdCAqICB0aGV5IHRha2Ugb3ZlciB0aGUgb3V0cHV0IHZhbHVlIG9mIHRoYXQgc2lnbmFsIG9yIEF1ZGlvUGFyYW0uXG5cdFx0ICogIEZvciBhbGwgb3RoZXIgbm9kZXMsIHRoZSBiZWhhdmlvciBpcyB0aGUgc2FtZSBhcyBhIGRlZmF1bHQgPGNvZGU+Y29ubmVjdDwvY29kZT4uXG5cdFx0ICpcblx0XHQgKiAgQG92ZXJyaWRlXG5cdFx0ICogIEBwYXJhbSB7QXVkaW9QYXJhbXxBdWRpb05vZGV8VG9uZS5TaWduYWx8VG9uZX0gbm9kZVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW291dHB1dE51bWJlcj0wXSBUaGUgb3V0cHV0IG51bWJlciB0byBjb25uZWN0IGZyb20uXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXROdW1iZXI9MF0gVGhlIGlucHV0IG51bWJlciB0byBjb25uZWN0IHRvLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TaWduYWxCYXNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAobm9kZSwgb3V0cHV0TnVtYmVyLCBpbnB1dE51bWJlcikge1xuXHQgICAgICAgIC8vemVybyBpdCBvdXQgc28gdGhhdCB0aGUgc2lnbmFsIGNhbiBoYXZlIGZ1bGwgY29udHJvbFxuXHQgICAgICAgIGlmIChUb25lLlNpZ25hbCAmJiBUb25lLlNpZ25hbCA9PT0gbm9kZS5jb25zdHJ1Y3RvciB8fCBUb25lLlBhcmFtICYmIFRvbmUuUGFyYW0gPT09IG5vZGUuY29uc3RydWN0b3IgfHwgVG9uZS5UaW1lbGluZVNpZ25hbCAmJiBUb25lLlRpbWVsaW5lU2lnbmFsID09PSBub2RlLmNvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgICAgIC8vY2FuY2VsIGNoYW5nZXNcblx0ICAgICAgICAgICAgbm9kZS5fcGFyYW0uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKDApO1xuXHQgICAgICAgICAgICAvL3Jlc2V0IHRoZSB2YWx1ZVxuXHQgICAgICAgICAgICBub2RlLl9wYXJhbS52YWx1ZSA9IDA7XG5cdCAgICAgICAgICAgIC8vbWFyayB0aGUgdmFsdWUgYXMgb3ZlcnJpZGRlblxuXHQgICAgICAgICAgICBub2RlLm92ZXJyaWRkZW4gPSB0cnVlO1xuXHQgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEF1ZGlvUGFyYW0pIHtcblx0ICAgICAgICAgICAgbm9kZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoMCk7XG5cdCAgICAgICAgICAgIG5vZGUudmFsdWUgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMsIG5vZGUsIG91dHB1dE51bWJlciwgaW5wdXROdW1iZXIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNpZ25hbEJhc2U7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBXcmFwcyB0aGUgbmF0aXZlIFdlYiBBdWRpbyBBUEkgXG5cdFx0ICogICAgICAgICBbV2F2ZVNoYXBlck5vZGVdKGh0dHA6Ly93ZWJhdWRpby5naXRodWIuaW8vd2ViLWF1ZGlvLWFwaS8jdGhlLXdhdmVzaGFwZXJub2RlLWludGVyZmFjZSkuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb258QXJyYXl8TnVtYmVyfSBtYXBwaW5nIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGRlZmluZSB0aGUgdmFsdWVzLiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBtYXBwaW5nIGZ1bmN0aW9uIHNob3VsZCB0YWtlIHR3byBhcmd1bWVudHM6IFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGZpcnN0IGlzIHRoZSB2YWx1ZSBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSBhcnJheSBwb3NpdGlvbi4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHRoYXQgYXJyYXkgd2lsbCBiZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0IGFzIHRoZSB3YXZlIHNoYXBpbmcgZnVuY3Rpb24uIFRoZSBpbnB1dFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsIGlzIGFuIEF1ZGlvUmFuZ2UgWy0xLCAxXSB2YWx1ZSBhbmQgdGhlIG91dHB1dFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsIGNhbiB0YWtlIG9uIGFueSBudW1lcmljYWwgdmFsdWVzLiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gW2J1ZmZlckxlbj0xMDI0XSBUaGUgbGVuZ3RoIG9mIHRoZSBXYXZlU2hhcGVyTm9kZSBidWZmZXIuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHRpbWVzVHdvID0gbmV3IFRvbmUuV2F2ZVNoYXBlcihmdW5jdGlvbih2YWwpe1xuXHRcdCAqIFx0cmV0dXJuIHZhbCAqIDI7XG5cdFx0ICogfSwgMjA0OCk7XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9hIHdhdmVzaGFwZXIgY2FuIGFsc28gYmUgY29uc3RydWN0ZWQgd2l0aCBhbiBhcnJheSBvZiB2YWx1ZXNcblx0XHQgKiB2YXIgaW52ZXJ0ID0gbmV3IFRvbmUuV2F2ZVNoYXBlcihbMSwgLTFdKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuV2F2ZVNoYXBlciA9IGZ1bmN0aW9uIChtYXBwaW5nLCBidWZmZXJMZW4pIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgd2F2ZXNoYXBlclxuXHRcdFx0ICogIEB0eXBlIHtXYXZlU2hhcGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2hhcGVyID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZVdhdmVTaGFwZXIoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgd2F2ZXNoYXBlcnMgY3VydmVcblx0XHRcdCAqICBAdHlwZSB7RmxvYXQzMkFycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jdXJ2ZSA9IG51bGw7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGluZykpIHtcblx0ICAgICAgICAgICAgdGhpcy5jdXJ2ZSA9IG1hcHBpbmc7XG5cdCAgICAgICAgfSBlbHNlIGlmIChpc0Zpbml0ZShtYXBwaW5nKSB8fCBUb25lLmlzVW5kZWYobWFwcGluZykpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY3VydmUgPSBuZXcgRmxvYXQzMkFycmF5KFRvbmUuZGVmYXVsdEFyZyhtYXBwaW5nLCAxMDI0KSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzRnVuY3Rpb24obWFwcGluZykpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY3VydmUgPSBuZXcgRmxvYXQzMkFycmF5KFRvbmUuZGVmYXVsdEFyZyhidWZmZXJMZW4sIDEwMjQpKTtcblx0ICAgICAgICAgICAgdGhpcy5zZXRNYXAobWFwcGluZyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuV2F2ZVNoYXBlciwgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBVc2VzIGEgbWFwcGluZyBmdW5jdGlvbiB0byBzZXQgdGhlIHZhbHVlIG9mIHRoZSBjdXJ2ZS4gXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IG1hcHBpbmcgVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZGVmaW5lIHRoZSB2YWx1ZXMuIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBtYXBwaW5nIGZ1bmN0aW9uIHRha2UgdHdvIGFyZ3VtZW50czogXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGZpcnN0IGlzIHRoZSB2YWx1ZSBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBnb2VzIGZyb20gLTEgdG8gMSBvdmVyIHRoZSBudW1iZXIgb2YgZWxlbWVudHNcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgY3VydmUgYXJyYXkuIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgdGhlIGFycmF5IHBvc2l0aW9uLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuV2F2ZVNoYXBlcn0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vbWFwIHRoZSBpbnB1dCBzaWduYWwgZnJvbSBbLTEsIDFdIHRvIFswLCAxMF1cblx0XHQgKiBzaGFwZXIuc2V0TWFwKGZ1bmN0aW9uKHZhbCwgaW5kZXgpe1xuXHRcdCAqIFx0cmV0dXJuICh2YWwgKyAxKSAqIDU7XG5cdFx0ICogfSlcblx0XHQgKi9cblx0ICAgIFRvbmUuV2F2ZVNoYXBlci5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gKG1hcHBpbmcpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fY3VydmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBpIC8gKGxlbiAtIDEpICogMiAtIDE7XG5cdCAgICAgICAgICAgIHRoaXMuX2N1cnZlW2ldID0gbWFwcGluZyhub3JtYWxpemVkLCBpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyLmN1cnZlID0gdGhpcy5fY3VydmU7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGFycmF5IHRvIHNldCBhcyB0aGUgd2F2ZXNoYXBlciBjdXJ2ZS4gRm9yIGxpbmVhciBjdXJ2ZXNcblx0XHQgKiBhcnJheSBsZW5ndGggZG9lcyBub3QgbWFrZSBtdWNoIGRpZmZlcmVuY2UsIGJ1dCBmb3IgY29tcGxleCBjdXJ2ZXNcblx0XHQgKiBsb25nZXIgYXJyYXlzIHdpbGwgcHJvdmlkZSBzbW9vdGhlciBpbnRlcnBvbGF0aW9uLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5XYXZlU2hhcGVyI1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAbmFtZSBjdXJ2ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuV2F2ZVNoYXBlci5wcm90b3R5cGUsICdjdXJ2ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlci5jdXJ2ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1hcHBpbmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY3VydmUgPSBuZXcgRmxvYXQzMkFycmF5KG1hcHBpbmcpO1xuXHQgICAgICAgICAgICB0aGlzLl9zaGFwZXIuY3VydmUgPSB0aGlzLl9jdXJ2ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFNwZWNpZmllcyB3aGF0IHR5cGUgb2Ygb3ZlcnNhbXBsaW5nIChpZiBhbnkpIHNob3VsZCBiZSB1c2VkIHdoZW4gXG5cdFx0ICogYXBwbHlpbmcgdGhlIHNoYXBpbmcgY3VydmUuIENhbiBlaXRoZXIgYmUgXCJub25lXCIsIFwiMnhcIiBvciBcIjR4XCIuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLldhdmVTaGFwZXIjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSBvdmVyc2FtcGxlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5XYXZlU2hhcGVyLnByb3RvdHlwZSwgJ292ZXJzYW1wbGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaGFwZXIub3ZlcnNhbXBsZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG92ZXJzYW1wbGluZykge1xuXHQgICAgICAgICAgICBpZiAoW1xuXHQgICAgICAgICAgICAgICAgICAgICdub25lJyxcblx0ICAgICAgICAgICAgICAgICAgICAnMngnLFxuXHQgICAgICAgICAgICAgICAgICAgICc0eCdcblx0ICAgICAgICAgICAgICAgIF0uaW5kZXhPZihvdmVyc2FtcGxpbmcpICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc2hhcGVyLm92ZXJzYW1wbGUgPSBvdmVyc2FtcGxpbmc7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVG9uZS5XYXZlU2hhcGVyOiBvdmVyc2FtcGxpbmcgbXVzdCBiZSBlaXRoZXIgXFwnbm9uZVxcJywgXFwnMnhcXCcsIG9yIFxcJzR4XFwnJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuV2F2ZVNoYXBlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5XYXZlU2hhcGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NoYXBlci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9jdXJ2ZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuV2F2ZVNoYXBlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlRpbWVCYXNlIGlzIGEgZmxleGlibGUgZW5jb2Rpbmcgb2YgdGltZVxuXHRcdCAqICAgICAgICAgd2hpY2ggY2FuIGJlIGV2YWx1YXRlZCB0byBhbmQgZnJvbSBhIHN0cmluZy5cblx0XHQgKiAgICAgICAgIFBhcnNpbmcgY29kZSBtb2RpZmllZCBmcm9tIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdGFwZGlnaXQvXG5cdFx0ICogICAgICAgICBDb3B5cmlnaHQgMjAxMSAyMDEyIEFyaXlhIEhpZGF5YXQsIE5ldyBCU0QgTGljZW5zZVxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHZhbCAgICBUaGUgdGltZSB2YWx1ZSBhcyBhIG51bWJlciBvciBzdHJpbmdcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nPX0gIHVuaXRzICBVbml0IHZhbHVlc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuVGltZUJhc2UoNCwgXCJuXCIpXG5cdFx0ICogVG9uZS5UaW1lQmFzZSgyLCBcInRcIilcblx0XHQgKiBUb25lLlRpbWVCYXNlKFwiMnRcIikuYWRkKFwiMW1cIilcblx0XHQgKiBUb25lLlRpbWVCYXNlKFwiMnQgKyAxbVwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UgPSBmdW5jdGlvbiAodmFsLCB1bml0cykge1xuXHQgICAgICAgIC8vYWxsb3dzIGl0IHRvIGJlIGNvbnN0cnVjdGVkIHdpdGggb3Igd2l0aG91dCAnbmV3J1xuXHQgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgVG9uZS5UaW1lQmFzZSkge1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIEFueSBleHByZXNzaW9ucyBwYXJzZWQgZnJvbSB0aGUgVGltZVxuXHRcdFx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9leHByID0gdGhpcy5fbm9PcDtcblx0ICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFRvbmUuVGltZUJhc2UpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29weSh2YWwpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKCFUb25lLmlzVW5kZWYodW5pdHMpIHx8IFRvbmUuaXNOdW1iZXIodmFsKSkge1xuXHQgICAgICAgICAgICAgICAgLy9kZWZhdWx0IHVuaXRzXG5cdCAgICAgICAgICAgICAgICB1bml0cyA9IFRvbmUuZGVmYXVsdEFyZyh1bml0cywgdGhpcy5fZGVmYXVsdFVuaXRzKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLl9wcmltYXJ5RXhwcmVzc2lvbnNbdW5pdHNdLm1ldGhvZDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2V4cHIgPSBtZXRob2QuYmluZCh0aGlzLCB2YWwpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNTdHJpbmcodmFsKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXQodmFsKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzVW5kZWYodmFsKSkge1xuXHQgICAgICAgICAgICAgICAgLy9kZWZhdWx0IGV4cHJlc3Npb25cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2V4cHIgPSB0aGlzLl9kZWZhdWx0RXhwcigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBUb25lLlRpbWVCYXNlKHZhbCwgdW5pdHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlRpbWVCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXBhbGNlIHRoZSBjdXJyZW50IHRpbWUgdmFsdWUgd2l0aCB0aGUgdmFsdWVcblx0XHQgKiAgZ2l2ZW4gYnkgdGhlIGV4cHJlc3Npb24gc3RyaW5nLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBleHByU3RyaW5nXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuVGltZUJhc2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChleHByU3RyaW5nKSB7XG5cdCAgICAgICAgdGhpcy5fZXhwciA9IHRoaXMuX3BhcnNlRXhwclN0cmluZyhleHByU3RyaW5nKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIGEgY2xvbmUgb2YgdGhlIFRpbWVCYXNlIG9iamVjdC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuVGltZUJhc2V9IFRoZSBuZXcgY2xvbmVkIFRvbmUuVGltZUJhc2Vcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdCAgICAgICAgaW5zdGFuY2UuY29weSh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvcGllcyB0aGUgdmFsdWUgb2YgdGltZSB0byB0aGlzIFRpbWVcblx0XHQgKiAgQHBhcmFtIHtUb25lLlRpbWVCYXNlfSB0aW1lXG5cdFx0ICogIEByZXR1cm4gIHtUaW1lQmFzZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHZhciB2YWwgPSB0aW1lLl9leHByKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHZhbCk7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0QUJTVFJBQ1QgU1lOVEFYIFRSRUUgUEFSU0VSXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBBbGwgdGhlIHByaW1hcnkgZXhwcmVzc2lvbnMuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3ByaW1hcnlFeHByZXNzaW9ucyA9IHtcblx0ICAgICAgICAnbic6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXihcXGQrKW4vaSxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlYXRzVG9Vbml0cyh0aGlzLl90aW1lU2lnbmF0dXJlKCkpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVhdHNUb1VuaXRzKDQgLyB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICd0Jzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eKFxcZCspdC9pLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVhdHNUb1VuaXRzKDggLyAocGFyc2VJbnQodmFsdWUpICogMykpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnbSc6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXihcXGQrKW0vaSxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWF0c1RvVW5pdHMocGFyc2VJbnQodmFsdWUpICogdGhpcy5fdGltZVNpZ25hdHVyZSgpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ2knOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkKylpL2ksXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGlja3NUb1VuaXRzKHBhcnNlSW50KHZhbHVlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICdoeic6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXihcXGQrKD86XFwuXFxkKyk/KWh6L2ksXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJlcXVlbmN5VG9Vbml0cyhwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICd0cic6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXihcXGQrKD86XFwuXFxkKyk/KTooXFxkKyg/OlxcLlxcZCspPyk6PyhcXGQrKD86XFwuXFxkKyk/KT8vLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChtLCBxLCBzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSAwO1xuXHQgICAgICAgICAgICAgICAgaWYgKG0gJiYgbSAhPT0gJzAnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5fYmVhdHNUb1VuaXRzKHRoaXMuX3RpbWVTaWduYXR1cmUoKSAqIHBhcnNlRmxvYXQobSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHEgJiYgcSAhPT0gJzAnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5fYmVhdHNUb1VuaXRzKHBhcnNlRmxvYXQocSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHMgJiYgcyAhPT0gJzAnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5fYmVhdHNUb1VuaXRzKHBhcnNlRmxvYXQocykgLyA0KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b3RhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ3MnOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkKyg/OlxcLlxcZCspP3MpLyxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWNvbmRzVG9Vbml0cyhwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICdzYW1wbGVzJzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eKFxcZCspc2FtcGxlcy8sXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUpIC8gdGhpcy5jb250ZXh0LnNhbXBsZVJhdGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICdkZWZhdWx0Jzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eKFxcZCsoPzpcXC5cXGQrKT8pLyxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmltYXJ5RXhwcmVzc2lvbnNbdGhpcy5fZGVmYXVsdFVuaXRzXS5tZXRob2QuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFsbCB0aGUgYmluYXJ5IGV4cHJlc3Npb25zIHRoYXQgVGltZUJhc2UgY2FuIGFjY2VwdC5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fYmluYXJ5RXhwcmVzc2lvbnMgPSB7XG5cdCAgICAgICAgJysnOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL15cXCsvLFxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlOiAyLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChsaCwgcmgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaCgpICsgcmgoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJy0nOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL15cXC0vLFxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlOiAyLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChsaCwgcmgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaCgpIC0gcmgoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJyonOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL15cXCovLFxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlOiAxLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChsaCwgcmgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaCgpICogcmgoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJy8nOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL15cXC8vLFxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlOiAxLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChsaCwgcmgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaCgpIC8gcmgoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWxsIHRoZSB1bmFyeSBleHByZXNzaW9ucy5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucyA9IHtcblx0ICAgICAgICAnbmVnJzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eXFwtLyxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAobGgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAtbGgoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3ludGFjdGljIGdsdWUgd2hpY2ggaG9sZHMgZXhwcmVzc2lvbnMgdG9nZXRoZXJcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fc3ludGF4R2x1ZSA9IHtcblx0ICAgICAgICAnKCc6IHsgcmVnZXhwOiAvXlxcKC8gfSxcblx0ICAgICAgICAnKSc6IHsgcmVnZXhwOiAvXlxcKS8gfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICB0b2tlbml6ZSB0aGUgZXhwcmVzc2lvbiBiYXNlZCBvbiB0aGUgRXhwcmVzc2lvbnMgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSAgIHtzdHJpbmd9IGV4cHIgXG5cdFx0ICogIEByZXR1cm4gIHtPYmplY3R9ICAgICAgcmV0dXJucyB0d28gbWV0aG9kcyBvbiB0aGUgdG9rZW5pemVkIGxpc3QsIG5leHQgYW5kIHBlZWtcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl90b2tlbml6ZSA9IGZ1bmN0aW9uIChleHByKSB7XG5cdCAgICAgICAgdmFyIHBvc2l0aW9uID0gLTE7XG5cdCAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuXHQgICAgICAgIHdoaWxlIChleHByLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgZXhwciA9IGV4cHIudHJpbSgpO1xuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSBnZXROZXh0VG9rZW4oZXhwciwgdGhpcyk7XG5cdCAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgZXhwciA9IGV4cHIuc3Vic3RyKHRva2VuLnZhbHVlLmxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldE5leHRUb2tlbihleHByLCBjb250ZXh0KSB7XG5cdCAgICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtcblx0ICAgICAgICAgICAgICAgICdfYmluYXJ5RXhwcmVzc2lvbnMnLFxuXHQgICAgICAgICAgICAgICAgJ191bmFyeUV4cHJlc3Npb25zJyxcblx0ICAgICAgICAgICAgICAgICdfcHJpbWFyeUV4cHJlc3Npb25zJyxcblx0ICAgICAgICAgICAgICAgICdfc3ludGF4R2x1ZSdcblx0ICAgICAgICAgICAgXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gY29udGV4dFtleHByZXNzaW9uc1tpXV07XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvcE5hbWUgaW4gZ3JvdXApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBncm91cFtvcE5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZWcgPSBvcC5yZWdleHA7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gZXhwci5tYXRjaChyZWcpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBvcC5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBvcC5wcmVjZWRlbmNlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhwOiBvcC5yZWdleHAsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hbMF1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUb25lLlRpbWVCYXNlOiBVbmV4cGVjdGVkIHRva2VuICcgKyBleHByKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1srK3Bvc2l0aW9uXTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgcGVlazogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1twb3NpdGlvbiArIDFdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2l2ZW4gYSB0b2tlbiwgZmluZCB0aGUgdmFsdWUgd2l0aGluIHRoZSBncm91cE5hbWVcblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IHRva2VuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWVcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IHByZWNlZGVuY2Vcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9tYXRjaEdyb3VwID0gZnVuY3Rpb24gKHRva2VuLCBncm91cCwgcHJlYykge1xuXHQgICAgICAgIHZhciByZXQgPSBmYWxzZTtcblx0ICAgICAgICBpZiAoIVRvbmUuaXNVbmRlZih0b2tlbikpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgb3BOYW1lIGluIGdyb3VwKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3AgPSBncm91cFtvcE5hbWVdO1xuXHQgICAgICAgICAgICAgICAgaWYgKG9wLnJlZ2V4cC50ZXN0KHRva2VuLnZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKHByZWMpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcC5wcmVjZWRlbmNlID09PSBwcmVjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3A7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE1hdGNoIGEgYmluYXJ5IGV4cHJlc3Npb24gZ2l2ZW4gdGhlIHRva2VuIGFuZCB0aGUgcHJlY2VkZW5jZVxuXHRcdCAqICBAcGFyYW0ge0xleGVyfSBsZXhlclxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gcHJlY2VkZW5jZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3BhcnNlQmluYXJ5ID0gZnVuY3Rpb24gKGxleGVyLCBwcmVjZWRlbmNlKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNVbmRlZihwcmVjZWRlbmNlKSkge1xuXHQgICAgICAgICAgICBwcmVjZWRlbmNlID0gMjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGV4cHI7XG5cdCAgICAgICAgaWYgKHByZWNlZGVuY2UgPCAwKSB7XG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLl9wYXJzZVVuYXJ5KGxleGVyKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBleHByID0gdGhpcy5fcGFyc2VCaW5hcnkobGV4ZXIsIHByZWNlZGVuY2UgLSAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgIHdoaWxlICh0b2tlbiAmJiB0aGlzLl9tYXRjaEdyb3VwKHRva2VuLCB0aGlzLl9iaW5hcnlFeHByZXNzaW9ucywgcHJlY2VkZW5jZSkpIHtcblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgIGV4cHIgPSB0b2tlbi5tZXRob2QuYmluZCh0aGlzLCBleHByLCB0aGlzLl9wYXJzZUJpbmFyeShsZXhlciwgcHJlY2VkZW5jZSAtIDEpKTtcblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5wZWVrKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBleHByO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBNYXRjaCBhIHVuYXJ5IGV4cHJlc3Npb24uXG5cdFx0ICogIEBwYXJhbSB7TGV4ZXJ9IGxleGVyXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fcGFyc2VVbmFyeSA9IGZ1bmN0aW9uIChsZXhlcikge1xuXHQgICAgICAgIHZhciB0b2tlbiwgZXhwcjtcblx0ICAgICAgICB0b2tlbiA9IGxleGVyLnBlZWsoKTtcblx0ICAgICAgICB2YXIgb3AgPSB0aGlzLl9tYXRjaEdyb3VwKHRva2VuLCB0aGlzLl91bmFyeUV4cHJlc3Npb25zKTtcblx0ICAgICAgICBpZiAob3ApIHtcblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLl9wYXJzZVVuYXJ5KGxleGVyKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG9wLm1ldGhvZC5iaW5kKHRoaXMsIGV4cHIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VQcmltYXJ5KGxleGVyKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgTWF0Y2ggYSBwcmltYXJ5IGV4cHJlc3Npb24gKGEgdmFsdWUpLlxuXHRcdCAqICBAcGFyYW0ge0xleGVyfSBsZXhlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3BhcnNlUHJpbWFyeSA9IGZ1bmN0aW9uIChsZXhlcikge1xuXHQgICAgICAgIHZhciB0b2tlbiwgZXhwcjtcblx0ICAgICAgICB0b2tlbiA9IGxleGVyLnBlZWsoKTtcblx0ICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKHRva2VuKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RvbmUuVGltZUJhc2U6IFVuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb24nKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuX21hdGNoR3JvdXAodG9rZW4sIHRoaXMuX3ByaW1hcnlFeHByZXNzaW9ucykpIHtcblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgIHZhciBtYXRjaGluZyA9IHRva2VuLnZhbHVlLm1hdGNoKHRva2VuLnJlZ2V4cCk7XG5cdCAgICAgICAgICAgIHJldHVybiB0b2tlbi5tZXRob2QuYmluZCh0aGlzLCBtYXRjaGluZ1sxXSwgbWF0Y2hpbmdbMl0sIG1hdGNoaW5nWzNdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnZhbHVlID09PSAnKCcpIHtcblx0ICAgICAgICAgICAgbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICBleHByID0gdGhpcy5fcGFyc2VCaW5hcnkobGV4ZXIpO1xuXHQgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgaWYgKCEodG9rZW4gJiYgdG9rZW4udmFsdWUgPT09ICcpJykpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRXhwZWN0ZWQgKScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBleHByO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RvbmUuVGltZUJhc2U6IENhbm5vdCBwcm9jZXNzIHRva2VuICcgKyB0b2tlbi52YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlY3Vyc2l2ZWx5IHBhcnNlIHRoZSBzdHJpbmcgZXhwcmVzc2lvbiBpbnRvIGEgc3ludGF4IHRyZWUuXG5cdFx0ICogIEBwYXJhbSAgIHtzdHJpbmd9IGV4cHIgXG5cdFx0ICogIEByZXR1cm4gIHtGdW5jdGlvbn0gdGhlIGJvdW5kIG1ldGhvZCB0byBiZSBldmFsdWF0ZWQgbGF0ZXJcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9wYXJzZUV4cHJTdHJpbmcgPSBmdW5jdGlvbiAoZXhwclN0cmluZykge1xuXHQgICAgICAgIGlmICghVG9uZS5pc1N0cmluZyhleHByU3RyaW5nKSkge1xuXHQgICAgICAgICAgICBleHByU3RyaW5nID0gZXhwclN0cmluZy50b1N0cmluZygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbGV4ZXIgPSB0aGlzLl90b2tlbml6ZShleHByU3RyaW5nKTtcblx0ICAgICAgICB2YXIgdHJlZSA9IHRoaXMuX3BhcnNlQmluYXJ5KGxleGVyKTtcblx0ICAgICAgICByZXR1cm4gdHJlZTtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRERUZBVUxUU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGluaXRpYWwgZXhwcmVzc2lvbiB2YWx1ZVxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgVGhlIGluaXRpYWwgdmFsdWUgMFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX25vT3AgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0IGV4cHJlc3Npb24gdmFsdWUgaWYgbm8gYXJndW1lbnRzIGFyZSBnaXZlblxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX2RlZmF1bHRFeHByID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9ub09wO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB1bml0cyBpZiBub25lIGFyZSBnaXZlbi5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9kZWZhdWx0VW5pdHMgPSAncyc7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRVTklUIENPTlZFUlNJT05TXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGZyZXF1ZW5jeSBpbiB0aGUgY3VycmVudCB1bml0c1xuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcVxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX2ZyZXF1ZW5jeVRvVW5pdHMgPSBmdW5jdGlvbiAoZnJlcSkge1xuXHQgICAgICAgIHJldHVybiAxIC8gZnJlcTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgYmVhdHMgaW4gdGhlIGN1cnJlbnQgdW5pdHNcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IGJlYXRzXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fYmVhdHNUb1VuaXRzID0gZnVuY3Rpb24gKGJlYXRzKSB7XG5cdCAgICAgICAgcmV0dXJuIDYwIC8gVG9uZS5UcmFuc3BvcnQuYnBtLnZhbHVlICogYmVhdHM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgc2Vjb25kIGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdFx0ICogIEBwYXJhbSB7U2Vjb25kc30gc2Vjb25kc1xuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3NlY29uZHNUb1VuaXRzID0gZnVuY3Rpb24gKHNlY29uZHMpIHtcblx0ICAgICAgICByZXR1cm4gc2Vjb25kcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgdmFsdWUgb2YgYSB0aWNrIGluIHRoZSBjdXJyZW50IHRpbWUgdW5pdHNcblx0XHQgKiAgQHBhcmFtIHtUaWNrc30gdGlja3Ncblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl90aWNrc1RvVW5pdHMgPSBmdW5jdGlvbiAodGlja3MpIHtcblx0ICAgICAgICByZXR1cm4gdGlja3MgKiAodGhpcy5fYmVhdHNUb1VuaXRzKDEpIC8gVG9uZS5UcmFuc3BvcnQuUFBRKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIHNpZ25hdHVyZS5cblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl90aW1lU2lnbmF0dXJlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydC50aW1lU2lnbmF0dXJlO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEVYUFJFU1NJT05TXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBQdXNoIGFuIGV4cHJlc3Npb24gb250byB0aGUgZXhwcmVzc2lvbiBsaXN0XG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB2YWxcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgdHlwZVxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICB1bml0c1xuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lQmFzZX0gXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fcHVzaEV4cHIgPSBmdW5jdGlvbiAodmFsLCBuYW1lLCB1bml0cykge1xuXHQgICAgICAgIC8vY3JlYXRlIHRoZSBleHByZXNzaW9uXG5cdCAgICAgICAgaWYgKCEodmFsIGluc3RhbmNlb2YgVG9uZS5UaW1lQmFzZSkpIHtcblx0ICAgICAgICAgICAgdmFsID0gbmV3IHRoaXMuY29uc3RydWN0b3IodmFsLCB1bml0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2V4cHIgPSB0aGlzLl9iaW5hcnlFeHByZXNzaW9uc1tuYW1lXS5tZXRob2QuYmluZCh0aGlzLCB0aGlzLl9leHByLCB2YWwuX2V4cHIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGQgdG8gdGhlIGN1cnJlbnQgdmFsdWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB2YWwgICAgVGhlIHZhbHVlIHRvIGFkZFxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmc9fSAgdW5pdHMgIE9wdGlvbmFsIHVuaXRzIHRvIHVzZSB3aXRoIHRoZSB2YWx1ZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuVGltZUJhc2V9ICB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UaW1lQmFzZShcIjJtXCIpLmFkZChcIjFtXCIpOyAvL1wiM21cIlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbCwgdW5pdHMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEV4cHIodmFsLCAnKycsIHVuaXRzKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3VidHJhY3QgdGhlIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHZhbCAgICBUaGUgdmFsdWUgdG8gc3VidHJhY3Rcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nPX0gIHVuaXRzICBPcHRpb25hbCB1bml0cyB0byB1c2Ugd2l0aCB0aGUgdmFsdWUuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlRpbWVCYXNlfSAgdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuVGltZUJhc2UoXCIybVwiKS5zdWIoXCIxbVwiKTsgLy9cIjFtXCJcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh2YWwsIHVuaXRzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hFeHByKHZhbCwgJy0nLCB1bml0cyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE11bHRpcGx5IHRoZSBjdXJyZW50IHZhbHVlIGJ5IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdmFsICAgIFRoZSB2YWx1ZSB0byBtdWx0aXBseVxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmc9fSAgdW5pdHMgIE9wdGlvbmFsIHVuaXRzIHRvIHVzZSB3aXRoIHRoZSB2YWx1ZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuVGltZUJhc2V9ICB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UaW1lQmFzZShcIjJtXCIpLm11bHQoXCIyXCIpOyAvL1wiNG1cIlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUubXVsdCA9IGZ1bmN0aW9uICh2YWwsIHVuaXRzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hFeHByKHZhbCwgJyonLCB1bml0cyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIERpdmlkZSB0aGUgY3VycmVudCB2YWx1ZSBieSB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHZhbCAgICBUaGUgdmFsdWUgdG8gZGl2aWRlIGJ5XG5cdFx0ICogIEBwYXJhbSAge1N0cmluZz19ICB1bml0cyAgT3B0aW9uYWwgdW5pdHMgdG8gdXNlIHdpdGggdGhlIHZhbHVlLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lQmFzZX0gIHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRpbWVCYXNlKFwiMm1cIikuZGl2KDIpOyAvL1wiMW1cIlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKHZhbCwgdW5pdHMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEV4cHIodmFsLCAnLycsIHVuaXRzKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRXZhbHVhdGUgdGhlIHRpbWUgdmFsdWUuIFJldHVybnMgdGhlIHRpbWVcblx0XHQgKiAgaW4gc2Vjb25kcy5cblx0XHQgKiAgQHJldHVybiAge1NlY29uZHN9IFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZXhwcigpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlRpbWVCYXNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2V4cHIgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRpbWVCYXNlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuVGltZSBpcyBhIHByaW1pdGl2ZSB0eXBlIGZvciBlbmNvZGluZyBUaW1lIHZhbHVlcy4gXG5cdFx0ICogICAgICAgICBFdmVudHVhbGx5IGFsbCB0aW1lIHZhbHVlcyBhcmUgZXZhbHVhdGVkIHRvIHNlY29uZHNcblx0XHQgKiAgICAgICAgIHVzaW5nIHRoZSBgZXZhbGAgbWV0aG9kLiBUb25lLlRpbWUgY2FuIGJlIGNvbnN0cnVjdGVkXG5cdFx0ICogICAgICAgICB3aXRoIG9yIHdpdGhvdXQgdGhlIGBuZXdgIGtleXdvcmQuIFRvbmUuVGltZSBjYW4gYmUgcGFzc2VkXG5cdFx0ICogICAgICAgICBpbnRvIHRoZSBwYXJhbWV0ZXIgb2YgYW55IG1ldGhvZCB3aGljaCB0YWtlcyB0aW1lIGFzIGFuIGFyZ3VtZW50LiBcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlRpbWVCYXNlfVxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd8TnVtYmVyfSAgdmFsICAgIFRoZSB0aW1lIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmc9fSAgdW5pdHMgIFRoZSB1bml0cyBvZiB0aGUgdmFsdWUuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHQgPSBUb25lLlRpbWUoXCI0blwiKTsvL2VuY29kZXMgYSBxdWFydGVyIG5vdGVcblx0XHQgKiB0Lm11bHQoNCk7IC8vIG11bHRpcGx5IHRoYXQgdmFsdWUgYnkgNFxuXHRcdCAqIHQudG9Ob3RhdGlvbigpOyAvL3JldHVybnMgXCIxbVwiXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUgPSBmdW5jdGlvbiAodmFsLCB1bml0cykge1xuXHQgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgVG9uZS5UaW1lKSB7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgSWYgdGhlIGN1cnJlbnQgY2xvY2sgdGltZSBzaG91bGRcblx0XHRcdFx0ICogIGJlIGFkZGVkIHRvIHRoZSBvdXRwdXRcblx0XHRcdFx0ICogIEB0eXBlICB7Qm9vbGVhbn1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9wbHVzTm93ID0gZmFsc2U7XG5cdCAgICAgICAgICAgIFRvbmUuVGltZUJhc2UuY2FsbCh0aGlzLCB2YWwsIHVuaXRzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFRvbmUuVGltZSh2YWwsIHVuaXRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5UaW1lLCBUb25lLlRpbWVCYXNlKTtcblx0ICAgIC8vY2xvbmUgdGhlIGV4cHJlc3Npb25zIHNvIHRoYXQgXG5cdCAgICAvL3dlIGNhbiBhZGQgbW9yZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgb3JpZ2luYWxcblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMgPSBPYmplY3QuY3JlYXRlKFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl91bmFyeUV4cHJlc3Npb25zKTtcblx0ICAgIC8qXG5cdFx0ICogIEFkZHMgYW4gYWRkaXRpb25hbCB1bmFyeSBleHByZXNzaW9uXG5cdFx0ICogIHdoaWNoIHF1YW50aXplcyB2YWx1ZXMgdG8gdGhlIG5leHQgc3ViZGl2aXNpb25cblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMucXVhbnRpemUgPSB7XG5cdCAgICAgICAgcmVnZXhwOiAvXkAvLFxuXHQgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHJoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydC5uZXh0U3ViZGl2aXNpb24ocmgoKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qXG5cdFx0ICogIEFkZHMgYW4gYWRkaXRpb25hbCB1bmFyeSBleHByZXNzaW9uXG5cdFx0ICogIHdoaWNoIGFkZHMgdGhlIGN1cnJlbnQgY2xvY2sgdGltZS5cblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMubm93ID0ge1xuXHQgICAgICAgIHJlZ2V4cDogL15cXCsvLFxuXHQgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGxoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BsdXNOb3cgPSB0cnVlO1xuXHQgICAgICAgICAgICByZXR1cm4gbGgoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFF1YW50aXplIHRoZSB0aW1lIGJ5IHRoZSBnaXZlbiBzdWJkaXZpc2lvbi4gT3B0aW9uYWxseSBhZGQgYVxuXHRcdCAqICBwZXJjZW50YWdlIHdoaWNoIHdpbGwgbW92ZSB0aGUgdGltZSB2YWx1ZSB0b3dhcmRzIHRoZSBpZGVhbFxuXHRcdCAqICBxdWFudGl6ZWQgdmFsdWUgYnkgdGhhdCBwZXJjZW50YWdlLiBcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfFRpbWV9ICB2YWwgICAgVGhlIHN1YmRpdmlzaW9uIHRvIHF1YW50aXplIHRvXG5cdFx0ICogIEBwYXJhbSAge05vcm1hbFJhbmdlfSAgW3BlcmNlbnQ9MV0gIE1vdmUgdGhlIHRpbWUgdmFsdWVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG93YXJkcyB0aGUgcXVhbnRpemVkIHZhbHVlIGJ5XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgcGVyY2VudGFnZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuVGltZX0gIHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRpbWUoMjEpLnF1YW50aXplKDIpIC8vcmV0dXJucyAyMlxuXHRcdCAqIFRvbmUuVGltZSgwLjYpLnF1YW50aXplKFwiNG5cIiwgMC41KSAvL3JldHVybnMgMC41NVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS5xdWFudGl6ZSA9IGZ1bmN0aW9uIChzdWJkaXYsIHBlcmNlbnQpIHtcblx0ICAgICAgICBwZXJjZW50ID0gVG9uZS5kZWZhdWx0QXJnKHBlcmNlbnQsIDEpO1xuXHQgICAgICAgIHRoaXMuX2V4cHIgPSBmdW5jdGlvbiAoZXhwciwgc3ViZGl2aXNpb24sIHBlcmNlbnQpIHtcblx0ICAgICAgICAgICAgZXhwciA9IGV4cHIoKTtcblx0ICAgICAgICAgICAgc3ViZGl2aXNpb24gPSBzdWJkaXZpc2lvbi50b1NlY29uZHMoKTtcblx0ICAgICAgICAgICAgdmFyIG11bHRpcGxlID0gTWF0aC5yb3VuZChleHByIC8gc3ViZGl2aXNpb24pO1xuXHQgICAgICAgICAgICB2YXIgaWRlYWwgPSBtdWx0aXBsZSAqIHN1YmRpdmlzaW9uO1xuXHQgICAgICAgICAgICB2YXIgZGlmZiA9IGlkZWFsIC0gZXhwcjtcblx0ICAgICAgICAgICAgcmV0dXJuIGV4cHIgKyBkaWZmICogcGVyY2VudDtcblx0ICAgICAgICB9LmJpbmQodGhpcywgdGhpcy5fZXhwciwgbmV3IHRoaXMuY29uc3RydWN0b3Ioc3ViZGl2KSwgcGVyY2VudCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZHMgdGhlIGNsb2NrIHRpbWUgdG8gdGhlIHRpbWUgZXhwcmVzc2lvbiBhdCB0aGUgXG5cdFx0ICogIG1vbWVudCBvZiBldmFsdWF0aW9uLiBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuVGltZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUuYWRkTm93ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX3BsdXNOb3cgPSB0cnVlO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBPdmVycmlkZSB0aGUgZGVmYXVsdCB2YWx1ZSByZXR1cm4gd2hlbiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbi5cblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgJ25vdydcblx0XHQgKiAgQG92ZXJyaWRlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLl9kZWZhdWx0RXhwciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9wbHVzTm93ID0gdHJ1ZTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fbm9PcDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29waWVzIHRoZSB2YWx1ZSBvZiB0aW1lIHRvIHRoaXMgVGltZVxuXHRcdCAqICBAcGFyYW0ge1RvbmUuVGltZX0gdGltZVxuXHRcdCAqICBAcmV0dXJuICB7VGltZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuY29weS5jYWxsKHRoaXMsIHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3BsdXNOb3cgPSB0aW1lLl9wbHVzTm93O1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8vQ09OVkVSU0lPTlMvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgYSBUaW1lIHRvIE5vdGF0aW9uLiBWYWx1ZXMgd2lsbCBiZSB0aHJlc2hvbGRlZCB0byB0aGUgbmVhcmVzdCAxMjh0aCBub3RlLiBcblx0XHQgKiAgQHJldHVybiB7Tm90YXRpb259IFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vaWYgdGhlIFRyYW5zcG9ydCBpcyBhdCAxMjBicG06XG5cdFx0ICogVG9uZS5UaW1lKDIpLnRvTm90YXRpb24oKTsvL3JldHVybnMgXCIxbVwiXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLnRvTm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHRpbWUgPSB0aGlzLnRvU2Vjb25kcygpO1xuXHQgICAgICAgIHZhciB0ZXN0Tm90YXRpb25zID0gW1xuXHQgICAgICAgICAgICAnMW0nLFxuXHQgICAgICAgICAgICAnMm4nLFxuXHQgICAgICAgICAgICAnNG4nLFxuXHQgICAgICAgICAgICAnOG4nLFxuXHQgICAgICAgICAgICAnMTZuJyxcblx0ICAgICAgICAgICAgJzMybicsXG5cdCAgICAgICAgICAgICc2NG4nLFxuXHQgICAgICAgICAgICAnMTI4bidcblx0ICAgICAgICBdO1xuXHQgICAgICAgIHZhciByZXROb3RhdGlvbiA9IHRoaXMuX3RvTm90YXRpb25IZWxwZXIodGltZSwgdGVzdE5vdGF0aW9ucyk7XG5cdCAgICAgICAgLy90cnkgdGhlIHNhbWUgdGhpbmcgYnV0IHdpdGggdHJpcGVsZXRzXG5cdCAgICAgICAgdmFyIHRlc3RUcmlwbGV0Tm90YXRpb25zID0gW1xuXHQgICAgICAgICAgICAnMW0nLFxuXHQgICAgICAgICAgICAnMm4nLFxuXHQgICAgICAgICAgICAnMnQnLFxuXHQgICAgICAgICAgICAnNG4nLFxuXHQgICAgICAgICAgICAnNHQnLFxuXHQgICAgICAgICAgICAnOG4nLFxuXHQgICAgICAgICAgICAnOHQnLFxuXHQgICAgICAgICAgICAnMTZuJyxcblx0ICAgICAgICAgICAgJzE2dCcsXG5cdCAgICAgICAgICAgICczMm4nLFxuXHQgICAgICAgICAgICAnMzJ0Jyxcblx0ICAgICAgICAgICAgJzY0bicsXG5cdCAgICAgICAgICAgICc2NHQnLFxuXHQgICAgICAgICAgICAnMTI4bidcblx0ICAgICAgICBdO1xuXHQgICAgICAgIHZhciByZXRUcmlwbGV0Tm90YXRpb24gPSB0aGlzLl90b05vdGF0aW9uSGVscGVyKHRpbWUsIHRlc3RUcmlwbGV0Tm90YXRpb25zKTtcblx0ICAgICAgICAvL2Nob29zZSB0aGUgc2ltcGxlciBleHByZXNzaW9uIG9mIHRoZSB0d29cblx0ICAgICAgICBpZiAocmV0VHJpcGxldE5vdGF0aW9uLnNwbGl0KCcrJykubGVuZ3RoIDwgcmV0Tm90YXRpb24uc3BsaXQoJysnKS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJldFRyaXBsZXROb3RhdGlvbjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gcmV0Tm90YXRpb247XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBIZWxwZXIgbWV0aG9kIGZvciBUb25lLnRvTm90YXRpb25cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IHVuaXRzIFxuXHRcdCAqICBAcGFyYW0ge0FycmF5fSB0ZXN0Tm90YXRpb25zXG5cdFx0ICogIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUuX3RvTm90YXRpb25IZWxwZXIgPSBmdW5jdGlvbiAodW5pdHMsIHRlc3ROb3RhdGlvbnMpIHtcblx0ICAgICAgICAvL3RoZSB0aHJlc2hvbGQgaXMgdGhlIGxhc3QgdmFsdWUgaW4gdGhlIGFycmF5XG5cdCAgICAgICAgdmFyIHRocmVzaG9sZCA9IHRoaXMuX25vdGF0aW9uVG9Vbml0cyh0ZXN0Tm90YXRpb25zW3Rlc3ROb3RhdGlvbnMubGVuZ3RoIC0gMV0pO1xuXHQgICAgICAgIHZhciByZXROb3RhdGlvbiA9ICcnO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVzdE5vdGF0aW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgbm90YXRpb25UaW1lID0gdGhpcy5fbm90YXRpb25Ub1VuaXRzKHRlc3ROb3RhdGlvbnNbaV0pO1xuXHQgICAgICAgICAgICAvL2FjY291bnQgZm9yIGZsb2F0aW5nIHBvaW50IGVycm9ycyAoaS5lLiByb3VuZCB1cCBpZiB0aGUgdmFsdWUgaXMgMC45OTk5OTkpXG5cdCAgICAgICAgICAgIHZhciBtdWx0aXBsZSA9IHVuaXRzIC8gbm90YXRpb25UaW1lO1xuXHQgICAgICAgICAgICB2YXIgZmxvYXRpbmdQb2ludEVycm9yID0gMC4wMDAwMDE7XG5cdCAgICAgICAgICAgIGlmICgxIC0gbXVsdGlwbGUgJSAxIDwgZmxvYXRpbmdQb2ludEVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBtdWx0aXBsZSArPSBmbG9hdGluZ1BvaW50RXJyb3I7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbXVsdGlwbGUgPSBNYXRoLmZsb29yKG11bHRpcGxlKTtcblx0ICAgICAgICAgICAgaWYgKG11bHRpcGxlID4gMCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0Tm90YXRpb24gKz0gdGVzdE5vdGF0aW9uc1tpXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0Tm90YXRpb24gKz0gbXVsdGlwbGUudG9TdHJpbmcoKSArICcqJyArIHRlc3ROb3RhdGlvbnNbaV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB1bml0cyAtPSBtdWx0aXBsZSAqIG5vdGF0aW9uVGltZTtcblx0ICAgICAgICAgICAgICAgIGlmICh1bml0cyA8IHRocmVzaG9sZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXROb3RhdGlvbiArPSAnICsgJztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmV0Tm90YXRpb24gPT09ICcnKSB7XG5cdCAgICAgICAgICAgIHJldE5vdGF0aW9uID0gJzAnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmV0Tm90YXRpb247XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgYSBub3RhdGlvbiB2YWx1ZSB0byB0aGUgY3VycmVudCB1bml0c1xuXHRcdCAqICBAcGFyYW0gIHtOb3RhdGlvbn0gIG5vdGF0aW9uIFxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfSBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUuX25vdGF0aW9uVG9Vbml0cyA9IGZ1bmN0aW9uIChub3RhdGlvbikge1xuXHQgICAgICAgIHZhciBwcmltYXJ5RXhwcnMgPSB0aGlzLl9wcmltYXJ5RXhwcmVzc2lvbnM7XG5cdCAgICAgICAgdmFyIG5vdGF0aW9uRXhwcnMgPSBbXG5cdCAgICAgICAgICAgIHByaW1hcnlFeHBycy5uLFxuXHQgICAgICAgICAgICBwcmltYXJ5RXhwcnMudCxcblx0ICAgICAgICAgICAgcHJpbWFyeUV4cHJzLm1cblx0ICAgICAgICBdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm90YXRpb25FeHBycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgZXhwciA9IG5vdGF0aW9uRXhwcnNbaV07XG5cdCAgICAgICAgICAgIHZhciBtYXRjaCA9IG5vdGF0aW9uLm1hdGNoKGV4cHIucmVnZXhwKTtcblx0ICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZXhwci5tZXRob2QuY2FsbCh0aGlzLCBtYXRjaFsxXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBlbmNvZGVkIGFzIEJhcnM6QmVhdHM6U2l4dGVlbnRocy5cblx0XHQgKiAgQHJldHVybiAge0JhcnNCZWF0c1NpeHRlZW50aHN9XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLnRvQmFyc0JlYXRzU2l4dGVlbnRocyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgcXVhcnRlclRpbWUgPSB0aGlzLl9iZWF0c1RvVW5pdHMoMSk7XG5cdCAgICAgICAgdmFyIHF1YXJ0ZXJzID0gdGhpcy50b1NlY29uZHMoKSAvIHF1YXJ0ZXJUaW1lO1xuXHQgICAgICAgIHZhciBtZWFzdXJlcyA9IE1hdGguZmxvb3IocXVhcnRlcnMgLyB0aGlzLl90aW1lU2lnbmF0dXJlKCkpO1xuXHQgICAgICAgIHZhciBzaXh0ZWVudGhzID0gcXVhcnRlcnMgJSAxICogNDtcblx0ICAgICAgICBxdWFydGVycyA9IE1hdGguZmxvb3IocXVhcnRlcnMpICUgdGhpcy5fdGltZVNpZ25hdHVyZSgpO1xuXHQgICAgICAgIHNpeHRlZW50aHMgPSBzaXh0ZWVudGhzLnRvU3RyaW5nKCk7XG5cdCAgICAgICAgaWYgKHNpeHRlZW50aHMubGVuZ3RoID4gMykge1xuXHQgICAgICAgICAgICAvLyB0aGUgYWRkaXRpb25hbCBwYXJzZUZsb2F0IHJlbW92ZXMgaW5zaWduaWZpY2FudCB0cmFpbGluZyB6ZXJvZXNcblx0ICAgICAgICAgICAgc2l4dGVlbnRocyA9IHBhcnNlRmxvYXQocGFyc2VGbG9hdChzaXh0ZWVudGhzKS50b0ZpeGVkKDMpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHByb2dyZXNzID0gW1xuXHQgICAgICAgICAgICBtZWFzdXJlcyxcblx0ICAgICAgICAgICAgcXVhcnRlcnMsXG5cdCAgICAgICAgICAgIHNpeHRlZW50aHNcblx0ICAgICAgICBdO1xuXHQgICAgICAgIHJldHVybiBwcm9ncmVzcy5qb2luKCc6Jyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBpbiB0aWNrcy5cblx0XHQgKiAgQHJldHVybiAge1RpY2tzfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS50b1RpY2tzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBxdWFydGVyVGltZSA9IHRoaXMuX2JlYXRzVG9Vbml0cygxKTtcblx0ICAgICAgICB2YXIgcXVhcnRlcnMgPSB0aGlzLnZhbHVlT2YoKSAvIHF1YXJ0ZXJUaW1lO1xuXHQgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHF1YXJ0ZXJzICogVG9uZS5UcmFuc3BvcnQuUFBRKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGluIHNhbXBsZXNcblx0XHQgKiAgQHJldHVybiAge1NhbXBsZXN9ICBcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUudG9TYW1wbGVzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnRvU2Vjb25kcygpICogdGhpcy5jb250ZXh0LnNhbXBsZVJhdGU7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBhcyBhIGZyZXF1ZW5jeSB2YWx1ZVxuXHRcdCAqICBAcmV0dXJuICB7RnJlcXVlbmN5fSBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRpbWUoMikudG9GcmVxdWVuY3koKTsgLy8wLjVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUudG9GcmVxdWVuY3kgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIDEgLyB0aGlzLnRvU2Vjb25kcygpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHRpbWUgaW4gc2Vjb25kcy5cblx0XHQgKiAgQHJldHVybiAge1NlY29uZHN9IFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS50b1NlY29uZHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuXHRcdCAqICBAcmV0dXJuICB7TWlsbGlzZWNvbmRzfSBcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUudG9NaWxsaXNlY29uZHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudG9TZWNvbmRzKCkgKiAxMDAwO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHRpbWUgaW4gc2Vjb25kcy5cblx0XHQgKiAgQHJldHVybiAge1NlY29uZHN9IFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciB2YWwgPSB0aGlzLl9leHByKCk7XG5cdCAgICAgICAgcmV0dXJuIHZhbCArICh0aGlzLl9wbHVzTm93ID8gdGhpcy5ub3coKSA6IDApO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRpbWU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5GcmVxdWVuY3kgaXMgYSBwcmltaXRpdmUgdHlwZSBmb3IgZW5jb2RpbmcgRnJlcXVlbmN5IHZhbHVlcy5cblx0XHQgKiAgICAgICAgIEV2ZW50dWFsbHkgYWxsIHRpbWUgdmFsdWVzIGFyZSBldmFsdWF0ZWQgdG8gaGVydHpcblx0XHQgKiAgICAgICAgIHVzaW5nIHRoZSBgZXZhbGAgbWV0aG9kLlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuVGltZUJhc2V9XG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ9ICB2YWwgICAgVGhlIHRpbWUgdmFsdWUuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZz19ICB1bml0cyAgVGhlIHVuaXRzIG9mIHRoZSB2YWx1ZS5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLkZyZXF1ZW5jeShcIkMzXCIpIC8vIDI2MVxuXHRcdCAqIFRvbmUuRnJlcXVlbmN5KDM4LCBcIm1pZGlcIikgLy9cblx0XHQgKiBUb25lLkZyZXF1ZW5jeShcIkMzXCIpLnRyYW5zcG9zZSg0KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5ID0gZnVuY3Rpb24gKHZhbCwgdW5pdHMpIHtcblx0ICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFRvbmUuRnJlcXVlbmN5KSB7XG5cdCAgICAgICAgICAgIFRvbmUuVGltZUJhc2UuY2FsbCh0aGlzLCB2YWwsIHVuaXRzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFRvbmUuRnJlcXVlbmN5KHZhbCwgdW5pdHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZyZXF1ZW5jeSwgVG9uZS5UaW1lQmFzZSk7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRBVUdNRU5UIEJBU0UgRVhQUkVTU0lPTlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9jbG9uZSB0aGUgZXhwcmVzc2lvbnMgc28gdGhhdFxuXHQgICAgLy93ZSBjYW4gYWRkIG1vcmUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuX3ByaW1hcnlFeHByZXNzaW9ucyA9IE9iamVjdC5jcmVhdGUoVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3ByaW1hcnlFeHByZXNzaW9ucyk7XG5cdCAgICAvKlxuXHRcdCAqICBtaWRpIHR5cGUgcHJpbWFyeSBleHByZXNzaW9uXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuX3ByaW1hcnlFeHByZXNzaW9ucy5taWRpID0ge1xuXHQgICAgICAgIHJlZ2V4cDogL14oXFxkKyg/OlxcLlxcZCspP21pZGkpLyxcblx0ICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5taWRpVG9GcmVxdWVuY3kodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKlxuXHRcdCAqICBub3RlIHR5cGUgcHJpbWFyeSBleHByZXNzaW9uXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuX3ByaW1hcnlFeHByZXNzaW9ucy5ub3RlID0ge1xuXHQgICAgICAgIHJlZ2V4cDogL14oW2EtZ117MX0oPzpifCN8eHxiYik/KSgtP1swLTldKykvaSxcblx0ICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChwaXRjaCwgb2N0YXZlKSB7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IG5vdGVUb1NjYWxlSW5kZXhbcGl0Y2gudG9Mb3dlckNhc2UoKV07XG5cdCAgICAgICAgICAgIHZhciBub3RlTnVtYmVyID0gaW5kZXggKyAocGFyc2VJbnQob2N0YXZlKSArIDEpICogMTI7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLm1pZGlUb0ZyZXF1ZW5jeShub3RlTnVtYmVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLypcblx0XHQgKiAgQmVhdHNCYXJzU2l4dGVlbnRocyB0eXBlIHByaW1hcnkgZXhwcmVzc2lvblxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnMudHIgPSB7XG5cdCAgICAgICAgcmVnZXhwOiAvXihcXGQrKD86XFwuXFxkKyk/KTooXFxkKyg/OlxcLlxcZCspPyk6PyhcXGQrKD86XFwuXFxkKyk/KT8vLFxuXHQgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKG0sIHEsIHMpIHtcblx0ICAgICAgICAgICAgdmFyIHRvdGFsID0gMTtcblx0ICAgICAgICAgICAgaWYgKG0gJiYgbSAhPT0gJzAnKSB7XG5cdCAgICAgICAgICAgICAgICB0b3RhbCAqPSB0aGlzLl9iZWF0c1RvVW5pdHModGhpcy5fdGltZVNpZ25hdHVyZSgpICogcGFyc2VGbG9hdChtKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHEgJiYgcSAhPT0gJzAnKSB7XG5cdCAgICAgICAgICAgICAgICB0b3RhbCAqPSB0aGlzLl9iZWF0c1RvVW5pdHMocGFyc2VGbG9hdChxKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHMgJiYgcyAhPT0gJzAnKSB7XG5cdCAgICAgICAgICAgICAgICB0b3RhbCAqPSB0aGlzLl9iZWF0c1RvVW5pdHMocGFyc2VGbG9hdChzKSAvIDQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0b3RhbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0RVhQUkVTU0lPTlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFRyYW5zcG9zZXMgdGhlIGZyZXF1ZW5jeSBieSB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHNlbWl0b25lcy5cblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWx9ICBpbnRlcnZhbFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5GcmVxdWVuY3l9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLkZyZXF1ZW5jeShcIkE0XCIpLnRyYW5zcG9zZSgzKTsgLy9cIkM1XCJcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcblx0ICAgICAgICB0aGlzLl9leHByID0gZnVuY3Rpb24gKGV4cHIsIGludGVydmFsKSB7XG5cdCAgICAgICAgICAgIHZhciB2YWwgPSBleHByKCk7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWwgKiBUb25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbyhpbnRlcnZhbCk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMsIHRoaXMuX2V4cHIsIGludGVydmFsKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGFrZXMgYW4gYXJyYXkgb2Ygc2VtaXRvbmUgaW50ZXJ2YWxzIGFuZCByZXR1cm5zXG5cdFx0ICogIGFuIGFycmF5IG9mIGZyZXF1ZW5jaWVzIHRyYW5zcG9zZWQgYnkgdGhvc2UgaW50ZXJ2YWxzLlxuXHRcdCAqICBAcGFyYW0gIHtBcnJheX0gIGludGVydmFsc1xuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5GcmVxdWVuY3l9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLkZyZXF1ZW5jeShcIkE0XCIpLmhhcm1vbml6ZShbMCwgMywgN10pOyAvL1tcIkE0XCIsIFwiQzVcIiwgXCJFNVwiXVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLmhhcm1vbml6ZSA9IGZ1bmN0aW9uIChpbnRlcnZhbHMpIHtcblx0ICAgICAgICB0aGlzLl9leHByID0gZnVuY3Rpb24gKGV4cHIsIGludGVydmFscykge1xuXHQgICAgICAgICAgICB2YXIgdmFsID0gZXhwcigpO1xuXHQgICAgICAgICAgICB2YXIgcmV0ID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICByZXRbaV0gPSB2YWwgKiBUb25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbyhpbnRlcnZhbHNbaV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMsIHRoaXMuX2V4cHIsIGludGVydmFscyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0VU5JVCBDT05WRVJTSU9OU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZnJlcXVlbmN5IGFzIGEgTUlESSBub3RlXG5cdFx0ICogIEByZXR1cm4gIHtNSURJfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuRnJlcXVlbmN5KFwiQzRcIikudG9NaWRpKCk7IC8vNjBcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS50b01pZGkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZnJlcXVlbmN5VG9NaWRpKHRoaXMudmFsdWVPZigpKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZnJlcXVlbmN5IGluIFNjaWVudGlmaWMgUGl0Y2ggTm90YXRpb25cblx0XHQgKiAgQHJldHVybiAge05vdGV9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5GcmVxdWVuY3koNjksIFwibWlkaVwiKS50b05vdGUoKTsgLy9cIkE0XCJcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS50b05vdGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGZyZXEgPSB0aGlzLnZhbHVlT2YoKTtcblx0ICAgICAgICB2YXIgbG9nID0gTWF0aC5sb2coZnJlcSAvIFRvbmUuRnJlcXVlbmN5LkE0KSAvIE1hdGguTE4yO1xuXHQgICAgICAgIHZhciBub3RlTnVtYmVyID0gTWF0aC5yb3VuZCgxMiAqIGxvZykgKyA1Nztcblx0ICAgICAgICB2YXIgb2N0YXZlID0gTWF0aC5mbG9vcihub3RlTnVtYmVyIC8gMTIpO1xuXHQgICAgICAgIGlmIChvY3RhdmUgPCAwKSB7XG5cdCAgICAgICAgICAgIG5vdGVOdW1iZXIgKz0gLTEyICogb2N0YXZlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbm90ZU5hbWUgPSBzY2FsZUluZGV4VG9Ob3RlW25vdGVOdW1iZXIgJSAxMl07XG5cdCAgICAgICAgcmV0dXJuIG5vdGVOYW1lICsgb2N0YXZlLnRvU3RyaW5nKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgZHVyYXRpb24gb2Ygb25lIGN5Y2xlIGluIHNlY29uZHMuXG5cdFx0ICogIEByZXR1cm4gIHtTZWNvbmRzfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLnRvU2Vjb25kcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gMSAvIHRoaXMudmFsdWVPZigpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHZhbHVlIGluIEhlcnR6XG5cdFx0ICogIEByZXR1cm4gIHtGcmVxdWVuY3l9XG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUudG9GcmVxdWVuY3kgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIGR1cmF0aW9uIG9mIG9uZSBjeWNsZSBpbiB0aWNrc1xuXHRcdCAqICBAcmV0dXJuICB7VGlja3N9XG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUudG9UaWNrcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgcXVhcnRlclRpbWUgPSB0aGlzLl9iZWF0c1RvVW5pdHMoMSk7XG5cdCAgICAgICAgdmFyIHF1YXJ0ZXJzID0gdGhpcy52YWx1ZU9mKCkgLyBxdWFydGVyVGltZTtcblx0ICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihxdWFydGVycyAqIFRvbmUuVHJhbnNwb3J0LlBQUSk7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0VU5JVCBDT05WRVJTSU9OUyBIRUxQRVJTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGZyZXF1ZW5jeSBpbiB0aGUgY3VycmVudCB1bml0c1xuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcVxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9mcmVxdWVuY3lUb1VuaXRzID0gZnVuY3Rpb24gKGZyZXEpIHtcblx0ICAgICAgICByZXR1cm4gZnJlcTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgdmFsdWUgb2YgYSB0aWNrIGluIHRoZSBjdXJyZW50IHRpbWUgdW5pdHNcblx0XHQgKiAgQHBhcmFtIHtUaWNrc30gdGlja3Ncblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fdGlja3NUb1VuaXRzID0gZnVuY3Rpb24gKHRpY2tzKSB7XG5cdCAgICAgICAgcmV0dXJuIDEgLyAodGlja3MgKiA2MCAvIChUb25lLlRyYW5zcG9ydC5icG0udmFsdWUgKiBUb25lLlRyYW5zcG9ydC5QUFEpKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgYmVhdHMgaW4gdGhlIGN1cnJlbnQgdW5pdHNcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IGJlYXRzXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuX2JlYXRzVG9Vbml0cyA9IGZ1bmN0aW9uIChiZWF0cykge1xuXHQgICAgICAgIHJldHVybiAxIC8gVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX2JlYXRzVG9Vbml0cy5jYWxsKHRoaXMsIGJlYXRzKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBzZWNvbmQgaW4gdGhlIGN1cnJlbnQgdW5pdHNcblx0XHQgKiAgQHBhcmFtIHtTZWNvbmRzfSBzZWNvbmRzXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuX3NlY29uZHNUb1VuaXRzID0gZnVuY3Rpb24gKHNlY29uZHMpIHtcblx0ICAgICAgICByZXR1cm4gMSAvIHNlY29uZHM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0IHVuaXRzIGlmIG5vbmUgYXJlIGdpdmVuLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9kZWZhdWx0VW5pdHMgPSAnaHonO1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0RlJFUVVFTkNZIENPTlZFUlNJT05TXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBOb3RlIHRvIHNjYWxlIGluZGV4XG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgdmFyIG5vdGVUb1NjYWxlSW5kZXggPSB7XG5cdCAgICAgICAgJ2NiYic6IC0yLFxuXHQgICAgICAgICdjYic6IC0xLFxuXHQgICAgICAgICdjJzogMCxcblx0ICAgICAgICAnYyMnOiAxLFxuXHQgICAgICAgICdjeCc6IDIsXG5cdCAgICAgICAgJ2RiYic6IDAsXG5cdCAgICAgICAgJ2RiJzogMSxcblx0ICAgICAgICAnZCc6IDIsXG5cdCAgICAgICAgJ2QjJzogMyxcblx0ICAgICAgICAnZHgnOiA0LFxuXHQgICAgICAgICdlYmInOiAyLFxuXHQgICAgICAgICdlYic6IDMsXG5cdCAgICAgICAgJ2UnOiA0LFxuXHQgICAgICAgICdlIyc6IDUsXG5cdCAgICAgICAgJ2V4JzogNixcblx0ICAgICAgICAnZmJiJzogMyxcblx0ICAgICAgICAnZmInOiA0LFxuXHQgICAgICAgICdmJzogNSxcblx0ICAgICAgICAnZiMnOiA2LFxuXHQgICAgICAgICdmeCc6IDcsXG5cdCAgICAgICAgJ2diYic6IDUsXG5cdCAgICAgICAgJ2diJzogNixcblx0ICAgICAgICAnZyc6IDcsXG5cdCAgICAgICAgJ2cjJzogOCxcblx0ICAgICAgICAnZ3gnOiA5LFxuXHQgICAgICAgICdhYmInOiA3LFxuXHQgICAgICAgICdhYic6IDgsXG5cdCAgICAgICAgJ2EnOiA5LFxuXHQgICAgICAgICdhIyc6IDEwLFxuXHQgICAgICAgICdheCc6IDExLFxuXHQgICAgICAgICdiYmInOiA5LFxuXHQgICAgICAgICdiYic6IDEwLFxuXHQgICAgICAgICdiJzogMTEsXG5cdCAgICAgICAgJ2IjJzogMTIsXG5cdCAgICAgICAgJ2J4JzogMTNcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc2NhbGUgaW5kZXggdG8gbm90ZSAoc2hhcnBzKVxuXHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdCAqL1xuXHQgICAgdmFyIHNjYWxlSW5kZXhUb05vdGUgPSBbXG5cdCAgICAgICAgJ0MnLFxuXHQgICAgICAgICdDIycsXG5cdCAgICAgICAgJ0QnLFxuXHQgICAgICAgICdEIycsXG5cdCAgICAgICAgJ0UnLFxuXHQgICAgICAgICdGJyxcblx0ICAgICAgICAnRiMnLFxuXHQgICAgICAgICdHJyxcblx0ICAgICAgICAnRyMnLFxuXHQgICAgICAgICdBJyxcblx0ICAgICAgICAnQSMnLFxuXHQgICAgICAgICdCJ1xuXHQgICAgXTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgW2NvbmNlcnQgcGl0Y2hdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmNlcnRfcGl0Y2gpXG5cdFx0ICogIEE0J3MgdmFsdWVzIGluIEhlcnR6LlxuXHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5BNCA9IDQ0MDtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGEgTUlESSBub3RlIHRvIGZyZXF1ZW5jeSB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtICB7TUlESX0gbWlkaSBUaGUgbWlkaSBudW1iZXIgdG8gY29udmVydC5cblx0XHQgKiAgQHJldHVybiB7RnJlcXVlbmN5fSB0aGUgY29ycmVzcG9uZGluZyBmcmVxdWVuY3kgdmFsdWVcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB0b25lLm1pZGlUb0ZyZXF1ZW5jeSg2OSk7IC8vIHJldHVybnMgNDQwXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUubWlkaVRvRnJlcXVlbmN5ID0gZnVuY3Rpb24gKG1pZGkpIHtcblx0ICAgICAgICByZXR1cm4gVG9uZS5GcmVxdWVuY3kuQTQgKiBNYXRoLnBvdygyLCAobWlkaSAtIDY5KSAvIDEyKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBhIGZyZXF1ZW5jeSB2YWx1ZSB0byBhIE1JREkgbm90ZS5cblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IGZyZXF1ZW5jeSBUaGUgdmFsdWUgdG8gZnJlcXVlbmN5IHZhbHVlIHRvIGNvbnZlcnQuXG5cdFx0ICogIEByZXR1cm5zICB7TUlESX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB0b25lLm1pZGlUb0ZyZXF1ZW5jeSg0NDApOyAvLyByZXR1cm5zIDY5XG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuZnJlcXVlbmN5VG9NaWRpID0gZnVuY3Rpb24gKGZyZXF1ZW5jeSkge1xuXHQgICAgICAgIHJldHVybiA2OSArIE1hdGgucm91bmQoMTIgKiBNYXRoLmxvZyhmcmVxdWVuY3kgLyBUb25lLkZyZXF1ZW5jeS5BNCkgLyBNYXRoLkxOMik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRnJlcXVlbmN5O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuVHJhbnNwb3J0VGltZSBpcyBhIHRoZSB0aW1lIGFsb25nIHRoZSBUcmFuc3BvcnQnc1xuXHRcdCAqICAgICAgICAgdGltZWxpbmUuIEl0IGlzIHNpbWlsYXIgdG8gVG9uZS5UaW1lLCBidXQgaW5zdGVhZCBvZiBldmFsdWF0aW5nXG5cdFx0ICogICAgICAgICBhZ2FpbnN0IHRoZSBBdWRpb0NvbnRleHQncyBjbG9jaywgaXQgaXMgZXZhbHVhdGVkIGFnYWluc3Rcblx0XHQgKiAgICAgICAgIHRoZSBUcmFuc3BvcnQncyBwb3NpdGlvbi4gU2VlIFtUcmFuc3BvcnRUaW1lIHdpa2ldKGh0dHBzOi8vZ2l0aHViLmNvbS9Ub25lanMvVG9uZS5qcy93aWtpL1RyYW5zcG9ydFRpbWUpLlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHZhbCAgICBUaGUgdGltZSB2YWx1ZSBhcyBhIG51bWJlciBvciBzdHJpbmdcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nPX0gIHVuaXRzICBVbml0IHZhbHVlc1xuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5UaW1lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lID0gZnVuY3Rpb24gKHZhbCwgdW5pdHMpIHtcblx0ICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFRvbmUuVHJhbnNwb3J0VGltZSkge1xuXHQgICAgICAgICAgICBUb25lLlRpbWUuY2FsbCh0aGlzLCB2YWwsIHVuaXRzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFRvbmUuVHJhbnNwb3J0VGltZSh2YWwsIHVuaXRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5UcmFuc3BvcnRUaW1lLCBUb25lLlRpbWUpO1xuXHQgICAgLy9jbG9uZSB0aGUgZXhwcmVzc2lvbnMgc28gdGhhdCBcblx0ICAgIC8vd2UgY2FuIGFkZCBtb3JlIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbFxuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucyA9IE9iamVjdC5jcmVhdGUoVG9uZS5UaW1lLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucyk7XG5cdCAgICAvKipcblx0XHQgKiAgQWRkcyBhbiBhZGRpdGlvbmFsIHVuYXJ5IGV4cHJlc3Npb25cblx0XHQgKiAgd2hpY2ggcXVhbnRpemVzIHZhbHVlcyB0byB0aGUgbmV4dCBzdWJkaXZpc2lvblxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucy5xdWFudGl6ZSA9IHtcblx0ICAgICAgICByZWdleHA6IC9eQC8sXG5cdCAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAocmgpIHtcblx0ICAgICAgICAgICAgdmFyIHN1YmRpdmlzaW9uID0gdGhpcy5fc2Vjb25kc1RvVGlja3MocmgoKSk7XG5cdCAgICAgICAgICAgIHZhciBtdWx0aXBsZSA9IE1hdGguY2VpbChUb25lLlRyYW5zcG9ydC50aWNrcyAvIHN1YmRpdmlzaW9uKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpY2tzVG9Vbml0cyhtdWx0aXBsZSAqIHN1YmRpdmlzaW9uKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgc2Vjb25kcyBpbnRvIHRpY2tzXG5cdFx0ICogIEBwYXJhbSB7U2Vjb25kc30gc2Vjb25kc1xuXHRcdCAqICBAcmV0dXJuICB7VGlja3N9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWUucHJvdG90eXBlLl9zZWNvbmRzVG9UaWNrcyA9IGZ1bmN0aW9uIChzZWNvbmRzKSB7XG5cdCAgICAgICAgdmFyIHF1YXJ0ZXJUaW1lID0gdGhpcy5fYmVhdHNUb1VuaXRzKDEpO1xuXHQgICAgICAgIHZhciBxdWFydGVycyA9IHNlY29uZHMgLyBxdWFydGVyVGltZTtcblx0ICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChxdWFydGVycyAqIFRvbmUuVHJhbnNwb3J0LlBQUSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEV2YWx1YXRlIHRoZSB0aW1lIGV4cHJlc3Npb24uIFJldHVybnMgdmFsdWVzIGluIHRpY2tzXG5cdFx0ICogIEByZXR1cm4ge1RpY2tzfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciB2YWwgPSB0aGlzLl9zZWNvbmRzVG9UaWNrcyh0aGlzLl9leHByKCkpO1xuXHQgICAgICAgIHJldHVybiB2YWwgKyAodGhpcy5fcGx1c05vdyA/IFRvbmUuVHJhbnNwb3J0LnRpY2tzIDogMCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBpbiB0aWNrcy5cblx0XHQgKiAgQHJldHVybiAge1RpY2tzfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS50b1RpY2tzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGluIHNlY29uZHMuXG5cdFx0ICogIEByZXR1cm4gIHtTZWNvbmRzfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS50b1NlY29uZHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IHRoaXMuX2V4cHIoKTtcblx0ICAgICAgICByZXR1cm4gdmFsICsgKHRoaXMuX3BsdXNOb3cgPyBUb25lLlRyYW5zcG9ydC5zZWNvbmRzIDogMCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBhcyBhIGZyZXF1ZW5jeSB2YWx1ZVxuXHRcdCAqICBAcmV0dXJuICB7RnJlcXVlbmN5fSBcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZS5wcm90b3R5cGUudG9GcmVxdWVuY3kgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIDEgLyB0aGlzLnRvU2Vjb25kcygpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRyYW5zcG9ydFRpbWU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFRZUEVTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqIFVuaXRzIHdoaWNoIGEgdmFsdWUgY2FuIHRha2Ugb24uXG5cdFx0ICogQGVudW0ge1N0cmluZ31cblx0XHQgKi9cblx0ICAgIFRvbmUuVHlwZSA9IHtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBEZWZhdWx0IHVuaXRzXG5cdFx0XHQgKiAgQHR5cGVkZWYge0RlZmF1bHR9XG5cdFx0XHQgKi9cblx0ICAgICAgICBEZWZhdWx0OiAnbnVtYmVyJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaW1lIGNhbiBiZSBkZXNjcmliZWQgaW4gYSBudW1iZXIgb2Ygd2F5cy4gUmVhZCBtb3JlIFtUaW1lXShodHRwczovL2dpdGh1Yi5jb20vVG9uZWpzL1RvbmUuanMvd2lraS9UaW1lKS5cblx0XHRcdCAqXG5cdFx0XHQgKiAgKiBOdW1iZXJzLCB3aGljaCB3aWxsIGJlIHRha2VuIGxpdGVyYWxseSBhcyB0aGUgdGltZSAoaW4gc2Vjb25kcykuXG5cdFx0XHQgKiAgKiBOb3RhdGlvbiwgKFwiNG5cIiwgXCI4dFwiKSBkZXNjcmliZXMgdGltZSBpbiBCUE0gYW5kIHRpbWUgc2lnbmF0dXJlIHJlbGF0aXZlIHZhbHVlcy5cblx0XHRcdCAqICAqIFRyYW5zcG9ydFRpbWUsIChcIjQ6MzoyXCIpIHdpbGwgYWxzbyBwcm92aWRlIHRlbXBvIGFuZCB0aW1lIHNpZ25hdHVyZSByZWxhdGl2ZSB0aW1lc1xuXHRcdFx0ICogIGluIHRoZSBmb3JtIEJBUlM6UVVBUlRFUlM6U0lYVEVFTlRIUy5cblx0XHRcdCAqICAqIEZyZXF1ZW5jeSwgKFwiOGh6XCIpIGlzIGNvbnZlcnRlZCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBjeWNsZSBpbiBzZWNvbmRzLlxuXHRcdFx0ICogICogTm93LVJlbGF0aXZlLCAoXCIrMVwiKSBwcmVmaXggYW55IG9mIHRoZSBhYm92ZSB3aXRoIFwiK1wiIGFuZCBpdCB3aWxsIGJlIGludGVycHJldGVkIGFzXG5cdFx0XHQgKiAgXCJ0aGUgY3VycmVudCB0aW1lIHBsdXMgd2hhdGV2ZXIgZXhwcmVzc2lvbiBmb2xsb3dzXCIuXG5cdFx0XHQgKiAgKiBFeHByZXNzaW9ucywgKFwiMzowICsgMiAtICgxbSAvIDcpXCIpIGFueSBvZiB0aGUgYWJvdmUgY2FuIGFsc28gYmUgY29tYmluZWRcblx0XHRcdCAqICBpbnRvIGEgbWF0aGVtYXRpY2FsIGV4cHJlc3Npb24gd2hpY2ggd2lsbCBiZSBldmFsdWF0ZWQgdG8gY29tcHV0ZSB0aGUgZGVzaXJlZCB0aW1lLlxuXHRcdFx0ICogICogTm8gQXJndW1lbnQsIGZvciBtZXRob2RzIHdoaWNoIGFjY2VwdCB0aW1lLCBubyBhcmd1bWVudCB3aWxsIGJlIGludGVycHJldGVkIGFzXG5cdFx0XHQgKiAgXCJub3dcIiAoaS5lLiB0aGUgY3VycmVudFRpbWUpLlxuXHRcdFx0ICpcblx0XHRcdCAqICBAdHlwZWRlZiB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIFRpbWU6ICd0aW1lJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBGcmVxdWVuY3kgY2FuIGJlIGRlc2NyaWJlZCBzaW1pbGFyIHRvIHRpbWUsIGV4Y2VwdCB1bHRpbWF0ZWx5IHRoZVxuXHRcdFx0ICogIHZhbHVlcyBhcmUgY29udmVydGVkIHRvIGZyZXF1ZW5jeSBpbnN0ZWFkIG9mIHNlY29uZHMuIEEgbnVtYmVyXG5cdFx0XHQgKiAgaXMgdGFrZW4gbGl0ZXJhbGx5IGFzIHRoZSB2YWx1ZSBpbiBoZXJ0ei4gQWRkaXRpb25hbGx5IGFueSBvZiB0aGVcblx0XHRcdCAqICBUaW1lIGVuY29kaW5ncyBjYW4gYmUgdXNlZC4gTm90ZSBuYW1lcyBpbiB0aGUgZm9ybVxuXHRcdFx0ICogIG9mIE5PVEUgT0NUQVZFIChpLmUuIEM0KSBhcmUgYWxzbyBhY2NlcHRlZCBhbmQgY29udmVydGVkIHRvIHRoZWlyXG5cdFx0XHQgKiAgZnJlcXVlbmN5IHZhbHVlLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtGcmVxdWVuY3l9XG5cdFx0XHQgKi9cblx0ICAgICAgICBGcmVxdWVuY3k6ICdmcmVxdWVuY3knLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRyYW5zcG9ydFRpbWUgZGVzY3JpYmVzIGEgcG9zaXRpb24gYWxvbmcgdGhlIFRyYW5zcG9ydCdzIHRpbWVsaW5lLiBJdCBpc1xuXHRcdFx0ICogIHNpbWlsYXIgdG8gVGltZSBpbiB0aGF0IGl0IHVzZXMgYWxsIHRoZSBzYW1lIGVuY29kaW5ncywgYnV0IFRyYW5zcG9ydFRpbWUgc3BlY2lmaWNhbGx5XG5cdFx0XHQgKiAgcGVydGFpbnMgdG8gdGhlIFRyYW5zcG9ydCdzIHRpbWVsaW5lLCB3aGljaCBpcyBzdGFydGFibGUsIHN0b3BwYWJsZSwgbG9vcGFibGUsIGFuZCBzZWVrYWJsZS5cblx0XHRcdCAqICBbUmVhZCBtb3JlXShodHRwczovL2dpdGh1Yi5jb20vVG9uZWpzL1RvbmUuanMvd2lraS9UcmFuc3BvcnRUaW1lKVxuXHRcdFx0ICogIEB0eXBlZGVmIHtUcmFuc3BvcnRUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgVHJhbnNwb3J0VGltZTogJ3RyYW5zcG9ydFRpbWUnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRpY2tzIGFyZSB0aGUgYmFzaWMgc3VidW5pdCBvZiB0aGUgVHJhbnNwb3J0LiBUaGV5IGFyZVxuXHRcdFx0ICogIHRoZSBzbWFsbGVzdCB1bml0IG9mIHRpbWUgdGhhdCB0aGUgVHJhbnNwb3J0IHN1cHBvcnRzLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtUaWNrc31cblx0XHRcdCAqL1xuXHQgICAgICAgIFRpY2tzOiAndGlja3MnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIE5vcm1hbCB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgcmFuZ2UgWzAsIDFdLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIE5vcm1hbFJhbmdlOiAnbm9ybWFsUmFuZ2UnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEF1ZGlvUmFuZ2UgdmFsdWVzIGFyZSBiZXR3ZWVuIFstMSwgMV0uXG5cdFx0XHQgKiAgQHR5cGVkZWYge0F1ZGlvUmFuZ2V9XG5cdFx0XHQgKi9cblx0ICAgICAgICBBdWRpb1JhbmdlOiAnYXVkaW9SYW5nZScsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgRGVjaWJlbHMgYXJlIGEgbG9nYXJpdGhtaWMgdW5pdCBvZiBtZWFzdXJlbWVudCB3aGljaCBpcyB1c2VmdWwgZm9yIHZvbHVtZVxuXHRcdFx0ICogIGJlY2F1c2Ugb2YgdGhlIGxvZ2FyaXRobWljIHdheSB0aGF0IHdlIHBlcmNlaXZlIGxvdWRuZXNzLiAwIGRlY2liZWxzXG5cdFx0XHQgKiAgbWVhbnMgbm8gY2hhbmdlIGluIHZvbHVtZS4gLTEwZGIgaXMgYXBwcm94aW1hdGVseSBoYWxmIGFzIGxvdWQgYW5kIDEwZGJcblx0XHRcdCAqICBpcyB0d2ljZSBpcyBsb3VkLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtEZWNpYmVsc31cblx0XHRcdCAqL1xuXHQgICAgICAgIERlY2liZWxzOiAnZGInLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEhhbGYtc3RlcCBub3RlIGluY3JlbWVudHMsIGkuZS4gMTIgaXMgYW4gb2N0YXZlIGFib3ZlIHRoZSByb290LiBhbmQgMSBpcyBhIGhhbGYtc3RlcCB1cC5cblx0XHRcdCAqICBAdHlwZWRlZiB7SW50ZXJ2YWx9XG5cdFx0XHQgKi9cblx0ICAgICAgICBJbnRlcnZhbDogJ2ludGVydmFsJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBCZWF0cyBwZXIgbWludXRlLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtCUE19XG5cdFx0XHQgKi9cblx0ICAgICAgICBCUE06ICdicG0nLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtQb3NpdGl2ZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIFBvc2l0aXZlOiAncG9zaXRpdmUnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEdhaW4gaXMgdGhlIHJhdGlvIGJldHdlZW4gaW5wdXQgYW5kIG91dHB1dCBvZiBhIHNpZ25hbC5cblx0XHRcdCAqICBBIGdhaW4gb2YgMCBpcyB0aGUgc2FtZSBhcyBzaWxlbmNpbmcgdGhlIHNpZ25hbC4gQSBnYWluIG9mXG5cdFx0XHQgKiAgMSwgY2F1c2VzIG5vIGNoYW5nZSB0byB0aGUgaW5jb21pbmcgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtHYWlufVxuXHRcdFx0ICovXG5cdCAgICAgICAgR2FpbjogJ2dhaW4nLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgY2VudCBpcyBhIGh1bmRyZWR0aCBvZiBhIHNlbWl0b25lLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtDZW50c31cblx0XHRcdCAqL1xuXHQgICAgICAgIENlbnRzOiAnY2VudHMnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFuZ2xlIGJldHdlZW4gMCBhbmQgMzYwLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtEZWdyZWVzfVxuXHRcdFx0ICovXG5cdCAgICAgICAgRGVncmVlczogJ2RlZ3JlZXMnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgbnVtYmVyIHJlcHJlc2VudGluZyBhIG1pZGkgbm90ZS5cblx0XHRcdCAqICBAdHlwZWRlZiB7TUlESX1cblx0XHRcdCAqL1xuXHQgICAgICAgIE1JREk6ICdtaWRpJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIGNvbG9uLXNlcGFyYXRlZCByZXByZXNlbnRhdGlvbiBvZiB0aW1lIGluIHRoZSBmb3JtIG9mXG5cdFx0XHQgKiAgQmFyczpCZWF0czpTaXh0ZWVudGhzLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtCYXJzQmVhdHNTaXh0ZWVudGhzfVxuXHRcdFx0ICovXG5cdCAgICAgICAgQmFyc0JlYXRzU2l4dGVlbnRoczogJ2JhcnNCZWF0c1NpeHRlZW50aHMnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFNhbXBsaW5nIGlzIHRoZSByZWR1Y3Rpb24gb2YgYSBjb250aW51b3VzIHNpZ25hbCB0byBhIGRpc2NyZXRlIHNpZ25hbC5cblx0XHRcdCAqICBBdWRpbyBpcyB0eXBpY2FsbHkgc2FtcGxlZCA0NDEwMCB0aW1lcyBwZXIgc2Vjb25kLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtTYW1wbGVzfVxuXHRcdFx0ICovXG5cdCAgICAgICAgU2FtcGxlczogJ3NhbXBsZXMnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEhlcnR6IGFyZSBhIGZyZXF1ZW5jeSByZXByZXNlbnRhdGlvbiBkZWZpbmVkIGFzIG9uZSBjeWNsZSBwZXIgc2Vjb25kLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtIZXJ0en1cblx0XHRcdCAqL1xuXHQgICAgICAgIEhlcnR6OiAnaGVydHonLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgZnJlcXVlbmN5IHJlcHJlc2VudGVkIGJ5IGEgbGV0dGVyIG5hbWUsXG5cdFx0XHQgKiAgYWNjaWRlbnRhbCBhbmQgb2N0YXZlLiBUaGlzIHN5c3RlbSBpcyBrbm93biBhc1xuXHRcdFx0ICogIFtTY2llbnRpZmljIFBpdGNoIE5vdGF0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2llbnRpZmljX3BpdGNoX25vdGF0aW9uKS5cblx0XHRcdCAqICBAdHlwZWRlZiB7Tm90ZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIE5vdGU6ICdub3RlJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBPbmUgbWlsbGlzZWNvbmQgaXMgYSB0aG91c2FuZHRoIG9mIGEgc2Vjb25kLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtNaWxsaXNlY29uZHN9XG5cdFx0XHQgKi9cblx0ICAgICAgICBNaWxsaXNlY29uZHM6ICdtaWxsaXNlY29uZHMnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFNlY29uZHMgYXJlIHRoZSB0aW1lIHVuaXQgb2YgdGhlIEF1ZGlvQ29udGV4dC4gSW4gdGhlIGVuZCxcblx0XHRcdCAqICBhbGwgdmFsdWVzIG5lZWQgdG8gYmUgZXZhbHVhdGVkIHRvIHNlY29uZHMuXG5cdFx0XHQgKiAgQHR5cGVkZWYge1NlY29uZHN9XG5cdFx0XHQgKi9cblx0ICAgICAgICBTZWNvbmRzOiAnc2Vjb25kcycsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZHVyYXRpb24gcmVsYXRpdmUgdG8gYSBtZWFzdXJlLlxuXHRcdFx0ICogICogXCI0blwiID0gcXVhcnRlciBub3RlXG5cdFx0XHQgKiAgKiBcIjJtXCIgPSB0d28gbWVhc3VyZXNcblx0XHRcdCAqICAqIFwiOHRcIiA9IGVpZ2h0aC1ub3RlIHRyaXBsZXRcblx0XHRcdCAqICBAdHlwZWRlZiB7Tm90YXRpb259XG5cdFx0XHQgKi9cblx0ICAgICAgICBOb3RhdGlvbjogJ25vdGF0aW9uJ1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gQVVHTUVOVCBUT05FJ3MgUFJPVE9UWVBFXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IFRpbWUgaW50byBzZWNvbmRzLlxuXHRcdCAqXG5cdFx0ICogIFVubGlrZSB0aGUgbWV0aG9kIHdoaWNoIGl0IG92ZXJyaWRlcywgdGhpcyB0YWtlcyBpbnRvIGFjY291bnRcblx0XHQgKiAgdHJhbnNwb3J0dGltZSBhbmQgbXVzaWNhbCBub3RhdGlvbi5cblx0XHQgKlxuXHRcdCAqICBUaW1lIDogMS40MFxuXHRcdCAqICBOb3RhdGlvbjogNG4gb3IgMW0gb3IgMnRcblx0XHQgKiAgTm93IFJlbGF0aXZlOiArM25cblx0XHQgKiAgTWF0aDogM24rMTZuIG9yIGV2ZW4gY29tcGxpY2F0ZWQgZXhwcmVzc2lvbnMgKCgzbioyKS82ICsgMSlcblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lXG5cdFx0ICogIEByZXR1cm4ge1NlY29uZHN9XG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS50b1NlY29uZHMgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIGlmIChUb25lLmlzTnVtYmVyKHRpbWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aW1lO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc1VuZGVmKHRpbWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLm5vdygpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc1N0cmluZyh0aW1lKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFRvbmUuVGltZSh0aW1lKS50b1NlY29uZHMoKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRpbWUgaW5zdGFuY2VvZiBUb25lLlRpbWVCYXNlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aW1lLnRvU2Vjb25kcygpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBhIGZyZXF1ZW5jeSByZXByZXNlbnRhdGlvbiBpbnRvIGEgbnVtYmVyLlxuXHRcdCAqICBAcGFyYW0gIHtGcmVxdWVuY3l9IGZyZXFcblx0XHQgKiAgQHJldHVybiB7SGVydHp9ICAgICAgdGhlIGZyZXF1ZW5jeSBpbiBoZXJ0elxuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUudG9GcmVxdWVuY3kgPSBmdW5jdGlvbiAoZnJlcSkge1xuXHQgICAgICAgIGlmIChUb25lLmlzTnVtYmVyKGZyZXEpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmcmVxO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc1N0cmluZyhmcmVxKSB8fCBUb25lLmlzVW5kZWYoZnJlcSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBUb25lLkZyZXF1ZW5jeShmcmVxKS52YWx1ZU9mKCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChmcmVxIGluc3RhbmNlb2YgVG9uZS5UaW1lQmFzZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZnJlcS50b0ZyZXF1ZW5jeSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBhIHRpbWUgcmVwcmVzZW50YXRpb24gaW50byB0aWNrcy5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gdGltZVxuXHRcdCAqICBAcmV0dXJuIHtUaWNrc30gIHRoZSB0aW1lIGluIHRpY2tzXG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS50b1RpY2tzID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc051bWJlcih0aW1lKSB8fCBUb25lLmlzU3RyaW5nKHRpbWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgVG9uZS5UcmFuc3BvcnRUaW1lKHRpbWUpLnRvVGlja3MoKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNVbmRlZih0aW1lKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnQudGlja3M7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aW1lIGluc3RhbmNlb2YgVG9uZS5UaW1lQmFzZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGltZS50b1RpY2tzKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5QYXJhbSB3cmFwcyB0aGUgbmF0aXZlIFdlYiBBdWRpbydzIEF1ZGlvUGFyYW0gdG8gcHJvdmlkZVxuXHRcdCAqICAgICAgICAgYWRkaXRpb25hbCB1bml0IGNvbnZlcnNpb24gZnVuY3Rpb25hbGl0eS4gSXQgYWxzb1xuXHRcdCAqICAgICAgICAgc2VydmVzIGFzIGEgYmFzZS1jbGFzcyBmb3IgY2xhc3NlcyB3aGljaCBoYXZlIGEgc2luZ2xlLFxuXHRcdCAqICAgICAgICAgYXV0b21hdGFibGUgcGFyYW1ldGVyLlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSAge0F1ZGlvUGFyYW19ICBwYXJhbSAgVGhlIHBhcmFtZXRlciB0byB3cmFwLlxuXHRcdCAqICBAcGFyYW0gIHtUb25lLlR5cGV9IHVuaXRzIFRoZSB1bml0cyBvZiB0aGUgYXVkaW8gcGFyYW0uXG5cdFx0ICogIEBwYXJhbSAge0Jvb2xlYW59IGNvbnZlcnQgSWYgdGhlIHBhcmFtIHNob3VsZCBiZSBjb252ZXJ0ZWQuXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3BhcmFtJyxcblx0ICAgICAgICAgICAgJ3VuaXRzJyxcblx0ICAgICAgICAgICAgJ2NvbnZlcnQnXG5cdCAgICAgICAgXSwgVG9uZS5QYXJhbSk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbmF0aXZlIHBhcmFtZXRlciB0byBjb250cm9sXG5cdFx0XHQgKiAgQHR5cGUgIHtBdWRpb1BhcmFtfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYXJhbSA9IHRoaXMuaW5wdXQgPSBvcHRpb25zLnBhcmFtO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB1bml0cyBvZiB0aGUgcGFyYW1ldGVyXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuVHlwZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudW5pdHMgPSBvcHRpb25zLnVuaXRzO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIElmIHRoZSB2YWx1ZSBzaG91bGQgYmUgY29udmVydGVkIG9yIG5vdFxuXHRcdFx0ICogIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5jb252ZXJ0ID0gb3B0aW9ucy5jb252ZXJ0O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRydWUgaWYgdGhlIHNpZ25hbCB2YWx1ZSBpcyBiZWluZyBvdmVycmlkZGVuIGJ5XG5cdFx0XHQgKiAgYSBjb25uZWN0ZWQgc2lnbmFsLlxuXHRcdFx0ICogIEByZWFkT25seVxuXHRcdFx0ICogIEB0eXBlICB7Ym9vbGVhbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vdmVycmlkZGVuID0gZmFsc2U7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSWYgdGhlcmUgaXMgYW4gTEZPLCB0aGlzIGlzIHdoZXJlIGl0IGlzIGhlbGQuXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvID0gbnVsbDtcblx0ICAgICAgICBpZiAoVG9uZS5pc09iamVjdChvcHRpb25zLmxmbykpIHtcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMubGZvO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoIVRvbmUuaXNVbmRlZihvcHRpb25zLnZhbHVlKSkge1xuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QYXJhbSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIERlZmF1bHRzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3VuaXRzJzogVG9uZS5UeXBlLkRlZmF1bHQsXG5cdCAgICAgICAgJ2NvbnZlcnQnOiB0cnVlLFxuXHQgICAgICAgICdwYXJhbSc6IHVuZGVmaW5lZFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGFyYW0jXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSB2YWx1ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFyYW0ucHJvdG90eXBlLCAndmFsdWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90b1VuaXRzKHRoaXMuX3BhcmFtLnZhbHVlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzT2JqZWN0KHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgLy90aHJvdyBhbiBlcnJvciBpZiB0aGUgTEZPIG5lZWRzIHRvIGJlIGluY2x1ZGVkXG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKFRvbmUuTEZPKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jbHVkZSBcXCdUb25lLkxGT1xcJyB0byB1c2UgYW4gTEZPIGFzIGEgUGFyYW0gdmFsdWUuJyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvL3JlbW92ZSB0aGUgb2xkIG9uZVxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xmbykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xmby5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm8gPSBuZXcgVG9uZS5MRk8odmFsdWUpLnN0YXJ0KCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm8uY29ubmVjdCh0aGlzLmlucHV0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0ZWRWYWwgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW0uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKDApO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW0udmFsdWUgPSBjb252ZXJ0ZWRWYWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IHRoZSBnaXZlbiB2YWx1ZSBmcm9tIHRoZSB0eXBlIHNwZWNpZmllZCBieSBUb25lLlBhcmFtLnVuaXRzXG5cdFx0ICogIGludG8gdGhlIGRlc3RpbmF0aW9uIHZhbHVlIChzdWNoIGFzIEdhaW4gb3IgRnJlcXVlbmN5KS5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHBhcmFtICB7Kn0gdmFsIHRoZSB2YWx1ZSB0byBjb252ZXJ0XG5cdFx0ICogIEByZXR1cm4ge251bWJlcn0gICAgIHRoZSBudW1iZXIgd2hpY2ggdGhlIHZhbHVlIHNob3VsZCBiZSBzZXQgdG9cblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLl9mcm9tVW5pdHMgPSBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuY29udmVydCB8fCBUb25lLmlzVW5kZWYodGhpcy5jb252ZXJ0KSkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKHRoaXMudW5pdHMpIHtcblx0ICAgICAgICAgICAgY2FzZSBUb25lLlR5cGUuVGltZTpcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU2Vjb25kcyh2YWwpO1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuVHlwZS5GcmVxdWVuY3k6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0ZyZXF1ZW5jeSh2YWwpO1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuVHlwZS5EZWNpYmVsczpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBUb25lLmRiVG9HYWluKHZhbCk7XG5cdCAgICAgICAgICAgIGNhc2UgVG9uZS5UeXBlLk5vcm1hbFJhbmdlOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgMCksIDEpO1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuVHlwZS5BdWRpb1JhbmdlOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgLTEpLCAxKTtcblx0ICAgICAgICAgICAgY2FzZSBUb25lLlR5cGUuUG9zaXRpdmU6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodmFsLCAwKTtcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBDb252ZXJ0IHRoZSBwYXJhbWV0ZXJzIHZhbHVlIGludG8gdGhlIHVuaXRzIHNwZWNpZmllZCBieSBUb25lLlBhcmFtLnVuaXRzLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHBhcmFtICB7bnVtYmVyfSB2YWwgdGhlIHZhbHVlIHRvIGNvbnZlcnRcblx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5fdG9Vbml0cyA9IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICBpZiAodGhpcy5jb252ZXJ0IHx8IFRvbmUuaXNVbmRlZih0aGlzLmNvbnZlcnQpKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAodGhpcy51bml0cykge1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuVHlwZS5EZWNpYmVsczpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBUb25lLmdhaW5Ub0RiKHZhbCk7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBtaW5pbXVtIG91dHB1dCB2YWx1ZVxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuX21pbk91dHB1dCA9IDAuMDAwMDE7XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGVzIGEgcGFyYW1ldGVyIHZhbHVlIGNoYW5nZSBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtIHsqfVx0dmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgc2lnbmFsLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9ICB0aW1lIFRoZSB0aW1lIHdoZW4gdGhlIGNoYW5nZSBzaG91bGQgb2NjdXIuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zZXQgdGhlIGZyZXF1ZW5jeSB0byBcIkc0XCIgaW4gZXhhY3RseSAxIHNlY29uZCBmcm9tIG5vdy5cblx0XHQgKiBmcmVxLnNldFZhbHVlQXRUaW1lKFwiRzRcIiwgXCIrMVwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLnNldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCB0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0uc2V0VmFsdWVBdFRpbWUodGhpcy5fZnJvbVVuaXRzKHZhbHVlKSwgdGhpcy50b1NlY29uZHModGltZSkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDcmVhdGVzIGEgc2NoZWR1bGUgcG9pbnQgd2l0aCB0aGUgY3VycmVudCB2YWx1ZSBhdCB0aGUgY3VycmVudCB0aW1lLlxuXHRcdCAqICBUaGlzIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYW4gYXV0b21hdGlvbiBhbmNob3IgcG9pbnQgaW4gb3JkZXIgdG9cblx0XHQgKiAgc2NoZWR1bGUgY2hhbmdlcyBmcm9tIHRoZSBjdXJyZW50IHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gbm93IChPcHRpb25hbGx5KSBwYXNzIHRoZSBub3cgdmFsdWUgaW4uXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5zZXRSYW1wUG9pbnQgPSBmdW5jdGlvbiAobm93KSB7XG5cdCAgICAgICAgbm93ID0gVG9uZS5kZWZhdWx0QXJnKG5vdywgdGhpcy5ub3coKSk7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRWYWwgPSB0aGlzLl9wYXJhbS52YWx1ZTtcblx0ICAgICAgICAvLyBleHBvbmVudGlhbFJhbXBUb1ZhbHVlQXQgY2Fubm90IGV2ZXIgcmFtcCBmcm9tIG9yIHRvIDBcblx0ICAgICAgICAvLyBNb3JlIGluZm86IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjU2MDAjYzJcblx0ICAgICAgICBpZiAoY3VycmVudFZhbCA9PT0gMCkge1xuXHQgICAgICAgICAgICBjdXJyZW50VmFsID0gdGhpcy5fbWluT3V0cHV0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9wYXJhbS5zZXRWYWx1ZUF0VGltZShjdXJyZW50VmFsLCBub3cpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZXMgYSBsaW5lYXIgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb20gdGhlXG5cdFx0ICogIHByZXZpb3VzIHNjaGVkdWxlZCBwYXJhbWV0ZXIgdmFsdWUgdG8gdGhlIGdpdmVuIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gZW5kVGltZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWUsIGVuZFRpbWUpIHtcblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIHRoaXMudG9TZWNvbmRzKGVuZFRpbWUpKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGVzIGFuIGV4cG9uZW50aWFsIGNvbnRpbnVvdXMgY2hhbmdlIGluIHBhcmFtZXRlciB2YWx1ZSBmcm9tXG5cdFx0ICogIHRoZSBwcmV2aW91cyBzY2hlZHVsZWQgcGFyYW1ldGVyIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGVuZFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWUsIGVuZFRpbWUpIHtcblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdCAgICAgICAgdmFsdWUgPSBNYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsIHZhbHVlKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCB0aGlzLnRvU2Vjb25kcyhlbmRUaW1lKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNjaGVkdWxlcyBhbiBleHBvbmVudGlhbCBjb250aW51b3VzIGNoYW5nZSBpbiBwYXJhbWV0ZXIgdmFsdWUgZnJvbVxuXHRcdCAqICB0aGUgY3VycmVudCB0aW1lIGFuZCBjdXJyZW50IHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZSBvdmVyIHRoZVxuXHRcdCAqICBkdXJhdGlvbiBvZiB0aGUgcmFtcFRpbWUuXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSB2YWx1ZSAgIFRoZSB2YWx1ZSB0byByYW1wIHRvLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSByYW1wVGltZSB0aGUgdGltZSB0aGF0IGl0IHRha2VzIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIHRvIHJhbXAgZnJvbSBpdCdzIGN1cnJlbnQgdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfVx0W3N0YXJ0VGltZT1ub3ddIFx0V2hlbiB0aGUgcmFtcCBzaG91bGQgc3RhcnQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9leHBvbmVudGlhbGx5IHJhbXAgdG8gdGhlIHZhbHVlIDIgb3ZlciA0IHNlY29uZHMuXG5cdFx0ICogc2lnbmFsLmV4cG9uZW50aWFsUmFtcFRvVmFsdWUoMiwgNCk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCByYW1wVGltZSwgc3RhcnRUaW1lKSB7XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLnNldFJhbXBQb2ludChzdGFydFRpbWUpO1xuXHQgICAgICAgIHRoaXMuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgc3RhcnRUaW1lICsgdGhpcy50b1NlY29uZHMocmFtcFRpbWUpKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGVzIGFuIGxpbmVhciBjb250aW51b3VzIGNoYW5nZSBpbiBwYXJhbWV0ZXIgdmFsdWUgZnJvbVxuXHRcdCAqICB0aGUgY3VycmVudCB0aW1lIGFuZCBjdXJyZW50IHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZSBvdmVyIHRoZVxuXHRcdCAqICBkdXJhdGlvbiBvZiB0aGUgcmFtcFRpbWUuXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSB2YWx1ZSAgIFRoZSB2YWx1ZSB0byByYW1wIHRvLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSByYW1wVGltZSB0aGUgdGltZSB0aGF0IGl0IHRha2VzIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIHRvIHJhbXAgZnJvbSBpdCdzIGN1cnJlbnQgdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfVx0W3N0YXJ0VGltZT1ub3ddIFx0V2hlbiB0aGUgcmFtcCBzaG91bGQgc3RhcnQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9saW5lYXJseSByYW1wIHRvIHRoZSB2YWx1ZSA0IG92ZXIgMyBzZWNvbmRzLlxuXHRcdCAqIHNpZ25hbC5saW5lYXJSYW1wVG9WYWx1ZSg0LCAzKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCByYW1wVGltZSwgc3RhcnRUaW1lKSB7XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLnNldFJhbXBQb2ludChzdGFydFRpbWUpO1xuXHQgICAgICAgIHRoaXMubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIHN0YXJ0VGltZSArIHRoaXMudG9TZWNvbmRzKHJhbXBUaW1lKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IGV4cG9uZW50aWFsbHkgYXBwcm9hY2hpbmcgdGhlIHRhcmdldCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZSB3aXRoXG5cdFx0ICogIGEgcmF0ZSBoYXZpbmcgdGhlIGdpdmVuIHRpbWUgY29uc3RhbnQuXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHN0YXJ0VGltZVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdGltZUNvbnN0YW50XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5zZXRUYXJnZXRBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0VGltZSwgdGltZUNvbnN0YW50KSB7XG5cdCAgICAgICAgdmFsdWUgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgIC8vIFRoZSB2YWx1ZSB3aWxsIG5ldmVyIGJlIGFibGUgdG8gYXBwcm9hY2ggd2l0aG91dCB0aW1lQ29uc3RhbnQgPiAwLlxuXHQgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3dlYmF1ZGlvLyNkZm4tc2V0VGFyZ2V0QXRUaW1lLCB3aGVyZSB0aGUgZXF1YXRpb25cblx0ICAgICAgICAvLyBpcyBkZXNjcmliZWQuIDAgcmVzdWx0cyBpbiBhIGRpdmlzaW9uIGJ5IDAuXG5cdCAgICAgICAgdmFsdWUgPSBNYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsIHZhbHVlKTtcblx0ICAgICAgICB0aW1lQ29uc3RhbnQgPSBNYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsIHRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0uc2V0VGFyZ2V0QXRUaW1lKHZhbHVlLCB0aGlzLnRvU2Vjb25kcyhzdGFydFRpbWUpLCB0aW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXRzIGFuIGFycmF5IG9mIGFyYml0cmFyeSBwYXJhbWV0ZXIgdmFsdWVzIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIGZvciB0aGUgZ2l2ZW4gZHVyYXRpb24uXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtIHtBcnJheX0gdmFsdWVzXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gc3RhcnRUaW1lXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gZHVyYXRpb25cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLnNldFZhbHVlQ3VydmVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWVzLCBzdGFydFRpbWUsIGR1cmF0aW9uKSB7XG5cdCAgICAgICAgZHVyYXRpb24gPSB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbik7XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLnNldFZhbHVlQXRUaW1lKHZhbHVlc1swXSwgc3RhcnRUaW1lKTtcblx0ICAgICAgICB2YXIgc2VnVGltZSA9IGR1cmF0aW9uIC8gKHZhbHVlcy5sZW5ndGggLSAxKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9wYXJhbS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLl9mcm9tVW5pdHModmFsdWVzW2ldKSwgc3RhcnRUaW1lICsgaSAqIHNlZ1RpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VscyBhbGwgc2NoZWR1bGVkIHBhcmFtZXRlciBjaGFuZ2VzIHdpdGggdGltZXMgZ3JlYXRlciB0aGFuIG9yXG5cdFx0ICogIGVxdWFsIHRvIHN0YXJ0VGltZS5cblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBzdGFydFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyA9IGZ1bmN0aW9uIChzdGFydFRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9wYXJhbS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJhbXBzIHRvIHRoZSBnaXZlbiB2YWx1ZSBvdmVyIHRoZSBkdXJhdGlvbiBvZiB0aGUgcmFtcFRpbWUuXG5cdFx0ICogIEF1dG9tYXRpY2FsbHkgc2VsZWN0cyB0aGUgYmVzdCByYW1wIHR5cGUgKGV4cG9uZW50aWFsIG9yIGxpbmVhcilcblx0XHQgKiAgZGVwZW5kaW5nIG9uIHRoZSBgdW5pdHNgIG9mIHRoZSBzaWduYWxcblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHJhbXBUaW1lIFx0VGhlIHRpbWUgdGhhdCBpdCB0YWtlcyB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIHRvIHJhbXAgZnJvbSBpdCdzIGN1cnJlbnQgdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfVx0W3N0YXJ0VGltZT1ub3ddIFx0V2hlbiB0aGUgcmFtcCBzaG91bGQgc3RhcnQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9yYW1wIHRvIHRoZSB2YWx1ZSBlaXRoZXIgbGluZWFybHkgb3IgZXhwb25lbnRpYWxseVxuXHRcdCAqIC8vZGVwZW5kaW5nIG9uIHRoZSBcInVuaXRzXCIgdmFsdWUgb2YgdGhlIHNpZ25hbFxuXHRcdCAqIHNpZ25hbC5yYW1wVG8oMCwgMTApO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vc2NoZWR1bGUgaXQgdG8gcmFtcCBzdGFydGluZyBhdCBhIHNwZWNpZmljIHRpbWVcblx0XHQgKiBzaWduYWwucmFtcFRvKDAsIDEwLCA1KVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUucmFtcFRvID0gZnVuY3Rpb24gKHZhbHVlLCByYW1wVGltZSwgc3RhcnRUaW1lKSB7XG5cdCAgICAgICAgcmFtcFRpbWUgPSBUb25lLmRlZmF1bHRBcmcocmFtcFRpbWUsIDApO1xuXHQgICAgICAgIGlmICh0aGlzLnVuaXRzID09PSBUb25lLlR5cGUuRnJlcXVlbmN5IHx8IHRoaXMudW5pdHMgPT09IFRvbmUuVHlwZS5CUE0gfHwgdGhpcy51bml0cyA9PT0gVG9uZS5UeXBlLkRlY2liZWxzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZSh2YWx1ZSwgcmFtcFRpbWUsIHN0YXJ0VGltZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5saW5lYXJSYW1wVG9WYWx1ZSh2YWx1ZSwgcmFtcFRpbWUsIHN0YXJ0VGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgTEZPIGNyZWF0ZWQgYnkgdGhlIHNpZ25hbCBpbnN0YW5jZS4gSWYgbm9uZVxuXHRcdCAqICB3YXMgY3JlYXRlZCwgdGhpcyBpcyBudWxsLlxuXHRcdCAqICBAdHlwZSB7VG9uZS5MRk99XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYXJhbSNcblx0XHQgKiAgQG5hbWUgbGZvXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYXJhbS5wcm90b3R5cGUsICdsZm8nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZm87XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbSA9IG51bGw7XG5cdCAgICAgICAgaWYgKHRoaXMuX2xmbykge1xuXHQgICAgICAgICAgICB0aGlzLl9sZm8uZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm8gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QYXJhbTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgY3JlYXRlR2FpbiBzaGltXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBpZiAod2luZG93LkdhaW5Ob2RlICYmICFBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW4pIHtcblx0ICAgICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW4gPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW5Ob2RlO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBIHRoaW4gd3JhcHBlciBhcm91bmQgdGhlIE5hdGl2ZSBXZWIgQXVkaW8gR2Fpbk5vZGUuXG5cdFx0ICogICAgICAgICBUaGUgR2Fpbk5vZGUgaXMgYSBiYXNpYyBidWlsZGluZyBibG9jayBvZiB0aGUgV2ViIEF1ZGlvXG5cdFx0ICogICAgICAgICBBUEkgYW5kIGlzIHVzZWZ1bCBmb3Igcm91dGluZyBhdWRpbyBhbmQgYWRqdXN0aW5nIGdhaW5zLlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyPX0gIGdhaW4gIFRoZSBpbml0aWFsIGdhaW4gb2YgdGhlIEdhaW5Ob2RlXG5cdFx0ICogIEBwYXJhbSB7VG9uZS5UeXBlPX0gdW5pdHMgVGhlIHVuaXRzIG9mIHRoZSBnYWluIHBhcmFtZXRlci5cblx0XHQgKi9cblx0ICAgIFRvbmUuR2FpbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdnYWluJyxcblx0ICAgICAgICAgICAgJ3VuaXRzJ1xuXHQgICAgICAgIF0sIFRvbmUuR2Fpbik7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgR2Fpbk5vZGVcblx0XHRcdCAqICBAdHlwZSAge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSB0aGlzLl9nYWluTm9kZSA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGdhaW4gcGFyYW1ldGVyIG9mIHRoZSBnYWluIG5vZGUuXG5cdFx0XHQgKiAgQHR5cGUge0dhaW59XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5nYWluID0gbmV3IFRvbmUuUGFyYW0oe1xuXHQgICAgICAgICAgICAncGFyYW0nOiB0aGlzLl9nYWluTm9kZS5nYWluLFxuXHQgICAgICAgICAgICAndW5pdHMnOiBvcHRpb25zLnVuaXRzLFxuXHQgICAgICAgICAgICAndmFsdWUnOiBvcHRpb25zLmdhaW4sXG5cdCAgICAgICAgICAgICdjb252ZXJ0Jzogb3B0aW9ucy5jb252ZXJ0XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ2dhaW4nKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkdhaW4sIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5HYWluLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdnYWluJzogMSxcblx0ICAgICAgICAnY29udmVydCc6IHRydWVcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkdhaW59ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkdhaW4ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9nYWluTm9kZS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fZ2Fpbk5vZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCdnYWluJyk7XG5cdCAgICAgICAgdGhpcy5nYWluLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmdhaW4gPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkdhaW47XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQSBzaWduYWwgaXMgYW4gYXVkaW8tcmF0ZSB2YWx1ZS4gVG9uZS5TaWduYWwgaXMgYSBjb3JlIGNvbXBvbmVudCBvZiB0aGUgbGlicmFyeS5cblx0XHQgKiAgICAgICAgICBVbmxpa2UgYSBudW1iZXIsIFNpZ25hbHMgY2FuIGJlIHNjaGVkdWxlZCB3aXRoIHNhbXBsZS1sZXZlbCBhY2N1cmFjeS4gVG9uZS5TaWduYWxcblx0XHQgKiAgICAgICAgICBoYXMgYWxsIG9mIHRoZSBtZXRob2RzIGF2YWlsYWJsZSB0byBuYXRpdmUgV2ViIEF1ZGlvIFxuXHRcdCAqICAgICAgICAgIFtBdWRpb1BhcmFtXShodHRwOi8vd2ViYXVkaW8uZ2l0aHViLmlvL3dlYi1hdWRpby1hcGkvI3RoZS1hdWRpb3BhcmFtLWludGVyZmFjZSlcblx0XHQgKiAgICAgICAgICBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgY29udmVuaWVuY2VzLiBSZWFkIG1vcmUgYWJvdXQgd29ya2luZyB3aXRoIHNpZ25hbHMgXG5cdFx0ICogICAgICAgICAgW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Ub25lanMvVG9uZS5qcy93aWtpL1NpZ25hbHMpLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5QYXJhbX1cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ8QXVkaW9QYXJhbX0gW3ZhbHVlXSBJbml0aWFsIHZhbHVlIG9mIHRoZSBzaWduYWwuIElmIGFuIEF1ZGlvUGFyYW1cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBwYXNzZWQgaW4sIHRoYXQgcGFyYW1ldGVyIHdpbGwgYmUgd3JhcHBlZFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBjb250cm9sbGVkIGJ5IHRoZSBTaWduYWwuIFxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPU51bWJlcl0gdW5pdCBUaGUgdW5pdHMgdGhlIHNpZ25hbCBpcyBpbi4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHNpZ25hbCA9IG5ldyBUb25lLlNpZ25hbCgxMCk7XG5cdFx0ICovXG5cdCAgICBUb25lLlNpZ25hbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd2YWx1ZScsXG5cdCAgICAgICAgICAgICd1bml0cydcblx0ICAgICAgICBdLCBUb25lLlNpZ25hbCk7XG5cdCAgICAgICAgdmFyIGdhaW5Ob2RlID0gVG9uZS5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0ICAgICAgICBvcHRpb25zLnBhcmFtID0gZ2Fpbk5vZGUuZ2Fpbjtcblx0ICAgICAgICBUb25lLlBhcmFtLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgbm9kZSB3aGVyZSB0aGUgY29uc3RhbnQgc2lnbmFsIHZhbHVlIGlzIHNjYWxlZC5cblx0XHRcdCAqIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm91dHB1dCA9IGdhaW5Ob2RlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIG5vZGUgd2hlcmUgdGhlIHZhbHVlIGlzIHNldC5cblx0XHRcdCAqIEB0eXBlIHtUb25lLlBhcmFtfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLl9wYXJhbSA9IHRoaXMub3V0cHV0LmdhaW47XG5cdCAgICAgICAgLy9jb25uZWN0IHRoZSBjb25zdCBvdXRwdXQgdG8gdGhlIG5vZGUgb3V0cHV0XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmdldENvbnN0YW50KDEpLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU2lnbmFsLCBUb25lLlBhcmFtKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLlNpZ25hbC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndmFsdWUnOiAwLFxuXHQgICAgICAgICd1bml0cyc6IFRvbmUuVHlwZS5EZWZhdWx0LFxuXHQgICAgICAgICdjb252ZXJ0JzogdHJ1ZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBXaGVuIHNpZ25hbHMgY29ubmVjdCB0byBvdGhlciBzaWduYWxzIG9yIEF1ZGlvUGFyYW1zLCBcblx0XHQgKiAgdGhleSB0YWtlIG92ZXIgdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGF0IHNpZ25hbCBvciBBdWRpb1BhcmFtLiBcblx0XHQgKiAgRm9yIGFsbCBvdGhlciBub2RlcywgdGhlIGJlaGF2aW9yIGlzIHRoZSBzYW1lIGFzIGEgZGVmYXVsdCA8Y29kZT5jb25uZWN0PC9jb2RlPi4gXG5cdFx0ICpcblx0XHQgKiAgQG92ZXJyaWRlXG5cdFx0ICogIEBwYXJhbSB7QXVkaW9QYXJhbXxBdWRpb05vZGV8VG9uZS5TaWduYWx8VG9uZX0gbm9kZSBcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtvdXRwdXROdW1iZXI9MF0gVGhlIG91dHB1dCBudW1iZXIgdG8gY29ubmVjdCBmcm9tLlxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW2lucHV0TnVtYmVyPTBdIFRoZSBpbnB1dCBudW1iZXIgdG8gY29ubmVjdCB0by5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuU2lnbmFsQmFzZX0gdGhpc1xuXHRcdCAqICBAbWV0aG9kXG5cdFx0ICovXG5cdCAgICBUb25lLlNpZ25hbC5wcm90b3R5cGUuY29ubmVjdCA9IFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuY29ubmVjdDtcblx0ICAgIC8qKlxuXHRcdCAqICBkaXNwb3NlIGFuZCBkaXNjb25uZWN0XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNpZ25hbH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TaWduYWwucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNpZ25hbDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEEgc2lnbmFsIHdoaWNoIGFkZHMgdGhlIG1ldGhvZCBnZXRWYWx1ZUF0VGltZS4gXG5cdFx0ICogICAgICAgICBDb2RlIGFuZCBpbnNwaXJhdGlvbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2FudGVsbC93ZWItYXVkaW8tYXV0b21hdGlvbi10aW1lbGluZVxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWx9XG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyPX0gdmFsdWUgVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIHNpZ25hbFxuXHRcdCAqICBAcGFyYW0ge1N0cmluZz19IHVuaXRzIFRoZSBjb252ZXJzaW9uIHVuaXRzIG9mIHRoZSBzaWduYWwuXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3ZhbHVlJyxcblx0ICAgICAgICAgICAgJ3VuaXRzJ1xuXHQgICAgICAgIF0sIFRvbmUuU2lnbmFsKTtcblx0ICAgICAgICBUb25lLlNpZ25hbC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBzY2hlZHVsZWQgZXZlbnRzXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBUb25lLlRpbWVsaW5lKDEwMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGluaXRpYWwgc2NoZWR1bGVkIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faW5pdGlhbCA9IHRoaXMuX2Zyb21Vbml0cyh0aGlzLl9wYXJhbS52YWx1ZSk7XG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG5cdCAgICAgICAgLy9kZWxldGUgdGhlIGlucHV0IG5vZGUgc28gdGhhdCBub3RoaW5nIGNhbiBvdmVyd3JpdGUgdGhlIHNpZ25hbCB2YWx1ZVxuXHQgICAgICAgIGRlbGV0ZSB0aGlzLmlucHV0O1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVGltZWxpbmVTaWduYWwsIFRvbmUuU2lnbmFsKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZXZlbnQgdHlwZXMgb2YgYSBzY2hlZHVsYWJsZSBzaWduYWwuXG5cdFx0ICogIEBlbnVtIHtTdHJpbmd9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUgPSB7XG5cdCAgICAgICAgTGluZWFyOiAnbGluZWFyJyxcblx0ICAgICAgICBFeHBvbmVudGlhbDogJ2V4cG9uZW50aWFsJyxcblx0ICAgICAgICBUYXJnZXQ6ICd0YXJnZXQnLFxuXHQgICAgICAgIFNldDogJ3NldCdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc2lnbmFsLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5UaW1lbGluZVNpZ25hbCNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIHZhbHVlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUsICd2YWx1ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmdldFZhbHVlQXRUaW1lKG5vdyk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90b1VuaXRzKHZhbCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29udmVydGVkVmFsID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWwgPSBjb252ZXJ0ZWRWYWw7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW0udmFsdWUgPSBjb252ZXJ0ZWRWYWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFNDSEVEVUxJTkdcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFNjaGVkdWxlcyBhIHBhcmFtZXRlciB2YWx1ZSBjaGFuZ2UgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSB7Kn1cdHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHNpZ25hbC5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSAgdGltZSBUaGUgdGltZSB3aGVuIHRoZSBjaGFuZ2Ugc2hvdWxkIG9jY3VyLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZVNpZ25hbH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vc2V0IHRoZSBmcmVxdWVuY3kgdG8gXCJHNFwiIGluIGV4YWN0bHkgMSBzZWNvbmQgZnJvbSBub3cuIFxuXHRcdCAqIGZyZXEuc2V0VmFsdWVBdFRpbWUoXCJHNFwiLCBcIisxXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuc2V0VmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0VGltZSkge1xuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICBzdGFydFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhzdGFydFRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cy5hZGQoe1xuXHQgICAgICAgICAgICAndHlwZSc6IFRvbmUuVGltZWxpbmVTaWduYWwuVHlwZS5TZXQsXG5cdCAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxuXHQgICAgICAgICAgICAndGltZSc6IHN0YXJ0VGltZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vaW52b2tlIHRoZSBvcmlnaW5hbCBldmVudFxuXHQgICAgICAgIHRoaXMuX3BhcmFtLnNldFZhbHVlQXRUaW1lKHZhbHVlLCBzdGFydFRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZXMgYSBsaW5lYXIgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb20gdGhlIFxuXHRcdCAqICBwcmV2aW91cyBzY2hlZHVsZWQgcGFyYW1ldGVyIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWUgICBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gZW5kVGltZSBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCBlbmRUaW1lKSB7XG5cdCAgICAgICAgdmFsdWUgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgIGVuZFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhlbmRUaW1lKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuYWRkKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuTGluZWFyLFxuXHQgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcblx0ICAgICAgICAgICAgJ3RpbWUnOiBlbmRUaW1lXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIGVuZFRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZXMgYW4gZXhwb25lbnRpYWwgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb20gXG5cdFx0ICogIHRoZSBwcmV2aW91cyBzY2hlZHVsZWQgcGFyYW1ldGVyIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWUgICBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gZW5kVGltZSBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWUsIGVuZFRpbWUpIHtcblx0ICAgICAgICAvL2dldCB0aGUgcHJldmlvdXMgZXZlbnQgYW5kIG1ha2Ugc3VyZSBpdCdzIG5vdCBzdGFydGluZyBmcm9tIDBcblx0ICAgICAgICBlbmRUaW1lID0gdGhpcy50b1NlY29uZHMoZW5kVGltZSk7XG5cdCAgICAgICAgdmFyIGJlZm9yZUV2ZW50ID0gdGhpcy5fc2VhcmNoQmVmb3JlKGVuZFRpbWUpO1xuXHQgICAgICAgIGlmIChiZWZvcmVFdmVudCAmJiBiZWZvcmVFdmVudC52YWx1ZSA9PT0gMCkge1xuXHQgICAgICAgICAgICAvL3Jlc2NoZWR1bGUgdGhhdCBldmVudFxuXHQgICAgICAgICAgICB0aGlzLnNldFZhbHVlQXRUaW1lKHRoaXMuX21pbk91dHB1dCwgYmVmb3JlRXZlbnQudGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICB2YXIgc2V0VmFsdWUgPSBNYXRoLm1heCh2YWx1ZSwgdGhpcy5fbWluT3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuYWRkKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuRXhwb25lbnRpYWwsXG5cdCAgICAgICAgICAgICd2YWx1ZSc6IHNldFZhbHVlLFxuXHQgICAgICAgICAgICAndGltZSc6IGVuZFRpbWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvL2lmIHRoZSByYW1wZWQgdG8gdmFsdWUgaXMgMCwgbWFrZSBpdCBnbyB0byB0aGUgbWluIG91dHB1dCwgYW5kIHRoZW4gc2V0IHRvIDAuXG5cdCAgICAgICAgaWYgKHZhbHVlIDwgdGhpcy5fbWluT3V0cHV0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhcmFtLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5fbWluT3V0cHV0LCBlbmRUaW1lIC0gdGhpcy5zYW1wbGVUaW1lKTtcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUF0VGltZSgwLCBlbmRUaW1lKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9wYXJhbS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCBlbmRUaW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IGV4cG9uZW50aWFsbHkgYXBwcm9hY2hpbmcgdGhlIHRhcmdldCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZSB3aXRoXG5cdFx0ICogIGEgcmF0ZSBoYXZpbmcgdGhlIGdpdmVuIHRpbWUgY29uc3RhbnQuXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAgICAgICAgXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gc3RhcnRUaW1lICAgIFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdGltZUNvbnN0YW50IFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZVNpZ25hbH0gdGhpcyBcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFRhcmdldEF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpIHtcblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdCAgICAgICAgdmFsdWUgPSBNYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsIHZhbHVlKTtcblx0ICAgICAgICB0aW1lQ29uc3RhbnQgPSBNYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsIHRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuYWRkKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuVGFyZ2V0LFxuXHQgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcblx0ICAgICAgICAgICAgJ3RpbWUnOiBzdGFydFRpbWUsXG5cdCAgICAgICAgICAgICdjb25zdGFudCc6IHRpbWVDb25zdGFudFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLnNldFRhcmdldEF0VGltZSh2YWx1ZSwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgYW4gYXJyYXkgb2YgYXJiaXRyYXJ5IHZhbHVlcyBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gdGltZSBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLlxuXHRcdCAqICBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmFsdWVzICAgICAgICBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydFRpbWUgICAgXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gZHVyYXRpb25cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3NjYWxpbmc9MV0gSWYgdGhlIHZhbHVlcyBpbiB0aGUgY3VydmUgc2hvdWxkIGJlIHNjYWxlZCBieSBzb21lIHZhbHVlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuc2V0VmFsdWVDdXJ2ZUF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZXMsIHN0YXJ0VGltZSwgZHVyYXRpb24sIHNjYWxpbmcpIHtcblx0ICAgICAgICBzY2FsaW5nID0gVG9uZS5kZWZhdWx0QXJnKHNjYWxpbmcsIDEpO1xuXHQgICAgICAgIGR1cmF0aW9uID0gdGhpcy50b1NlY29uZHMoZHVyYXRpb24pO1xuXHQgICAgICAgIHN0YXJ0VGltZSA9IHRoaXMudG9TZWNvbmRzKHN0YXJ0VGltZSk7XG5cdCAgICAgICAgdmFyIHNlZ1RpbWUgPSBkdXJhdGlvbiAvICh2YWx1ZXMubGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgdGhpcy5zZXRWYWx1ZUF0VGltZSh2YWx1ZXNbMF0gKiBzY2FsaW5nLCBzdGFydFRpbWUpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHRoaXMubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsdWVzW2ldICogc2NhbGluZywgc3RhcnRUaW1lICsgaSAqIHNlZ1RpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VscyBhbGwgc2NoZWR1bGVkIHBhcmFtZXRlciBjaGFuZ2VzIHdpdGggdGltZXMgZ3JlYXRlciB0aGFuIG9yIFxuXHRcdCAqICBlcXVhbCB0byBzdGFydFRpbWUuXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBzdGFydFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyA9IGZ1bmN0aW9uIChhZnRlcikge1xuXHQgICAgICAgIGFmdGVyID0gdGhpcy50b1NlY29uZHMoYWZ0ZXIpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cy5jYW5jZWwoYWZ0ZXIpO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhhZnRlcik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldHMgdGhlIGNvbXB1dGVkIHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lLiBUaGlzIHByb3ZpZGVzXG5cdFx0ICogIGEgcG9pbnQgZnJvbSB3aGljaCBhIGxpbmVhciBvciBleHBvbmVudGlhbCBjdXJ2ZVxuXHRcdCAqICBjYW4gYmUgc2NoZWR1bGVkIGFmdGVyLiBXaWxsIGNhbmNlbCBldmVudHMgYWZ0ZXIgXG5cdFx0ICogIHRoZSBnaXZlbiB0aW1lIGFuZCBzaG9ydGVuIHRoZSBjdXJyZW50bHkgc2NoZWR1bGVkXG5cdFx0ICogIGxpbmVhciBvciBleHBvbmVudGlhbCByYW1wIHNvIHRoYXQgaXQgZW5kcyBhdCBgdGltZWAgLlxuXHRcdCAqICBUaGlzIGlzIHRvIGF2b2lkIGRpc2NvbnRpbnVpdGllcyBhbmQgY2xpY2tzIGluIGVudmVsb3Blcy4gXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gdGltZSBXaGVuIHRvIHNldCB0aGUgcmFtcCBwb2ludFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZVNpZ25hbH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuc2V0UmFtcFBvaW50ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgLy9nZXQgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lXG5cdCAgICAgICAgdmFyIHZhbCA9IHRoaXMuX3RvVW5pdHModGhpcy5nZXRWYWx1ZUF0VGltZSh0aW1lKSk7XG5cdCAgICAgICAgLy9pZiB0aGVyZSBpcyBhbiBldmVudCBhdCB0aGUgZ2l2ZW4gdGltZVxuXHQgICAgICAgIC8vYW5kIHRoYXQgZXZlbiBpcyBub3QgYSBcInNldFwiXG5cdCAgICAgICAgdmFyIGJlZm9yZSA9IHRoaXMuX3NlYXJjaEJlZm9yZSh0aW1lKTtcblx0ICAgICAgICBpZiAoYmVmb3JlICYmIGJlZm9yZS50aW1lID09PSB0aW1lKSB7XG5cdCAgICAgICAgICAgIC8vcmVtb3ZlIGV2ZXJ5dGhpbmcgYWZ0ZXJcblx0ICAgICAgICAgICAgdGhpcy5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGltZSArIHRoaXMuc2FtcGxlVGltZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy9yZXNjaGVkdWxlIHRoZSBuZXh0IGV2ZW50IHRvIGVuZCBhdCB0aGUgZ2l2ZW4gdGltZVxuXHQgICAgICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLl9zZWFyY2hBZnRlcih0aW1lKTtcblx0ICAgICAgICAgICAgaWYgKGFmdGVyKSB7XG5cdCAgICAgICAgICAgICAgICAvL2NhbmNlbCB0aGUgbmV4dCBldmVudChzKVxuXHQgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGltZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIudHlwZSA9PT0gVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlLkxpbmVhcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsLCB0aW1lKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZ0ZXIudHlwZSA9PT0gVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlLkV4cG9uZW50aWFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHZhbCwgdGltZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUF0VGltZSh2YWwsIHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRG8gYSBsaW5lYXIgcmFtcCB0byB0aGUgZ2l2ZW4gdmFsdWUgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGZpbmlzaCB0aW1lcy5cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byByYW1wIHRvLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHN0YXJ0IFRoZSBiZWdpbm5pbmcgYW5jaG9yIHBvaW50IHRvIGRvIHRoZSBsaW5lYXIgcmFtcFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGZpbmlzaCBUaGUgZW5kaW5nIGFuY2hvciBwb2ludCBieSB3aGljaCB0aGUgdmFsdWUgb2Zcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIHNpZ25hbCB3aWxsIGVxdWFsIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQmV0d2VlbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGZpbmlzaCkge1xuXHQgICAgICAgIHRoaXMuc2V0UmFtcFBvaW50KHN0YXJ0KTtcblx0ICAgICAgICB0aGlzLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCBmaW5pc2gpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBEbyBhIGV4cG9uZW50aWFsIHJhbXAgdG8gdGhlIGdpdmVuIHZhbHVlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBmaW5pc2ggdGltZXMuXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmFtcCB0by5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydCBUaGUgYmVnaW5uaW5nIGFuY2hvciBwb2ludCB0byBkbyB0aGUgZXhwb25lbnRpYWwgcmFtcFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGZpbmlzaCBUaGUgZW5kaW5nIGFuY2hvciBwb2ludCBieSB3aGljaCB0aGUgdmFsdWUgb2Zcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIHNpZ25hbCB3aWxsIGVxdWFsIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVCZXR3ZWVuID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZmluaXNoKSB7XG5cdCAgICAgICAgdGhpcy5zZXRSYW1wUG9pbnQoc3RhcnQpO1xuXHQgICAgICAgIHRoaXMuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgZmluaXNoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRHRVRUSU5HIFNDSEVEVUxFRCBWQUxVRVNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHZhbHVlIGJlZm9yZSBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeVxuXHRcdCAqICBAcmV0dXJuICB7T2JqZWN0fSAgVGhlIGV2ZW50IGF0IG9yIGJlZm9yZSB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9zZWFyY2hCZWZvcmUgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMuZ2V0KHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZXZlbnQgYWZ0ZXIgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEByZXR1cm4gIHtPYmplY3R9ICBUaGUgbmV4dCBldmVudCBhZnRlciB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuX3NlYXJjaEFmdGVyID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmdldEFmdGVyKHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgdGhlIHNjaGVkdWxlZCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZS4gVGhpcyB3aWxsXG5cdFx0ICogIHJldHVybiB0aGUgdW5jb252ZXJ0ZWQgKHJhdykgdmFsdWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIGluIHNlY29uZHMuXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9ICBUaGUgc2NoZWR1bGVkIHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuZ2V0VmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLl9zZWFyY2hBZnRlcih0aW1lKTtcblx0ICAgICAgICB2YXIgYmVmb3JlID0gdGhpcy5fc2VhcmNoQmVmb3JlKHRpbWUpO1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2luaXRpYWw7XG5cdCAgICAgICAgLy9pZiBpdCB3YXMgc2V0IGJ5XG5cdCAgICAgICAgaWYgKGJlZm9yZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2luaXRpYWw7XG5cdCAgICAgICAgfSBlbHNlIGlmIChiZWZvcmUudHlwZSA9PT0gVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlLlRhcmdldCkge1xuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLl9ldmVudHMuZ2V0QmVmb3JlKGJlZm9yZS50aW1lKTtcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VWYWw7XG5cdCAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcHJldmlvdVZhbCA9IHRoaXMuX2luaXRpYWw7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBwcmV2aW91VmFsID0gcHJldmlvdXMudmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9leHBvbmVudGlhbEFwcHJvYWNoKGJlZm9yZS50aW1lLCBwcmV2aW91VmFsLCBiZWZvcmUudmFsdWUsIGJlZm9yZS5jb25zdGFudCwgdGltZSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChhZnRlciA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IGJlZm9yZS52YWx1ZTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGFmdGVyLnR5cGUgPT09IFRvbmUuVGltZWxpbmVTaWduYWwuVHlwZS5MaW5lYXIpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9saW5lYXJJbnRlcnBvbGF0ZShiZWZvcmUudGltZSwgYmVmb3JlLnZhbHVlLCBhZnRlci50aW1lLCBhZnRlci52YWx1ZSwgdGltZSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChhZnRlci50eXBlID09PSBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuRXhwb25lbnRpYWwpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9leHBvbmVudGlhbEludGVycG9sYXRlKGJlZm9yZS50aW1lLCBiZWZvcmUudmFsdWUsIGFmdGVyLnRpbWUsIGFmdGVyLnZhbHVlLCB0aW1lKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IGJlZm9yZS52YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBXaGVuIHNpZ25hbHMgY29ubmVjdCB0byBvdGhlciBzaWduYWxzIG9yIEF1ZGlvUGFyYW1zLCBcblx0XHQgKiAgdGhleSB0YWtlIG92ZXIgdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGF0IHNpZ25hbCBvciBBdWRpb1BhcmFtLiBcblx0XHQgKiAgRm9yIGFsbCBvdGhlciBub2RlcywgdGhlIGJlaGF2aW9yIGlzIHRoZSBzYW1lIGFzIGEgZGVmYXVsdCA8Y29kZT5jb25uZWN0PC9jb2RlPi4gXG5cdFx0ICpcblx0XHQgKiAgQG92ZXJyaWRlXG5cdFx0ICogIEBwYXJhbSB7QXVkaW9QYXJhbXxBdWRpb05vZGV8VG9uZS5TaWduYWx8VG9uZX0gbm9kZSBcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtvdXRwdXROdW1iZXI9MF0gVGhlIG91dHB1dCBudW1iZXIgdG8gY29ubmVjdCBmcm9tLlxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW2lucHV0TnVtYmVyPTBdIFRoZSBpbnB1dCBudW1iZXIgdG8gY29ubmVjdCB0by5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKiAgQG1ldGhvZFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuY29ubmVjdCA9IFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuY29ubmVjdDtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEFVVE9NQVRJT04gQ1VSVkUgQ0FMQ1VMQVRJT05TXG5cdCAgICAvL1x0TUlUIExpY2Vuc2UsIGNvcHlyaWdodCAoYykgMjAxNCBKb3JkYW4gU2FudGVsbFxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgQ2FsY3VsYXRlcyB0aGUgdGhlIHZhbHVlIGFsb25nIHRoZSBjdXJ2ZSBwcm9kdWNlZCBieSBzZXRUYXJnZXRBdFRpbWVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9leHBvbmVudGlhbEFwcHJvYWNoID0gZnVuY3Rpb24gKHQwLCB2MCwgdjEsIHRpbWVDb25zdGFudCwgdCkge1xuXHQgICAgICAgIHJldHVybiB2MSArICh2MCAtIHYxKSAqIE1hdGguZXhwKC0odCAtIHQwKSAvIHRpbWVDb25zdGFudCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbGN1bGF0ZXMgdGhlIHRoZSB2YWx1ZSBhbG9uZyB0aGUgY3VydmUgcHJvZHVjZWQgYnkgbGluZWFyUmFtcFRvVmFsdWVBdFRpbWVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9saW5lYXJJbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICh0MCwgdjAsIHQxLCB2MSwgdCkge1xuXHQgICAgICAgIHJldHVybiB2MCArICh2MSAtIHYwKSAqICgodCAtIHQwKSAvICh0MSAtIHQwKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbGN1bGF0ZXMgdGhlIHRoZSB2YWx1ZSBhbG9uZyB0aGUgY3VydmUgcHJvZHVjZWQgYnkgZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuX2V4cG9uZW50aWFsSW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAodDAsIHYwLCB0MSwgdjEsIHQpIHtcblx0ICAgICAgICB2MCA9IE1hdGgubWF4KHRoaXMuX21pbk91dHB1dCwgdjApO1xuXHQgICAgICAgIHJldHVybiB2MCAqIE1hdGgucG93KHYxIC8gdjAsICh0IC0gdDApIC8gKHQxIC0gdDApKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWwucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVGltZWxpbmVTaWduYWw7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBQb3cgYXBwbGllcyBhbiBleHBvbmVudCB0byB0aGUgaW5jb21pbmcgc2lnbmFsLiBUaGUgaW5jb21pbmcgc2lnbmFsXG5cdFx0ICogICAgICAgICBtdXN0IGJlIEF1ZGlvUmFuZ2UuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7UG9zaXRpdmV9IGV4cCBUaGUgZXhwb25lbnQgdG8gYXBwbHkgdG8gdGhlIGluY29taW5nIHNpZ25hbCwgbXVzdCBiZSBhdCBsZWFzdCAyLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgcG93ID0gbmV3IFRvbmUuUG93KDIpO1xuXHRcdCAqIHZhciBzaWcgPSBuZXcgVG9uZS5TaWduYWwoMC41KS5jb25uZWN0KHBvdyk7XG5cdFx0ICogLy9vdXRwdXQgb2YgcG93IGlzIDAuMjUuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5Qb3cgPSBmdW5jdGlvbiAoZXhwKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiB0aGUgZXhwb25lbnRcblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXhwID0gVG9uZS5kZWZhdWx0QXJnKGV4cCwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1dhdmVTaGFwZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9leHBTY2FsZXIgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKHRoaXMuX2V4cEZ1bmModGhpcy5fZXhwKSwgODE5Mik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Qb3csIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdmFsdWUgb2YgdGhlIGV4cG9uZW50LlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBvdyNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIHZhbHVlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Qb3cucHJvdG90eXBlLCAndmFsdWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHA7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChleHApIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXhwID0gZXhwO1xuXHQgICAgICAgICAgICB0aGlzLl9leHBTY2FsZXIuc2V0TWFwKHRoaXMuX2V4cEZ1bmModGhpcy5fZXhwKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGZ1bmN0aW9uIHdoaWNoIG1hcHMgdGhlIHdhdmVzaGFwZXJcblx0XHQgKiAgQHBhcmFtICAge251bWJlcn0gZXhwXG5cdFx0ICogIEByZXR1cm4ge2Z1bmN0aW9ufVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Qb3cucHJvdG90eXBlLl9leHBGdW5jID0gZnVuY3Rpb24gKGV4cCkge1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyhNYXRoLmFicyh2YWwpLCBleHApO1xuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Qb3d9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUG93LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2V4cFNjYWxlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZXhwU2NhbGVyID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Qb3c7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5FbnZlbG9wZSBpcyBhbiBbQURTUl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ludGhlc2l6ZXIjQURTUl9lbnZlbG9wZSlcblx0XHQgKiAgICAgICAgICBlbnZlbG9wZSBnZW5lcmF0b3IuIFRvbmUuRW52ZWxvcGUgb3V0cHV0cyBhIHNpZ25hbCB3aGljaFxuXHRcdCAqICAgICAgICAgIGNhbiBiZSBjb25uZWN0ZWQgdG8gYW4gQXVkaW9QYXJhbSBvciBUb25lLlNpZ25hbC5cblx0XHQgKiAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvZS9lYS9BRFNSX3BhcmFtZXRlci5zdmdcIj5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFthdHRhY2tdIFRoZSBhbW91bnQgb2YgdGltZSBpdCB0YWtlcyBmb3IgdGhlIGVudmVsb3BlIHRvIGdvIGZyb21cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAwIHRvIGl0J3MgbWF4aW11bSB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbZGVjYXldXHRUaGUgcGVyaW9kIG9mIHRpbWUgYWZ0ZXIgdGhlIGF0dGFjayB0aGF0IGl0IHRha2VzIGZvciB0aGUgZW52ZWxvcGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgXHR0byBmYWxsIHRvIHRoZSBzdXN0YWluIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbc3VzdGFpbl1cdFRoZSBwZXJjZW50IG9mIHRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgdGhlIGVudmVsb3BlIHJlc3RzIGF0IHVudGlsXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0dGhlIHJlbGVhc2UgaXMgdHJpZ2dlcmVkLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFtyZWxlYXNlXVx0VGhlIGFtb3VudCBvZiB0aW1lIGFmdGVyIHRoZSByZWxlYXNlIGlzIHRyaWdnZXJlZCBpdCB0YWtlcyB0byByZWFjaCAwLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vYW4gYW1wbGl0dWRlIGVudmVsb3BlXG5cdFx0ICogdmFyIGdhaW5Ob2RlID0gVG9uZS5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0XHQgKiB2YXIgZW52ID0gbmV3IFRvbmUuRW52ZWxvcGUoe1xuXHRcdCAqIFx0XCJhdHRhY2tcIiA6IDAuMSxcblx0XHQgKiBcdFwiZGVjYXlcIiA6IDAuMixcblx0XHQgKiBcdFwic3VzdGFpblwiIDogMSxcblx0XHQgKiBcdFwicmVsZWFzZVwiIDogMC44LFxuXHRcdCAqIH0pO1xuXHRcdCAqIGVudi5jb25uZWN0KGdhaW5Ob2RlLmdhaW4pO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbnZlbG9wZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvL2dldCBhbGwgb2YgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnYXR0YWNrJyxcblx0ICAgICAgICAgICAgJ2RlY2F5Jyxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nLFxuXHQgICAgICAgICAgICAncmVsZWFzZSdcblx0ICAgICAgICBdLCBUb25lLkVudmVsb3BlKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFdoZW4gdHJpZ2dlckF0dGFjayBpcyBjYWxsZWQsIHRoZSBhdHRhY2sgdGltZSBpcyB0aGUgYW1vdW50IG9mXG5cdFx0XHQgKiAgdGltZSBpdCB0YWtlcyBmb3IgdGhlIGVudmVsb3BlIHRvIHJlYWNoIGl0J3MgbWF4aW11bSB2YWx1ZS5cblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuYXR0YWNrID0gb3B0aW9ucy5hdHRhY2s7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQWZ0ZXIgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZSwgdGhlIHZhbHVlIHdpbGwgZmFsbFxuXHRcdFx0ICogIG92ZXIgdGhlIGR1cmF0aW9uIG9mIHRoZSBkZWNheSB0aW1lIHRvIGl0J3Mgc3VzdGFpbiB2YWx1ZS5cblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVjYXkgPSBvcHRpb25zLmRlY2F5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogXHRUaGUgc3VzdGFpbiB2YWx1ZSBpcyB0aGUgdmFsdWVcblx0XHRcdCAqIFx0d2hpY2ggdGhlIGVudmVsb3BlIHJlc3RzIGF0IGFmdGVyIHRyaWdnZXJBdHRhY2sgaXNcblx0XHRcdCAqIFx0Y2FsbGVkLCBidXQgYmVmb3JlIHRyaWdnZXJSZWxlYXNlIGlzIGludm9rZWQuXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5zdXN0YWluID0gb3B0aW9ucy5zdXN0YWluO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFmdGVyIHRyaWdnZXJSZWxlYXNlIGlzIGNhbGxlZCwgdGhlIGVudmVsb3BlJ3Ncblx0XHRcdCAqICB2YWx1ZSB3aWxsIGZhbGwgdG8gaXQncyBtaW1pbnVtIHZhbHVlIG92ZXIgdGhlXG5cdFx0XHQgKiAgZHVyYXRpb24gb2YgdGhlIHJlbGVhc2UgdGltZS5cblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmVsZWFzZSA9IG9wdGlvbnMucmVsZWFzZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbmV4dCB0aW1lIHRoZSBlbnZlbG9wZSBpcyBhdCBzdGFuZGJ5XG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYXR0YWNrQ3VydmUgPSAnbGluZWFyJztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbmV4dCB0aW1lIHRoZSBlbnZlbG9wZSBpcyBhdCBzdGFuZGJ5XG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcmVsZWFzZUN1cnZlID0gJ2V4cG9uZW50aWFsJztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgc2lnbmFsXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmVTaWduYWx9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NpZyA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuVGltZWxpbmVTaWduYWwoKTtcblx0ICAgICAgICB0aGlzLl9zaWcuc2V0VmFsdWVBdFRpbWUoMCwgMCk7XG5cdCAgICAgICAgLy9zZXQgdGhlIGF0dGFja0N1cnZlIGluaXRpYWxseVxuXHQgICAgICAgIHRoaXMuYXR0YWNrQ3VydmUgPSBvcHRpb25zLmF0dGFja0N1cnZlO1xuXHQgICAgICAgIHRoaXMucmVsZWFzZUN1cnZlID0gb3B0aW9ucy5yZWxlYXNlQ3VydmU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5FbnZlbG9wZSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuRW52ZWxvcGUuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2F0dGFjayc6IDAuMDEsXG5cdCAgICAgICAgJ2RlY2F5JzogMC4xLFxuXHQgICAgICAgICdzdXN0YWluJzogMC41LFxuXHQgICAgICAgICdyZWxlYXNlJzogMSxcblx0ICAgICAgICAnYXR0YWNrQ3VydmUnOiAnbGluZWFyJyxcblx0ICAgICAgICAncmVsZWFzZUN1cnZlJzogJ2V4cG9uZW50aWFsJ1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFJlYWQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGVudmVsb3BlLiBVc2VmdWwgZm9yXG5cdFx0ICogc3luY3Jvbml6aW5nIHZpc3VhbCBvdXRwdXQgdG8gdGhlIGVudmVsb3BlLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkVudmVsb3BlI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgdmFsdWVcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkVudmVsb3BlLnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0VGltZSh0aGlzLm5vdygpKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBzaGFwZSBvZiB0aGUgYXR0YWNrLlxuXHRcdCAqIENhbiBiZSBhbnkgb2YgdGhlc2Ugc3RyaW5nczpcblx0XHQgKiA8dWw+XG5cdFx0ICogICA8bGk+bGluZWFyPC9saT5cblx0XHQgKiAgIDxsaT5leHBvbmVudGlhbDwvbGk+XG5cdFx0ICogICA8bGk+c2luZTwvbGk+XG5cdFx0ICogICA8bGk+Y29zaW5lPC9saT5cblx0XHQgKiAgIDxsaT5ib3VuY2U8L2xpPlxuXHRcdCAqICAgPGxpPnJpcHBsZTwvbGk+XG5cdFx0ICogICA8bGk+c3RlcDwvbGk+XG5cdFx0ICogPC91bD5cblx0XHQgKiBDYW4gYWxzbyBiZSBhbiBhcnJheSB3aGljaCBkZXNjcmliZXMgdGhlIGN1cnZlLiBWYWx1ZXNcblx0XHQgKiBpbiB0aGUgYXJyYXkgYXJlIGV2ZW5seSBzdWJkaXZpZGVkIGFuZCBsaW5lYXJseVxuXHRcdCAqIGludGVycG9sYXRlZCBvdmVyIHRoZSBkdXJhdGlvbiBvZiB0aGUgYXR0YWNrLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkVudmVsb3BlI1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd8QXJyYXl9XG5cdFx0ICogQG5hbWUgYXR0YWNrQ3VydmVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIGVudi5hdHRhY2tDdXJ2ZSA9IFwibGluZWFyXCI7XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvL2NhbiBhbHNvIGJlIGFuIGFycmF5XG5cdFx0ICogZW52LmF0dGFja0N1cnZlID0gWzAsIDAuMiwgMC4zLCAwLjQsIDFdXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUsICdhdHRhY2tDdXJ2ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNTdHJpbmcodGhpcy5fYXR0YWNrQ3VydmUpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNrQ3VydmU7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc0FycmF5KHRoaXMuX2F0dGFja0N1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgLy9sb29rIHVwIHRoZSBuYW1lIGluIHRoZSBjdXJ2ZXMgYXJyYXlcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHR5cGUgaW4gVG9uZS5FbnZlbG9wZS5UeXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFRvbmUuRW52ZWxvcGUuVHlwZVt0eXBlXS5JbiA9PT0gdGhpcy5fYXR0YWNrQ3VydmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy9vdGhlcndpc2UganVzdCByZXR1cm4gdGhlIGFycmF5XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNrQ3VydmU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGN1cnZlKSB7XG5cdCAgICAgICAgICAgIC8vY2hlY2sgaWYgaXQncyBhIHZhbGlkIHR5cGVcblx0ICAgICAgICAgICAgaWYgKFRvbmUuRW52ZWxvcGUuVHlwZS5oYXNPd25Qcm9wZXJ0eShjdXJ2ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjdXJ2ZURlZiA9IFRvbmUuRW52ZWxvcGUuVHlwZVtjdXJ2ZV07XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc09iamVjdChjdXJ2ZURlZikpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2tDdXJ2ZSA9IGN1cnZlRGVmLkluO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2tDdXJ2ZSA9IGN1cnZlRGVmO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNBcnJheShjdXJ2ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFja0N1cnZlID0gY3VydmU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbmUuRW52ZWxvcGU6IGludmFsaWQgY3VydmU6ICcgKyBjdXJ2ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBzaGFwZSBvZiB0aGUgcmVsZWFzZS4gU2VlIHRoZSBhdHRhY2sgY3VydmUgdHlwZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge1N0cmluZ3xBcnJheX1cblx0XHQgKiBAbmFtZSByZWxlYXNlQ3VydmVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIGVudi5yZWxlYXNlQ3VydmUgPSBcImxpbmVhclwiO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLCAncmVsZWFzZUN1cnZlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAoVG9uZS5pc1N0cmluZyh0aGlzLl9yZWxlYXNlQ3VydmUpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVsZWFzZUN1cnZlO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNBcnJheSh0aGlzLl9yZWxlYXNlQ3VydmUpKSB7XG5cdCAgICAgICAgICAgICAgICAvL2xvb2sgdXAgdGhlIG5hbWUgaW4gdGhlIGN1cnZlcyBhcnJheVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBUb25lLkVudmVsb3BlLlR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoVG9uZS5FbnZlbG9wZS5UeXBlW3R5cGVdLk91dCA9PT0gdGhpcy5fcmVsZWFzZUN1cnZlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHRoZSBhcnJheVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbGVhc2VDdXJ2ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoY3VydmUpIHtcblx0ICAgICAgICAgICAgLy9jaGVjayBpZiBpdCdzIGEgdmFsaWQgdHlwZVxuXHQgICAgICAgICAgICBpZiAoVG9uZS5FbnZlbG9wZS5UeXBlLmhhc093blByb3BlcnR5KGN1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGN1cnZlRGVmID0gVG9uZS5FbnZlbG9wZS5UeXBlW2N1cnZlXTtcblx0ICAgICAgICAgICAgICAgIGlmIChUb25lLmlzT2JqZWN0KGN1cnZlRGVmKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VDdXJ2ZSA9IGN1cnZlRGVmLk91dDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVsZWFzZUN1cnZlID0gY3VydmVEZWY7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc0FycmF5KGN1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVsZWFzZUN1cnZlID0gY3VydmU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbmUuRW52ZWxvcGU6IGludmFsaWQgY3VydmU6ICcgKyBjdXJ2ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBhdHRhY2svZGVjYXkgcG9ydGlvbiBvZiB0aGUgQURTUiBlbnZlbG9wZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBhdHRhY2sgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbdmVsb2NpdHk9MV0gVGhlIHZlbG9jaXR5IG9mIHRoZSBlbnZlbG9wZSBzY2FsZXMgdGhlIHZhbGVzLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciBiZXR3ZWVuIDAtMVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FbnZlbG9wZX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAvL3RyaWdnZXIgdGhlIGF0dGFjayAwLjUgc2Vjb25kcyBmcm9tIG5vdyB3aXRoIGEgdmVsb2NpdHkgb2YgMC4yXG5cdFx0ICogIGVudi50cmlnZ2VyQXR0YWNrKFwiKzAuNVwiLCAwLjIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uICh0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB2YXIgb3JpZ2luYWxBdHRhY2sgPSB0aGlzLnRvU2Vjb25kcyh0aGlzLmF0dGFjayk7XG5cdCAgICAgICAgdmFyIGF0dGFjayA9IG9yaWdpbmFsQXR0YWNrO1xuXHQgICAgICAgIHZhciBkZWNheSA9IHRoaXMudG9TZWNvbmRzKHRoaXMuZGVjYXkpO1xuXHQgICAgICAgIHZlbG9jaXR5ID0gVG9uZS5kZWZhdWx0QXJnKHZlbG9jaXR5LCAxKTtcblx0ICAgICAgICAvL2NoZWNrIGlmIGl0J3Mgbm90IGEgY29tcGxldGUgYXR0YWNrXG5cdCAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cdCAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+IDApIHtcblx0ICAgICAgICAgICAgLy9zdWJ0cmFjdCB0aGUgY3VycmVudCB2YWx1ZSBmcm9tIHRoZSBhdHRhY2sgdGltZVxuXHQgICAgICAgICAgICB2YXIgYXR0YWNrUmF0ZSA9IDEgLyBhdHRhY2s7XG5cdCAgICAgICAgICAgIHZhciByZW1haW5pbmdEaXN0YW5jZSA9IDEgLSBjdXJyZW50VmFsdWU7XG5cdCAgICAgICAgICAgIC8vdGhlIGF0dGFjayBpcyBub3cgdGhlIHJlbWFpbmluZyB0aW1lXG5cdCAgICAgICAgICAgIGF0dGFjayA9IHJlbWFpbmluZ0Rpc3RhbmNlIC8gYXR0YWNrUmF0ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9hdHRhY2tcblx0ICAgICAgICBpZiAodGhpcy5fYXR0YWNrQ3VydmUgPT09ICdsaW5lYXInKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NpZy5saW5lYXJSYW1wVG9WYWx1ZSh2ZWxvY2l0eSwgYXR0YWNrLCB0aW1lKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2F0dGFja0N1cnZlID09PSAnZXhwb25lbnRpYWwnKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NpZy5leHBvbmVudGlhbFJhbXBUb1ZhbHVlKHZlbG9jaXR5LCBhdHRhY2ssIHRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYXR0YWNrID4gMCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zaWcuc2V0UmFtcFBvaW50KHRpbWUpO1xuXHQgICAgICAgICAgICB2YXIgY3VydmUgPSB0aGlzLl9hdHRhY2tDdXJ2ZTtcblx0ICAgICAgICAgICAgLy90YWtlIG9ubHkgYSBwb3J0aW9uIG9mIHRoZSBjdXJ2ZVxuXHQgICAgICAgICAgICBpZiAoYXR0YWNrIDwgb3JpZ2luYWxBdHRhY2spIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwZXJjZW50Q29tcGxldGUgPSAxIC0gYXR0YWNrIC8gb3JpZ2luYWxBdHRhY2s7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2xpY2VJbmRleCA9IE1hdGguZmxvb3IocGVyY2VudENvbXBsZXRlICogdGhpcy5fYXR0YWNrQ3VydmUubGVuZ3RoKTtcblx0ICAgICAgICAgICAgICAgIGN1cnZlID0gdGhpcy5fYXR0YWNrQ3VydmUuc2xpY2Uoc2xpY2VJbmRleCk7XG5cdCAgICAgICAgICAgICAgICAvL3RoZSBmaXJzdCBpbmRleCBpcyB0aGUgY3VycmVudCB2YWx1ZVxuXHQgICAgICAgICAgICAgICAgY3VydmVbMF0gPSBjdXJyZW50VmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fc2lnLnNldFZhbHVlQ3VydmVBdFRpbWUoY3VydmUsIHRpbWUsIGF0dGFjaywgdmVsb2NpdHkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2RlY2F5XG5cdCAgICAgICAgdGhpcy5fc2lnLmV4cG9uZW50aWFsUmFtcFRvVmFsdWUodmVsb2NpdHkgKiB0aGlzLnN1c3RhaW4sIGRlY2F5LCBhdHRhY2sgKyB0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlcnMgdGhlIHJlbGVhc2Ugb2YgdGhlIGVudmVsb3BlLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGUgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FbnZlbG9wZX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAvL3RyaWdnZXIgcmVsZWFzZSBpbW1lZGlhdGVseVxuXHRcdCAqICBlbnYudHJpZ2dlclJlbGVhc2UoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cdCAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+IDApIHtcblx0ICAgICAgICAgICAgdmFyIHJlbGVhc2UgPSB0aGlzLnRvU2Vjb25kcyh0aGlzLnJlbGVhc2UpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fcmVsZWFzZUN1cnZlID09PSAnbGluZWFyJykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc2lnLmxpbmVhclJhbXBUb1ZhbHVlKDAsIHJlbGVhc2UsIHRpbWUpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3JlbGVhc2VDdXJ2ZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc2lnLmV4cG9uZW50aWFsUmFtcFRvVmFsdWUoMCwgcmVsZWFzZSwgdGltZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY3VydmUgPSB0aGlzLl9yZWxlYXNlQ3VydmU7XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc0FycmF5KGN1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpZy5zZXRSYW1wUG9pbnQodGltZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2lnLnNldFZhbHVlQ3VydmVBdFRpbWUoY3VydmUsIHRpbWUsIHJlbGVhc2UsIGN1cnJlbnRWYWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCB0aGUgc2NoZWR1bGVkIHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lLiBUaGlzIHdpbGxcblx0XHQgKiAgcmV0dXJuIHRoZSB1bmNvbnZlcnRlZCAocmF3KSB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgaW4gc2Vjb25kcy5cblx0XHQgKiAgQHJldHVybiAge051bWJlcn0gIFRoZSBzY2hlZHVsZWQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlLnByb3RvdHlwZS5nZXRWYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3NpZy5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgdHJpZ2dlckF0dGFja1JlbGVhc2UgaXMgc2hvcnRoYW5kIGZvciB0cmlnZ2VyQXR0YWNrLCB0aGVuIHdhaXRpbmdcblx0XHQgKiAgc29tZSBkdXJhdGlvbiwgdGhlbiB0cmlnZ2VyUmVsZWFzZS5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHN1c3RhaW4uXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBhdHRhY2sgc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFt2ZWxvY2l0eT0xXSBUaGUgdmVsb2NpdHkgb2YgdGhlIGVudmVsb3BlLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FbnZlbG9wZX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdHJpZ2dlciB0aGUgYXR0YWNrIGFuZCB0aGVuIHRoZSByZWxlYXNlIGFmdGVyIDAuNiBzZWNvbmRzLlxuXHRcdCAqIGVudi50cmlnZ2VyQXR0YWNrUmVsZWFzZSgwLjYpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUudHJpZ2dlckF0dGFja1JlbGVhc2UgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyUmVsZWFzZSh0aW1lICsgdGhpcy50b1NlY29uZHMoZHVyYXRpb24pKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VscyBhbGwgc2NoZWR1bGVkIGVudmVsb3BlIGNoYW5nZXMgYWZ0ZXIgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGFmdGVyXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkVudmVsb3BlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoYWZ0ZXIpIHtcblx0ICAgICAgICB0aGlzLl9zaWcuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKGFmdGVyKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQm9ycm93cyB0aGUgY29ubmVjdCBtZXRob2QgZnJvbSBUb25lLlNpZ25hbC5cblx0XHQgKiAgQGZ1bmN0aW9uXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlLnByb3RvdHlwZS5jb25uZWN0ID0gVG9uZS5TaWduYWwucHJvdG90eXBlLmNvbm5lY3Q7XG5cdCAgICAvKipcblx0IFx0ICogIEdlbmVyYXRlIHNvbWUgY29tcGxleCBlbnZlbG9wZSBjdXJ2ZXMuXG5cdCBcdCAqL1xuXHQgICAgKGZ1bmN0aW9uIF9jcmVhdGVDdXJ2ZXMoKSB7XG5cdCAgICAgICAgdmFyIGN1cnZlTGVuID0gMTI4O1xuXHQgICAgICAgIHZhciBpLCBrO1xuXHQgICAgICAgIC8vY29zaW5lIGN1cnZlXG5cdCAgICAgICAgdmFyIGNvc2luZUN1cnZlID0gW107XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGN1cnZlTGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgY29zaW5lQ3VydmVbaV0gPSBNYXRoLnNpbihpIC8gKGN1cnZlTGVuIC0gMSkgKiAoTWF0aC5QSSAvIDIpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9yaXBwbGUgY3VydmVcblx0ICAgICAgICB2YXIgcmlwcGxlQ3VydmUgPSBbXTtcblx0ICAgICAgICB2YXIgcmlwcGxlQ3VydmVGcmVxID0gNi40O1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjdXJ2ZUxlbiAtIDE7IGkrKykge1xuXHQgICAgICAgICAgICBrID0gaSAvIChjdXJ2ZUxlbiAtIDEpO1xuXHQgICAgICAgICAgICB2YXIgc2luZVdhdmUgPSBNYXRoLnNpbihrICogKE1hdGguUEkgKiAyKSAqIHJpcHBsZUN1cnZlRnJlcSAtIE1hdGguUEkgLyAyKSArIDE7XG5cdCAgICAgICAgICAgIHJpcHBsZUN1cnZlW2ldID0gc2luZVdhdmUgLyAxMCArIGsgKiAwLjgzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByaXBwbGVDdXJ2ZVtjdXJ2ZUxlbiAtIDFdID0gMTtcblx0ICAgICAgICAvL3N0YWlycyBjdXJ2ZVxuXHQgICAgICAgIHZhciBzdGFpcnNDdXJ2ZSA9IFtdO1xuXHQgICAgICAgIHZhciBzdGVwcyA9IDU7XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGN1cnZlTGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgc3RhaXJzQ3VydmVbaV0gPSBNYXRoLmNlaWwoaSAvIChjdXJ2ZUxlbiAtIDEpICogc3RlcHMpIC8gc3RlcHM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vaW4tb3V0IGVhc2luZyBjdXJ2ZVxuXHQgICAgICAgIHZhciBzaW5lQ3VydmUgPSBbXTtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY3VydmVMZW47IGkrKykge1xuXHQgICAgICAgICAgICBrID0gaSAvIChjdXJ2ZUxlbiAtIDEpO1xuXHQgICAgICAgICAgICBzaW5lQ3VydmVbaV0gPSAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vYSBib3VuY2UgY3VydmVcblx0ICAgICAgICB2YXIgYm91bmNlQ3VydmUgPSBbXTtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY3VydmVMZW47IGkrKykge1xuXHQgICAgICAgICAgICBrID0gaSAvIChjdXJ2ZUxlbiAtIDEpO1xuXHQgICAgICAgICAgICB2YXIgZnJlcSA9IE1hdGgucG93KGssIDMpICogNCArIDAuMjtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IE1hdGguY29zKGZyZXEgKiBNYXRoLlBJICogMiAqIGspO1xuXHQgICAgICAgICAgICBib3VuY2VDdXJ2ZVtpXSA9IE1hdGguYWJzKHZhbCAqICgxIC0gaykpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBJbnZlcnQgYSB2YWx1ZSBjdXJ2ZSB0byBtYWtlIGl0IHdvcmsgZm9yIHRoZSByZWxlYXNlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIGZ1bmN0aW9uIGludmVydEN1cnZlKGN1cnZlKSB7XG5cdCAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXkoY3VydmUubGVuZ3RoKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjdXJ2ZS5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgb3V0W2pdID0gMSAtIGN1cnZlW2pdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBvdXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHJldmVyc2UgdGhlIGN1cnZlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIGZ1bmN0aW9uIHJldmVyc2VDdXJ2ZShjdXJ2ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gY3VydmUuc2xpY2UoMCkucmV2ZXJzZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBhdHRhY2sgYW5kIHJlbGVhc2UgY3VydmUgYXJyYXlzXG5cdFx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIFRvbmUuRW52ZWxvcGUuVHlwZSA9IHtcblx0ICAgICAgICAgICAgJ2xpbmVhcic6ICdsaW5lYXInLFxuXHQgICAgICAgICAgICAnZXhwb25lbnRpYWwnOiAnZXhwb25lbnRpYWwnLFxuXHQgICAgICAgICAgICAnYm91bmNlJzoge1xuXHQgICAgICAgICAgICAgICAgSW46IGludmVydEN1cnZlKGJvdW5jZUN1cnZlKSxcblx0ICAgICAgICAgICAgICAgIE91dDogYm91bmNlQ3VydmVcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ2Nvc2luZSc6IHtcblx0ICAgICAgICAgICAgICAgIEluOiBjb3NpbmVDdXJ2ZSxcblx0ICAgICAgICAgICAgICAgIE91dDogcmV2ZXJzZUN1cnZlKGNvc2luZUN1cnZlKVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnc3RlcCc6IHtcblx0ICAgICAgICAgICAgICAgIEluOiBzdGFpcnNDdXJ2ZSxcblx0ICAgICAgICAgICAgICAgIE91dDogaW52ZXJ0Q3VydmUoc3RhaXJzQ3VydmUpXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICdyaXBwbGUnOiB7XG5cdCAgICAgICAgICAgICAgICBJbjogcmlwcGxlQ3VydmUsXG5cdCAgICAgICAgICAgICAgICBPdXQ6IGludmVydEN1cnZlKHJpcHBsZUN1cnZlKVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnc2luZSc6IHtcblx0ICAgICAgICAgICAgICAgIEluOiBzaW5lQ3VydmUsXG5cdCAgICAgICAgICAgICAgICBPdXQ6IGludmVydEN1cnZlKHNpbmVDdXJ2ZSlcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXHQgICAgLyoqXG5cdFx0ICogIERpc2Nvbm5lY3QgYW5kIGRpc3Bvc2UuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkVudmVsb3BlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc2lnLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zaWcgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2F0dGFja0N1cnZlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9yZWxlYXNlQ3VydmUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkVudmVsb3BlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUgaXMgYSBUb25lLkVudmVsb3BlIGNvbm5lY3RlZCB0byBhIGdhaW4gbm9kZS5cblx0XHQgKiAgICAgICAgICBVbmxpa2UgVG9uZS5FbnZlbG9wZSwgd2hpY2ggb3V0cHV0cyB0aGUgZW52ZWxvcGUncyB2YWx1ZSwgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZSBhY2NlcHRzXG5cdFx0ICogICAgICAgICAgYW4gYXVkaW8gc2lnbmFsIGFzIHRoZSBpbnB1dCBhbmQgd2lsbCBhcHBseSB0aGUgZW52ZWxvcGUgdG8gdGhlIGFtcGxpdHVkZVxuXHRcdCAqICAgICAgICAgIG9mIHRoZSBzaWduYWwuIFJlYWQgbW9yZSBhYm91dCBBRFNSIEVudmVsb3BlcyBvbiBbV2lraXBlZGlhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW50aGVzaXplciNBRFNSX2VudmVsb3BlKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRW52ZWxvcGV9XG5cdFx0ICogIEBwYXJhbSB7VGltZXxPYmplY3R9IFthdHRhY2tdIFRoZSBhbW91bnQgb2YgdGltZSBpdCB0YWtlcyBmb3IgdGhlIGVudmVsb3BlIHRvIGdvIGZyb21cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIHRvIGl0J3MgbWF4aW11bSB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbZGVjYXldXHRUaGUgcGVyaW9kIG9mIHRpbWUgYWZ0ZXIgdGhlIGF0dGFjayB0aGF0IGl0IHRha2VzIGZvciB0aGUgZW52ZWxvcGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgXHR0byBmYWxsIHRvIHRoZSBzdXN0YWluIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbc3VzdGFpbl1cdFRoZSBwZXJjZW50IG9mIHRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgdGhlIGVudmVsb3BlIHJlc3RzIGF0IHVudGlsXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0dGhlIHJlbGVhc2UgaXMgdHJpZ2dlcmVkLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFtyZWxlYXNlXVx0VGhlIGFtb3VudCBvZiB0aW1lIGFmdGVyIHRoZSByZWxlYXNlIGlzIHRyaWdnZXJlZCBpdCB0YWtlcyB0byByZWFjaCAwLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBhbXBFbnYgPSBuZXcgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZSh7XG5cdFx0ICogXHRcImF0dGFja1wiOiAwLjEsXG5cdFx0ICogXHRcImRlY2F5XCI6IDAuMixcblx0XHQgKiBcdFwic3VzdGFpblwiOiAxLjAsXG5cdFx0ICogXHRcInJlbGVhc2VcIjogMC44XG5cdFx0ICogfSkudG9NYXN0ZXIoKTtcblx0XHQgKiAvL2NyZWF0ZSBhbiBvc2NpbGxhdG9yIGFuZCBjb25uZWN0IGl0XG5cdFx0ICogdmFyIG9zYyA9IG5ldyBUb25lLk9zY2lsbGF0b3IoKS5jb25uZWN0KGFtcEVudikuc3RhcnQoKTtcblx0XHQgKiAvL3RyaWdnZXIgdGhlIGVudmVsb3BlcyBhdHRhY2sgYW5kIHJlbGVhc2UgXCI4dFwiIGFwYXJ0XG5cdFx0ICogYW1wRW52LnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiOHRcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkFtcGxpdHVkZUVudmVsb3BlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRW52ZWxvcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgaW5wdXQgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIHRoaXMuX3NpZy5jb25uZWN0KHRoaXMub3V0cHV0LmdhaW4pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUsIFRvbmUuRW52ZWxvcGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkFtcGxpdHVkZUVudmVsb3BlfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVudmVsb3BlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQW1wbGl0dWRlRW52ZWxvcGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEFuYWx5c2VyTm9kZS5nZXRGbG9hdFRpbWVEb21haW5EYXRhIHBvbHlmaWxsXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBpZiAod2luZG93LkFuYWx5c2VyTm9kZSAmJiAhQW5hbHlzZXJOb2RlLnByb3RvdHlwZS5nZXRGbG9hdFRpbWVEb21haW5EYXRhKSB7XG5cdCAgICAgICAgLy9yZWZlcmVuY2VkIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2hheW9uYW8vZ2V0LWZsb2F0LXRpbWUtZG9tYWluLWRhdGFcblx0ICAgICAgICBBbmFseXNlck5vZGUucHJvdG90eXBlLmdldEZsb2F0VGltZURvbWFpbkRhdGEgPSBmdW5jdGlvbiAoYXJyYXkpIHtcblx0ICAgICAgICAgICAgdmFyIHVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkubGVuZ3RoKTtcblx0ICAgICAgICAgICAgdGhpcy5nZXRCeXRlVGltZURvbWFpbkRhdGEodWludDgpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVpbnQ4Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBhcnJheVtpXSA9ICh1aW50OFtpXSAtIDEyOCkgLyAxMjg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgV3JhcHBlciBhcm91bmQgdGhlIG5hdGl2ZSBXZWIgQXVkaW8nc1xuXHRcdCAqICAgICAgICAgIFtBbmFseXNlck5vZGVdKGh0dHA6Ly93ZWJhdWRpby5naXRodWIuaW8vd2ViLWF1ZGlvLWFwaS8jaWRsLWRlZi1BbmFseXNlck5vZGUpLlxuXHRcdCAqICAgICAgICAgIEV4dHJhY3RzIEZGVCBvciBXYXZlZm9ybSBkYXRhIGZyb20gdGhlIGluY29taW5nIHNpZ25hbC5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge1N0cmluZz19IHR5cGUgVGhlIHJldHVybiB0eXBlIG9mIHRoZSBhbmFseXNpcywgZWl0aGVyIFwiZmZ0XCIsIG9yIFwid2F2ZWZvcm1cIi5cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXI9fSBzaXplIFRoZSBzaXplIG9mIHRoZSBGRlQuIFZhbHVlIG11c3QgYmUgYSBwb3dlciBvZlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICB0d28gaW4gdGhlIHJhbmdlIDMyIHRvIDMyNzY4LlxuXHRcdCAqL1xuXHQgICAgVG9uZS5BbmFseXNlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd0eXBlJyxcblx0ICAgICAgICAgICAgJ3NpemUnXG5cdCAgICAgICAgXSwgVG9uZS5BbmFseXNlcik7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW5hbHlzZXIgbm9kZS5cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtBbmFseXNlck5vZGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hbmFseXNlciA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbmFseXNpcyB0eXBlXG5cdFx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYnVmZmVyIHRoYXQgdGhlIEZGVCBkYXRhIGlzIHdyaXR0ZW4gdG9cblx0XHRcdCAqICBAdHlwZSB7VHlwZWRBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcblx0ICAgICAgICAvL3NldCB0aGUgdmFsdWVzIGluaXRpYWxseVxuXHQgICAgICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5BbmFseXNlciwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0IHZhbHVlcy5cblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLkFuYWx5c2VyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdzaXplJzogMTAyNCxcblx0ICAgICAgICAndHlwZSc6ICdmZnQnLFxuXHQgICAgICAgICdzbW9vdGhpbmcnOiAwLjhcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUG9zc2libGUgcmV0dXJuIHR5cGVzIG9mIFRvbmUuQW5hbHlzZXIuYW5hbHlzZSgpXG5cdFx0ICogIEBlbnVtIHtTdHJpbmd9XG5cdFx0ICovXG5cdCAgICBUb25lLkFuYWx5c2VyLlR5cGUgPSB7XG5cdCAgICAgICAgV2F2ZWZvcm06ICd3YXZlZm9ybScsXG5cdCAgICAgICAgRkZUOiAnZmZ0J1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSdW4gdGhlIGFuYWx5c2lzIGdpdmVuIHRoZSBjdXJyZW50IHNldHRpbmdzIGFuZCByZXR1cm4gdGhlXG5cdFx0ICogIHJlc3VsdCBhcyBhIFR5cGVkQXJyYXkuXG5cdFx0ICogIEByZXR1cm5zIHtUeXBlZEFycmF5fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BbmFseXNlci5wcm90b3R5cGUuYW5hbHlzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gVG9uZS5BbmFseXNlci5UeXBlLkZGVCkge1xuXHQgICAgICAgICAgICB0aGlzLl9hbmFseXNlci5nZXRGbG9hdEZyZXF1ZW5jeURhdGEodGhpcy5fYnVmZmVyKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFRvbmUuQW5hbHlzZXIuVHlwZS5XYXZlZm9ybSkge1xuXHQgICAgICAgICAgICB0aGlzLl9hbmFseXNlci5nZXRGbG9hdFRpbWVEb21haW5EYXRhKHRoaXMuX2J1ZmZlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXI7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzaXplIG9mIGFuYWx5c2lzLiBUaGlzIG11c3QgYmUgYSBwb3dlciBvZiB0d28gaW4gdGhlIHJhbmdlIDMyIHRvIDMyNzY4LlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5BbmFseXNlciNcblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG5hbWUgc2l6ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQW5hbHlzZXIucHJvdG90eXBlLCAnc2l6ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2l6ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9hbmFseXNlci5mZnRTaXplID0gc2l6ZSAqIDI7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGFuYWx5c2lzIGZ1bmN0aW9uIHJldHVybmVkIGJ5IFRvbmUuQW5hbHlzZXIuYW5hbHlzZSgpLCBlaXRoZXIgXCJmZnRcIiBvciBcIndhdmVmb3JtXCIuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkFuYWx5c2VyI1xuXHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqICBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BbmFseXNlci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGUgIT09IFRvbmUuQW5hbHlzZXIuVHlwZS5XYXZlZm9ybSAmJiB0eXBlICE9PSBUb25lLkFuYWx5c2VyLlR5cGUuRkZUKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUb25lLkFuYWx5c2VyOiBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICAwIHJlcHJlc2VudHMgbm8gdGltZSBhdmVyYWdpbmcgd2l0aCB0aGUgbGFzdCBhbmFseXNpcyBmcmFtZS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQW5hbHlzZXIjXG5cdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiAgQG5hbWUgc21vb3RoaW5nXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BbmFseXNlci5wcm90b3R5cGUsICdzbW9vdGhpbmcnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gdmFsO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5BbmFseXNlcn0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQW5hbHlzZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9hbmFseXNlci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fYW5hbHlzZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQW5hbHlzZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkNvbXByZXNzb3IgaXMgYSB0aGluIHdyYXBwZXIgYXJvdW5kIHRoZSBXZWIgQXVkaW9cblx0XHQgKiAgICAgICAgIFtEeW5hbWljc0NvbXByZXNzb3JOb2RlXShodHRwOi8vd2ViYXVkaW8uZ2l0aHViLmlvL3dlYi1hdWRpby1hcGkvI3RoZS1keW5hbWljc2NvbXByZXNzb3Jub2RlLWludGVyZmFjZSkuXG5cdFx0ICogICAgICAgICBDb21wcmVzc2lvbiByZWR1Y2VzIHRoZSB2b2x1bWUgb2YgbG91ZCBzb3VuZHMgb3IgYW1wbGlmaWVzIHF1aWV0IHNvdW5kc1xuXHRcdCAqICAgICAgICAgYnkgbmFycm93aW5nIG9yIFwiY29tcHJlc3NpbmdcIiBhbiBhdWRpbyBzaWduYWwncyBkeW5hbWljIHJhbmdlLlxuXHRcdCAqICAgICAgICAgUmVhZCBtb3JlIG9uIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0R5bmFtaWNfcmFuZ2VfY29tcHJlc3Npb24pLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RGVjaWJlbHN8T2JqZWN0fSBbdGhyZXNob2xkXSBUaGUgdmFsdWUgYWJvdmUgd2hpY2ggdGhlIGNvbXByZXNzaW9uIHN0YXJ0cyB0byBiZSBhcHBsaWVkLlxuXHRcdCAqICBAcGFyYW0ge1Bvc2l0aXZlfSBbcmF0aW9dIFRoZSBnYWluIHJlZHVjdGlvbiByYXRpby5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgY29tcCA9IG5ldyBUb25lLkNvbXByZXNzb3IoLTMwLCAzKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQ29tcHJlc3NvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd0aHJlc2hvbGQnLFxuXHQgICAgICAgICAgICAncmF0aW8nXG5cdCAgICAgICAgXSwgVG9uZS5Db21wcmVzc29yKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBjb21wcmVzc29yIG5vZGVcblx0XHRcdCAqICBAdHlwZSB7RHluYW1pY3NDb21wcmVzc29yTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY29tcHJlc3NvciA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgdGhyZXNob2xkIHZhdWVcblx0XHRcdCAqICBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy50aHJlc2hvbGQgPSBuZXcgVG9uZS5QYXJhbSh7XG5cdCAgICAgICAgICAgICdwYXJhbSc6IHRoaXMuX2NvbXByZXNzb3IudGhyZXNob2xkLFxuXHQgICAgICAgICAgICAndW5pdHMnOiBUb25lLlR5cGUuRGVjaWJlbHMsXG5cdCAgICAgICAgICAgICdjb252ZXJ0JzogZmFsc2Vcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYXR0YWNrIHBhcmFtZXRlclxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuYXR0YWNrID0gbmV3IFRvbmUuUGFyYW0odGhpcy5fY29tcHJlc3Nvci5hdHRhY2ssIFRvbmUuVHlwZS5UaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcmVsZWFzZSBwYXJhbWV0ZXJcblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJlbGVhc2UgPSBuZXcgVG9uZS5QYXJhbSh0aGlzLl9jb21wcmVzc29yLnJlbGVhc2UsIFRvbmUuVHlwZS5UaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUga25lZSBwYXJhbWV0ZXJcblx0XHRcdCAqICBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5rbmVlID0gbmV3IFRvbmUuUGFyYW0oe1xuXHQgICAgICAgICAgICAncGFyYW0nOiB0aGlzLl9jb21wcmVzc29yLmtuZWUsXG5cdCAgICAgICAgICAgICd1bml0cyc6IFRvbmUuVHlwZS5EZWNpYmVscyxcblx0ICAgICAgICAgICAgJ2NvbnZlcnQnOiBmYWxzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSByYXRpbyB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5yYXRpbyA9IG5ldyBUb25lLlBhcmFtKHtcblx0ICAgICAgICAgICAgJ3BhcmFtJzogdGhpcy5fY29tcHJlc3Nvci5yYXRpbyxcblx0ICAgICAgICAgICAgJ2NvbnZlcnQnOiBmYWxzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vc2V0IHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2tuZWUnLFxuXHQgICAgICAgICAgICAncmVsZWFzZScsXG5cdCAgICAgICAgICAgICdhdHRhY2snLFxuXHQgICAgICAgICAgICAncmF0aW8nLFxuXHQgICAgICAgICAgICAndGhyZXNob2xkJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuc2V0KG9wdGlvbnMpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ29tcHJlc3NvciwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkNvbXByZXNzb3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3JhdGlvJzogMTIsXG5cdCAgICAgICAgJ3RocmVzaG9sZCc6IC0yNCxcblx0ICAgICAgICAncmVsZWFzZSc6IDAuMjUsXG5cdCAgICAgICAgJ2F0dGFjayc6IDAuMDAzLFxuXHQgICAgICAgICdrbmVlJzogMzBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ29tcHJlc3Nvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Db21wcmVzc29yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAna25lZScsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJyxcblx0ICAgICAgICAgICAgJ2F0dGFjaycsXG5cdCAgICAgICAgICAgICdyYXRpbycsXG5cdCAgICAgICAgICAgICd0aHJlc2hvbGQnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5fY29tcHJlc3Nvci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fY29tcHJlc3NvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5hdHRhY2suZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuYXR0YWNrID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnJlbGVhc2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMucmVsZWFzZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy50aHJlc2hvbGQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMudGhyZXNob2xkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnJhdGlvLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnJhdGlvID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmtuZWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMua25lZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQ29tcHJlc3Nvcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEFkZCBhIHNpZ25hbCBhbmQgYSBudW1iZXIgb3IgdHdvIHNpZ25hbHMuIFdoZW4gbm8gdmFsdWUgaXNcblx0XHQgKiAgICAgICAgIHBhc3NlZCBpbnRvIHRoZSBjb25zdHJ1Y3RvciwgVG9uZS5BZGQgd2lsbCBzdW0gPGNvZGU+aW5wdXRbMF08L2NvZGU+XG5cdFx0ICogICAgICAgICBhbmQgPGNvZGU+aW5wdXRbMV08L2NvZGU+LiBJZiBhIHZhbHVlIGlzIHBhc3NlZCBpbnRvIHRoZSBjb25zdHJ1Y3RvciwgXG5cdFx0ICogICAgICAgICB0aGUgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW5wdXQuXG5cdFx0ICogIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsfVxuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IHZhbHVlIElmIG5vIHZhbHVlIGlzIHByb3ZpZGVkLCBUb25lLkFkZCB3aWxsIHN1bSB0aGUgZmlyc3Rcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgc2Vjb25kIGlucHV0cy4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHNpZ25hbCA9IG5ldyBUb25lLlNpZ25hbCgyKTtcblx0XHQgKiB2YXIgYWRkID0gbmV3IFRvbmUuQWRkKDIpO1xuXHRcdCAqIHNpZ25hbC5jb25uZWN0KGFkZCk7XG5cdFx0ICogLy90aGUgb3V0cHV0IG9mIGFkZCBlcXVhbHMgNFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vaWYgY29uc3RydWN0ZWQgd2l0aCBubyBhcmd1bWVudHNcblx0XHQgKiAvL2l0IHdpbGwgYWRkIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGlucHV0c1xuXHRcdCAqIHZhciBhZGQgPSBuZXcgVG9uZS5BZGQoKTtcblx0XHQgKiB2YXIgc2lnMCA9IG5ldyBUb25lLlNpZ25hbCgzKS5jb25uZWN0KGFkZCwgMCwgMCk7XG5cdFx0ICogdmFyIHNpZzEgPSBuZXcgVG9uZS5TaWduYWwoNCkuY29ubmVjdChhZGQsIDAsIDEpO1xuXHRcdCAqIC8vdGhlIG91dHB1dCBvZiBhZGQgZXF1YWxzIDcuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5BZGQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbC5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygyLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgc3VtbWluZyBub2RlXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdW0gPSB0aGlzLmlucHV0WzBdID0gdGhpcy5pbnB1dFsxXSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU2lnbmFsfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGFyYW0gPSB0aGlzLmlucHV0WzFdID0gbmV3IFRvbmUuU2lnbmFsKHZhbHVlKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbS5jb25uZWN0KHRoaXMuX3N1bSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5BZGQsIFRvbmUuU2lnbmFsKTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuQWRkfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkFkZC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3N1bS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3VtID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5BZGQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgTXVsdGlwbHkgdHdvIGluY29taW5nIHNpZ25hbHMuIE9yLCBpZiBhIG51bWJlciBpcyBnaXZlbiBpbiB0aGUgY29uc3RydWN0b3IsIFxuXHRcdCAqICAgICAgICAgIG11bHRpcGxpZXMgdGhlIGluY29taW5nIHNpZ25hbCBieSB0aGF0IHZhbHVlLiBcblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsfVxuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IHZhbHVlIENvbnN0YW50IHZhbHVlIHRvIG11bHRpcGxlLiBJZiBubyB2YWx1ZSBpcyBwcm92aWRlZCxcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICBpdCB3aWxsIHJldHVybiB0aGUgcHJvZHVjdCBvZiB0aGUgZmlyc3QgYW5kIHNlY29uZCBpbnB1dHNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbXVsdCA9IG5ldyBUb25lLk11bHRpcGx5KCk7XG5cdFx0ICogdmFyIHNpZ0EgPSBuZXcgVG9uZS5TaWduYWwoMyk7XG5cdFx0ICogdmFyIHNpZ0IgPSBuZXcgVG9uZS5TaWduYWwoNCk7XG5cdFx0ICogc2lnQS5jb25uZWN0KG11bHQsIDAsIDApO1xuXHRcdCAqIHNpZ0IuY29ubmVjdChtdWx0LCAwLCAxKTtcblx0XHQgKiAvL291dHB1dCBvZiBtdWx0IGlzIDEyLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBtdWx0ID0gbmV3IFRvbmUuTXVsdGlwbHkoMTApO1xuXHRcdCAqIHZhciBzaWcgPSBuZXcgVG9uZS5TaWduYWwoMikuY29ubmVjdChtdWx0KTtcblx0XHQgKiAvL3RoZSBvdXRwdXQgb2YgbXVsdCBpcyAyMC4gXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpcGx5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWwuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMiwgMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGlucHV0IG5vZGUgaXMgdGhlIHNhbWUgYXMgdGhlIG91dHB1dCBub2RlXG5cdFx0XHQgKiAgaXQgaXMgYWxzbyB0aGUgR2Fpbk5vZGUgd2hpY2ggaGFuZGxlcyB0aGUgc2NhbGluZyBvZiBpbmNvbWluZyBzaWduYWxcblx0XHRcdCAqICBcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX211bHQgPSB0aGlzLmlucHV0WzBdID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHNjYWxpbmcgcGFyYW1ldGVyXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvUGFyYW19XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhcmFtID0gdGhpcy5pbnB1dFsxXSA9IHRoaXMub3V0cHV0LmdhaW47XG5cdCAgICAgICAgdGhpcy5fcGFyYW0udmFsdWUgPSBUb25lLmRlZmF1bHRBcmcodmFsdWUsIDApO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTXVsdGlwbHksIFRvbmUuU2lnbmFsKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NdWx0aXBseX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aXBseS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX211bHQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX211bHQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5NdWx0aXBseTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIE5lZ2F0ZSB0aGUgaW5jb21pbmcgc2lnbmFsLiBpLmUuIGFuIGlucHV0IHNpZ25hbCBvZiAxMCB3aWxsIG91dHB1dCAtMTBcblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbmVnID0gbmV3IFRvbmUuTmVnYXRlKCk7XG5cdFx0ICogdmFyIHNpZyA9IG5ldyBUb25lLlNpZ25hbCgtMikuY29ubmVjdChuZWcpO1xuXHRcdCAqIC8vb3V0cHV0IG9mIG5lZyBpcyBwb3NpdGl2ZSAyLiBcblx0XHQgKi9cblx0ICAgIFRvbmUuTmVnYXRlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIG5lZ2F0aW9uIGlzIGRvbmUgYnkgbXVsdGlwbHlpbmcgYnkgLTFcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NdWx0aXBseX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbXVsdGlwbHkgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5NdWx0aXBseSgtMSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5OZWdhdGUsIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTmVnYXRlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk5lZ2F0ZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9tdWx0aXBseS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbXVsdGlwbHkgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk5lZ2F0ZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFN1YnRyYWN0IHRoZSBzaWduYWwgY29ubmVjdGVkIHRvIDxjb2RlPmlucHV0WzFdPC9jb2RlPiBmcm9tIHRoZSBzaWduYWwgY29ubmVjdGVkIFxuXHRcdCAqICAgICAgICAgdG8gPGNvZGU+aW5wdXRbMF08L2NvZGU+LiBJZiBhbiBhcmd1bWVudCBpcyBwcm92aWRlZCBpbiB0aGUgY29uc3RydWN0b3IsIHRoZSBcblx0XHQgKiAgICAgICAgIHNpZ25hbHMgPGNvZGU+LnZhbHVlPC9jb2RlPiB3aWxsIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgaW5jb21pbmcgc2lnbmFsLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbH1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gdmFsdWUgVGhlIHZhbHVlIHRvIHN1YnRyYWN0IGZyb20gdGhlIGluY29taW5nIHNpZ25hbC4gSWYgdGhlIHZhbHVlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgaXMgb21pdHRlZCwgaXQgd2lsbCBzdWJ0cmFjdCB0aGUgc2Vjb25kIHNpZ25hbCBmcm9tIHRoZSBmaXJzdC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc3ViID0gbmV3IFRvbmUuU3VidHJhY3QoMSk7XG5cdFx0ICogdmFyIHNpZyA9IG5ldyBUb25lLlNpZ25hbCg0KS5jb25uZWN0KHN1Yik7XG5cdFx0ICogLy90aGUgb3V0cHV0IG9mIHN1YiBpcyAzLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc3ViID0gbmV3IFRvbmUuU3VidHJhY3QoKTtcblx0XHQgKiB2YXIgc2lnQSA9IG5ldyBUb25lLlNpZ25hbCgxMCk7XG5cdFx0ICogdmFyIHNpZ0IgPSBuZXcgVG9uZS5TaWduYWwoMi41KTtcblx0XHQgKiBzaWdBLmNvbm5lY3Qoc3ViLCAwLCAwKTtcblx0XHQgKiBzaWdCLmNvbm5lY3Qoc3ViLCAwLCAxKTtcblx0XHQgKiAvL291dHB1dCBvZiBzdWIgaXMgNy41XG5cdFx0ICovXG5cdCAgICBUb25lLlN1YnRyYWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWwuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMiwgMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHN1bW1pbmcgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3VtID0gdGhpcy5pbnB1dFswXSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIG5lZ2F0ZSB0aGUgaW5wdXQgb2YgdGhlIHNlY29uZCBpbnB1dCBiZWZvcmUgY29ubmVjdGluZyBpdFxuXHRcdFx0ICogIHRvIHRoZSBzdW1taW5nIG5vZGUuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTmVnYXRlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9uZWcgPSBuZXcgVG9uZS5OZWdhdGUoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbm9kZSB3aGVyZSB0aGUgdmFsdWUgaXMgc2V0XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TaWduYWx9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYXJhbSA9IHRoaXMuaW5wdXRbMV0gPSBuZXcgVG9uZS5TaWduYWwodmFsdWUpO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLmNoYWluKHRoaXMuX25lZywgdGhpcy5fc3VtKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlN1YnRyYWN0LCBUb25lLlNpZ25hbCk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNpZ25hbEJhc2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU3VidHJhY3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWwucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9uZWcuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX25lZyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3VtLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9zdW0gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlN1YnRyYWN0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEdyZWF0ZXJUaGFuWmVybyBvdXRwdXRzIDEgd2hlbiB0aGUgaW5wdXQgaXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIHplcm9cblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBndDAgPSBuZXcgVG9uZS5HcmVhdGVyVGhhblplcm8oKTtcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKDAuMDEpLmNvbm5lY3QoZ3QwKTtcblx0XHQgKiAvL3RoZSBvdXRwdXQgb2YgZ3QwIGlzIDEuIFxuXHRcdCAqIHNpZy52YWx1ZSA9IDA7XG5cdFx0ICogLy90aGUgb3V0cHV0IG9mIGd0MCBpcyAwLiBcblx0XHQgKi9cblx0ICAgIFRvbmUuR3JlYXRlclRoYW5aZXJvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLldhdmVTaGFwZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3RocmVzaCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuV2F2ZVNoYXBlcihmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWwgPD0gMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sIDEyNyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgc2NhbGUgdGhlIGZpcnN0IHRocmVzaG9sZGVkIHNpZ25hbCBieSBhIGxhcmdlIHZhbHVlLlxuXHRcdFx0ICogIHRoaXMgd2lsbCBoZWxwIHdpdGggdmFsdWVzIHdoaWNoIGFyZSB2ZXJ5IGNsb3NlIHRvIDBcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NdWx0aXBseX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuTXVsdGlwbHkoMTAwMDApO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLl9zY2FsZS5jb25uZWN0KHRoaXMuX3RocmVzaCk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5HcmVhdGVyVGhhblplcm8sIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiAgZGlzcG9zZSBtZXRob2Rcblx0XHQgKiAgQHJldHVybnMge1RvbmUuR3JlYXRlclRoYW5aZXJvfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkdyZWF0ZXJUaGFuWmVyby5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3RocmVzaC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdGhyZXNoID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5HcmVhdGVyVGhhblplcm87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgT3V0cHV0IDEgaWYgdGhlIHNpZ25hbCBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlLCBvdGhlcndpc2Ugb3V0cHV0cyAwLlxuXHRcdCAqICAgICAgICAgIGNhbiBjb21wYXJlIHR3byBzaWduYWxzIG9yIGEgc2lnbmFsIGFuZCBhIG51bWJlci4gXG5cdFx0ICogIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsfVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3ZhbHVlPTBdIHRoZSB2YWx1ZSB0byBjb21wYXJlIHRvIHRoZSBpbmNvbWluZyBzaWduYWxcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgZ3QgPSBuZXcgVG9uZS5HcmVhdGVyVGhhbigyKTtcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKDQpLmNvbm5lY3QoZ3QpO1xuXHRcdCAqIC8vb3V0cHV0IG9mIGd0IGlzIGVxdWFsIDEuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmVhdGVyVGhhbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDIsIDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHN1YnRyYWN0IHRoZSBhbW91bnQgZnJvbSB0aGUgaW5jb21pbmcgc2lnbmFsXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU3VidHJhY3R9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhcmFtID0gdGhpcy5pbnB1dFswXSA9IG5ldyBUb25lLlN1YnRyYWN0KHZhbHVlKTtcblx0ICAgICAgICB0aGlzLmlucHV0WzFdID0gdGhpcy5fcGFyYW0uaW5wdXRbMV07XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgY29tcGFyZSB0aGF0IGFtb3VudCB0byB6ZXJvXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR3JlYXRlclRoYW5aZXJvfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ndHogPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdyZWF0ZXJUaGFuWmVybygpO1xuXHQgICAgICAgIC8vY29ubmVjdFxuXHQgICAgICAgIHRoaXMuX3BhcmFtLmNvbm5lY3QodGhpcy5fZ3R6KTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkdyZWF0ZXJUaGFuLCBUb25lLlNpZ25hbCk7XG5cdCAgICAvKipcblx0XHQgKiAgZGlzcG9zZSBtZXRob2Rcblx0XHQgKiAgQHJldHVybnMge1RvbmUuR3JlYXRlclRoYW59IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuR3JlYXRlclRoYW4ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWwucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9ndHouZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2d0eiA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuR3JlYXRlclRoYW47XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBSZXR1cm4gdGhlIGFic29sdXRlIHZhbHVlIG9mIGFuIGluY29taW5nIHNpZ25hbC4gXG5cdFx0ICogIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc2lnbmFsID0gbmV3IFRvbmUuU2lnbmFsKC0xKTtcblx0XHQgKiB2YXIgYWJzID0gbmV3IFRvbmUuQWJzKCk7XG5cdFx0ICogc2lnbmFsLmNvbm5lY3QoYWJzKTtcblx0XHQgKiAvL3RoZSBvdXRwdXQgb2YgYWJzIGlzIDEuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5BYnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTGVzc1RoYW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FicyA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLldhdmVTaGFwZXIoZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICBpZiAodmFsID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh2YWwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSwgMTI3KTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkFicywgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBkaXNwb3NlIG1ldGhvZFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BYnN9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQWJzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2Ficy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYWJzID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5BYnM7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBTaWduYWwtcmF0ZSBtb2R1bG8gb3BlcmF0b3IuIE9ubHkgd29ya3MgaW4gQXVkaW9SYW5nZSBbLTEsIDFdIGFuZCBmb3IgbW9kdWx1c1xuXHRcdCAqICAgICAgICAgdmFsdWVzIGluIHRoZSBOb3JtYWxSYW5nZS4gXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IG1vZHVsdXMgVGhlIG1vZHVsdXMgdG8gYXBwbHkuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIG1vZCA9IG5ldyBUb25lLk1vZHVsbygwLjIpXG5cdFx0ICogdmFyIHNpZyA9IG5ldyBUb25lLlNpZ25hbCgwLjUpLmNvbm5lY3QobW9kKTtcblx0XHQgKiAvL21vZCBvdXRwdXRzIDAuMVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb2R1bG8gPSBmdW5jdGlvbiAobW9kdWx1cykge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygxLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIHdhdmVzaGFwZXIgZ2V0cyB0aGUgaW50ZWdlciBtdWx0aXBsZSBvZiBcblx0XHRcdCAqICB0aGUgaW5wdXQgc2lnbmFsIGFuZCB0aGUgbW9kdWx1cy5cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLldhdmVTaGFwZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zaGFwZXIgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKE1hdGgucG93KDIsIDE2KSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGludGVnZXIgbXVsdGlwbGUgaXMgbXVsdGlwbGllZCBieSB0aGUgbW9kdWx1c1xuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5NdWx0aXBseX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbXVsdGlwbHkgPSBuZXcgVG9uZS5NdWx0aXBseSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGFuZCBzdWJ0cmFjdGVkIGZyb20gdGhlIGlucHV0IHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5TdWJ0cmFjdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3VidHJhY3QgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlN1YnRyYWN0KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG1vZHVsdXMgc2lnbmFsXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLlNpZ25hbH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbW9kU2lnbmFsID0gbmV3IFRvbmUuU2lnbmFsKG1vZHVsdXMpO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmlucHV0LmZhbih0aGlzLl9zaGFwZXIsIHRoaXMuX3N1YnRyYWN0KTtcblx0ICAgICAgICB0aGlzLl9tb2RTaWduYWwuY29ubmVjdCh0aGlzLl9tdWx0aXBseSwgMCwgMCk7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyLmNvbm5lY3QodGhpcy5fbXVsdGlwbHksIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuX211bHRpcGx5LmNvbm5lY3QodGhpcy5fc3VidHJhY3QsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuX3NldFdhdmVTaGFwZXIobW9kdWx1cyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Nb2R1bG8sIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSAgbW9kICB0aGUgbW9kdWx1cyB0byBhcHBseVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb2R1bG8ucHJvdG90eXBlLl9zZXRXYXZlU2hhcGVyID0gZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgICAgIHRoaXMuX3NoYXBlci5zZXRNYXAoZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICB2YXIgbXVsdGlwbGUgPSBNYXRoLmZsb29yKCh2YWwgKyAwLjAwMDEpIC8gbW9kKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG11bHRpcGxlO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBtb2R1bHVzIHZhbHVlLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk1vZHVsbyNcblx0XHQgKiBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0ICogQG5hbWUgdmFsdWVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk1vZHVsby5wcm90b3R5cGUsICd2YWx1ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vZFNpZ25hbC52YWx1ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9tb2RTaWduYWwudmFsdWUgPSBtb2Q7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFdhdmVTaGFwZXIobW9kKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1vZHVsb30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb2R1bG8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zaGFwZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX211bHRpcGx5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tdWx0aXBseSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3VidHJhY3QuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3N1YnRyYWN0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2RTaWduYWwuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZFNpZ25hbCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTW9kdWxvO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQXVkaW9Ub0dhaW4gY29udmVydHMgYW4gaW5wdXQgaW4gQXVkaW9SYW5nZSBbLTEsMV0gdG8gTm9ybWFsUmFuZ2UgWzAsMV0uIFxuXHRcdCAqICAgICAgICAgU2VlIFRvbmUuR2FpblRvQXVkaW8uXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIHZhciBhMmcgPSBuZXcgVG9uZS5BdWRpb1RvR2FpbigpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdWRpb1RvR2FpbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7V2F2ZVNoYXBlck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX25vcm0gPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoeCArIDEpIC8gMjtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkF1ZGlvVG9HYWluLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkF1ZGlvVG9HYWlufSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1ZGlvVG9HYWluLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX25vcm0uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX25vcm0gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkF1ZGlvVG9HYWluO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgRXZhbHVhdGUgYW4gZXhwcmVzc2lvbiBhdCBhdWRpbyByYXRlLiA8YnI+PGJyPlxuXHRcdCAqICAgICAgICAgUGFyc2luZyBjb2RlIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC90YXBkaWdpdC9cblx0XHQgKiAgICAgICAgIENvcHlyaWdodCAyMDExIDIwMTIgQXJpeWEgSGlkYXlhdCwgTmV3IEJTRCBMaWNlbnNlXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBleHByIHRoZSBleHByZXNzaW9uIHRvIGdlbmVyYXRlXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9hZGRzIHRoZSBzaWduYWxzIGZyb20gaW5wdXRbMF0gYW5kIGlucHV0WzFdLlxuXHRcdCAqIHZhciBleHByID0gbmV3IFRvbmUuRXhwcihcIiQwICsgJDFcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkV4cHIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLl9yZXBsYWNlbWVudHMoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG5cdCAgICAgICAgdmFyIGlucHV0Q291bnQgPSB0aGlzLl9wYXJzZUlucHV0cyhleHByKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBob2xkIG9udG8gYWxsIG9mIHRoZSBub2RlcyBmb3IgZGlzcG9zYWxcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX25vZGVzID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGlucHV0cy4gVGhlIGxlbmd0aCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBleHByZXNzaW9uLiBcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmlucHV0ID0gbmV3IEFycmF5KGlucHV0Q291bnQpO1xuXHQgICAgICAgIC8vY3JlYXRlIGEgZ2FpbiBmb3IgZWFjaCBpbnB1dFxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaW5wdXRbaV0gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL3BhcnNlIHRoZSBzeW50YXggdHJlZVxuXHQgICAgICAgIHZhciB0cmVlID0gdGhpcy5fcGFyc2VUcmVlKGV4cHIpO1xuXHQgICAgICAgIC8vZXZhbHVhdGUgdGhlIHJlc3VsdHNcblx0ICAgICAgICB2YXIgcmVzdWx0O1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2V2YWwodHJlZSk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9kaXNwb3NlTm9kZXMoKTtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLkV4cHI6IENvdWxkIGV2YWx1YXRlIGV4cHJlc3Npb246ICcgKyBleHByKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG91dHB1dCBub2RlIGlzIHRoZSByZXN1bHQgb2YgdGhlIGV4cHJlc3Npb25cblx0XHRcdCAqICBAdHlwZSB7VG9uZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub3V0cHV0ID0gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRXhwciwgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8vc29tZSBoZWxwZXJzIHRvIGN1dCBkb3duIHRoZSBhbW91bnQgb2YgY29kZVxuXHQgICAgZnVuY3Rpb24gYXBwbHlCaW5hcnkoQ29uc3RydWN0b3IsIGFyZ3MsIHNlbGYpIHtcblx0ICAgICAgICB2YXIgb3AgPSBuZXcgQ29uc3RydWN0b3IoKTtcblx0ICAgICAgICBzZWxmLl9ldmFsKGFyZ3NbMF0pLmNvbm5lY3Qob3AsIDAsIDApO1xuXHQgICAgICAgIHNlbGYuX2V2YWwoYXJnc1sxXSkuY29ubmVjdChvcCwgMCwgMSk7XG5cdCAgICAgICAgcmV0dXJuIG9wO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gYXBwbHlVbmFyeShDb25zdHJ1Y3RvciwgYXJncywgc2VsZikge1xuXHQgICAgICAgIHZhciBvcCA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuXHQgICAgICAgIHNlbGYuX2V2YWwoYXJnc1swXSkuY29ubmVjdChvcCwgMCwgMCk7XG5cdCAgICAgICAgcmV0dXJuIG9wO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZ2V0TnVtYmVyKGFyZykge1xuXHQgICAgICAgIHJldHVybiBhcmcgPyBwYXJzZUZsb2F0KGFyZykgOiB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBsaXRlcmFsTnVtYmVyKGFyZykge1xuXHQgICAgICAgIHJldHVybiBhcmcgJiYgYXJnLmFyZ3MgPyBwYXJzZUZsb2F0KGFyZy5hcmdzKSA6IHVuZGVmaW5lZDtcblx0ICAgIH1cblx0ICAgIC8qXG5cdFx0ICogIHRoZSBFeHByZXNzaW9ucyB0aGF0IFRvbmUuRXhwciBjYW4gcGFyc2UuXG5cdFx0ICpcblx0XHQgKiAgZWFjaCBleHByZXNzaW9uIGJlbG9uZ3MgdG8gYSBncm91cCBhbmQgY29udGFpbnMgYSByZWdleHAgXG5cdFx0ICogIGZvciBzZWxlY3RpbmcgdGhlIG9wZXJhdG9yIGFzIHdlbGwgYXMgdGhhdCBvcGVyYXRvcnMgbWV0aG9kXG5cdFx0ICogIFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByLl9FeHByZXNzaW9ucyA9IHtcblx0ICAgICAgICAvL3ZhbHVlc1xuXHQgICAgICAgICd2YWx1ZSc6IHtcblx0ICAgICAgICAgICAgJ3NpZ25hbCc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15cXGQrXFwuXFxkK3xeXFxkKy8sXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChhcmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKGdldE51bWJlcihhcmcpKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnaW5wdXQnOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9eXFwkXFxkLyxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGFyZywgc2VsZikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmlucHV0W2dldE51bWJlcihhcmcuc3Vic3RyKDEpKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIC8vc3ludGFjdGljIGdsdWVcblx0ICAgICAgICAnZ2x1ZSc6IHtcblx0ICAgICAgICAgICAgJygnOiB7IHJlZ2V4cDogL15cXCgvIH0sXG5cdCAgICAgICAgICAgICcpJzogeyByZWdleHA6IC9eXFwpLyB9LFxuXHQgICAgICAgICAgICAnLCc6IHsgcmVnZXhwOiAvXiwvIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIC8vZnVuY3Rpb25zXG5cdCAgICAgICAgJ2Z1bmMnOiB7XG5cdCAgICAgICAgICAgICdhYnMnOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9eYWJzLyxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogYXBwbHlVbmFyeS5iaW5kKHRoaXMsIFRvbmUuQWJzKVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnbW9kJzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXm1vZC8sXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChhcmdzLCBzZWxmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1vZHVsdXMgPSBsaXRlcmFsTnVtYmVyKGFyZ3NbMV0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IG5ldyBUb25lLk1vZHVsbyhtb2R1bHVzKTtcblx0ICAgICAgICAgICAgICAgICAgICBzZWxmLl9ldmFsKGFyZ3NbMF0pLmNvbm5lY3Qob3ApO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ3Bvdyc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15wb3cvLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoYXJncywgc2VsZikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBleHAgPSBsaXRlcmFsTnVtYmVyKGFyZ3NbMV0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IG5ldyBUb25lLlBvdyhleHApO1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbGYuX2V2YWwoYXJnc1swXSkuY29ubmVjdChvcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnYTJnJzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXmEyZy8sXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChhcmdzLCBzZWxmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gbmV3IFRvbmUuQXVkaW9Ub0dhaW4oKTtcblx0ICAgICAgICAgICAgICAgICAgICBzZWxmLl9ldmFsKGFyZ3NbMF0pLmNvbm5lY3Qob3ApO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy9iaW5hcnkgZXhwcmVzc2lvbnNcblx0ICAgICAgICAnYmluYXJ5Jzoge1xuXHQgICAgICAgICAgICAnKyc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15cXCsvLFxuXHQgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogMSxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogYXBwbHlCaW5hcnkuYmluZCh0aGlzLCBUb25lLkFkZClcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJy0nOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9eXFwtLyxcblx0ICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDEsXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChhcmdzLCBzZWxmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9ib3RoIHVuYXJ5IGFuZCBiaW5hcnkgb3Bcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5VW5hcnkoVG9uZS5OZWdhdGUsIGFyZ3MsIHNlbGYpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHBseUJpbmFyeShUb25lLlN1YnRyYWN0LCBhcmdzLCBzZWxmKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICcqJzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXlxcKi8sXG5cdCAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiAwLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBhcHBseUJpbmFyeS5iaW5kKHRoaXMsIFRvbmUuTXVsdGlwbHkpXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIC8vdW5hcnkgZXhwcmVzc2lvbnNcblx0ICAgICAgICAndW5hcnknOiB7XG5cdCAgICAgICAgICAgICctJzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXlxcLS8sXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGFwcGx5VW5hcnkuYmluZCh0aGlzLCBUb25lLk5lZ2F0ZSlcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJyEnOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9eXFwhLyxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogYXBwbHlVbmFyeS5iaW5kKHRoaXMsIFRvbmUuTk9UKVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBAcGFyYW0gICB7c3RyaW5nfSBleHByIHRoZSBleHByZXNzaW9uIHN0cmluZ1xuXHRcdCAqICBAcmV0dXJuICB7bnVtYmVyfSAgICAgIHRoZSBpbnB1dCBjb3VudFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByLnByb3RvdHlwZS5fcGFyc2VJbnB1dHMgPSBmdW5jdGlvbiAoZXhwcikge1xuXHQgICAgICAgIHZhciBpbnB1dEFycmF5ID0gZXhwci5tYXRjaCgvXFwkXFxkL2cpO1xuXHQgICAgICAgIHZhciBpbnB1dE1heCA9IDA7XG5cdCAgICAgICAgaWYgKGlucHV0QXJyYXkgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5wdXROdW0gPSBwYXJzZUludChpbnB1dEFycmF5W2ldLnN1YnN0cigxKSkgKyAxO1xuXHQgICAgICAgICAgICAgICAgaW5wdXRNYXggPSBNYXRoLm1heChpbnB1dE1heCwgaW5wdXROdW0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBpbnB1dE1heDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQHBhcmFtICAge0FycmF5fSBhcmdzIFx0YW4gYXJyYXkgb2YgYXJndW1lbnRzXG5cdFx0ICogIEByZXR1cm4gIHtzdHJpbmd9IHRoZSByZXN1bHRzIG9mIHRoZSByZXBsYWNlbWVudHMgYmVpbmcgcmVwbGFjZWRcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRXhwci5wcm90b3R5cGUuX3JlcGxhY2VtZW50cyA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdCAgICAgICAgdmFyIGV4cHIgPSBhcmdzLnNoaWZ0KCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGV4cHIgPSBleHByLnJlcGxhY2UoL1xcJS9pLCBhcmdzW2ldKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHRva2VuaXplIHRoZSBleHByZXNzaW9uIGJhc2VkIG9uIHRoZSBFeHByZXNzaW9ucyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtICAge3N0cmluZ30gZXhwciBcblx0XHQgKiAgQHJldHVybiAge09iamVjdH0gICAgICByZXR1cm5zIHR3byBtZXRob2RzIG9uIHRoZSB0b2tlbml6ZWQgbGlzdCwgbmV4dCBhbmQgcGVla1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByLnByb3RvdHlwZS5fdG9rZW5pemUgPSBmdW5jdGlvbiAoZXhwcikge1xuXHQgICAgICAgIHZhciBwb3NpdGlvbiA9IC0xO1xuXHQgICAgICAgIHZhciB0b2tlbnMgPSBbXTtcblx0ICAgICAgICB3aGlsZSAoZXhwci5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgIGV4cHIgPSBleHByLnRyaW0oKTtcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gZ2V0TmV4dFRva2VuKGV4cHIpO1xuXHQgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG5cdCAgICAgICAgICAgIGV4cHIgPSBleHByLnN1YnN0cih0b2tlbi52YWx1ZS5sZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXROZXh0VG9rZW4oZXhwcikge1xuXHQgICAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIFRvbmUuRXhwci5fRXhwcmVzc2lvbnMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBncm91cCA9IFRvbmUuRXhwci5fRXhwcmVzc2lvbnNbdHlwZV07XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvcE5hbWUgaW4gZ3JvdXApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBncm91cFtvcE5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZWcgPSBvcC5yZWdleHA7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gZXhwci5tYXRjaChyZWcpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXRjaFswXSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogb3AubWV0aG9kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVG9uZS5FeHByOiBVbmV4cGVjdGVkIHRva2VuICcgKyBleHByKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1srK3Bvc2l0aW9uXTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgcGVlazogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1twb3NpdGlvbiArIDFdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgcmVjdXJzaXZlbHkgcGFyc2UgdGhlIHN0cmluZyBleHByZXNzaW9uIGludG8gYSBzeW50YXggdHJlZVxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICAge3N0cmluZ30gZXhwciBcblx0XHQgKiAgQHJldHVybiAge09iamVjdH1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRXhwci5wcm90b3R5cGUuX3BhcnNlVHJlZSA9IGZ1bmN0aW9uIChleHByKSB7XG5cdCAgICAgICAgdmFyIGxleGVyID0gdGhpcy5fdG9rZW5pemUoZXhwcik7XG5cdCAgICAgICAgdmFyIGlzVW5kZWYgPSBUb25lLmlzVW5kZWYuYmluZCh0aGlzKTtcblx0ICAgICAgICBmdW5jdGlvbiBtYXRjaFN5bnRheCh0b2tlbiwgc3luKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAhaXNVbmRlZih0b2tlbikgJiYgdG9rZW4udHlwZSA9PT0gJ2dsdWUnICYmIHRva2VuLnZhbHVlID09PSBzeW47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG1hdGNoR3JvdXAodG9rZW4sIGdyb3VwTmFtZSwgcHJlYykge1xuXHQgICAgICAgICAgICB2YXIgcmV0ID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHZhciBncm91cCA9IFRvbmUuRXhwci5fRXhwcmVzc2lvbnNbZ3JvdXBOYW1lXTtcblx0ICAgICAgICAgICAgaWYgKCFpc1VuZGVmKHRva2VuKSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb3BOYW1lIGluIGdyb3VwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gZ3JvdXBbb3BOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3AucmVnZXhwLnRlc3QodG9rZW4udmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZihwcmVjKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnByZWNlZGVuY2UgPT09IHByZWMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihwcmVjZWRlbmNlKSB7XG5cdCAgICAgICAgICAgIGlmIChpc1VuZGVmKHByZWNlZGVuY2UpKSB7XG5cdCAgICAgICAgICAgICAgICBwcmVjZWRlbmNlID0gNTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgZXhwcjtcblx0ICAgICAgICAgICAgaWYgKHByZWNlZGVuY2UgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICBleHByID0gcGFyc2VVbmFyeSgpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbihwcmVjZWRlbmNlIC0gMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgICAgICB3aGlsZSAobWF0Y2hHcm91cCh0b2tlbiwgJ2JpbmFyeScsIHByZWNlZGVuY2UpKSB7XG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHRva2VuLnZhbHVlLFxuXHQgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdG9rZW4ubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwcixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VFeHByZXNzaW9uKHByZWNlZGVuY2UgLSAxKVxuXHQgICAgICAgICAgICAgICAgICAgIF1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IGxleGVyLnBlZWsoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZXhwcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gcGFyc2VVbmFyeSgpIHtcblx0ICAgICAgICAgICAgdmFyIHRva2VuLCBleHByO1xuXHQgICAgICAgICAgICB0b2tlbiA9IGxleGVyLnBlZWsoKTtcblx0ICAgICAgICAgICAgaWYgKG1hdGNoR3JvdXAodG9rZW4sICd1bmFyeScpKSB7XG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5KCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB0b2tlbi52YWx1ZSxcblx0ICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHRva2VuLm1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZXhwcl1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHBhcnNlUHJpbWFyeSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBwYXJzZVByaW1hcnkoKSB7XG5cdCAgICAgICAgICAgIHZhciB0b2tlbiwgZXhwcjtcblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5wZWVrKCk7XG5cdCAgICAgICAgICAgIGlmIChpc1VuZGVmKHRva2VuKSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUb25lLkV4cHI6IFVuZXhwZWN0ZWQgdGVybWluYXRpb24gb2YgZXhwcmVzc2lvbicpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnZnVuYycpIHtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25DYWxsKHRva2VuKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3ZhbHVlJykge1xuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdG9rZW4ubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHRva2VuLnZhbHVlXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChtYXRjaFN5bnRheCh0b2tlbiwgJygnKSkge1xuXHQgICAgICAgICAgICAgICAgbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW1hdGNoU3ludGF4KHRva2VuLCAnKScpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdFeHBlY3RlZCApJyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZXhwcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RvbmUuRXhwcjogUGFyc2UgZXJyb3IsIGNhbm5vdCBwcm9jZXNzIHRva2VuICcgKyB0b2tlbi52YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25DYWxsKGZ1bmMpIHtcblx0ICAgICAgICAgICAgdmFyIHRva2VuLCBhcmdzID0gW107XG5cdCAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICBpZiAoIW1hdGNoU3ludGF4KHRva2VuLCAnKCcpKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RvbmUuRXhwcjogRXhwZWN0ZWQgKCBpbiBhIGZ1bmN0aW9uIGNhbGwgXCInICsgZnVuYy52YWx1ZSArICdcIicpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgICAgICBpZiAoIW1hdGNoU3ludGF4KHRva2VuLCAnKScpKSB7XG5cdCAgICAgICAgICAgICAgICBhcmdzID0gcGFyc2VBcmd1bWVudExpc3QoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgaWYgKCFtYXRjaFN5bnRheCh0b2tlbiwgJyknKSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUb25lLkV4cHI6IEV4cGVjdGVkICkgaW4gYSBmdW5jdGlvbiBjYWxsIFwiJyArIGZ1bmMudmFsdWUgKyAnXCInKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBmdW5jLm1ldGhvZCxcblx0ICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG5cdCAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRMaXN0KCkge1xuXHQgICAgICAgICAgICB2YXIgdG9rZW4sIGV4cHIsIGFyZ3MgPSBbXTtcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblx0ICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGV4cHIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBtYXliZSB0aHJvdyBleGNlcHRpb24/XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXhwcik7XG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IGxleGVyLnBlZWsoKTtcblx0ICAgICAgICAgICAgICAgIGlmICghbWF0Y2hTeW50YXgodG9rZW4sICcsJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gYXJncztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbigpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICByZWN1cnNpdmVseSBldmFsdWF0ZSB0aGUgZXhwcmVzc2lvbiB0cmVlXG5cdFx0ICogIEBwYXJhbSAgIHtPYmplY3R9IHRyZWUgXG5cdFx0ICogIEByZXR1cm4gIHtBdWRpb05vZGV9ICAgICAgdGhlIHJlc3VsdGluZyBhdWRpbyBub2RlIGZyb20gdGhlIGV4cHJlc3Npb25cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRXhwci5wcm90b3R5cGUuX2V2YWwgPSBmdW5jdGlvbiAodHJlZSkge1xuXHQgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKHRyZWUpKSB7XG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdHJlZS5tZXRob2QodHJlZS5hcmdzLCB0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBkaXNwb3NlIGFsbCB0aGUgbm9kZXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRXhwci5wcm90b3R5cGUuX2Rpc3Bvc2VOb2RlcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX25vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZXNbaV07XG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzRnVuY3Rpb24obm9kZS5kaXNwb3NlKSkge1xuXHQgICAgICAgICAgICAgICAgbm9kZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc0Z1bmN0aW9uKG5vZGUuZGlzY29ubmVjdCkpIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG5vZGUgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLl9ub2Rlc1tpXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX25vZGVzID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKi9cblx0ICAgIFRvbmUuRXhwci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9kaXNwb3NlTm9kZXMoKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5FeHByO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQ29udmVydCBhbiBpbmNvbWluZyBzaWduYWwgYmV0d2VlbiAwLCAxIHRvIGFuIGVxdWFsIHBvd2VyIGdhaW4gc2NhbGUuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGVxUG93R2FpbiA9IG5ldyBUb25lLkVxdWFsUG93ZXJHYWluKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkVxdWFsUG93ZXJHYWluID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLldhdmVTaGFwZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2VxUG93ZXIgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgaWYgKE1hdGguYWJzKHZhbCkgPCAwLjAwMSkge1xuXHQgICAgICAgICAgICAgICAgLy9zaG91bGQgb3V0cHV0IDAgd2hlbiBpbnB1dCBpcyAwXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBUb25lLmVxdWFsUG93ZXJTY2FsZSh2YWwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpLCA0MDk2KTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkVxdWFsUG93ZXJHYWluLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkVxdWFsUG93ZXJHYWlufSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVxdWFsUG93ZXJHYWluLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2VxUG93ZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2VxUG93ZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkVxdWFsUG93ZXJHYWluO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqIEBjbGFzcyAgVG9uZS5Dcm9zc2ZhZGUgcHJvdmlkZXMgZXF1YWwgcG93ZXIgZmFkaW5nIGJldHdlZW4gdHdvIGlucHV0cy5cblx0XHQgKiAgICAgICAgIE1vcmUgb24gY3Jvc3NmYWRpbmcgdGVjaG5pcXVlIFtoZXJlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GYWRlXyhhdWRpb19lbmdpbmVlcmluZykjQ3Jvc3NmYWRpbmcpLlxuXHRcdCAqXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICogQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IFtpbml0aWFsRmFkZT0wLjVdXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiB2YXIgY3Jvc3NGYWRlID0gbmV3IFRvbmUuQ3Jvc3NGYWRlKDAuNSk7XG5cdFx0ICogLy9jb25uZWN0IGVmZmVjdCBBIHRvIGNyb3NzZmFkZSBmcm9tXG5cdFx0ICogLy9lZmZlY3Qgb3V0cHV0IDAgdG8gY3Jvc3NmYWRlIGlucHV0IDBcblx0XHQgKiBlZmZlY3RBLmNvbm5lY3QoY3Jvc3NGYWRlLCAwLCAwKTtcblx0XHQgKiAvL2Nvbm5lY3QgZWZmZWN0IEIgdG8gY3Jvc3NmYWRlIGZyb21cblx0XHQgKiAvL2VmZmVjdCBvdXRwdXQgMCB0byBjcm9zc2ZhZGUgaW5wdXQgMVxuXHRcdCAqIGVmZmVjdEIuY29ubmVjdChjcm9zc0ZhZGUsIDAsIDEpO1xuXHRcdCAqIGNyb3NzRmFkZS5mYWRlLnZhbHVlID0gMDtcblx0XHQgKiAvLyBeIG9ubHkgZWZmZWN0QSBpcyBvdXRwdXRcblx0XHQgKiBjcm9zc0ZhZGUuZmFkZS52YWx1ZSA9IDE7XG5cdFx0ICogLy8gXiBvbmx5IGVmZmVjdEIgaXMgb3V0cHV0XG5cdFx0ICogY3Jvc3NGYWRlLmZhZGUudmFsdWUgPSAwLjU7XG5cdFx0ICogLy8gXiB0aGUgdHdvIHNpZ25hbHMgYXJlIG1peGVkIGVxdWFsbHkuXG5cdFx0ICovXG5cdCAgICBUb25lLkNyb3NzRmFkZSA9IGZ1bmN0aW9uIChpbml0aWFsRmFkZSkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDIsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFsaWFzIGZvciA8Y29kZT5pbnB1dFswXTwvY29kZT4uXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuYSA9IHRoaXMuaW5wdXRbMF0gPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQWxpYXMgZm9yIDxjb2RlPmlucHV0WzFdPC9jb2RlPi5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5iID0gdGhpcy5pbnB1dFsxXSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFx0VGhlIG1peCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzLiBBIGZhZGUgdmFsdWUgb2YgMFxuXHRcdFx0ICogXHR3aWxsIG91dHB1dCAxMDAlIDxjb2RlPmlucHV0WzBdPC9jb2RlPiBhbmRcblx0XHRcdCAqIFx0YSB2YWx1ZSBvZiAxIHdpbGwgb3V0cHV0IDEwMCUgPGNvZGU+aW5wdXRbMV08L2NvZGU+LlxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZhZGUgPSBuZXcgVG9uZS5TaWduYWwoVG9uZS5kZWZhdWx0QXJnKGluaXRpYWxGYWRlLCAwLjUpLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGVxdWFsIHBvd2VyIGdhaW4gY3Jvc3MgZmFkZVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRXF1YWxQb3dlckdhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9lcXVhbFBvd2VyQSA9IG5ldyBUb25lLkVxdWFsUG93ZXJHYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgZXF1YWwgcG93ZXIgZ2FpbiBjcm9zcyBmYWRlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5FcXVhbFBvd2VyR2Fpbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2VxdWFsUG93ZXJCID0gbmV3IFRvbmUuRXF1YWxQb3dlckdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBpbnZlcnQgdGhlIGluY29taW5nIHNpZ25hbFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9pbnZlcnQgPSBuZXcgVG9uZS5FeHByKCcxIC0gJDAnKTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5hLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuYi5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLmZhZGUuY2hhaW4odGhpcy5fZXF1YWxQb3dlckIsIHRoaXMuYi5nYWluKTtcblx0ICAgICAgICB0aGlzLmZhZGUuY2hhaW4odGhpcy5faW52ZXJ0LCB0aGlzLl9lcXVhbFBvd2VyQSwgdGhpcy5hLmdhaW4pO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCdmYWRlJyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Dcm9zc0ZhZGUsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Dcm9zc0ZhZGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3Jvc3NGYWRlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ2ZhZGUnKTtcblx0ICAgICAgICB0aGlzLl9lcXVhbFBvd2VyQS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZXF1YWxQb3dlckEgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2VxdWFsUG93ZXJCLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9lcXVhbFBvd2VyQiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mYWRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZhZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2ludmVydC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5faW52ZXJ0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmEuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuYSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5iLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkNyb3NzRmFkZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLkZpbHRlciBpcyBhIGZpbHRlciB3aGljaCBhbGxvd3MgZm9yIGFsbCBvZiB0aGUgc2FtZSBuYXRpdmUgbWV0aG9kc1xuXHRcdCAqICAgICAgICAgIGFzIHRoZSBbQmlxdWFkRmlsdGVyTm9kZV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtYmlxdWFkZmlsdGVybm9kZS1pbnRlcmZhY2UpLlxuXHRcdCAqICAgICAgICAgIFRvbmUuRmlsdGVyIGhhcyB0aGUgYWRkZWQgYWJpbGl0eSB0byBzZXQgdGhlIGZpbHRlciByb2xsb2ZmIGF0IC0xMlxuXHRcdCAqICAgICAgICAgIChkZWZhdWx0KSwgLTI0IGFuZCAtNDguXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l8T2JqZWN0fSBbZnJlcXVlbmN5XSBUaGUgY3V0b2ZmIGZyZXF1ZW5jeSBvZiB0aGUgZmlsdGVyLlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZz19IHR5cGUgVGhlIHR5cGUgb2YgZmlsdGVyLlxuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IHJvbGxvZmYgVGhlIGRyb3AgaW4gZGVjaWJlbHMgcGVyIG9jdGF2ZSBhZnRlciB0aGUgY3V0b2ZmIGZyZXF1ZW5jeS5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzIGNob2ljZXM6IC0xMiwgLTI0LCBhbmQgLTQ4XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIHZhciBmaWx0ZXIgPSBuZXcgVG9uZS5GaWx0ZXIoMjAwLCBcImhpZ2hwYXNzXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ3R5cGUnLFxuXHQgICAgICAgICAgICAncm9sbG9mZidcblx0ICAgICAgICBdLCBUb25lLkZpbHRlcik7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMSwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGZpbHRlcihzKVxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmlsdGVycyA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjdXRvZmYgZnJlcXVlbmN5IG9mIHRoZSBmaWx0ZXIuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBwYXJhbWV0ZXJcblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBuZXcgVG9uZS5TaWduYWwoMCwgVG9uZS5UeXBlLkNlbnRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZ2FpbiBvZiB0aGUgZmlsdGVyLCBvbmx5IHVzZWQgaW4gY2VydGFpbiBmaWx0ZXIgdHlwZXNcblx0XHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZ2FpbiA9IG5ldyBUb25lLlNpZ25hbCh7XG5cdCAgICAgICAgICAgICd2YWx1ZSc6IG9wdGlvbnMuZ2Fpbixcblx0ICAgICAgICAgICAgJ2NvbnZlcnQnOiBmYWxzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBRIG9yIFF1YWxpdHkgb2YgdGhlIGZpbHRlclxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLlEgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5RKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgdHlwZSBvZiB0aGUgZmlsdGVyXG5cdFx0XHQgKiAgQHR5cGUge3N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgcm9sbG9mZiB2YWx1ZSBvZiB0aGUgZmlsdGVyXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcm9sbG9mZiA9IG9wdGlvbnMucm9sbG9mZjtcblx0ICAgICAgICAvL3NldCB0aGUgcm9sbG9mZjtcblx0ICAgICAgICB0aGlzLnJvbGxvZmYgPSBvcHRpb25zLnJvbGxvZmY7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdnYWluJyxcblx0ICAgICAgICAgICAgJ1EnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5GaWx0ZXIsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICpcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GaWx0ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3R5cGUnOiAnbG93cGFzcycsXG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDM1MCxcblx0ICAgICAgICAncm9sbG9mZic6IC0xMixcblx0ICAgICAgICAnUSc6IDEsXG5cdCAgICAgICAgJ2dhaW4nOiAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIGZpbHRlci4gVHlwZXM6IFwibG93cGFzc1wiLCBcImhpZ2hwYXNzXCIsXG5cdFx0ICogXCJiYW5kcGFzc1wiLCBcImxvd3NoZWxmXCIsIFwiaGlnaHNoZWxmXCIsIFwibm90Y2hcIiwgXCJhbGxwYXNzXCIsIG9yIFwicGVha2luZ1wiLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZpbHRlciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZpbHRlci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdmFyIHR5cGVzID0gW1xuXHQgICAgICAgICAgICAgICAgJ2xvd3Bhc3MnLFxuXHQgICAgICAgICAgICAgICAgJ2hpZ2hwYXNzJyxcblx0ICAgICAgICAgICAgICAgICdiYW5kcGFzcycsXG5cdCAgICAgICAgICAgICAgICAnbG93c2hlbGYnLFxuXHQgICAgICAgICAgICAgICAgJ2hpZ2hzaGVsZicsXG5cdCAgICAgICAgICAgICAgICAnbm90Y2gnLFxuXHQgICAgICAgICAgICAgICAgJ2FsbHBhc3MnLFxuXHQgICAgICAgICAgICAgICAgJ3BlYWtpbmcnXG5cdCAgICAgICAgICAgIF07XG5cdCAgICAgICAgICAgIGlmICh0eXBlcy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVG9uZS5GaWx0ZXI6IGludmFsaWQgdHlwZSAnICsgdHlwZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZmlsdGVycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyc1tpXS50eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHJvbGxvZmYgb2YgdGhlIGZpbHRlciB3aGljaCBpcyB0aGUgZHJvcCBpbiBkYlxuXHRcdCAqIHBlciBvY3RhdmUuIEltcGxlbWVudGVkIGludGVybmFsbHkgYnkgY2FzY2FkaW5nIGZpbHRlcnMuXG5cdFx0ICogT25seSBhY2NlcHRzIHRoZSB2YWx1ZXMgLTEyLCAtMjQsIC00OCBhbmQgLTk2LlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZpbHRlciNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIHJvbGxvZmZcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZpbHRlci5wcm90b3R5cGUsICdyb2xsb2ZmJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9sbG9mZjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJvbGxvZmYpIHtcblx0ICAgICAgICAgICAgcm9sbG9mZiA9IHBhcnNlSW50KHJvbGxvZmYsIDEwKTtcblx0ICAgICAgICAgICAgdmFyIHBvc3NpYmlsaXRpZXMgPSBbXG5cdCAgICAgICAgICAgICAgICAtMTIsXG5cdCAgICAgICAgICAgICAgICAtMjQsXG5cdCAgICAgICAgICAgICAgICAtNDgsXG5cdCAgICAgICAgICAgICAgICAtOTZcblx0ICAgICAgICAgICAgXTtcblx0ICAgICAgICAgICAgdmFyIGNhc2NhZGluZ0NvdW50ID0gcG9zc2liaWxpdGllcy5pbmRleE9mKHJvbGxvZmYpO1xuXHQgICAgICAgICAgICAvL2NoZWNrIHRoZSByb2xsb2ZmIGlzIHZhbGlkXG5cdCAgICAgICAgICAgIGlmIChjYXNjYWRpbmdDb3VudCA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUb25lLkZpbHRlcjogcm9sbG9mZiBjYW4gb25seSBiZSAtMTIsIC0yNCwgLTQ4IG9yIC05NicpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhc2NhZGluZ0NvdW50ICs9IDE7XG5cdCAgICAgICAgICAgIHRoaXMuX3JvbGxvZmYgPSByb2xsb2ZmO1xuXHQgICAgICAgICAgICAvL2ZpcnN0IGRpc2Nvbm5lY3QgdGhlIGZpbHRlcnMgYW5kIHRocm93IHRoZW0gYXdheVxuXHQgICAgICAgICAgICB0aGlzLmlucHV0LmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9maWx0ZXJzW2ldLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNbaV0gPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnMgPSBuZXcgQXJyYXkoY2FzY2FkaW5nQ291bnQpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBjb3VudCA9IDA7IGNvdW50IDwgY2FzY2FkaW5nQ291bnQ7IGNvdW50KyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG5cdCAgICAgICAgICAgICAgICBmaWx0ZXIudHlwZSA9IHRoaXMuX3R5cGU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KGZpbHRlci5mcmVxdWVuY3kpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kZXR1bmUuY29ubmVjdChmaWx0ZXIuZGV0dW5lKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuUS5jb25uZWN0KGZpbHRlci5RKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZ2Fpbi5jb25uZWN0KGZpbHRlci5nYWluKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNbY291bnRdID0gZmlsdGVyO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vY29ubmVjdCB0aGVtIHVwXG5cdCAgICAgICAgICAgIHZhciBjb25uZWN0aW9uQ2hhaW4gPSBbdGhpcy5pbnB1dF0uY29uY2F0KHRoaXMuX2ZpbHRlcnMpLmNvbmNhdChbdGhpcy5vdXRwdXRdKTtcblx0ICAgICAgICAgICAgVG9uZS5jb25uZWN0U2VyaWVzLmFwcGx5KFRvbmUsIGNvbm5lY3Rpb25DaGFpbik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZpbHRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZmlsdGVycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9maWx0ZXJzW2ldLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fZmlsdGVyc1tpXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2RldHVuZScsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZ2FpbicsXG5cdCAgICAgICAgICAgICdRJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLlEuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLlEgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5nYWluLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmdhaW4gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZpbHRlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFNwbGl0IHRoZSBpbmNvbWluZyBzaWduYWwgaW50byB0aHJlZSBiYW5kcyAobG93LCBtaWQsIGhpZ2gpXG5cdFx0ICogICAgICAgICB3aXRoIHR3byBjcm9zc292ZXIgZnJlcXVlbmN5IGNvbnRyb2xzLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fE9iamVjdH0gW2xvd0ZyZXF1ZW5jeV0gdGhlIGxvdy9taWQgY3Jvc3NvdmVyIGZyZXF1ZW5jeVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gW2hpZ2hGcmVxdWVuY3ldIHRoZSBtaWQvaGlnaCBjcm9zc292ZXIgZnJlcXVlbmN5XG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpYmFuZFNwbGl0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2xvd0ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdoaWdoRnJlcXVlbmN5J1xuXHQgICAgICAgIF0sIFRvbmUuTXVsdGliYW5kU3BsaXQpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGlucHV0XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgb3V0cHV0c1xuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vdXRwdXQgPSBuZXcgQXJyYXkoMyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGxvdyBiYW5kLiBBbGlhcyBmb3IgPGNvZGU+b3V0cHV0WzBdPC9jb2RlPlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZpbHRlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubG93ID0gdGhpcy5vdXRwdXRbMF0gPSBuZXcgVG9uZS5GaWx0ZXIoMCwgJ2xvd3Bhc3MnKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbG93ZXIgZmlsdGVyIG9mIHRoZSBtaWQgYmFuZFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZpbHRlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbG93TWlkRmlsdGVyID0gbmV3IFRvbmUuRmlsdGVyKDAsICdoaWdocGFzcycpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaWQgYmFuZCBvdXRwdXQuIEFsaWFzIGZvciA8Y29kZT5vdXRwdXRbMV08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRmlsdGVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5taWQgPSB0aGlzLm91dHB1dFsxXSA9IG5ldyBUb25lLkZpbHRlcigwLCAnbG93cGFzcycpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBoaWdoIGJhbmQgb3V0cHV0LiBBbGlhcyBmb3IgPGNvZGU+b3V0cHV0WzJdPC9jb2RlPlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZpbHRlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGlnaCA9IHRoaXMub3V0cHV0WzJdID0gbmV3IFRvbmUuRmlsdGVyKDAsICdoaWdocGFzcycpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBsb3cvbWlkIGNyb3Nzb3ZlciBmcmVxdWVuY3kuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmxvd0ZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmxvd0ZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pZC9oaWdoIGNyb3Nzb3ZlciBmcmVxdWVuY3kuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5oaWdoRnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcXVhbGl0eSBvZiBhbGwgdGhlIGZpbHRlcnNcblx0XHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuUSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLlEpO1xuXHQgICAgICAgIHRoaXMuaW5wdXQuZmFuKHRoaXMubG93LCB0aGlzLmhpZ2gpO1xuXHQgICAgICAgIHRoaXMuaW5wdXQuY2hhaW4odGhpcy5fbG93TWlkRmlsdGVyLCB0aGlzLm1pZCk7XG5cdCAgICAgICAgLy90aGUgZnJlcXVlbmN5IGNvbnRyb2wgc2lnbmFsXG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kuY29ubmVjdCh0aGlzLmxvdy5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fbG93TWlkRmlsdGVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5oaWdoRnJlcXVlbmN5LmNvbm5lY3QodGhpcy5taWQuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kuY29ubmVjdCh0aGlzLmhpZ2guZnJlcXVlbmN5KTtcblx0ICAgICAgICAvL3RoZSBRIHZhbHVlXG5cdCAgICAgICAgdGhpcy5RLmNvbm5lY3QodGhpcy5sb3cuUSk7XG5cdCAgICAgICAgdGhpcy5RLmNvbm5lY3QodGhpcy5fbG93TWlkRmlsdGVyLlEpO1xuXHQgICAgICAgIHRoaXMuUS5jb25uZWN0KHRoaXMubWlkLlEpO1xuXHQgICAgICAgIHRoaXMuUS5jb25uZWN0KHRoaXMuaGlnaC5RKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdoaWdoJyxcblx0ICAgICAgICAgICAgJ21pZCcsXG5cdCAgICAgICAgICAgICdsb3cnLFxuXHQgICAgICAgICAgICAnaGlnaEZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdsb3dGcmVxdWVuY3knXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NdWx0aWJhbmRTcGxpdCwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGliYW5kU3BsaXQuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2xvd0ZyZXF1ZW5jeSc6IDQwMCxcblx0ICAgICAgICAnaGlnaEZyZXF1ZW5jeSc6IDI1MDAsXG5cdCAgICAgICAgJ1EnOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NdWx0aWJhbmRTcGxpdH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aWJhbmRTcGxpdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2hpZ2gnLFxuXHQgICAgICAgICAgICAnbWlkJyxcblx0ICAgICAgICAgICAgJ2xvdycsXG5cdCAgICAgICAgICAgICdoaWdoRnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2xvd0ZyZXF1ZW5jeSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmxvdy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5sb3cgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xvd01pZEZpbHRlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbG93TWlkRmlsdGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1pZC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5taWQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGlnaC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5oaWdoID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmxvd0ZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGlnaEZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5oaWdoRnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLlEuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuUSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTXVsdGliYW5kU3BsaXQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkVRMyBpcyBhIHRocmVlIGJhbmQgRVEgd2l0aCBjb250cm9sIG92ZXIgbG93LCBtaWQsIGFuZCBoaWdoIGdhaW4gYXNcblx0XHQgKiAgICAgICAgIHdlbGwgYXMgdGhlIGxvdyBhbmQgaGlnaCBjcm9zc292ZXIgZnJlcXVlbmNpZXMuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKlxuXHRcdCAqICBAcGFyYW0ge0RlY2liZWxzfE9iamVjdH0gW2xvd0xldmVsXSBUaGUgZ2FpbiBhcHBsaWVkIHRvIHRoZSBsb3dzLlxuXHRcdCAqICBAcGFyYW0ge0RlY2liZWxzfSBbbWlkTGV2ZWxdIFRoZSBnYWluIGFwcGxpZWQgdG8gdGhlIG1pZC5cblx0XHQgKiAgQHBhcmFtIHtEZWNpYmVsc30gW2hpZ2hMZXZlbF0gVGhlIGdhaW4gYXBwbGllZCB0byB0aGUgaGlnaC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgZXEgPSBuZXcgVG9uZS5FUTMoLTEwLCAzLCAtMjApO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FUTMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnbG93Jyxcblx0ICAgICAgICAgICAgJ21pZCcsXG5cdCAgICAgICAgICAgICdoaWdoJ1xuXHQgICAgICAgIF0sIFRvbmUuRVEzKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBvdXRwdXQgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG11bHRpYmFuZCBzcGxpdFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk11bHRpYmFuZFNwbGl0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tdWx0aWJhbmRTcGxpdCA9IHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5NdWx0aWJhbmRTcGxpdCh7XG5cdCAgICAgICAgICAgICdsb3dGcmVxdWVuY3knOiBvcHRpb25zLmxvd0ZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ2hpZ2hGcmVxdWVuY3knOiBvcHRpb25zLmhpZ2hGcmVxdWVuY3lcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZ2FpbiBmb3IgdGhlIGxvd2VyIHNpZ25hbHNcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbG93R2FpbiA9IG5ldyBUb25lLkdhaW4ob3B0aW9ucy5sb3csIFRvbmUuVHlwZS5EZWNpYmVscyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGdhaW4gZm9yIHRoZSBtaWQgc2lnbmFsc1xuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9taWRHYWluID0gbmV3IFRvbmUuR2FpbihvcHRpb25zLm1pZCwgVG9uZS5UeXBlLkRlY2liZWxzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBnYWluIGluIGRlY2liZWxzIG9mIHRoZSBoaWdoIHBhcnRcblx0XHRcdCAqIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faGlnaEdhaW4gPSBuZXcgVG9uZS5HYWluKG9wdGlvbnMuaGlnaCwgVG9uZS5UeXBlLkRlY2liZWxzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBnYWluIGluIGRlY2liZWxzIG9mIHRoZSBsb3cgcGFydFxuXHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5sb3cgPSB0aGlzLl9sb3dHYWluLmdhaW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgZ2FpbiBpbiBkZWNpYmVscyBvZiB0aGUgbWlkIHBhcnRcblx0XHRcdCAqIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWlkID0gdGhpcy5fbWlkR2Fpbi5nYWluO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGdhaW4gaW4gZGVjaWJlbHMgb2YgdGhlIGhpZ2ggcGFydFxuXHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oaWdoID0gdGhpcy5faGlnaEdhaW4uZ2Fpbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgUSB2YWx1ZSBmb3IgYWxsIG9mIHRoZSBmaWx0ZXJzLlxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLlEgPSB0aGlzLl9tdWx0aWJhbmRTcGxpdC5RO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBsb3cvbWlkIGNyb3Nzb3ZlciBmcmVxdWVuY3kuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmxvd0ZyZXF1ZW5jeSA9IHRoaXMuX211bHRpYmFuZFNwbGl0Lmxvd0ZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWlkL2hpZ2ggY3Jvc3NvdmVyIGZyZXF1ZW5jeS5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGlnaEZyZXF1ZW5jeSA9IHRoaXMuX211bHRpYmFuZFNwbGl0LmhpZ2hGcmVxdWVuY3k7XG5cdCAgICAgICAgLy90aGUgZnJlcXVlbmN5IGJhbmRzXG5cdCAgICAgICAgdGhpcy5fbXVsdGliYW5kU3BsaXQubG93LmNoYWluKHRoaXMuX2xvd0dhaW4sIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9tdWx0aWJhbmRTcGxpdC5taWQuY2hhaW4odGhpcy5fbWlkR2FpbiwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX211bHRpYmFuZFNwbGl0LmhpZ2guY2hhaW4odGhpcy5faGlnaEdhaW4sIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdsb3cnLFxuXHQgICAgICAgICAgICAnbWlkJyxcblx0ICAgICAgICAgICAgJ2hpZ2gnLFxuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2hpZ2hGcmVxdWVuY3knXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5FUTMsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRVEzLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdsb3cnOiAwLFxuXHQgICAgICAgICdtaWQnOiAwLFxuXHQgICAgICAgICdoaWdoJzogMCxcblx0ICAgICAgICAnbG93RnJlcXVlbmN5JzogNDAwLFxuXHQgICAgICAgICdoaWdoRnJlcXVlbmN5JzogMjUwMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FUTN9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRVEzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnbG93Jyxcblx0ICAgICAgICAgICAgJ21pZCcsXG5cdCAgICAgICAgICAgICdoaWdoJyxcblx0ICAgICAgICAgICAgJ2xvd0ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdoaWdoRnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuX211bHRpYmFuZFNwbGl0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tdWx0aWJhbmRTcGxpdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGlnaEZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbG93R2Fpbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbG93R2FpbiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbWlkR2Fpbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbWlkR2FpbiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5faGlnaEdhaW4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2hpZ2hHYWluID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmxvdyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5taWQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGlnaCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5RID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5FUTM7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgUGVyZm9ybXMgYSBsaW5lYXIgc2NhbGluZyBvbiBhbiBpbnB1dCBzaWduYWwuXG5cdFx0ICogICAgICAgICAgU2NhbGVzIGEgTm9ybWFsUmFuZ2UgaW5wdXQgdG8gYmV0d2VlblxuXHRcdCAqICAgICAgICAgIG91dHB1dE1pbiBhbmQgb3V0cHV0TWF4LlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW291dHB1dE1pbj0wXSBUaGUgb3V0cHV0IHZhbHVlIHdoZW4gdGhlIGlucHV0IGlzIDAuIFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW291dHB1dE1heD0xXVx0VGhlIG91dHB1dCB2YWx1ZSB3aGVuIHRoZSBpbnB1dCBpcyAxLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc2NhbGUgPSBuZXcgVG9uZS5TY2FsZSg1MCwgMTAwKTtcblx0XHQgKiB2YXIgc2lnbmFsID0gbmV3IFRvbmUuU2lnbmFsKDAuNSkuY29ubmVjdChzY2FsZSk7XG5cdFx0ICogLy90aGUgb3V0cHV0IG9mIHNjYWxlIGVxdWFscyA3NVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TY2FsZSA9IGZ1bmN0aW9uIChvdXRwdXRNaW4sIG91dHB1dE1heCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vdXRwdXRNaW4gPSBUb25lLmRlZmF1bHRBcmcob3V0cHV0TWluLCAwKTtcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb3V0cHV0TWF4ID0gVG9uZS5kZWZhdWx0QXJnKG91dHB1dE1heCwgMSk7XG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTXVsdGlwbHl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NjYWxlID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLk11bHRpcGx5KDEpO1xuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkFkZH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYWRkID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5BZGQoMCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUuY29ubmVjdCh0aGlzLl9hZGQpO1xuXHQgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TY2FsZSwgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBtaW5pbXVtIG91dHB1dCB2YWx1ZS4gVGhpcyBudW1iZXIgaXMgb3V0cHV0IHdoZW4gXG5cdFx0ICogdGhlIHZhbHVlIGlucHV0IHZhbHVlIGlzIDAuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlNjYWxlI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgbWluXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5TY2FsZS5wcm90b3R5cGUsICdtaW4nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdXRwdXRNaW47XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtaW4pIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3V0cHV0TWluID0gbWluO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRSYW5nZSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1heGltdW0gb3V0cHV0IHZhbHVlLiBUaGlzIG51bWJlciBpcyBvdXRwdXQgd2hlbiBcblx0XHQgKiB0aGUgdmFsdWUgaW5wdXQgdmFsdWUgaXMgMS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGUjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtYXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNjYWxlLnByb3RvdHlwZSwgJ21heCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX291dHB1dE1heDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1heCkge1xuXHQgICAgICAgICAgICB0aGlzLl9vdXRwdXRNYXggPSBtYXg7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgc2V0IHRoZSB2YWx1ZXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuU2NhbGUucHJvdG90eXBlLl9zZXRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9hZGQudmFsdWUgPSB0aGlzLl9vdXRwdXRNaW47XG5cdCAgICAgICAgdGhpcy5fc2NhbGUudmFsdWUgPSB0aGlzLl9vdXRwdXRNYXggLSB0aGlzLl9vdXRwdXRNaW47XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TY2FsZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TY2FsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9hZGQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2FkZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TY2FsZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgUGVyZm9ybXMgYW4gZXhwb25lbnRpYWwgc2NhbGluZyBvbiBhbiBpbnB1dCBzaWduYWwuXG5cdFx0ICogICAgICAgICAgU2NhbGVzIGEgTm9ybWFsUmFuZ2UgdmFsdWUgWzAsMV0gZXhwb25lbnRpYWxseVxuXHRcdCAqICAgICAgICAgIHRvIHRoZSBvdXRwdXQgcmFuZ2Ugb2Ygb3V0cHV0TWluIHRvIG91dHB1dE1heC5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtvdXRwdXRNaW49MF0gVGhlIG91dHB1dCB2YWx1ZSB3aGVuIHRoZSBpbnB1dCBpcyAwLiBcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtvdXRwdXRNYXg9MV1cdFRoZSBvdXRwdXQgdmFsdWUgd2hlbiB0aGUgaW5wdXQgaXMgMS4gXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbZXhwb25lbnQ9Ml0gVGhlIGV4cG9uZW50IHdoaWNoIHNjYWxlcyB0aGUgaW5jb21pbmcgc2lnbmFsLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzY2FsZUV4cCA9IG5ldyBUb25lLlNjYWxlRXhwKDAsIDEwMCwgMik7XG5cdFx0ICogdmFyIHNpZ25hbCA9IG5ldyBUb25lLlNpZ25hbCgwLjUpLmNvbm5lY3Qoc2NhbGVFeHApO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TY2FsZUV4cCA9IGZ1bmN0aW9uIChvdXRwdXRNaW4sIG91dHB1dE1heCwgZXhwb25lbnQpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzY2FsZSB0aGUgaW5wdXQgdG8gdGhlIG91dHB1dCByYW5nZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlNjYWxlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuU2NhbGUob3V0cHV0TWluLCBvdXRwdXRNYXgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuUG93fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9leHAgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuUG93KFRvbmUuZGVmYXVsdEFyZyhleHBvbmVudCwgMikpO1xuXHQgICAgICAgIHRoaXMuX2V4cC5jb25uZWN0KHRoaXMuX3NjYWxlKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlNjYWxlRXhwLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogSW5zdGVhZCBvZiBpbnRlcnBvbGF0aW5nIGxpbmVhcmx5IGJldHdlZW4gdGhlIDxjb2RlPm1pbjwvY29kZT4gYW5kIFxuXHRcdCAqIDxjb2RlPm1heDwvY29kZT4gdmFsdWVzLCBzZXR0aW5nIHRoZSBleHBvbmVudCB3aWxsIGludGVycG9sYXRlIGJldHdlZW5cblx0XHQgKiB0aGUgdHdvIHZhbHVlcyB3aXRoIGFuIGV4cG9uZW50aWFsIGN1cnZlLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5TY2FsZUV4cCNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIGV4cG9uZW50XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5TY2FsZUV4cC5wcm90b3R5cGUsICdleHBvbmVudCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cC52YWx1ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGV4cCkge1xuXHQgICAgICAgICAgICB0aGlzLl9leHAudmFsdWUgPSBleHA7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWluaW11bSBvdXRwdXQgdmFsdWUuIFRoaXMgbnVtYmVyIGlzIG91dHB1dCB3aGVuIFxuXHRcdCAqIHRoZSB2YWx1ZSBpbnB1dCB2YWx1ZSBpcyAwLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5TY2FsZUV4cCNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIG1pblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2NhbGVFeHAucHJvdG90eXBlLCAnbWluJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGUubWluO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWluKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlLm1pbiA9IG1pbjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIG91dHB1dCB2YWx1ZS4gVGhpcyBudW1iZXIgaXMgb3V0cHV0IHdoZW4gXG5cdFx0ICogdGhlIHZhbHVlIGlucHV0IHZhbHVlIGlzIDEuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlNjYWxlRXhwI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgbWF4XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5TY2FsZUV4cC5wcm90b3R5cGUsICdtYXgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2FsZS5tYXg7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtYXgpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2NhbGUubWF4ID0gbWF4O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TY2FsZUV4cH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TY2FsZUV4cC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2V4cC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZXhwID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TY2FsZUV4cDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgY3JlYXRlRGVsYXkgc2hpbVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgaWYgKHdpbmRvdy5EZWxheU5vZGUgJiYgIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXkpIHtcblx0ICAgICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5ID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheU5vZGU7XG5cdCAgICB9XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFdyYXBwZXIgYXJvdW5kIFdlYiBBdWRpbydzIG5hdGl2ZSBbRGVsYXlOb2RlXShodHRwOi8vd2ViYXVkaW8uZ2l0aHViLmlvL3dlYi1hdWRpby1hcGkvI3RoZS1kZWxheW5vZGUtaW50ZXJmYWNlKS5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSB7VGltZT19IGRlbGF5VGltZSBUaGUgZGVsYXkgYXBwbGllZCB0byB0aGUgaW5jb21pbmcgc2lnbmFsLlxuXHRcdCAqICBAcGFyYW0ge1RpbWU9fSBtYXhEZWxheSBUaGUgbWF4aW11bSBkZWxheSB0aW1lLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5EZWxheSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnLFxuXHQgICAgICAgICAgICAnbWF4RGVsYXknXG5cdCAgICAgICAgXSwgVG9uZS5EZWxheSk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbmF0aXZlIGRlbGF5IG5vZGVcblx0XHRcdCAqICBAdHlwZSB7RGVsYXlOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGUgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlRGVsYXkodGhpcy50b1NlY29uZHMob3B0aW9ucy5tYXhEZWxheSkpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2YgdGltZSB0aGUgaW5jb21pbmcgc2lnbmFsIGlzXG5cdFx0XHQgKiAgZGVsYXllZC5cblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IG5ldyBUb25lLlBhcmFtKHtcblx0ICAgICAgICAgICAgJ3BhcmFtJzogdGhpcy5fZGVsYXlOb2RlLmRlbGF5VGltZSxcblx0ICAgICAgICAgICAgJ3VuaXRzJzogVG9uZS5UeXBlLlRpbWUsXG5cdCAgICAgICAgICAgICd2YWx1ZSc6IG9wdGlvbnMuZGVsYXlUaW1lXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ2RlbGF5VGltZScpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRGVsYXksIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5EZWxheS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnbWF4RGVsYXknOiAxLFxuXHQgICAgICAgICdkZWxheVRpbWUnOiAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5EZWxheX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRGVsYXkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGUuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Tm9kZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ2RlbGF5VGltZScpO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5EZWxheTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIENvbWIgZmlsdGVycyBhcmUgYmFzaWMgYnVpbGRpbmcgYmxvY2tzIGZvciBwaHlzaWNhbCBtb2RlbGluZy4gUmVhZCBtb3JlXG5cdFx0ICogICAgICAgICBhYm91dCBjb21iIGZpbHRlcnMgb24gW0NDUk1BJ3Mgd2Vic2l0ZV0oaHR0cHM6Ly9jY3JtYS5zdGFuZm9yZC5lZHUvfmpvcy9wYXNwL0ZlZWRiYWNrX0NvbWJfRmlsdGVycy5odG1sKS5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge1RpbWV8T2JqZWN0fSBbZGVsYXlUaW1lXSBUaGUgZGVsYXkgdGltZSBvZiB0aGUgZmlsdGVyLlxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlPX0gcmVzb25hbmNlIFRoZSBhbW91bnQgb2YgZmVlZGJhY2sgdGhlIGZpbHRlciBoYXMuXG5cdFx0ICovXG5cdCAgICBUb25lLkZlZWRiYWNrQ29tYkZpbHRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnLFxuXHQgICAgICAgICAgICAncmVzb25hbmNlJ1xuXHQgICAgICAgIF0sIFRvbmUuRmVlZGJhY2tDb21iRmlsdGVyKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZWxheSBub2RlXG5cdFx0XHQgKiAgQHR5cGUge0RlbGF5Tm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXkgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5EZWxheShvcHRpb25zLmRlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBkZWxheSBvZiB0aGUgY29tYiBmaWx0ZXIuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUgPSB0aGlzLl9kZWxheS5kZWxheVRpbWU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGZlZWRiYWNrIG5vZGVcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrID0gbmV3IFRvbmUuR2FpbihvcHRpb25zLnJlc29uYW5jZSwgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIGZlZWRiYWNrIG9mIHRoZSBkZWxheWVkIHNpZ25hbC5cblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5yZXNvbmFuY2UgPSB0aGlzLl9mZWVkYmFjay5nYWluO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5LmNoYWluKHRoaXMuX2ZlZWRiYWNrLCB0aGlzLl9kZWxheSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAncmVzb25hbmNlJyxcblx0ICAgICAgICAgICAgJ2RlbGF5VGltZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZlZWRiYWNrQ29tYkZpbHRlciwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRmVlZGJhY2tDb21iRmlsdGVyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdkZWxheVRpbWUnOiAwLjEsXG5cdCAgICAgICAgJ3Jlc29uYW5jZSc6IDAuNVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5GZWVkYmFja0NvbWJGaWx0ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRmVlZGJhY2tDb21iRmlsdGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAncmVzb25hbmNlJyxcblx0ICAgICAgICAgICAgJ2RlbGF5VGltZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLl9kZWxheS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFjay5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHRoaXMucmVzb25hbmNlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5Gb2xsb3dlciBpcyBhICBjcnVkZSBlbnZlbG9wZSBmb2xsb3dlciB3aGljaCB3aWxsIGZvbGxvd1xuXHRcdCAqICAgICAgICAgIHRoZSBhbXBsaXR1ZGUgb2YgYW4gaW5jb21pbmcgc2lnbmFsLlxuXHRcdCAqICAgICAgICAgIFRha2UgY2FyZSB3aXRoIHNtYWxsICg8IDAuMDIpIGF0dGFjayBvciBkZWNheSB2YWx1ZXNcblx0XHQgKiAgICAgICAgICBhcyBmb2xsb3dlciBoYXMgc29tZSByaXBwbGUgd2hpY2ggaXMgZXhhZ2dlcmF0ZWRcblx0XHQgKiAgICAgICAgICBhdCB0aGVzZSB2YWx1ZXMuIFJlYWQgbW9yZSBhYm91dCBlbnZlbG9wZSBmb2xsb3dlcnMgKGFsc28ga25vd25cblx0XHQgKiAgICAgICAgICBhcyBlbnZlbG9wZSBkZXRlY3RvcnMpIG9uIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VudmVsb3BlX2RldGVjdG9yKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge1RpbWV8T2JqZWN0fSBbYXR0YWNrXSBUaGUgcmF0ZSBhdCB3aGljaCB0aGUgZm9sbG93ZXIgcmlzZXMuXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IHJlbGVhc2UgVGhlIHJhdGUgYXQgd2hpY2ggdGhlIGZvbG93ZXIgZmFsbHMuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGZvbGxvd2VyID0gbmV3IFRvbmUuRm9sbG93ZXIoMC4yLCAwLjQpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Gb2xsb3dlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdhdHRhY2snLFxuXHQgICAgICAgICAgICAncmVsZWFzZSdcblx0ICAgICAgICBdLCBUb25lLkZvbGxvd2VyKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygxLCAxKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BYnN9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FicyA9IG5ldyBUb25lLkFicygpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBsb3dwYXNzIGZpbHRlciB3aGljaCBzbW9vdGhzIHRoZSBpbnB1dFxuXHRcdFx0ICogIEB0eXBlIHtCaXF1YWRGaWx0ZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9maWx0ZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyLnR5cGUgPSAnbG93cGFzcyc7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyLmZyZXF1ZW5jeS52YWx1ZSA9IDA7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyLlEudmFsdWUgPSAtMTAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtXYXZlU2hhcGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZnJlcXVlbmN5VmFsdWVzID0gbmV3IFRvbmUuV2F2ZVNoYXBlcigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN1YnRyYWN0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdWIgPSBuZXcgVG9uZS5TdWJ0cmFjdCgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkRlbGF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheSA9IG5ldyBUb25lLkRlbGF5KHRoaXMuYmxvY2tUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGlzIGtlZXBzIGl0IGZhciBmcm9tIDAsIGV2ZW4gZm9yIHZlcnkgc21hbGwgZGlmZmVyZW5jZXNcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NdWx0aXBseX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbXVsdCA9IG5ldyBUb25lLk11bHRpcGx5KDEwMDAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hdHRhY2sgPSBvcHRpb25zLmF0dGFjaztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9yZWxlYXNlID0gb3B0aW9ucy5yZWxlYXNlO1xuXHQgICAgICAgIC8vdGhlIHNtb290aGVkIHNpZ25hbCB0byBnZXQgdGhlIHZhbHVlc1xuXHQgICAgICAgIHRoaXMuaW5wdXQuY2hhaW4odGhpcy5fYWJzLCB0aGlzLl9maWx0ZXIsIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICAvL3RoZSBkaWZmZXJlbmNlIHBhdGhcblx0ICAgICAgICB0aGlzLl9hYnMuY29ubmVjdCh0aGlzLl9zdWIsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlci5jaGFpbih0aGlzLl9kZWxheSwgdGhpcy5fc3ViKTtcblx0ICAgICAgICAvL3RocmVzaG9sZCB0aGUgZGlmZmVyZW5jZSBhbmQgdXNlIHRoZSB0aHJlc2ggdG8gc2V0IHRoZSBmcmVxdWVuY3lcblx0ICAgICAgICB0aGlzLl9zdWIuY2hhaW4odGhpcy5fbXVsdCwgdGhpcy5fZnJlcXVlbmN5VmFsdWVzLCB0aGlzLl9maWx0ZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICAvL3NldCB0aGUgYXR0YWNrIGFuZCByZWxlYXNlIHZhbHVlcyBpbiB0aGUgdGFibGVcblx0ICAgICAgICB0aGlzLl9zZXRBdHRhY2tSZWxlYXNlKHRoaXMuX2F0dGFjaywgdGhpcy5fcmVsZWFzZSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Gb2xsb3dlciwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRm9sbG93ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2F0dGFjayc6IDAuMDUsXG5cdCAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc2V0cyB0aGUgYXR0YWNrIGFuZCByZWxlYXNlIHRpbWVzIGluIHRoZSB3YXZlIHNoYXBlclxuXHRcdCAqICBAcGFyYW0gICB7VGltZX0gYXR0YWNrXG5cdFx0ICogIEBwYXJhbSAgIHtUaW1lfSByZWxlYXNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZvbGxvd2VyLnByb3RvdHlwZS5fc2V0QXR0YWNrUmVsZWFzZSA9IGZ1bmN0aW9uIChhdHRhY2ssIHJlbGVhc2UpIHtcblx0ICAgICAgICB2YXIgbWluVGltZSA9IHRoaXMuYmxvY2tUaW1lO1xuXHQgICAgICAgIGF0dGFjayA9IFRvbmUuVGltZShhdHRhY2spLnRvRnJlcXVlbmN5KCk7XG5cdCAgICAgICAgcmVsZWFzZSA9IFRvbmUuVGltZShyZWxlYXNlKS50b0ZyZXF1ZW5jeSgpO1xuXHQgICAgICAgIGF0dGFjayA9IE1hdGgubWF4KGF0dGFjaywgbWluVGltZSk7XG5cdCAgICAgICAgcmVsZWFzZSA9IE1hdGgubWF4KHJlbGVhc2UsIG1pblRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2ZyZXF1ZW5jeVZhbHVlcy5zZXRNYXAoZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICBpZiAodmFsIDw9IDApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhdHRhY2s7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVsZWFzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBhdHRhY2sgdGltZS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Gb2xsb3dlciNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBhdHRhY2tcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZvbGxvd2VyLnByb3RvdHlwZSwgJ2F0dGFjaycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFjaztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGF0dGFjaykge1xuXHQgICAgICAgICAgICB0aGlzLl9hdHRhY2sgPSBhdHRhY2s7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldEF0dGFja1JlbGVhc2UodGhpcy5fYXR0YWNrLCB0aGlzLl9yZWxlYXNlKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSByZWxlYXNlIHRpbWUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRm9sbG93ZXIjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgcmVsZWFzZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRm9sbG93ZXIucHJvdG90eXBlLCAncmVsZWFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbGVhc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyZWxlYXNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlbGVhc2UgPSByZWxlYXNlO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRBdHRhY2tSZWxlYXNlKHRoaXMuX2F0dGFjaywgdGhpcy5fcmVsZWFzZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQm9ycm93cyB0aGUgY29ubmVjdCBtZXRob2QgZnJvbSBTaWduYWwgc28gdGhhdCB0aGUgb3V0cHV0IGNhbiBiZSB1c2VkXG5cdFx0ICogIGFzIGEgVG9uZS5TaWduYWwgY29udHJvbCBzaWduYWwuXG5cdFx0ICogIEBmdW5jdGlvblxuXHRcdCAqL1xuXHQgICAgVG9uZS5Gb2xsb3dlci5wcm90b3R5cGUuY29ubmVjdCA9IFRvbmUuU2lnbmFsLnByb3RvdHlwZS5jb25uZWN0O1xuXHQgICAgLyoqXG5cdFx0ICogIGRpc3Bvc2Vcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRm9sbG93ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRm9sbG93ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9maWx0ZXIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZnJlcXVlbmN5VmFsdWVzLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9mcmVxdWVuY3lWYWx1ZXMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3ViLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9zdWIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2Ficy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYWJzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tdWx0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tdWx0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9jdXJ2ZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRm9sbG93ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlNjYWxlZEVudmVsb3AgaXMgYW4gZW52ZWxvcGUgd2hpY2ggY2FuIGJlIHNjYWxlZCBcblx0XHQgKiAgICAgICAgIHRvIGFueSByYW5nZS4gSXQncyB1c2VmdWwgZm9yIGFwcGx5aW5nIGFuIGVudmVsb3BlIFxuXHRcdCAqICAgICAgICAgdG8gYSBmcmVxdWVuY3kgb3IgYW55IG90aGVyIG5vbi1Ob3JtYWxSYW5nZSBzaWduYWwgXG5cdFx0ICogICAgICAgICBwYXJhbWV0ZXIuIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVudmVsb3BlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2F0dGFja11cdHRoZSBhdHRhY2sgdGltZSBpbiBzZWNvbmRzXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW2RlY2F5XVx0dGhlIGRlY2F5IHRpbWUgaW4gc2Vjb25kc1xuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3N1c3RhaW5dIFx0YSBwZXJjZW50YWdlICgwLTEpIG9mIHRoZSBmdWxsIGFtcGxpdHVkZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFtyZWxlYXNlXVx0dGhlIHJlbGVhc2UgdGltZSBpbiBzZWNvbmRzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIHZhciBzY2FsZWRFbnYgPSBuZXcgVG9uZS5TY2FsZWRFbnZlbG9wZSh7XG5cdFx0ICogIFx0XCJhdHRhY2tcIiA6IDAuMixcblx0XHQgKiAgXHRcIm1pblwiIDogMjAwLFxuXHRcdCAqICBcdFwibWF4XCIgOiAyMDAwXG5cdFx0ICogIH0pO1xuXHRcdCAqICBzY2FsZWRFbnYuY29ubmVjdChvc2NpbGxhdG9yLmZyZXF1ZW5jeSk7XG5cdFx0ICovXG5cdCAgICBUb25lLlNjYWxlZEVudmVsb3BlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vZ2V0IGFsbCBvZiB0aGUgZGVmYXVsdHNcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdhdHRhY2snLFxuXHQgICAgICAgICAgICAnZGVjYXknLFxuXHQgICAgICAgICAgICAnc3VzdGFpbicsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJ1xuXHQgICAgICAgIF0sIFRvbmUuRW52ZWxvcGUpO1xuXHQgICAgICAgIFRvbmUuRW52ZWxvcGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuU2NhbGVkRW52ZWxvcGUuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBzY2FsZSB0aGUgaW5jb21pbmcgc2lnbmFsIGJ5IGFuIGV4cG9uZW50XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuUG93fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9leHAgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlBvdyhvcHRpb25zLmV4cG9uZW50KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzY2FsZSB0aGUgc2lnbmFsIHRvIHRoZSBkZXNpcmVkIHJhbmdlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTXVsdGlwbHl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NjYWxlID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5TY2FsZShvcHRpb25zLm1pbiwgb3B0aW9ucy5tYXgpO1xuXHQgICAgICAgIHRoaXMuX3NpZy5jaGFpbih0aGlzLl9leHAsIHRoaXMuX3NjYWxlKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlNjYWxlZEVudmVsb3BlLCBUb25lLkVudmVsb3BlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2NhbGVkRW52ZWxvcGUuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgJ21heCc6IDEsXG5cdCAgICAgICAgJ2V4cG9uZW50JzogMVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBlbnZlbG9wZSdzIG1pbiBvdXRwdXQgdmFsdWUuIFRoaXMgaXMgdGhlIHZhbHVlIHdoaWNoIGl0XG5cdFx0ICogc3RhcnRzIGF0LiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5TY2FsZWRFbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIG1pblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2NhbGVkRW52ZWxvcGUucHJvdG90eXBlLCAnbWluJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGUubWluO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWluKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlLm1pbiA9IG1pbjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBlbnZlbG9wZSdzIG1heCBvdXRwdXQgdmFsdWUuIEluIG90aGVyIHdvcmRzLCB0aGUgdmFsdWVcblx0XHQgKiBhdCB0aGUgcGVhayBvZiB0aGUgYXR0YWNrIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5TY2FsZWRFbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIG1heFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2NhbGVkRW52ZWxvcGUucHJvdG90eXBlLCAnbWF4Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGUubWF4O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWF4KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlLm1heCA9IG1heDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBlbnZlbG9wZSdzIGV4cG9uZW50IHZhbHVlLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5TY2FsZWRFbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIGV4cG9uZW50XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5TY2FsZWRFbnZlbG9wZS5wcm90b3R5cGUsICdleHBvbmVudCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cC52YWx1ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGV4cCkge1xuXHQgICAgICAgICAgICB0aGlzLl9leHAudmFsdWUgPSBleHA7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU2NhbGVkRW52ZWxvcGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2NhbGVkRW52ZWxvcGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZXhwLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9leHAgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNjYWxlZEVudmVsb3BlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5GcmVxdWVuY3lFbnZlbG9wZSBpcyBhIFRvbmUuU2NhbGVkRW52ZWxvcGUsIGJ1dCBpbnN0ZWFkIG9mIGBtaW5gIGFuZCBgbWF4YFxuXHRcdCAqICAgICAgICAgaXQncyBnb3QgYSBgYmFzZUZyZXF1ZW5jeWAgYW5kIGBvY3RhdmVzYCBwYXJhbWV0ZXIuIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVudmVsb3BlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2F0dGFja11cdHRoZSBhdHRhY2sgdGltZSBpbiBzZWNvbmRzXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW2RlY2F5XVx0dGhlIGRlY2F5IHRpbWUgaW4gc2Vjb25kc1xuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3N1c3RhaW5dIFx0YSBwZXJjZW50YWdlICgwLTEpIG9mIHRoZSBmdWxsIGFtcGxpdHVkZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFtyZWxlYXNlXVx0dGhlIHJlbGVhc2UgdGltZSBpbiBzZWNvbmRzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIHZhciBlbnYgPSBuZXcgVG9uZS5GcmVxdWVuY3lFbnZlbG9wZSh7XG5cdFx0ICogIFx0XCJhdHRhY2tcIiA6IDAuMixcblx0XHQgKiAgXHRcImJhc2VGcmVxdWVuY3lcIiA6IFwiQzJcIixcblx0XHQgKiAgXHRcIm9jdGF2ZXNcIiA6IDRcblx0XHQgKiAgfSk7XG5cdFx0ICogIHNjYWxlZEVudi5jb25uZWN0KG9zY2lsbGF0b3IuZnJlcXVlbmN5KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnYXR0YWNrJyxcblx0ICAgICAgICAgICAgJ2RlY2F5Jyxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nLFxuXHQgICAgICAgICAgICAncmVsZWFzZSdcblx0ICAgICAgICBdLCBUb25lLkVudmVsb3BlKTtcblx0ICAgICAgICBUb25lLlNjYWxlZEVudmVsb3BlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLy9tZXJnZSBpdCB3aXRoIHRoZSBmcmVxdWVuY3kgZW52ZWxvcGUgZGVmYXVsdHNcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFN0b3JlcyB0aGUgb2N0YXZlIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vY3RhdmVzID0gb3B0aW9ucy5vY3RhdmVzO1xuXHQgICAgICAgIC8vc2V0dXBcblx0ICAgICAgICB0aGlzLmJhc2VGcmVxdWVuY3kgPSBvcHRpb25zLmJhc2VGcmVxdWVuY3k7XG5cdCAgICAgICAgdGhpcy5vY3RhdmVzID0gb3B0aW9ucy5vY3RhdmVzO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUsIFRvbmUuRW52ZWxvcGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3lFbnZlbG9wZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnYmFzZUZyZXF1ZW5jeSc6IDIwMCxcblx0ICAgICAgICAnb2N0YXZlcyc6IDQsXG5cdCAgICAgICAgJ2V4cG9uZW50JzogMlxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBlbnZlbG9wZSdzIG1pbmludW0gb3V0cHV0IHZhbHVlLiBUaGlzIGlzIHRoZSB2YWx1ZSB3aGljaCBpdFxuXHRcdCAqIHN0YXJ0cyBhdC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHQgKiBAbmFtZSBiYXNlRnJlcXVlbmN5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GcmVxdWVuY3lFbnZlbG9wZS5wcm90b3R5cGUsICdiYXNlRnJlcXVlbmN5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGUubWluO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWluKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlLm1pbiA9IHRoaXMudG9GcmVxdWVuY3kobWluKTtcblx0ICAgICAgICAgICAgLy9hbHNvIHVwZGF0ZSB0aGUgb2N0YXZlc1xuXHQgICAgICAgICAgICB0aGlzLm9jdGF2ZXMgPSB0aGlzLl9vY3RhdmVzO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBvY3RhdmVzIGFib3ZlIHRoZSBiYXNlRnJlcXVlbmN5IHRoYXQgdGhlXG5cdFx0ICogZW52ZWxvcGUgd2lsbCBzY2FsZSB0by5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GcmVxdWVuY3lFbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogQG5hbWUgb2N0YXZlc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUucHJvdG90eXBlLCAnb2N0YXZlcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvY3RhdmVzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29jdGF2ZXMgPSBvY3RhdmVzO1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZS5tYXggPSB0aGlzLmJhc2VGcmVxdWVuY3kgKiBNYXRoLnBvdygyLCBvY3RhdmVzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBlbnZlbG9wZSdzIGV4cG9uZW50IHZhbHVlLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GcmVxdWVuY3lFbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIGV4cG9uZW50XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GcmVxdWVuY3lFbnZlbG9wZS5wcm90b3R5cGUsICdleHBvbmVudCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cC52YWx1ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGV4cCkge1xuXHQgICAgICAgICAgICB0aGlzLl9leHAudmFsdWUgPSBleHA7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRnJlcXVlbmN5RW52ZWxvcGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TY2FsZWRFbnZlbG9wZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZyZXF1ZW5jeUVudmVsb3BlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuR2F0ZSBvbmx5IHBhc3NlcyBhIHNpZ25hbCB0aHJvdWdoIHdoZW4gdGhlIGluY29taW5nXG5cdFx0ICogICAgICAgICAgc2lnbmFsIGV4Y2VlZHMgYSBzcGVjaWZpZWQgdGhyZXNob2xkLiBUbyBkbyB0aGlzLCBHYXRlIHVzZXNcblx0XHQgKiAgICAgICAgICBhIFRvbmUuRm9sbG93ZXIgdG8gZm9sbG93IHRoZSBhbXBsaXR1ZGUgb2YgdGhlIGluY29taW5nIHNpZ25hbC5cblx0XHQgKiAgICAgICAgICBBIGNvbW1vbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGNsYXNzIGlzIGEgW05vaXNlIEdhdGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05vaXNlX2dhdGUpLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSB7RGVjaWJlbHN8T2JqZWN0fSBbdGhyZXNob2xkXSBUaGUgdGhyZXNob2xkIGFib3ZlIHdoaWNoIHRoZSBnYXRlIHdpbGwgb3Blbi5cblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gYXR0YWNrIFRoZSBmb2xsb3dlcidzIGF0dGFjayB0aW1lXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IHJlbGVhc2UgVGhlIGZvbGxvd2VyJ3MgcmVsZWFzZSB0aW1lXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGdhdGUgPSBuZXcgVG9uZS5HYXRlKC0zMCwgMC4yLCAwLjMpLnRvTWFzdGVyKCk7XG5cdFx0ICogdmFyIG1pYyA9IG5ldyBUb25lLlVzZXJNZWRpYSgpLmNvbm5lY3QoZ2F0ZSk7XG5cdFx0ICogLy90aGUgZ2F0ZSB3aWxsIG9ubHkgcGFzcyB0aHJvdWdoIHRoZSBpbmNvbWluZ1xuXHRcdCAqIC8vc2lnbmFsIHdoZW4gaXQncyBsb3VkZXIgdGhhbiAtMzBkYlxuXHRcdCAqL1xuXHQgICAgVG9uZS5HYXRlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3RocmVzaG9sZCcsXG5cdCAgICAgICAgICAgICdhdHRhY2snLFxuXHQgICAgICAgICAgICAncmVsZWFzZSdcblx0ICAgICAgICBdLCBUb25lLkdhdGUpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDEsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZvbGxvd2VyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mb2xsb3dlciA9IG5ldyBUb25lLkZvbGxvd2VyKG9wdGlvbnMuYXR0YWNrLCBvcHRpb25zLnJlbGVhc2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdyZWF0ZXJUaGFufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ndCA9IG5ldyBUb25lLkdyZWF0ZXJUaGFuKFRvbmUuZGJUb0dhaW4ob3B0aW9ucy50aHJlc2hvbGQpKTtcblx0ICAgICAgICAvL3RoZSBjb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgLy90aGUgY29udHJvbCBzaWduYWxcblx0ICAgICAgICB0aGlzLmlucHV0LmNoYWluKHRoaXMuX2d0LCB0aGlzLl9mb2xsb3dlciwgdGhpcy5vdXRwdXQuZ2Fpbik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5HYXRlLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuR2F0ZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnYXR0YWNrJzogMC4xLFxuXHQgICAgICAgICdyZWxlYXNlJzogMC4xLFxuXHQgICAgICAgICd0aHJlc2hvbGQnOiAtNDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdGhyZXNob2xkIG9mIHRoZSBnYXRlIGluIGRlY2liZWxzXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuR2F0ZSNcblx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0ICogQG5hbWUgdGhyZXNob2xkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HYXRlLnByb3RvdHlwZSwgJ3RocmVzaG9sZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuZ2FpblRvRGIodGhpcy5fZ3QudmFsdWUpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhyZXNoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2d0LnZhbHVlID0gVG9uZS5kYlRvR2Fpbih0aHJlc2gpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGF0dGFjayBzcGVlZCBvZiB0aGUgZ2F0ZVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkdhdGUjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgYXR0YWNrXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HYXRlLnByb3RvdHlwZSwgJ2F0dGFjaycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbGxvd2VyLmF0dGFjaztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGF0dGFja1RpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZm9sbG93ZXIuYXR0YWNrID0gYXR0YWNrVGltZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSByZWxlYXNlIHNwZWVkIG9mIHRoZSBnYXRlXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuR2F0ZSNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSByZWxlYXNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HYXRlLnByb3RvdHlwZSwgJ3JlbGVhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb2xsb3dlci5yZWxlYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmVsZWFzZVRpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZm9sbG93ZXIucmVsZWFzZSA9IHJlbGVhc2VUaW1lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5HYXRlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkdhdGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9mb2xsb3dlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZ3QuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZvbGxvd2VyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9ndCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuR2F0ZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogQGNsYXNzIFRvbmUuVGlja1NpZ25hbCBleHRlbmRzIFRvbmUuVGltZWxpbmVTaWduYWwsIGJ1dCBhZGRzIHRoZSBjYXBhYmlsaXR5XG5cdFx0ICogICAgICAgIHRvIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGVsYXBzZWQgdGlja3MuIGV4cG9uZW50aWFsIGFuZCB0YXJnZXQgY3VydmVzXG5cdFx0ICogICAgICAgIGFyZSBhcHByb3hpbWF0ZWQgd2l0aCBtdWx0aXBsZSBsaW5lYXIgcmFtcHMuXG5cdFx0ICpcblx0XHQgKiAgICAgICAgVGhhbmsgeW91IEJydW5vIERpYXMsIEguIFNvZmlhIFBpbnRvLCBhbmQgRGF2aWQgTS4gTWF0b3MsIGZvciB5b3VyIFtXQUMgcGFwZXJdKGh0dHBzOi8vc21hcnRlY2guZ2F0ZWNoLmVkdS9iaXRzdHJlYW0vaGFuZGxlLzE4NTMvNTQ1ODgvV0FDMjAxNi00OS5wZGYpXG5cdFx0ICogICAgICAgIGRlc2NyaWJpbmcgaW50ZWdyYXRpbmcgdGltaW5nIGZ1bmN0aW9ucyBmb3IgdGVtcG8gY2FsY3VsYXRpb25zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBzaWduYWxcblx0XHQgKiBAZXh0ZW5kcyB7VG9uZS5UaW1lbGluZVNpZ25hbH1cblx0XHQgKi9cblx0ICAgIFRvbmUuVGlja1NpZ25hbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhbHVlID0gVG9uZS5kZWZhdWx0QXJnKHZhbHVlLCAxKTtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLmNhbGwodGhpcywge1xuXHQgICAgICAgICAgICAndW5pdHMnOiBUb25lLlR5cGUuVGlja3MsXG5cdCAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy9leHRlbmQgdGhlIG1lbW9yeVxuXHQgICAgICAgIHRoaXMuX2V2ZW50cy5tZW1vcnkgPSBJbmZpbml0eTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlRpY2tTaWduYWwsIFRvbmUuVGltZWxpbmVTaWduYWwpO1xuXHQgICAgLyoqXG5cdFx0ICogV3JhcHMgVG9uZS5UaW1lbGluZVNpZ25hbCBtZXRob2RzIHNvIHRoYXQgdGhleSBhbHNvXG5cdFx0ICogcmVjb3JkIHRoZSB0aWNrcy5cblx0XHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbWV0aG9kXG5cdFx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIGZ1bmN0aW9uIF93cmFwU2NoZWR1bGVNZXRob2RzKG1ldGhvZCkge1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIHRpbWUpIHtcblx0ICAgICAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgICAgICBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5fZXZlbnRzLmdldCh0aW1lKTtcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzRXZlbnQgPSB0aGlzLl9ldmVudHMucHJldmlvdXNFdmVudChldmVudCk7XG5cdCAgICAgICAgICAgIHZhciB0aWNrc1VudGlsVGltZSA9IHRoaXMuX2dldFRpY2tVbnRpbEV2ZW50KHByZXZpb3VzRXZlbnQsIHRpbWUgLSB0aGlzLnNhbXBsZVRpbWUpO1xuXHQgICAgICAgICAgICBldmVudC50aWNrcyA9IE1hdGgubWF4KHRpY2tzVW50aWxUaW1lLCAwKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUuc2V0VmFsdWVBdFRpbWUgPSBfd3JhcFNjaGVkdWxlTWV0aG9kcyhUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRWYWx1ZUF0VGltZSk7XG5cdCAgICBUb25lLlRpY2tTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lID0gX3dyYXBTY2hlZHVsZU1ldGhvZHMoVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IGV4cG9uZW50aWFsbHkgYXBwcm9hY2hpbmcgdGhlIHRhcmdldCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZSB3aXRoXG5cdFx0ICogIGEgcmF0ZSBoYXZpbmcgdGhlIGdpdmVuIHRpbWUgY29uc3RhbnQuXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHN0YXJ0VGltZVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdGltZUNvbnN0YW50XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpY2tTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUuc2V0VGFyZ2V0QXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCB0aW1lLCBjb25zdGFudCkge1xuXHQgICAgICAgIC8vYXByb3hpbWF0ZSBpdCB3aXRoIG11bHRpcGxlIGxpbmVhciByYW1wc1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLnNldFJhbXBQb2ludCh0aW1lKTtcblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdCAgICAgICAgLy9zdGFydCBmcm9tIHByZXZpb3VzbHkgc2NoZWR1bGVkIHZhbHVlXG5cdCAgICAgICAgdmFyIHByZXZFdmVudCA9IHRoaXMuX2V2ZW50cy5nZXQodGltZSk7XG5cdCAgICAgICAgdmFyIHNlZ21lbnRzID0gNTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBzZWdtZW50czsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBzZWdUaW1lID0gY29uc3RhbnQgKiBpICsgdGltZTtcblx0ICAgICAgICAgICAgdmFyIHJhbXBWYWwgPSB0aGlzLl9leHBvbmVudGlhbEFwcHJvYWNoKHByZXZFdmVudC50aW1lLCBwcmV2RXZlbnQudmFsdWUsIHZhbHVlLCBjb25zdGFudCwgc2VnVGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5fdG9Vbml0cyhyYW1wVmFsKSwgc2VnVGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZXMgYW4gZXhwb25lbnRpYWwgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb21cblx0XHQgKiAgdGhlIHByZXZpb3VzIHNjaGVkdWxlZCBwYXJhbWV0ZXIgdmFsdWUgdG8gdGhlIGdpdmVuIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGVuZFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGlja1NpZ25hbH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaWNrU2lnbmFsLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCB0aW1lKSB7XG5cdCAgICAgICAgLy9hcHJveGltYXRlIGl0IHdpdGggbXVsdGlwbGUgbGluZWFyIHJhbXBzXG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICAvL3N0YXJ0IGZyb20gcHJldmlvdXNseSBzY2hlZHVsZWQgdmFsdWVcblx0ICAgICAgICB2YXIgcHJldkV2ZW50ID0gdGhpcy5fZXZlbnRzLmdldCh0aW1lKTtcblx0ICAgICAgICBpZiAocHJldkV2ZW50ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHByZXZFdmVudCA9IHtcblx0ICAgICAgICAgICAgICAgICd2YWx1ZSc6IHRoaXMuX2luaXRpYWwsXG5cdCAgICAgICAgICAgICAgICAndGltZSc6IDBcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNlZ21lbnRzID0gNTtcblx0ICAgICAgICB2YXIgc2VnbWVudER1ciA9ICh0aW1lIC0gcHJldkV2ZW50LnRpbWUpIC8gc2VnbWVudHM7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc2VnbWVudHM7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgc2VnVGltZSA9IHNlZ21lbnREdXIgKiBpICsgcHJldkV2ZW50LnRpbWU7XG5cdCAgICAgICAgICAgIHZhciByYW1wVmFsID0gdGhpcy5fZXhwb25lbnRpYWxJbnRlcnBvbGF0ZShwcmV2RXZlbnQudGltZSwgcHJldkV2ZW50LnZhbHVlLCB0aW1lLCB2YWx1ZSwgc2VnVGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5fdG9Vbml0cyhyYW1wVmFsKSwgc2VnVGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHRpY2sgdmFsdWUgYXQgdGhlIHRpbWUuIFRha2VzIGludG8gYWNjb3VudFxuXHRcdCAqIGFueSBhdXRvbWF0aW9uIGN1cnZlcyBzY2hlZHVsZWQgb24gdGhlIHNpZ25hbC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSAge1RpbWV9IHRpbWUgVGhlIHRpbWUgdG8gZ2V0IHRoZSB0aWNrIGNvdW50IGF0XG5cdFx0ICogQHJldHVybiB7VGlja3N9ICAgICAgVGhlIG51bWJlciBvZiB0aWNrcyB3aGljaCBoYXZlIGVsYXBzZWQgYXQgdGhlIHRpbWVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2l2ZW4gYW55IGF1dG9tYXRpb25zLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaWNrU2lnbmFsLnByb3RvdHlwZS5fZ2V0VGlja1VudGlsRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIHRpbWUpIHtcblx0ICAgICAgICBpZiAoZXZlbnQgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgZXZlbnQgPSB7XG5cdCAgICAgICAgICAgICAgICAndGlja3MnOiAwLFxuXHQgICAgICAgICAgICAgICAgJ3RpbWUnOiAwXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB2YWwwID0gdGhpcy5nZXRWYWx1ZUF0VGltZShldmVudC50aW1lKTtcblx0ICAgICAgICB2YXIgdmFsMSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIDAuNSAqICh0aW1lIC0gZXZlbnQudGltZSkgKiAodmFsMCArIHZhbDEpICsgZXZlbnQudGlja3M7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogUmV0dXJucyB0aGUgdGljayB2YWx1ZSBhdCB0aGUgdGltZS4gVGFrZXMgaW50byBhY2NvdW50XG5cdFx0ICogYW55IGF1dG9tYXRpb24gY3VydmVzIHNjaGVkdWxlZCBvbiB0aGUgc2lnbmFsLlxuXHRcdCAqIEBwYXJhbSAge1RpbWV9IHRpbWUgVGhlIHRpbWUgdG8gZ2V0IHRoZSB0aWNrIGNvdW50IGF0XG5cdFx0ICogQHJldHVybiB7VGlja3N9ICAgICAgVGhlIG51bWJlciBvZiB0aWNrcyB3aGljaCBoYXZlIGVsYXBzZWQgYXQgdGhlIHRpbWVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2l2ZW4gYW55IGF1dG9tYXRpb25zLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaWNrU2lnbmFsLnByb3RvdHlwZS5nZXRUaWNrQXRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5fZXZlbnRzLmdldCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VGlja1VudGlsRXZlbnQoZXZlbnQsIHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFJldHVybiB0aGUgZWxhcHNlZCB0aW1lIG9mIHRoZSBudW1iZXIgb2YgdGlja3MgZnJvbSB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqIEBwYXJhbSB7VGlja3N9IHRpY2tzIFRoZSBudW1iZXIgb2YgdGlja3MgdG8gY2FsY3VsYXRlXG5cdFx0ICogQHBhcmFtICB7VGltZX0gdGltZSBUaGUgdGltZSB0byBnZXQgdGhlIG5leHQgdGljayBmcm9tXG5cdFx0ICogQHJldHVybiB7U2Vjb25kc30gVGhlIGR1cmF0aW9uIG9mIHRoZSBudW1iZXIgb2YgdGlja3MgZnJvbSB0aGUgZ2l2ZW4gdGltZSBpbiBzZWNvbmRzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpY2tTaWduYWwucHJvdG90eXBlLmdldER1cmF0aW9uT2ZUaWNrcyA9IGZ1bmN0aW9uICh0aWNrcywgdGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB2YXIgY3VycmVudFRpY2sgPSB0aGlzLmdldFRpY2tBdFRpbWUodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGltZU9mVGljayhjdXJyZW50VGljayArIHRpY2tzKSAtIHRpbWU7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogR2l2ZW4gYSB0aWNrLCByZXR1cm5zIHRoZSB0aW1lIHRoYXQgdGljayBvY2N1cnMgYXQuXG5cdFx0ICogQHBhcmFtICB7VGlja3N9IHRpY2tcblx0XHQgKiBAcmV0dXJuIHtUaW1lfSAgICAgIFRoZSB0aW1lIHRoYXQgdGhlIHRpY2sgb2NjdXJzLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaWNrU2lnbmFsLnByb3RvdHlwZS5nZXRUaW1lT2ZUaWNrID0gZnVuY3Rpb24gKHRpY2spIHtcblx0ICAgICAgICB2YXIgYmVmb3JlID0gdGhpcy5fZXZlbnRzLmdldCh0aWNrLCAndGlja3MnKTtcblx0ICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLl9ldmVudHMuZ2V0QWZ0ZXIodGljaywgJ3RpY2tzJyk7XG5cdCAgICAgICAgaWYgKGJlZm9yZSAmJiBiZWZvcmUudGlja3MgPT09IHRpY2spIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGJlZm9yZS50aW1lO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYmVmb3JlICYmIGFmdGVyICYmIGFmdGVyLnR5cGUgPT09IFRvbmUuVGltZWxpbmVTaWduYWwuVHlwZS5MaW5lYXIgJiYgYmVmb3JlLnZhbHVlICE9PSBhZnRlci52YWx1ZSkge1xuXHQgICAgICAgICAgICB2YXIgdmFsMCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoYmVmb3JlLnRpbWUpO1xuXHQgICAgICAgICAgICB2YXIgdmFsMSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoYWZ0ZXIudGltZSk7XG5cdCAgICAgICAgICAgIHZhciBkZWx0YSA9ICh2YWwxIC0gdmFsMCkgLyAoYWZ0ZXIudGltZSAtIGJlZm9yZS50aW1lKTtcblx0ICAgICAgICAgICAgdmFyIGsgPSBNYXRoLnNxcnQoTWF0aC5wb3codmFsMCwgMikgLSAyICogZGVsdGEgKiAoYmVmb3JlLnRpY2tzIC0gdGljaykpO1xuXHQgICAgICAgICAgICB2YXIgc29sMSA9ICgtdmFsMCArIGspIC8gZGVsdGE7XG5cdCAgICAgICAgICAgIHZhciBzb2wyID0gKC12YWwwIC0gaykgLyBkZWx0YTtcblx0ICAgICAgICAgICAgcmV0dXJuIChzb2wxID4gMCA/IHNvbDEgOiBzb2wyKSArIGJlZm9yZS50aW1lO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYmVmb3JlKSB7XG5cdCAgICAgICAgICAgIGlmIChiZWZvcmUudmFsdWUgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBiZWZvcmUudGltZSArICh0aWNrIC0gYmVmb3JlLnRpY2tzKSAvIGJlZm9yZS52YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aWNrIC8gdGhpcy5faW5pdGlhbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVGlja1NpZ25hbDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBBIFRpbWVsaW5lIFN0YXRlLiBQcm92aWRlcyB0aGUgbWV0aG9kczogPGNvZGU+c2V0U3RhdGVBdFRpbWUoXCJzdGF0ZVwiLCB0aW1lKTwvY29kZT5cblx0XHQgKiAgICAgICAgICBhbmQgPGNvZGU+Z2V0VmFsdWVBdFRpbWUodGltZSk8L2NvZGU+LlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlRpbWVsaW5lfVxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gaW5pdGlhbCBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgVGltZWxpbmVTdGF0ZS4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIDxjb2RlPnVuZGVmaW5lZDwvY29kZT5cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTdGF0ZSA9IGZ1bmN0aW9uIChpbml0aWFsKSB7XG5cdCAgICAgICAgVG9uZS5UaW1lbGluZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBpbml0aWFsIHN0YXRlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faW5pdGlhbCA9IGluaXRpYWw7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5UaW1lbGluZVN0YXRlLCBUb25lLlRpbWVsaW5lKTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBzY2hlZHVsZWQgc3RhdGUgc2NoZWR1bGVkIGJlZm9yZSBvciBhdFxuXHRcdCAqICB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEByZXR1cm4gIHtTdHJpbmd9ICBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgaW5wdXQgaW4gc2V0U3RhdGVBdFRpbWUuXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU3RhdGUucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLmdldCh0aW1lKTtcblx0ICAgICAgICBpZiAoZXZlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnN0YXRlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0aWFsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWRkIGEgc3RhdGUgdG8gdGhlIHRpbWVsaW5lLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBzdGF0ZSBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgdG8gc2V0LlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTdGF0ZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVN0YXRlLnByb3RvdHlwZS5zZXRTdGF0ZUF0VGltZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGltZSkge1xuXHQgICAgICAgIHRoaXMuYWRkKHtcblx0ICAgICAgICAgICAgJ3N0YXRlJzogc3RhdGUsXG5cdCAgICAgICAgICAgICd0aW1lJzogdGltZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRpbWVsaW5lU3RhdGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQSBzYW1wbGUgYWNjdXJhdGUgY2xvY2sgd2hpY2ggcHJvdmlkZXMgYSBjYWxsYmFjayBhdCB0aGUgZ2l2ZW4gcmF0ZS4gXG5cdFx0ICogICAgICAgICAgV2hpbGUgdGhlIGNhbGxiYWNrIGlzIG5vdCBzYW1wbGUtYWNjdXJhdGUgKGl0IGlzIHN0aWxsIHN1c2NlcHRpYmxlIHRvXG5cdFx0ICogICAgICAgICAgbG9vc2UgSlMgdGltaW5nKSwgdGhlIHRpbWUgcGFzc2VkIGluIGFzIHRoZSBhcmd1bWVudCB0byB0aGUgY2FsbGJhY2tcblx0XHQgKiAgICAgICAgICBpcyBwcmVjaXNlLiBGb3IgbW9zdCBhcHBsaWNhdGlvbnMsIGl0IGlzIGJldHRlciB0byB1c2UgVG9uZS5UcmFuc3BvcnRcblx0XHQgKiAgICAgICAgICBpbnN0ZWFkIG9mIHRoZSBDbG9jayBieSBpdHNlbGYgc2luY2UgeW91IGNhbiBzeW5jaHJvbml6ZSBtdWx0aXBsZSBjYWxsYmFja3MuXG5cdFx0ICpcblx0XHQgKiBcdEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FbWl0dGVyfVxuXHRcdCAqIFx0QHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgdGltZSBvZiB0aGUgYXVkaW8gZXZlbnRcblx0XHQgKiBcdEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIHJhdGUgb2YgdGhlIGNhbGxiYWNrXG5cdFx0ICogXHRAZXhhbXBsZVxuXHRcdCAqIC8vdGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCBhcHByb3hpbWF0ZWx5IG9uY2UgYSBzZWNvbmRcblx0XHQgKiAvL2FuZCB3aWxsIHByaW50IHRoZSB0aW1lIGV4YWN0bHkgb25jZSBhIHNlY29uZCBhcGFydC5cblx0XHQgKiB2YXIgY2xvY2sgPSBuZXcgVG9uZS5DbG9jayhmdW5jdGlvbih0aW1lKXtcblx0XHQgKiBcdGNvbnNvbGUubG9nKHRpbWUpO1xuXHRcdCAqIH0sIDEpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DbG9jayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdjYWxsYmFjaycsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knXG5cdCAgICAgICAgXSwgVG9uZS5DbG9jayk7XG5cdCAgICAgICAgVG9uZS5FbWl0dGVyLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZSBhdCB0aGUgc2NoZWR1bGVkIHRpY2suXG5cdFx0XHQgKiAgQHR5cGUgIHtGdW5jdGlvbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBuZXh0IHRpbWUgdGhlIGNhbGxiYWNrIGlzIHNjaGVkdWxlZC5cblx0XHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9uZXh0VGljayA9IDA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGxhc3Qgc3RhdGUgb2YgdGhlIGNsb2NrLlxuXHRcdFx0ICogIEB0eXBlICB7U3RhdGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xhc3RTdGF0ZSA9IFRvbmUuU3RhdGUuU3RvcHBlZDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcmF0ZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gc2hvdWxkIGJlIGludm9rZWQuIFxuXHRcdFx0ICogIEB0eXBlICB7QlBNfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuVGlja1NpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ2ZyZXF1ZW5jeScpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGNhbGxiYWNrIHdhcyBpbnZva2VkLiBTdGFydHMgY291bnRpbmcgYXQgMFxuXHRcdFx0ICogIGFuZCBpbmNyZW1lbnRzIGFmdGVyIHRoZSBjYWxsYmFjayB3YXMgaW52b2tlZC4gXG5cdFx0XHQgKiAgQHR5cGUge1RpY2tzfVxuXHRcdFx0ICogIEByZWFkT25seVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy50aWNrcyA9IDA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHN0YXRlIHRpbWVsaW5lXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmVTdGF0ZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgVG9uZS5UaW1lbGluZVN0YXRlKFRvbmUuU3RhdGUuU3RvcHBlZCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGxvb3AgZnVuY3Rpb24gYm91bmQgdG8gaXRzIGNvbnRleHQuIFxuXHRcdFx0ICogIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSB0aGUgZXZlbnQgaW4gdGhlIGVuZC5cblx0XHRcdCAqICBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2JvdW5kTG9vcCA9IHRoaXMuX2xvb3AuYmluZCh0aGlzKTtcblx0ICAgICAgICAvL2JpbmQgYSBjYWxsYmFjayB0byB0aGUgd29ya2VyIHRocmVhZFxuXHQgICAgICAgIHRoaXMuY29udGV4dC5vbigndGljaycsIHRoaXMuX2JvdW5kTG9vcCk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5DbG9jaywgVG9uZS5FbWl0dGVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DbG9jay5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnY2FsbGJhY2snOiBUb25lLm5vT3AsXG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgcGxheWJhY2sgc3RhdGUgb2YgdGhlIHNvdXJjZSwgZWl0aGVyIFwic3RhcnRlZFwiLCBcInN0b3BwZWRcIiBvciBcInBhdXNlZFwiLlxuXHRcdCAqICBAdHlwZSB7VG9uZS5TdGF0ZX1cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkNsb2NrI1xuXHRcdCAqICBAbmFtZSBzdGF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ2xvY2sucHJvdG90eXBlLCAnc3RhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aGlzLm5vdygpKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgY2xvY2sgYXQgdGhlIGdpdmVuIHRpbWUuIE9wdGlvbmFsbHkgcGFzcyBpbiBhbiBvZmZzZXRcblx0XHQgKiAgb2Ygd2hlcmUgdG8gc3RhcnQgdGhlIHRpY2sgY291bnRlciBmcm9tLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIHRpbWUgICAgVGhlIHRpbWUgdGhlIGNsb2NrIHNob3VsZCBzdGFydFxuXHRcdCAqICBAcGFyYW0gIHtUaWNrcz19ICBvZmZzZXQgIFdoZXJlIHRoZSB0aWNrIGNvdW50ZXIgc3RhcnRzIGNvdW50aW5nIGZyb20uXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkNsb2NrfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DbG9jay5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKSAhPT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuU3RhcnRlZCwgdGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlLmdldCh0aW1lKS5vZmZzZXQgPSBvZmZzZXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBjbG9jay4gU3RvcHBpbmcgdGhlIGNsb2NrIHJlc2V0cyB0aGUgdGljayBjb3VudGVyIHRvIDAuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBUaGUgdGltZSB3aGVuIHRoZSBjbG9jayBzaG91bGQgc3RvcC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ2xvY2t9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBjbG9jay5zdG9wKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuY2FuY2VsKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuU3RvcHBlZCwgdGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFBhdXNlIHRoZSBjbG9jay4gUGF1c2luZyBkb2VzIG5vdCByZXNldCB0aGUgdGljayBjb3VudGVyLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gVGhlIHRpbWUgd2hlbiB0aGUgY2xvY2sgc2hvdWxkIHN0b3AuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNsb2NrfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuUGF1c2VkLCB0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzY2hlZHVsaW5nIGxvb3AuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLnByb3RvdHlwZS5fbG9vcCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvL3RoZSBlbmQgb2YgdGhlIHVwZGF0ZSBpbnRlcnZhbFxuXHQgICAgICAgIHZhciBlbmRUaW1lID0gdGhpcy5ub3coKSArIHRoaXMuY29udGV4dC51cGRhdGVJbnRlcnZhbDtcblx0ICAgICAgICAvL3RoZSBjdXJyZW50IGV2ZW50IGF0IHRoZSB0aW1lIG9mIHRoZSBsb29wXG5cdCAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5fc3RhdGUuZ2V0KGVuZFRpbWUpO1xuXHQgICAgICAgIGlmIChldmVudCkge1xuXHQgICAgICAgICAgICAvL3N0YXRlIGNoYW5nZSBldmVudHNcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXRlICE9PSB0aGlzLl9sYXN0U3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RTdGF0ZSA9IGV2ZW50LnN0YXRlO1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC5zdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSBUb25lLlN0YXRlLlN0YXJ0ZWQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFUb25lLmlzVW5kZWYoZXZlbnQub2Zmc2V0KSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpY2tzID0gZXZlbnQub2Zmc2V0O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0VGljayA9IGV2ZW50LnRpbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcsIGV2ZW50LnRpbWUsIHRoaXMudGlja3MpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSBUb25lLlN0YXRlLlN0b3BwZWQ6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aWNrcyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wJywgZXZlbnQudGltZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFRvbmUuU3RhdGUuUGF1c2VkOlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGF1c2UnLCBldmVudC50aW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL2FsbCB0aGUgdGljayBldmVudHNcblx0ICAgICAgICAgICAgd2hpbGUgKGVuZFRpbWUgPiB0aGlzLl9uZXh0VGljayAmJiB0aGlzLl9zdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRpY2tUaW1lID0gdGhpcy5fbmV4dFRpY2s7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5mcmVxdWVuY3kpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0VGljayArPSB0aGlzLmZyZXF1ZW5jeS5nZXREdXJhdGlvbk9mVGlja3MoMSwgdGhpcy5fbmV4dFRpY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHRpY2tUaW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGlja3MrKztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aWNrcysrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgc2NoZWR1bGVkIHN0YXRlIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEByZXR1cm4gIHtTdHJpbmd9ICBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgaW5wdXQgaW4gc2V0U3RhdGVBdFRpbWUuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogY2xvY2suc3RhcnQoXCIrMC4xXCIpO1xuXHRcdCAqIGNsb2NrLmdldFN0YXRlQXRUaW1lKFwiKzAuMVwiKTsgLy9yZXR1cm5zIFwic3RhcnRlZFwiXG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLnByb3RvdHlwZS5nZXRTdGF0ZUF0VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ2xvY2t9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ2xvY2sucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FbWl0dGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0Lm9mZigndGljaycsIHRoaXMuX2JvdW5kTG9vcCk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ2ZyZXF1ZW5jeScpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYm91bmRMb29wID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9uZXh0VGljayA9IEluZmluaXR5O1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQ2xvY2s7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBTaW1pbGFyIHRvIFRvbmUuVGltZWxpbmUsIGJ1dCBhbGwgZXZlbnRzIHJlcHJlc2VudFxuXHRcdCAqICAgICAgICAgaW50ZXJ2YWxzIHdpdGggYm90aCBcInRpbWVcIiBhbmQgXCJkdXJhdGlvblwiIHRpbWVzLiBUaGUgXG5cdFx0ICogICAgICAgICBldmVudHMgYXJlIHBsYWNlZCBpbiBhIHRyZWUgc3RydWN0dXJlIG9wdGltaXplZFxuXHRcdCAqICAgICAgICAgZm9yIHF1ZXJ5aW5nIGFuIGludGVyc2VjdGlvbiBwb2ludCB3aXRoIHRoZSB0aW1lbGluZVxuXHRcdCAqICAgICAgICAgZXZlbnRzLiBJbnRlcm5hbGx5IHVzZXMgYW4gW0ludGVydmFsIFRyZWVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVydmFsX3RyZWUpXG5cdFx0ICogICAgICAgICB0byByZXByZXNlbnQgdGhlIGRhdGEuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcm9vdCBub2RlIG9mIHRoZSBpbnRldmFsIHRyZWVcblx0XHRcdCAqICBAdHlwZSAge0ludGVydmFsTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgS2VlcCB0cmFjayBvZiB0aGUgbGVuZ3RoIG9mIHRoZSB0aW1lbGluZS5cblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkludGVydmFsVGltZWxpbmUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBldmVudCB0byBhZGQgdG8gdGhlIHRpbWVsaW5lLiBBbGwgZXZlbnRzIG11c3QgXG5cdFx0ICogIGhhdmUgYSB0aW1lIGFuZCBkdXJhdGlvbiB2YWx1ZVxuXHRcdCAqICBAcGFyYW0gIHtPYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IHRvIGFkZCB0byB0aGUgdGltZWxpbmVcblx0XHQgKiAgQHJldHVybiAge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNVbmRlZihldmVudC50aW1lKSB8fCBUb25lLmlzVW5kZWYoZXZlbnQuZHVyYXRpb24pKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5JbnRlcnZhbFRpbWVsaW5lOiBldmVudHMgbXVzdCBoYXZlIHRpbWUgYW5kIGR1cmF0aW9uIHBhcmFtZXRlcnMnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG5vZGUgPSBuZXcgSW50ZXJ2YWxOb2RlKGV2ZW50LnRpbWUsIGV2ZW50LnRpbWUgKyBldmVudC5kdXJhdGlvbiwgZXZlbnQpO1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBub2RlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3QuaW5zZXJ0KG5vZGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9sZW5ndGgrKztcblx0ICAgICAgICAvLyBSZXN0cnVjdHVyZSB0cmVlIHRvIGJlIGJhbGFuY2VkXG5cdCAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgbm9kZS51cGRhdGVIZWlnaHQoKTtcblx0ICAgICAgICAgICAgbm9kZS51cGRhdGVNYXgoKTtcblx0ICAgICAgICAgICAgdGhpcy5fcmViYWxhbmNlKG5vZGUpO1xuXHQgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgYW4gZXZlbnQgZnJvbSB0aGUgdGltZWxpbmUuXG5cdFx0ICogIEBwYXJhbSAge09iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgdG8gcmVtb3ZlIGZyb20gdGhlIHRpbWVsaW5lXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkludGVydmFsVGltZWxpbmV9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3Quc2VhcmNoKGV2ZW50LnRpbWUsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBub2RlID0gcmVzdWx0c1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLmV2ZW50ID09PSBldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZU5vZGUobm9kZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHRpbWVsaW5lLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5JbnRlcnZhbFRpbWVsaW5lI1xuXHRcdCAqICBAbmFtZSBsZW5ndGhcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgZXZlbnRzIHdob3NlIHRpbWUgdGltZSBpcyBhZnRlciB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoYWZ0ZXIpIHtcblx0ICAgICAgICB0aGlzLmZvckVhY2hBZnRlcihhZnRlciwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV2ZW50KTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgdGhlIHJvb3Qgbm9kZSBhcyB0aGUgZ2l2ZW4gbm9kZVxuXHRcdCAqICBAcGFyYW0ge0ludGVydmFsTm9kZX0gbm9kZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5fc2V0Um9vdCA9IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgdGhpcy5fcm9vdCA9IG5vZGU7XG5cdCAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcm9vdC5wYXJlbnQgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmVwbGFjZSB0aGUgcmVmZXJlbmNlcyB0byB0aGUgbm9kZSBpbiB0aGUgbm9kZSdzIHBhcmVudFxuXHRcdCAqICB3aXRoIHRoZSByZXBsYWNlbWVudCBub2RlLlxuXHRcdCAqICBAcGFyYW0gIHtJbnRlcnZhbE5vZGV9ICBub2RlICAgICAgICBcblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgcmVwbGFjZW1lbnQgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLl9yZXBsYWNlTm9kZUluUGFyZW50ID0gZnVuY3Rpb24gKG5vZGUsIHJlcGxhY2VtZW50KSB7XG5cdCAgICAgICAgaWYgKG5vZGUucGFyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChub2RlLmlzTGVmdENoaWxkKCkpIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fcmViYWxhbmNlKG5vZGUucGFyZW50KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRSb290KHJlcGxhY2VtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSB0cmVlIGFuZCByZXBsYWNlIGl0IHdpdGggXG5cdFx0ICogIGEgc3VjY2Vzc29yIHdoaWNoIGZvbGxvd3MgdGhlIHNjaGVtYS5cblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgbm9kZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5fcmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgaWYgKG5vZGUubGVmdCA9PT0gbnVsbCAmJiBub2RlLnJpZ2h0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VOb2RlSW5QYXJlbnQobm9kZSwgbnVsbCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChub2RlLnJpZ2h0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VOb2RlSW5QYXJlbnQobm9kZSwgbm9kZS5sZWZ0KTtcblx0ICAgICAgICB9IGVsc2UgaWYgKG5vZGUubGVmdCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9yZXBsYWNlTm9kZUluUGFyZW50KG5vZGUsIG5vZGUucmlnaHQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBiYWxhbmNlID0gbm9kZS5nZXRCYWxhbmNlKCk7XG5cdCAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCwgdGVtcDtcblx0ICAgICAgICAgICAgaWYgKGJhbGFuY2UgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWZ0LnJpZ2h0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBub2RlLmxlZnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucmlnaHQgPSBub2RlLnJpZ2h0O1xuXHQgICAgICAgICAgICAgICAgICAgIHRlbXAgPSByZXBsYWNlbWVudDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBub2RlLmxlZnQucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlcGxhY2VtZW50LnJpZ2h0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50LmxlZnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHJlcGxhY2VtZW50LnBhcmVudDtcblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5sZWZ0ID0gbm9kZS5sZWZ0O1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnJpZ2h0ID0gbm9kZS5yaWdodDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLnJpZ2h0LmxlZnQgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IG5vZGUucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQubGVmdCA9IG5vZGUubGVmdDtcblx0ICAgICAgICAgICAgICAgICAgICB0ZW1wID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gbm9kZS5yaWdodC5sZWZ0O1xuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZXBsYWNlbWVudC5sZWZ0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50ID0gcmVwbGFjZW1lbnQucGFyZW50O1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHJlcGxhY2VtZW50LnBhcmVudDtcblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5sZWZ0ID0gbm9kZS5sZWZ0O1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnJpZ2h0ID0gbm9kZS5yaWdodDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLmlzTGVmdENoaWxkKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zZXRSb290KHJlcGxhY2VtZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyB0aGlzLl9yZXBsYWNlTm9kZUluUGFyZW50KG5vZGUsIHJlcGxhY2VtZW50KTtcblx0ICAgICAgICAgICAgdGhpcy5fcmViYWxhbmNlKHRlbXApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBub2RlLmRpc3Bvc2UoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUm90YXRlIHRoZSB0cmVlIHRvIHRoZSBsZWZ0XG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsTm9kZX0gIG5vZGVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuX3JvdGF0ZUxlZnQgPSBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcblx0ICAgICAgICB2YXIgaXNMZWZ0Q2hpbGQgPSBub2RlLmlzTGVmdENoaWxkKCk7XG5cdCAgICAgICAgLy8gTWFrZSBub2RlLnJpZ2h0IHRoZSBuZXcgcm9vdCBvZiB0aGlzIHN1YiB0cmVlIChpbnN0ZWFkIG9mIG5vZGUpXG5cdCAgICAgICAgdmFyIHBpdm90Tm9kZSA9IG5vZGUucmlnaHQ7XG5cdCAgICAgICAgbm9kZS5yaWdodCA9IHBpdm90Tm9kZS5sZWZ0O1xuXHQgICAgICAgIHBpdm90Tm9kZS5sZWZ0ID0gbm9kZTtcblx0ICAgICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChpc0xlZnRDaGlsZCkge1xuXHQgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSBwaXZvdE5vZGU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSBwaXZvdE5vZGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRSb290KHBpdm90Tm9kZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSb3RhdGUgdGhlIHRyZWUgdG8gdGhlIHJpZ2h0XG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsTm9kZX0gIG5vZGVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuX3JvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG5cdCAgICAgICAgdmFyIGlzTGVmdENoaWxkID0gbm9kZS5pc0xlZnRDaGlsZCgpO1xuXHQgICAgICAgIC8vIE1ha2Ugbm9kZS5sZWZ0IHRoZSBuZXcgcm9vdCBvZiB0aGlzIHN1YiB0cmVlIChpbnN0ZWFkIG9mIG5vZGUpXG5cdCAgICAgICAgdmFyIHBpdm90Tm9kZSA9IG5vZGUubGVmdDtcblx0ICAgICAgICBub2RlLmxlZnQgPSBwaXZvdE5vZGUucmlnaHQ7XG5cdCAgICAgICAgcGl2b3ROb2RlLnJpZ2h0ID0gbm9kZTtcblx0ICAgICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChpc0xlZnRDaGlsZCkge1xuXHQgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSBwaXZvdE5vZGU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSBwaXZvdE5vZGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRSb290KHBpdm90Tm9kZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBCYWxhbmNlIHRoZSBCU1Rcblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgbm9kZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5fcmViYWxhbmNlID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICB2YXIgYmFsYW5jZSA9IG5vZGUuZ2V0QmFsYW5jZSgpO1xuXHQgICAgICAgIGlmIChiYWxhbmNlID4gMSkge1xuXHQgICAgICAgICAgICBpZiAobm9kZS5sZWZ0LmdldEJhbGFuY2UoKSA8IDApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JvdGF0ZUxlZnQobm9kZS5sZWZ0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JvdGF0ZVJpZ2h0KG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmIChiYWxhbmNlIDwgLTEpIHtcblx0ICAgICAgICAgICAgaWYgKG5vZGUucmlnaHQuZ2V0QmFsYW5jZSgpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcm90YXRlUmlnaHQobm9kZS5yaWdodCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yb3RhdGVMZWZ0KG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgYW4gZXZlbnQgd2hvc2UgdGltZSBhbmQgZHVyYXRpb24gc3BhbiB0aGUgZ2l2ZSB0aW1lLiBXaWxsXG5cdFx0ICogIHJldHVybiB0aGUgbWF0Y2ggd2hvc2UgXCJ0aW1lXCIgdmFsdWUgaXMgY2xvc2VzdCB0byB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7T2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCB0byBhZGQgdG8gdGhlIHRpbWVsaW5lXG5cdFx0ICogIEByZXR1cm4gIHtPYmplY3R9ICBUaGUgZXZlbnQgd2hpY2ggc3BhbnMgdGhlIGRlc2lyZWQgdGltZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3Quc2VhcmNoKHRpbWUsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWF4ID0gcmVzdWx0c1swXTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldLmxvdyA+IG1heC5sb3cpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gcmVzdWx0c1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbWF4LmV2ZW50O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgZXZlcnl0aGluZyBpbiB0aGUgdGltZWxpbmUuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0XHQgKiAgQHJldHVybnMge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIGFsbE5vZGVzID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3QudHJhdmVyc2UoZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICAgICAgICAgIGFsbE5vZGVzLnB1c2gobm9kZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXYgPSBhbGxOb2Rlc1tpXS5ldmVudDtcblx0ICAgICAgICAgICAgICAgIGlmIChldikge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5IGluIHdoaWNoIHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIG92ZXJsYXBzIHdpdGggdGhlIHRpbWUgYW5kIGR1cmF0aW9uIHRpbWUgb2YgdGhlIGV2ZW50LlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lIFRoZSB0aW1lIHRvIGNoZWNrIGlmIGl0ZW1zIGFyZSBvdmVybGFwcGluZ1xuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkludGVydmFsVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuZm9yRWFjaEF0VGltZSA9IGZ1bmN0aW9uICh0aW1lLCBjYWxsYmFjaykge1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3Quc2VhcmNoKHRpbWUsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gcmVzdWx0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV2ID0gcmVzdWx0c1tpXS5ldmVudDtcblx0ICAgICAgICAgICAgICAgIGlmIChldikge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5IGluIHdoaWNoIHRoZSB0aW1lIGlzIGdyZWF0ZXJcblx0XHQgKiAgdGhhbiB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSBUaGUgdGltZSB0byBjaGVjayBpZiBpdGVtcyBhcmUgYmVmb3JlXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0XHQgKiAgQHJldHVybnMge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoQWZ0ZXIgPSBmdW5jdGlvbiAodGltZSwgY2FsbGJhY2spIHtcblx0ICAgICAgICBpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXHQgICAgICAgICAgICB0aGlzLl9yb290LnNlYXJjaEFmdGVyKHRpbWUsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gcmVzdWx0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV2ID0gcmVzdWx0c1tpXS5ldmVudDtcblx0ICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYWxsTm9kZXMgPSBbXTtcblx0ICAgICAgICBpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9yb290LnRyYXZlcnNlKGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgICAgICAgICBhbGxOb2Rlcy5wdXNoKG5vZGUpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBhbGxOb2Rlc1tpXS5kaXNwb3NlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGFsbE5vZGVzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRJTlRFUlZBTCBOT0RFIEhFTFBFUlxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgUmVwcmVzZW50cyBhIG5vZGUgaW4gdGhlIGJpbmFyeSBzZWFyY2ggdHJlZSwgd2l0aCB0aGUgYWRkaXRpb25cblx0XHQgKiAgb2YgYSBcImhpZ2hcIiB2YWx1ZSB3aGljaCBrZWVwcyB0cmFjayBvZiB0aGUgaGlnaGVzdCB2YWx1ZSBvZlxuXHRcdCAqICBpdHMgY2hpbGRyZW4uIFxuXHRcdCAqICBSZWZlcmVuY2VzOiBcblx0XHQgKiAgaHR0cHM6Ly9icm9va25vdmFrLndvcmRwcmVzcy5jb20vMjAxMy8xMi8wNy9hdWdtZW50ZWQtaW50ZXJ2YWwtdHJlZS1pbi1jL1xuXHRcdCAqICBodHRwOi8vd3d3Lm1pZi52dS5sdC9+dmFsZGFzL0FMR09SSVRNQUkvTElURVJBVFVSQS9Db3JtZW4vQ29ybWVuLnBkZlxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gbG93XG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICB2YXIgSW50ZXJ2YWxOb2RlID0gZnVuY3Rpb24gKGxvdywgaGlnaCwgZXZlbnQpIHtcblx0ICAgICAgICAvL3RoZSBldmVudCBjb250YWluZXJcblx0ICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdCAgICAgICAgLy90aGUgbG93IHZhbHVlXG5cdCAgICAgICAgdGhpcy5sb3cgPSBsb3c7XG5cdCAgICAgICAgLy90aGUgaGlnaCB2YWx1ZVxuXHQgICAgICAgIHRoaXMuaGlnaCA9IGhpZ2g7XG5cdCAgICAgICAgLy90aGUgaGlnaCB2YWx1ZSBmb3IgdGhpcyBhbmQgYWxsIGNoaWxkIG5vZGVzXG5cdCAgICAgICAgdGhpcy5tYXggPSB0aGlzLmhpZ2g7XG5cdCAgICAgICAgLy90aGUgbm9kZXMgdG8gdGhlIGxlZnRcblx0ICAgICAgICB0aGlzLl9sZWZ0ID0gbnVsbDtcblx0ICAgICAgICAvL3RoZSBub2RlcyB0byB0aGUgcmlnaHRcblx0ICAgICAgICB0aGlzLl9yaWdodCA9IG51bGw7XG5cdCAgICAgICAgLy90aGUgcGFyZW50IG5vZGVcblx0ICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG5cdCAgICAgICAgLy90aGUgbnVtYmVyIG9mIGNoaWxkIG5vZGVzXG5cdCAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuXHQgICAgfTtcblx0ICAgIC8qKiBcblx0XHQgKiAgSW5zZXJ0IGEgbm9kZSBpbnRvIHRoZSBjb3JyZWN0IHNwb3QgaW4gdGhlIHRyZWVcblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgbm9kZVxuXHRcdCAqL1xuXHQgICAgSW50ZXJ2YWxOb2RlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgIGlmIChub2RlLmxvdyA8PSB0aGlzLmxvdykge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmxlZnQgPSBub2RlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5sZWZ0Lmluc2VydChub2RlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbm9kZTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuaW5zZXJ0KG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZWFyY2ggdGhlIHRyZWUgZm9yIG5vZGVzIHdoaWNoIG92ZXJsYXAgXG5cdFx0ICogIHdpdGggdGhlIGdpdmVuIHBvaW50XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHBvaW50ICBUaGUgcG9pbnQgdG8gcXVlcnlcblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9ICByZXN1bHRzICBUaGUgYXJyYXkgdG8gcHV0IHRoZSByZXN1bHRzXG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChwb2ludCwgcmVzdWx0cykge1xuXHQgICAgICAgIC8vIElmIHAgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgcG9pbnQgb2YgYW55IGludGVydmFsXG5cdCAgICAgICAgLy8gaW4gdGhpcyBub2RlIGFuZCBhbGwgY2hpbGRyZW4sIHRoZXJlIHdvbid0IGJlIGFueSBtYXRjaGVzLlxuXHQgICAgICAgIGlmIChwb2ludCA+IHRoaXMubWF4KSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU2VhcmNoIGxlZnQgY2hpbGRyZW5cblx0ICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMubGVmdC5zZWFyY2gocG9pbnQsIHJlc3VsdHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBDaGVjayB0aGlzIG5vZGVcblx0ICAgICAgICBpZiAodGhpcy5sb3cgPD0gcG9pbnQgJiYgdGhpcy5oaWdoID4gcG9pbnQpIHtcblx0ICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBJZiBwIGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSB0aW1lIG9mIHRoaXMgaW50ZXJ2YWwsXG5cdCAgICAgICAgLy8gdGhlbiBpdCBjYW4ndCBiZSBpbiBhbnkgY2hpbGQgdG8gdGhlIHJpZ2h0LlxuXHQgICAgICAgIGlmICh0aGlzLmxvdyA+IHBvaW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU2VhcmNoIHJpZ2h0IGNoaWxkcmVuXG5cdCAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5yaWdodC5zZWFyY2gocG9pbnQsIHJlc3VsdHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2VhcmNoIHRoZSB0cmVlIGZvciBub2RlcyB3aGljaCBhcmUgbGVzcyBcblx0XHQgKiAgdGhhbiB0aGUgZ2l2ZW4gcG9pbnRcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgcG9pbnQgIFRoZSBwb2ludCB0byBxdWVyeVxuXHRcdCAqICBAcGFyYW0gIHtBcnJheX0gIHJlc3VsdHMgIFRoZSBhcnJheSB0byBwdXQgdGhlIHJlc3VsdHNcblx0XHQgKi9cblx0ICAgIEludGVydmFsTm9kZS5wcm90b3R5cGUuc2VhcmNoQWZ0ZXIgPSBmdW5jdGlvbiAocG9pbnQsIHJlc3VsdHMpIHtcblx0ICAgICAgICAvLyBDaGVjayB0aGlzIG5vZGVcblx0ICAgICAgICBpZiAodGhpcy5sb3cgPj0gcG9pbnQpIHtcblx0ICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmxlZnQuc2VhcmNoQWZ0ZXIocG9pbnQsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIHNlYXJjaCB0aGUgcmlnaHQgc2lkZVxuXHQgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMucmlnaHQuc2VhcmNoQWZ0ZXIocG9pbnQsIHJlc3VsdHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGlzIGVsZW1lbnQgYW5kIGJvdGggaXQncyBicmFuY2hlc1xuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrXG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgY2FsbGJhY2sodGhpcyk7XG5cdCAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLmxlZnQudHJhdmVyc2UoY2FsbGJhY2spO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLnJpZ2h0LnRyYXZlcnNlKGNhbGxiYWNrKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFVwZGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBub2RlXG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLnVwZGF0ZUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsICYmIHRoaXMucmlnaHQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLmxlZnQuaGVpZ2h0LCB0aGlzLnJpZ2h0LmhlaWdodCkgKyAxO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMucmlnaHQuaGVpZ2h0ICsgMTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMubGVmdC5oZWlnaHQgKyAxO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFVwZGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBub2RlXG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLnVwZGF0ZU1heCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLm1heCA9IHRoaXMuaGlnaDtcblx0ICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5tYXgsIHRoaXMubGVmdC5tYXgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubWF4LCB0aGlzLnJpZ2h0Lm1heCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgYmFsYW5jZSBpcyBob3cgdGhlIGxlYWZzIGFyZSBkaXN0cmlidXRlZCBvbiB0aGUgbm9kZVxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgTmVnYXRpdmUgbnVtYmVycyBhcmUgYmFsYW5jZWQgdG8gdGhlIHJpZ2h0XG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLmdldEJhbGFuY2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGJhbGFuY2UgPSAwO1xuXHQgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwgJiYgdGhpcy5yaWdodCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBiYWxhbmNlID0gdGhpcy5sZWZ0LmhlaWdodCAtIHRoaXMucmlnaHQuaGVpZ2h0O1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGJhbGFuY2UgPSB0aGlzLmxlZnQuaGVpZ2h0ICsgMTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgYmFsYW5jZSA9IC0odGhpcy5yaWdodC5oZWlnaHQgKyAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGJhbGFuY2U7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgbm9kZSBpcyB0aGUgbGVmdCBjaGlsZFxuXHRcdCAqICBvZiBpdHMgcGFyZW50XG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLmlzTGVmdENoaWxkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnBhcmVudCAhPT0gbnVsbCAmJiB0aGlzLnBhcmVudC5sZWZ0ID09PSB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBnZXQvc2V0IHRoZSBsZWZ0IG5vZGVcblx0XHQgKiAgQHR5cGUge0ludGVydmFsTm9kZX1cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRlcnZhbE5vZGUucHJvdG90eXBlLCAnbGVmdCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xlZnQgPSBub2RlO1xuXHQgICAgICAgICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XG5cdCAgICAgICAgICAgIHRoaXMudXBkYXRlTWF4KCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgZ2V0L3NldCB0aGUgcmlnaHQgbm9kZVxuXHRcdCAqICBAdHlwZSB7SW50ZXJ2YWxOb2RlfVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEludGVydmFsTm9kZS5wcm90b3R5cGUsICdyaWdodCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9yaWdodCA9IG5vZGU7XG5cdCAgICAgICAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IHRoaXM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcblx0ICAgICAgICAgICAgdGhpcy51cGRhdGVNYXgoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBudWxsIG91dCByZWZlcmVuY2VzLlxuXHRcdCAqL1xuXHQgICAgSW50ZXJ2YWxOb2RlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZWZ0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9yaWdodCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5ldmVudCA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0RU5EIElOVEVSVkFMIE5PREUgSEVMUEVSXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIHJldHVybiBUb25lLkludGVydmFsVGltZWxpbmU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVHJhbnNwb3J0IGZvciB0aW1pbmcgbXVzaWNhbCBldmVudHMuXG5cdFx0ICogICAgICAgICAgU3VwcG9ydHMgdGVtcG8gY3VydmVzIGFuZCB0aW1lIGNoYW5nZXMuIFVubGlrZSBicm93c2VyLWJhc2VkIHRpbWluZyAoc2V0SW50ZXJ2YWwsIHJlcXVlc3RBbmltYXRpb25GcmFtZSlcblx0XHQgKiAgICAgICAgICBUb25lLlRyYW5zcG9ydCB0aW1pbmcgZXZlbnRzIHBhc3MgaW4gdGhlIGV4YWN0IHRpbWUgb2YgdGhlIHNjaGVkdWxlZCBldmVudFxuXHRcdCAqICAgICAgICAgIGluIHRoZSBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uIFBhc3MgdGhhdCB0aW1lIHZhbHVlIHRvIHRoZSBvYmplY3Rcblx0XHQgKiAgICAgICAgICB5b3UncmUgc2NoZWR1bGluZy4gPGJyPjxicj5cblx0XHQgKiAgICAgICAgICBBIHNpbmdsZSB0cmFuc3BvcnQgaXMgY3JlYXRlZCBmb3IgeW91IHdoZW4gdGhlIGxpYnJhcnkgaXMgaW5pdGlhbGl6ZWQuIFxuXHRcdCAqICAgICAgICAgIDxicj48YnI+XG5cdFx0ICogICAgICAgICAgVGhlIHRyYW5zcG9ydCBlbWl0cyB0aGUgZXZlbnRzOiBcInN0YXJ0XCIsIFwic3RvcFwiLCBcInBhdXNlXCIsIGFuZCBcImxvb3BcIiB3aGljaCBhcmVcblx0XHQgKiAgICAgICAgICBjYWxsZWQgd2l0aCB0aGUgdGltZSBvZiB0aGF0IGV2ZW50IGFzIHRoZSBhcmd1bWVudC4gXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRW1pdHRlcn1cblx0XHQgKiAgQHNpbmdsZXRvblxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vcmVwZWF0ZWQgZXZlbnQgZXZlcnkgOHRoIG5vdGVcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZVJlcGVhdChmdW5jdGlvbih0aW1lKXtcblx0XHQgKiBcdC8vZG8gc29tZXRoaW5nIHdpdGggdGhlIHRpbWVcblx0XHQgKiB9LCBcIjhuXCIpO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vc2NoZWR1bGUgYW4gZXZlbnQgb24gdGhlIDE2dGggbWVhc3VyZVxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKGZ1bmN0aW9uKHRpbWUpe1xuXHRcdCAqIFx0Ly9kbyBzb21ldGhpbmcgd2l0aCB0aGUgdGltZVxuXHRcdCAqIH0sIFwiMTY6MDowXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FbWl0dGVyLmNhbGwodGhpcyk7XG5cdCAgICAgICAgVG9uZS5nZXRDb250ZXh0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgICAgICAgICAgLy9cdExPT1BJTkdcblx0ICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgICAgICAvKiogXG5cdFx0XHRcdCAqIFx0SWYgdGhlIHRyYW5zcG9ydCBsb29wcyBvciBub3QuXG5cdFx0XHRcdCAqICBAdHlwZSB7Ym9vbGVhbn1cblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMubG9vcCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAvKiogXG5cdFx0XHRcdCAqIFx0VGhlIGxvb3Agc3RhcnQgcG9zaXRpb24gaW4gdGlja3Ncblx0XHRcdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wU3RhcnQgPSAwO1xuXHQgICAgICAgICAgICAvKiogXG5cdFx0XHRcdCAqIFx0VGhlIGxvb3AgZW5kIHBvc2l0aW9uIGluIHRpY2tzXG5cdFx0XHRcdCAqICBAdHlwZSB7VGlja3N9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fbG9vcEVuZCA9IDA7XG5cdCAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgICAgIC8vXHRDTE9DSy9URU1QT1xuXHQgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgUHVsc2VzIHBlciBxdWFydGVyIGlzIHRoZSBudW1iZXIgb2YgdGlja3MgcGVyIHF1YXJ0ZXIgbm90ZS5cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX3BwcSA9IFRyYW5zcG9ydENvbnN0cnVjdG9yLmRlZmF1bHRzLlBQUTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICB3YXRjaGVzIHRoZSBtYWluIG9zY2lsbGF0b3IgZm9yIHRpbWluZyB0aWNrc1xuXHRcdFx0XHQgKiAgaW5pdGlhbGx5IHN0YXJ0cyBhdCAxMjBicG1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqICBAdHlwZSB7VG9uZS5DbG9ja31cblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX2Nsb2NrID0gbmV3IFRvbmUuQ2xvY2soe1xuXHQgICAgICAgICAgICAgICAgJ2NhbGxiYWNrJzogdGhpcy5fcHJvY2Vzc1RpY2suYmluZCh0aGlzKSxcblx0ICAgICAgICAgICAgICAgICdmcmVxdWVuY3knOiAwXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLl9iaW5kQ2xvY2tFdmVudHMoKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBUaGUgQmVhdHMgUGVyIE1pbnV0ZSBvZiB0aGUgVHJhbnNwb3J0LiBcblx0XHRcdFx0ICogIEB0eXBlIHtCUE19XG5cdFx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0XHQgKiBUb25lLlRyYW5zcG9ydC5icG0udmFsdWUgPSA4MDtcblx0XHRcdFx0ICogLy9yYW1wIHRoZSBicG0gdG8gMTIwIG92ZXIgMTAgc2Vjb25kc1xuXHRcdFx0XHQgKiBUb25lLlRyYW5zcG9ydC5icG0ucmFtcFRvKDEyMCwgMTApO1xuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5icG0gPSB0aGlzLl9jbG9jay5mcmVxdWVuY3k7XG5cdCAgICAgICAgICAgIHRoaXMuYnBtLl90b1VuaXRzID0gdGhpcy5fdG9Vbml0cy5iaW5kKHRoaXMpO1xuXHQgICAgICAgICAgICB0aGlzLmJwbS5fZnJvbVVuaXRzID0gdGhpcy5fZnJvbVVuaXRzLmJpbmQodGhpcyk7XG5cdCAgICAgICAgICAgIHRoaXMuYnBtLnVuaXRzID0gVG9uZS5UeXBlLkJQTTtcblx0ICAgICAgICAgICAgdGhpcy5icG0udmFsdWUgPSBUcmFuc3BvcnRDb25zdHJ1Y3Rvci5kZWZhdWx0cy5icG07XG5cdCAgICAgICAgICAgIHRoaXMuX3JlYWRPbmx5KCdicG0nKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBUaGUgdGltZSBzaWduYXR1cmUsIG9yIG1vcmUgYWNjdXJhdGVseSB0aGUgbnVtZXJhdG9yXG5cdFx0XHRcdCAqICBvZiB0aGUgdGltZSBzaWduYXR1cmUgb3ZlciBhIGRlbm9taW5hdG9yIG9mIDQuIFxuXHRcdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl90aW1lU2lnbmF0dXJlID0gVHJhbnNwb3J0Q29uc3RydWN0b3IuZGVmYXVsdHMudGltZVNpZ25hdHVyZTtcblx0ICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgICAgICAgICAgLy9cdFRJTUVMSU5FIEVWRU5UU1xuXHQgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgQWxsIHRoZSBldmVudHMgaW4gYW4gb2JqZWN0IHRvIGtlZXAgdHJhY2sgYnkgSURcblx0XHRcdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVkRXZlbnRzID0ge307XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgVGhlIGV2ZW50IElEIGNvdW50ZXJcblx0XHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnRJRCA9IDA7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiBcdFRoZSBzY2hlZHVsZWQgZXZlbnRzLlxuXHRcdFx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmV9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUgPSBuZXcgVG9uZS5UaW1lbGluZSgpO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIFJlcGVhdGVkIGV2ZW50c1xuXHRcdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX3JlcGVhdGVkRXZlbnRzID0gbmV3IFRvbmUuSW50ZXJ2YWxUaW1lbGluZSgpO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIEV2ZW50cyB0aGF0IG9jY3VyIG9uY2Vcblx0XHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9vbmNlRXZlbnRzID0gbmV3IFRvbmUuVGltZWxpbmUoKTtcblx0ICAgICAgICAgICAgLyoqIFxuXHRcdFx0XHQgKiAgQWxsIG9mIHRoZSBzeW5jZWQgU2lnbmFsc1xuXHRcdFx0XHQgKiAgQHByaXZhdGUgXG5cdFx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9zeW5jZWRTaWduYWxzID0gW107XG5cdCAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgICAgIC8vXHRTV0lOR1xuXHQgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgVGhlIHN1YmRpdmlzaW9uIG9mIHRoZSBzd2luZ1xuXHRcdFx0XHQgKiAgQHR5cGUgIHtUaWNrc31cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9zd2luZ1RpY2tzID0gVHJhbnNwb3J0Q29uc3RydWN0b3IuZGVmYXVsdHMuUFBRIC8gMjtcblx0ICAgICAgICAgICAgLy84blxuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIFRoZSBzd2luZyBhbW91bnRcblx0XHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9zd2luZ0Ftb3VudCA9IDA7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlRyYW5zcG9ydCwgVG9uZS5FbWl0dGVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdHNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdicG0nOiAxMjAsXG5cdCAgICAgICAgJ3N3aW5nJzogMCxcblx0ICAgICAgICAnc3dpbmdTdWJkaXZpc2lvbic6ICc4bicsXG5cdCAgICAgICAgJ3RpbWVTaWduYXR1cmUnOiA0LFxuXHQgICAgICAgICdsb29wU3RhcnQnOiAwLFxuXHQgICAgICAgICdsb29wRW5kJzogJzRtJyxcblx0ICAgICAgICAnUFBRJzogMTkyXG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFRJQ0tTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgY2FsbGVkIG9uIGV2ZXJ5IHRpY2tcblx0XHQgKiAgQHBhcmFtICAge251bWJlcn0gdGlja1RpbWUgY2xvY2sgcmVsYXRpdmUgdGljayB0aW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuX3Byb2Nlc3NUaWNrID0gZnVuY3Rpb24gKHRpY2tUaW1lKSB7XG5cdCAgICAgICAgdmFyIHRpY2tzID0gdGhpcy5fY2xvY2sudGlja3M7XG5cdCAgICAgICAgLy9oYW5kbGUgc3dpbmdcblx0ICAgICAgICBpZiAodGhpcy5fc3dpbmdBbW91bnQgPiAwICYmIHRpY2tzICUgdGhpcy5fcHBxICE9PSAwICYmIC8vbm90IG9uIGEgZG93bmJlYXRcblx0ICAgICAgICAgICAgdGlja3MgJSAodGhpcy5fc3dpbmdUaWNrcyAqIDIpICE9PSAwKSB7XG5cdCAgICAgICAgICAgIC8vYWRkIHNvbWUgc3dpbmdcblx0ICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gdGlja3MgJSAodGhpcy5fc3dpbmdUaWNrcyAqIDIpIC8gKHRoaXMuX3N3aW5nVGlja3MgKiAyKTtcblx0ICAgICAgICAgICAgdmFyIGFtb3VudCA9IE1hdGguc2luKHByb2dyZXNzICogTWF0aC5QSSkgKiB0aGlzLl9zd2luZ0Ftb3VudDtcblx0ICAgICAgICAgICAgdGlja1RpbWUgKz0gVG9uZS5UaW1lKHRoaXMuX3N3aW5nVGlja3MgKiAyIC8gMywgJ2knKSAqIGFtb3VudDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9kbyB0aGUgbG9vcCB0ZXN0XG5cdCAgICAgICAgaWYgKHRoaXMubG9vcCkge1xuXHQgICAgICAgICAgICBpZiAodGlja3MgPj0gdGhpcy5fbG9vcEVuZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdsb29wRW5kJywgdGlja1RpbWUpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2xvY2sudGlja3MgPSB0aGlzLl9sb29wU3RhcnQ7XG5cdCAgICAgICAgICAgICAgICB0aWNrcyA9IHRoaXMuX2xvb3BTdGFydDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9vcFN0YXJ0JywgdGlja1RpbWUsIHRoaXMuc2Vjb25kcyk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2xvb3AnLCB0aWNrVGltZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9wcm9jZXNzIHRoZSBzaW5nbGUgb2NjdXJyZW5jZSBldmVudHNcblx0ICAgICAgICB0aGlzLl9vbmNlRXZlbnRzLmZvckVhY2hCZWZvcmUodGlja3MsIGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBldmVudC5jYWxsYmFjayh0aWNrVGltZSk7XG5cdCAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBldmVudFxuXHQgICAgICAgICAgICBkZWxldGUgdGhpcy5fc2NoZWR1bGVkRXZlbnRzW2V2ZW50LmlkLnRvU3RyaW5nKCldO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgLy9hbmQgY2xlYXIgdGhlIHNpbmdsZSBvY2N1cnJlbmNlIHRpbWVsaW5lXG5cdCAgICAgICAgdGhpcy5fb25jZUV2ZW50cy5jYW5jZWxCZWZvcmUodGlja3MpO1xuXHQgICAgICAgIC8vZmlyZSB0aGUgbmV4dCB0aWNrIGV2ZW50cyBpZiB0aGVpciB0aW1lIGhhcyBjb21lXG5cdCAgICAgICAgdGhpcy5fdGltZWxpbmUuZm9yRWFjaEF0VGltZSh0aWNrcywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGV2ZW50LmNhbGxiYWNrKHRpY2tUaW1lKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvL3Byb2Nlc3MgdGhlIHJlcGVhdGVkIGV2ZW50c1xuXHQgICAgICAgIHRoaXMuX3JlcGVhdGVkRXZlbnRzLmZvckVhY2hBdFRpbWUodGlja3MsIGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBpZiAoKHRpY2tzIC0gZXZlbnQudGltZSkgJSBldmVudC5pbnRlcnZhbCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgZXZlbnQuY2FsbGJhY2sodGlja1RpbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFNDSEVEVUxBQkxFIEVWRU5UU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFNjaGVkdWxlIGFuIGV2ZW50IGFsb25nIHRoZSB0aW1lbGluZS5cblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYXQgdGhlIHRpbWUuXG5cdFx0ICogIEBwYXJhbSB7VHJhbnNwb3J0VGltZX0gIHRpbWUgVGhlIHRpbWUgdG8gaW52b2tlIHRoZSBjYWxsYmFjayBhdC5cblx0XHQgKiAgQHJldHVybiB7TnVtYmVyfSBUaGUgaWQgb2YgdGhlIGV2ZW50IHdoaWNoIGNhbiBiZSB1c2VkIGZvciBjYW5jZWxpbmcgdGhlIGV2ZW50LiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3RyaWdnZXIgdGhlIGNhbGxiYWNrIHdoZW4gdGhlIFRyYW5zcG9ydCByZWFjaGVzIHRoZSBkZXNpcmVkIHRpbWVcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZShmdW5jdGlvbih0aW1lKXtcblx0XHQgKiBcdGVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSk7XG5cdFx0ICogfSwgXCIxMjhpXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aW1lKSB7XG5cdCAgICAgICAgdmFyIGV2ZW50ID0ge1xuXHQgICAgICAgICAgICAndGltZSc6IHRoaXMudG9UaWNrcyh0aW1lKSxcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJzogY2FsbGJhY2tcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHZhciBpZCA9IHRoaXMuX2V2ZW50SUQrKztcblx0ICAgICAgICB0aGlzLl9zY2hlZHVsZWRFdmVudHNbaWQudG9TdHJpbmcoKV0gPSB7XG5cdCAgICAgICAgICAgICdldmVudCc6IGV2ZW50LFxuXHQgICAgICAgICAgICAndGltZWxpbmUnOiB0aGlzLl90aW1lbGluZVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5fdGltZWxpbmUuYWRkKGV2ZW50KTtcblx0ICAgICAgICByZXR1cm4gaWQ7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNjaGVkdWxlIGEgcmVwZWF0ZWQgZXZlbnQgYWxvbmcgdGhlIHRpbWVsaW5lLiBUaGUgZXZlbnQgd2lsbCBmaXJlXG5cdFx0ICogIGF0IHRoZSBgaW50ZXJ2YWxgIHN0YXJ0aW5nIGF0IHRoZSBgc3RhcnRUaW1lYCBhbmQgZm9yIHRoZSBzcGVjaWZpZWRcblx0XHQgKiAgYGR1cmF0aW9uYC4gXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgICBpbnRlcnZhbCAgIFRoZSBkdXJhdGlvbiBiZXR3ZWVuIHN1Y2Nlc3NpdmVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MuXG5cdFx0ICogIEBwYXJhbSAge1RpbWVsaW5lUG9zaXRpb249fSAgICBzdGFydFRpbWUgIFdoZW4gYWxvbmcgdGhlIHRpbWVsaW5lIHRoZSBldmVudHMgc2hvdWxkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgYmVpbmcgaW52b2tlZC5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbZHVyYXRpb249SW5maW5pdHldIEhvdyBsb25nIHRoZSBldmVudCBzaG91bGQgcmVwZWF0LiBcblx0XHQgKiAgQHJldHVybiAge051bWJlcn0gICAgVGhlIElEIG9mIHRoZSBzY2hlZHVsZWQgZXZlbnQuIFVzZSB0aGlzIHRvIGNhbmNlbFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGV2ZW50LiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2EgY2FsbGJhY2sgaW52b2tlZCBldmVyeSBlaWdodGggbm90ZSBhZnRlciB0aGUgZmlyc3QgbWVhc3VyZVxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlUmVwZWF0KGNhbGxiYWNrLCBcIjhuXCIsIFwiMW1cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuc2NoZWR1bGVSZXBlYXQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGludGVydmFsLCBzdGFydFRpbWUsIGR1cmF0aW9uKSB7XG5cdCAgICAgICAgaWYgKGludGVydmFsIDw9IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLlRyYW5zcG9ydDogcmVwZWF0IGV2ZW50cyBtdXN0IGhhdmUgYW4gaW50ZXJ2YWwgbGFyZ2VyIHRoYW4gMCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZXZlbnQgPSB7XG5cdCAgICAgICAgICAgICd0aW1lJzogdGhpcy50b1RpY2tzKHN0YXJ0VGltZSksXG5cdCAgICAgICAgICAgICdkdXJhdGlvbic6IHRoaXMudG9UaWNrcyhUb25lLmRlZmF1bHRBcmcoZHVyYXRpb24sIEluZmluaXR5KSksXG5cdCAgICAgICAgICAgICdpbnRlcnZhbCc6IHRoaXMudG9UaWNrcyhpbnRlcnZhbCksXG5cdCAgICAgICAgICAgICdjYWxsYmFjayc6IGNhbGxiYWNrXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLl9ldmVudElEKys7XG5cdCAgICAgICAgdGhpcy5fc2NoZWR1bGVkRXZlbnRzW2lkLnRvU3RyaW5nKCldID0ge1xuXHQgICAgICAgICAgICAnZXZlbnQnOiBldmVudCxcblx0ICAgICAgICAgICAgJ3RpbWVsaW5lJzogdGhpcy5fcmVwZWF0ZWRFdmVudHNcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMuX3JlcGVhdGVkRXZlbnRzLmFkZChldmVudCk7XG5cdCAgICAgICAgcmV0dXJuIGlkO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZSBhbiBldmVudCB0aGF0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBpdCBpcyBpbnZva2VkLiBcblx0XHQgKiAgTm90ZSB0aGF0IGlmIHRoZSBnaXZlbiB0aW1lIGlzIGxlc3MgdGhhbiB0aGUgY3VycmVudCB0cmFuc3BvcnQgdGltZSwgXG5cdFx0ICogIHRoZSBldmVudCB3aWxsIGJlIGludm9rZWQgaW1tZWRpYXRlbHkuIFxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIG9uY2UuXG5cdFx0ICogIEBwYXJhbSB7VHJhbnNwb3J0VGltZX0gdGltZSBUaGUgdGltZSB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIGludm9rZWQuXG5cdFx0ICogIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBJRCBvZiB0aGUgc2NoZWR1bGVkIGV2ZW50LiBcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5zY2hlZHVsZU9uY2UgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRpbWUpIHtcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLl9ldmVudElEKys7XG5cdCAgICAgICAgdmFyIGV2ZW50ID0ge1xuXHQgICAgICAgICAgICAndGltZSc6IHRoaXMudG9UaWNrcyh0aW1lKSxcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJzogY2FsbGJhY2ssXG5cdCAgICAgICAgICAgICdpZCc6IGlkXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLl9zY2hlZHVsZWRFdmVudHNbaWQudG9TdHJpbmcoKV0gPSB7XG5cdCAgICAgICAgICAgICdldmVudCc6IGV2ZW50LFxuXHQgICAgICAgICAgICAndGltZWxpbmUnOiB0aGlzLl9vbmNlRXZlbnRzXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLl9vbmNlRXZlbnRzLmFkZChldmVudCk7XG5cdCAgICAgICAgcmV0dXJuIGlkO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhciB0aGUgcGFzc2VkIGluIGV2ZW50IGlkIGZyb20gdGhlIHRpbWVsaW5lXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBldmVudElkIFRoZSBpZCBvZiB0aGUgZXZlbnQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyYW5zcG9ydH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKGV2ZW50SWQpIHtcblx0ICAgICAgICBpZiAodGhpcy5fc2NoZWR1bGVkRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50SWQpKSB7XG5cdCAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fc2NoZWR1bGVkRXZlbnRzW2V2ZW50SWQudG9TdHJpbmcoKV07XG5cdCAgICAgICAgICAgIGl0ZW0udGltZWxpbmUucmVtb3ZlKGl0ZW0uZXZlbnQpO1xuXHQgICAgICAgICAgICBkZWxldGUgdGhpcy5fc2NoZWR1bGVkRXZlbnRzW2V2ZW50SWQudG9TdHJpbmcoKV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgc2NoZWR1bGVkIGV2ZW50cyBmcm9tIHRoZSB0aW1lbGluZSBhZnRlclxuXHRcdCAqICB0aGUgZ2l2ZW4gdGltZS4gUmVwZWF0ZWQgZXZlbnRzIHdpbGwgYmUgcmVtb3ZlZFxuXHRcdCAqICBpZiB0aGVpciBzdGFydFRpbWUgaXMgYWZ0ZXIgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtIHtUcmFuc3BvcnRUaW1lfSBbYWZ0ZXI9MF0gQ2xlYXIgYWxsIGV2ZW50cyBhZnRlclxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHRpbWUuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoYWZ0ZXIpIHtcblx0ICAgICAgICBhZnRlciA9IFRvbmUuZGVmYXVsdEFyZyhhZnRlciwgMCk7XG5cdCAgICAgICAgYWZ0ZXIgPSB0aGlzLnRvVGlja3MoYWZ0ZXIpO1xuXHQgICAgICAgIHRoaXMuX3RpbWVsaW5lLmNhbmNlbChhZnRlcik7XG5cdCAgICAgICAgdGhpcy5fb25jZUV2ZW50cy5jYW5jZWwoYWZ0ZXIpO1xuXHQgICAgICAgIHRoaXMuX3JlcGVhdGVkRXZlbnRzLmNhbmNlbChhZnRlcik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFNUQVJUL1NUT1AvUEFVU0Vcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBCaW5kIHN0YXJ0L3N0b3AvcGF1c2UgZXZlbnRzIGZyb20gdGhlIGNsb2NrIGFuZCBlbWl0IHRoZW0uXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuX2JpbmRDbG9ja0V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9jbG9jay5vbignc3RhcnQnLCBmdW5jdGlvbiAodGltZSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIG9mZnNldCA9IFRvbmUuVGltZSh0aGlzLl9jbG9jay50aWNrcywgJ2knKS50b1NlY29uZHMoKTtcblx0ICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcsIHRpbWUsIG9mZnNldCk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB0aGlzLl9jbG9jay5vbignc3RvcCcsIGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcCcsIHRpbWUpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5fY2xvY2sub24oJ3BhdXNlJywgZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5lbWl0KCdwYXVzZScsIHRpbWUpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBzb3VyY2UsIGVpdGhlciBcInN0YXJ0ZWRcIiwgXCJzdG9wcGVkXCIsIG9yIFwicGF1c2VkXCJcblx0XHQgKiAgQHR5cGUge1RvbmUuU3RhdGV9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogIEBuYW1lIHN0YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCAnc3RhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9jay5nZXRTdGF0ZUF0VGltZSh0aGlzLm5vdygpKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgdHJhbnNwb3J0IGFuZCBhbGwgc291cmNlcyBzeW5jZWQgdG8gdGhlIHRyYW5zcG9ydC5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBUaGUgdGltZSB3aGVuIHRoZSB0cmFuc3BvcnQgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcGFyYW0gIHtUcmFuc3BvcnRUaW1lPX0gb2Zmc2V0IFRoZSB0aW1lbGluZSBvZmZzZXQgdG8gc3RhcnQgdGhlIHRyYW5zcG9ydC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zdGFydCB0aGUgdHJhbnNwb3J0IGluIG9uZSBzZWNvbmQgc3RhcnRpbmcgYXQgYmVnaW5uaW5nIG9mIHRoZSA1dGggbWVhc3VyZS4gXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc3RhcnQoXCIrMVwiLCBcIjQ6MDowXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUsIG9mZnNldCkge1xuXHQgICAgICAgIC8vc3RhcnQgdGhlIGNsb2NrXG5cdCAgICAgICAgaWYgKCFUb25lLmlzVW5kZWYob2Zmc2V0KSkge1xuXHQgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnRvVGlja3Mob2Zmc2V0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fY2xvY2suc3RhcnQodGltZSwgb2Zmc2V0KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCB0aGUgdHJhbnNwb3J0IGFuZCBhbGwgc291cmNlcyBzeW5jZWQgdG8gdGhlIHRyYW5zcG9ydC5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBUaGUgdGltZSB3aGVuIHRoZSB0cmFuc3BvcnQgc2hvdWxkIHN0b3AuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zdG9wKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fY2xvY2suc3RvcCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUGF1c2UgdGhlIHRyYW5zcG9ydCBhbmQgYWxsIHNvdXJjZXMgc3luY2VkIHRvIHRoZSB0cmFuc3BvcnQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd11cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrLnBhdXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRvZ2dsZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdHJhbnNwb3J0LiBJZiBpdCBpc1xuXHRcdCAqIHN0YXJ0ZWQsIGl0IHdpbGwgc3RvcCBpdCwgb3RoZXJ3aXNlIGl0IHdpbGwgc3RhcnQgdGhlIFRyYW5zcG9ydC5cblx0XHQgKiBAcGFyYW0gIHtUaW1lPX0gdGltZSBUaGUgdGltZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBAcmV0dXJuIHtUb25lLlRyYW5zcG9ydH0gICAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgaWYgKHRoaXMuX2Nsb2NrLmdldFN0YXRlQXRUaW1lKHRpbWUpICE9PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgdGhpcy5zdGFydCh0aW1lKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLnN0b3AodGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRTRVRURVJTL0dFVFRFUlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgdGltZSBzaWduYXR1cmUgYXMganVzdCB0aGUgbnVtZXJhdG9yIG92ZXIgNC4gXG5cdFx0ICogIEZvciBleGFtcGxlIDQvNCB3b3VsZCBiZSBqdXN0IDQgYW5kIDYvOCB3b3VsZCBiZSAzLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ8QXJyYXl9XG5cdFx0ICogIEBuYW1lIHRpbWVTaWduYXR1cmVcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2NvbW1vbiB0aW1lXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQudGltZVNpZ25hdHVyZSA9IDQ7XG5cdFx0ICogLy8gNy84XG5cdFx0ICogVG9uZS5UcmFuc3BvcnQudGltZVNpZ25hdHVyZSA9IFs3LCA4XTtcblx0XHQgKiAvL3RoaXMgd2lsbCBiZSByZWR1Y2VkIHRvIGEgc2luZ2xlIG51bWJlclxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnRpbWVTaWduYXR1cmU7IC8vcmV0dXJucyAzLjVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsICd0aW1lU2lnbmF0dXJlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZVNpZ25hdHVyZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHRpbWVTaWcpIHtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNBcnJheSh0aW1lU2lnKSkge1xuXHQgICAgICAgICAgICAgICAgdGltZVNpZyA9IHRpbWVTaWdbMF0gLyB0aW1lU2lnWzFdICogNDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl90aW1lU2lnbmF0dXJlID0gdGltZVNpZztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFdoZW4gdGhlIFRvbmUuVHJhbnNwb3J0Lmxvb3AgPSB0cnVlLCB0aGlzIGlzIHRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiB0aGUgbG9vcC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogQHR5cGUge1RyYW5zcG9ydFRpbWV9XG5cdFx0ICogQG5hbWUgbG9vcFN0YXJ0XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCAnbG9vcFN0YXJ0Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX2xvb3BTdGFydCwgJ2knKS50b1NlY29uZHMoKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHN0YXJ0UG9zaXRpb24pIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcFN0YXJ0ID0gdGhpcy50b1RpY2tzKHN0YXJ0UG9zaXRpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogV2hlbiB0aGUgVG9uZS5UcmFuc3BvcnQubG9vcCA9IHRydWUsIHRoaXMgaXMgdGhlIGVuZGluZyBwb3NpdGlvbiBvZiB0aGUgbG9vcC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogQHR5cGUge1RyYW5zcG9ydFRpbWV9XG5cdFx0ICogQG5hbWUgbG9vcEVuZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ2xvb3BFbmQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydFRpbWUodGhpcy5fbG9vcEVuZCwgJ2knKS50b1NlY29uZHMoKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGVuZFBvc2l0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3BFbmQgPSB0aGlzLnRvVGlja3MoZW5kUG9zaXRpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCB0aGUgbG9vcCBzdGFydCBhbmQgc3RvcCBhdCB0aGUgc2FtZSB0aW1lLiBcblx0XHQgKiAgQHBhcmFtIHtUcmFuc3BvcnRUaW1lfSBzdGFydFBvc2l0aW9uIFxuXHRcdCAqICBAcGFyYW0ge1RyYW5zcG9ydFRpbWV9IGVuZFBvc2l0aW9uICAgXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyYW5zcG9ydH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vbG9vcCBvdmVyIHRoZSBmaXJzdCBtZWFzdXJlXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc2V0TG9vcFBvaW50cygwLCBcIjFtXCIpO1xuXHRcdCAqIFRvbmUuVHJhbnNwb3J0Lmxvb3AgPSB0cnVlO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnNldExvb3BQb2ludHMgPSBmdW5jdGlvbiAoc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pIHtcblx0ICAgICAgICB0aGlzLmxvb3BTdGFydCA9IHN0YXJ0UG9zaXRpb247XG5cdCAgICAgICAgdGhpcy5sb29wRW5kID0gZW5kUG9zaXRpb247XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzd2luZyB2YWx1ZS4gQmV0d2VlbiAwLTEgd2hlcmUgMSBlcXVhbCB0byBcblx0XHQgKiAgdGhlIG5vdGUgKyBoYWxmIHRoZSBzdWJkaXZpc2lvbi5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0ICogIEBuYW1lIHN3aW5nXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCAnc3dpbmcnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zd2luZ0Ftb3VudDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGFtb3VudCkge1xuXHQgICAgICAgICAgICAvL3NjYWxlIHRoZSB2YWx1ZXMgdG8gYSBub3JtYWwgcmFuZ2Vcblx0ICAgICAgICAgICAgdGhpcy5fc3dpbmdBbW91bnQgPSBhbW91bnQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgU2V0IHRoZSBzdWJkaXZpc2lvbiB3aGljaCB0aGUgc3dpbmcgd2lsbCBiZSBhcHBsaWVkIHRvLiBcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgYW4gOHRoIG5vdGUuIFZhbHVlIG11c3QgYmUgbGVzcyBcblx0XHQgKiAgdGhhbiBhIHF1YXJ0ZXIgbm90ZS5cblx0XHQgKiAgXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0ICogIEBuYW1lIHN3aW5nU3ViZGl2aXNpb25cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsICdzd2luZ1N1YmRpdmlzaW9uJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UaW1lKHRoaXMuX3N3aW5nVGlja3MsICdpJykudG9Ob3RhdGlvbigpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc3ViZGl2aXNpb24pIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3dpbmdUaWNrcyA9IHRoaXMudG9UaWNrcyhzdWJkaXZpc2lvbik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIFRyYW5zcG9ydCdzIHBvc2l0aW9uIGluIEJhcnM6QmVhdHM6U2l4dGVlbnRocy5cblx0XHQgKiAgU2V0dGluZyB0aGUgdmFsdWUgd2lsbCBqdW1wIHRvIHRoYXQgcG9zaXRpb24gcmlnaHQgYXdheS4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0XHQgKiAgQHR5cGUge0JhcnNCZWF0c1NpeHRlZW50aHN9XG5cdFx0ICogIEBuYW1lIHBvc2l0aW9uXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCAncG9zaXRpb24nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydFRpbWUodGhpcy50aWNrcywgJ2knKS50b0JhcnNCZWF0c1NpeHRlZW50aHMoKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHByb2dyZXNzKSB7XG5cdCAgICAgICAgICAgIHZhciB0aWNrcyA9IHRoaXMudG9UaWNrcyhwcm9ncmVzcyk7XG5cdCAgICAgICAgICAgIHRoaXMudGlja3MgPSB0aWNrcztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgVHJhbnNwb3J0J3MgcG9zaXRpb24gaW4gc2Vjb25kc1xuXHRcdCAqICBTZXR0aW5nIHRoZSB2YWx1ZSB3aWxsIGp1bXAgdG8gdGhhdCBwb3NpdGlvbiByaWdodCBhd2F5LiBcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqICBAdHlwZSB7U2Vjb25kc31cblx0XHQgKiAgQG5hbWUgc2Vjb25kc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3NlY29uZHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydFRpbWUodGhpcy50aWNrcywgJ2knKS50b1NlY29uZHMoKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHByb2dyZXNzKSB7XG5cdCAgICAgICAgICAgIHZhciB0aWNrcyA9IHRoaXMudG9UaWNrcyhwcm9ncmVzcyk7XG5cdCAgICAgICAgICAgIHRoaXMudGlja3MgPSB0aWNrcztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgVHJhbnNwb3J0J3MgbG9vcCBwb3NpdGlvbiBhcyBhIG5vcm1hbGl6ZWQgdmFsdWUuIEFsd2F5c1xuXHRcdCAqICByZXR1cm5zIDAgaWYgdGhlIHRyYW5zcG9ydCBpZiBsb29wIGlzIG5vdCB0cnVlLiBcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqICBAbmFtZSBwcm9ncmVzc1xuXHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCAncHJvZ3Jlc3MnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy50aWNrcyAtIHRoaXMuX2xvb3BTdGFydCkgLyAodGhpcy5fbG9vcEVuZCAtIHRoaXMuX2xvb3BTdGFydCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB0cmFuc3BvcnRzIGN1cnJlbnQgdGljayBwb3NpdGlvbi5cblx0XHQgKiAgXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0XHQgKiAgQHR5cGUge1RpY2tzfVxuXHRcdCAqICBAbmFtZSB0aWNrc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3RpY2tzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvY2sudGlja3M7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9jbG9jay50aWNrcyAhPT0gdCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgICAgICAvL3N0b3AgZXZlcnl0aGluZyBzeW5jZWQgdG8gdGhlIHRyYW5zcG9ydFxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcCcsIG5vdyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvY2sudGlja3MgPSB0O1xuXHQgICAgICAgICAgICAgICAgICAgIC8vcmVzdGFydCBpdCB3aXRoIHRoZSBuZXcgdGltZVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnQnLCBub3csIHRoaXMuc2Vjb25kcyk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb2NrLnRpY2tzID0gdDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFB1bHNlcyBQZXIgUXVhcnRlciBub3RlLiBUaGlzIGlzIHRoZSBzbWFsbGVzdCByZXNvbHV0aW9uXG5cdFx0ICogIHRoZSBUcmFuc3BvcnQgdGltaW5nIHN1cHBvcnRzLiBUaGlzIHNob3VsZCBiZSBzZXQgb25jZVxuXHRcdCAqICBvbiBpbml0aWFsaXphdGlvbiBhbmQgbm90IHNldCBhZ2Fpbi4gQ2hhbmdpbmcgdGhpcyB2YWx1ZSBcblx0XHQgKiAgYWZ0ZXIgb3RoZXIgb2JqZWN0cyBoYXZlIGJlZW4gY3JlYXRlZCBjYW4gY2F1c2UgcHJvYmxlbXMuIFxuXHRcdCAqICBcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbmFtZSBQUFFcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsICdQUFEnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcHE7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwcHEpIHtcblx0ICAgICAgICAgICAgdmFyIGJwbSA9IHRoaXMuYnBtLnZhbHVlO1xuXHQgICAgICAgICAgICB0aGlzLl9wcHEgPSBwcHE7XG5cdCAgICAgICAgICAgIHRoaXMuYnBtLnZhbHVlID0gYnBtO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgZnJvbSBCUE0gdG8gZnJlcXVlbmN5IChmYWN0b3JpbmcgaW4gUFBRKVxuXHRcdCAqICBAcGFyYW0gIHtCUE19ICBicG0gVGhlIEJQTSB2YWx1ZSB0byBjb252ZXJ0IHRvIGZyZXF1ZW5jeVxuXHRcdCAqICBAcmV0dXJuICB7RnJlcXVlbmN5fSAgVGhlIEJQTSBhcyBhIGZyZXF1ZW5jeSB3aXRoIFBQUSBmYWN0b3JlZCBpbi5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5fZnJvbVVuaXRzID0gZnVuY3Rpb24gKGJwbSkge1xuXHQgICAgICAgIHJldHVybiAxIC8gKDYwIC8gYnBtIC8gdGhpcy5QUFEpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGZyb20gZnJlcXVlbmN5ICh3aXRoIFBQUSkgaW50byBCUE1cblx0XHQgKiAgQHBhcmFtICB7RnJlcXVlbmN5fSAgZnJlcSBUaGUgY2xvY2tzIGZyZXF1ZW5jeSB0byBjb252ZXJ0IHRvIEJQTVxuXHRcdCAqICBAcmV0dXJuICB7QlBNfSAgVGhlIGZyZXF1ZW5jeSB2YWx1ZSBhcyBCUE0uXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuX3RvVW5pdHMgPSBmdW5jdGlvbiAoZnJlcSkge1xuXHQgICAgICAgIHJldHVybiBmcmVxIC8gdGhpcy5QUFEgKiA2MDtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0U1lOQ0lOR1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHRpbWUgYWxpZ25lZCB0byB0aGUgbmV4dCBzdWJkaXZpc2lvblxuXHRcdCAqICBvZiB0aGUgVHJhbnNwb3J0LiBJZiB0aGUgVHJhbnNwb3J0IGlzIG5vdCBzdGFydGVkLFxuXHRcdCAqICBpdCB3aWxsIHJldHVybiAwLlxuXHRcdCAqICBOb3RlOiB0aGlzIHdpbGwgbm90IHdvcmsgcHJlY2lzZWx5IGR1cmluZyB0ZW1wbyByYW1wcy5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHN1YmRpdmlzaW9uICBUaGUgc3ViZGl2aXNpb24gdG8gcXVhbnRpemUgdG9cblx0XHQgKiAgQHJldHVybiAge051bWJlcn0gIFRoZSBjb250ZXh0IHRpbWUgb2YgdGhlIG5leHQgc3ViZGl2aXNpb24uXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc3RhcnQoKTsgLy90aGUgdHJhbnNwb3J0IG11c3QgYmUgc3RhcnRlZFxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0Lm5leHRTdWJkaXZpc2lvbihcIjRuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLm5leHRTdWJkaXZpc2lvbiA9IGZ1bmN0aW9uIChzdWJkaXZpc2lvbikge1xuXHQgICAgICAgIHN1YmRpdmlzaW9uID0gdGhpcy50b1NlY29uZHMoc3ViZGl2aXNpb24pO1xuXHQgICAgICAgIC8vaWYgdGhlIHRyYW5zcG9ydCdzIG5vdCBzdGFydGVkLCByZXR1cm4gMFxuXHQgICAgICAgIHZhciBub3c7XG5cdCAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICBub3cgPSB0aGlzLl9jbG9jay5fbmV4dFRpY2s7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB0cmFuc3BvcnRQb3MgPSBUb25lLlRpbWUodGhpcy50aWNrcywgJ2knKTtcblx0ICAgICAgICB2YXIgcmVtYWluaW5nVGltZSA9IHN1YmRpdmlzaW9uIC0gdHJhbnNwb3J0UG9zICUgc3ViZGl2aXNpb247XG5cdCAgICAgICAgaWYgKHJlbWFpbmluZ1RpbWUgPT09IDApIHtcblx0ICAgICAgICAgICAgcmVtYWluaW5nVGltZSA9IHN1YmRpdmlzaW9uO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbm93ICsgcmVtYWluaW5nVGltZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQXR0YWNoZXMgdGhlIHNpZ25hbCB0byB0aGUgdGVtcG8gY29udHJvbCBzaWduYWwgc28gdGhhdCBcblx0XHQgKiAgYW55IGNoYW5nZXMgaW4gdGhlIHRlbXBvIHdpbGwgY2hhbmdlIHRoZSBzaWduYWwgaW4gdGhlIHNhbWVcblx0XHQgKiAgcmF0aW8uIFxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7VG9uZS5TaWduYWx9IHNpZ25hbCBcblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSByYXRpbyBPcHRpb25hbGx5IHBhc3MgaW4gdGhlIHJhdGlvIGJldHdlZW5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdHdvIHNpZ25hbHMuIE90aGVyd2lzZSBpdCB3aWxsIGJlIGNvbXB1dGVkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWQgb24gdGhlaXIgY3VycmVudCB2YWx1ZXMuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5zeW5jU2lnbmFsID0gZnVuY3Rpb24gKHNpZ25hbCwgcmF0aW8pIHtcblx0ICAgICAgICBpZiAoIXJhdGlvKSB7XG5cdCAgICAgICAgICAgIC8vZ2V0IHRoZSBzeW5jIHJhdGlvXG5cdCAgICAgICAgICAgIGlmIChzaWduYWwuX3BhcmFtLnZhbHVlICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByYXRpbyA9IHNpZ25hbC5fcGFyYW0udmFsdWUgLyB0aGlzLmJwbS5fcGFyYW0udmFsdWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByYXRpbyA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJhdGlvU2lnbmFsID0gbmV3IFRvbmUuR2FpbihyYXRpbyk7XG5cdCAgICAgICAgdGhpcy5icG0uY2hhaW4ocmF0aW9TaWduYWwsIHNpZ25hbC5fcGFyYW0pO1xuXHQgICAgICAgIHRoaXMuX3N5bmNlZFNpZ25hbHMucHVzaCh7XG5cdCAgICAgICAgICAgICdyYXRpbyc6IHJhdGlvU2lnbmFsLFxuXHQgICAgICAgICAgICAnc2lnbmFsJzogc2lnbmFsLFxuXHQgICAgICAgICAgICAnaW5pdGlhbCc6IHNpZ25hbC5fcGFyYW0udmFsdWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBzaWduYWwuX3BhcmFtLnZhbHVlID0gMDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVW5zeW5jcyBhIHByZXZpb3VzbHkgc3luY2VkIHNpZ25hbCBmcm9tIHRoZSB0cmFuc3BvcnQncyBjb250cm9sLiBcblx0XHQgKiAgU2VlIFRvbmUuVHJhbnNwb3J0LnN5bmNTaWduYWwuXG5cdFx0ICogIEBwYXJhbSAge1RvbmUuU2lnbmFsfSBzaWduYWwgXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyYW5zcG9ydH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnVuc3luY1NpZ25hbCA9IGZ1bmN0aW9uIChzaWduYWwpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fc3luY2VkU2lnbmFscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICB2YXIgc3luY2VkU2lnbmFsID0gdGhpcy5fc3luY2VkU2lnbmFsc1tpXTtcblx0ICAgICAgICAgICAgaWYgKHN5bmNlZFNpZ25hbC5zaWduYWwgPT09IHNpZ25hbCkge1xuXHQgICAgICAgICAgICAgICAgc3luY2VkU2lnbmFsLnJhdGlvLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgICAgIHN5bmNlZFNpZ25hbC5zaWduYWwuX3BhcmFtLnZhbHVlID0gc3luY2VkU2lnbmFsLmluaXRpYWw7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zeW5jZWRTaWduYWxzLnNwbGljZShpLCAxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRW1pdHRlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jbG9jayA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ2JwbScpO1xuXHQgICAgICAgIHRoaXMuYnBtID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl90aW1lbGluZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdGltZWxpbmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX29uY2VFdmVudHMuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX29uY2VFdmVudHMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3JlcGVhdGVkRXZlbnRzLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9yZXBlYXRlZEV2ZW50cyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdElOSVRJQUxJWkFUSU9OXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICB2YXIgVHJhbnNwb3J0Q29uc3RydWN0b3IgPSBUb25lLlRyYW5zcG9ydDtcblx0ICAgIFRvbmUuVHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydENvbnN0cnVjdG9yKCk7XG5cdCAgICBUb25lLkNvbnRleHQub24oJ2luaXQnLCBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgICAgIGlmIChjb250ZXh0LlRyYW5zcG9ydCBpbnN0YW5jZW9mIFRyYW5zcG9ydENvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgICAgIFRvbmUuVHJhbnNwb3J0ID0gY29udGV4dC5UcmFuc3BvcnQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgVG9uZS5UcmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0Q29uc3RydWN0b3IoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9zdG9yZSB0aGUgVHJhbnNwb3J0IG9uIHRoZSBjb250ZXh0IHNvIGl0IGNhbiBiZSByZXRyaWV2ZWQgbGF0ZXJcblx0ICAgICAgICBjb250ZXh0LlRyYW5zcG9ydCA9IFRvbmUuVHJhbnNwb3J0O1xuXHQgICAgfSk7XG5cdCAgICBUb25lLkNvbnRleHQub24oJ2Nsb3NlJywgZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgICBpZiAoY29udGV4dC5UcmFuc3BvcnQgaW5zdGFuY2VvZiBUcmFuc3BvcnRDb25zdHJ1Y3Rvcikge1xuXHQgICAgICAgICAgICBjb250ZXh0LlRyYW5zcG9ydC5kaXNwb3NlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlZvbHVtZSBpcyBhIHNpbXBsZSB2b2x1bWUgbm9kZSwgdXNlZnVsIGZvciBjcmVhdGluZyBhIHZvbHVtZSBmYWRlci5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge0RlY2liZWxzfSBbdm9sdW1lPTBdIHRoZSBpbml0aWFsIHZvbHVtZVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciB2b2wgPSBuZXcgVG9uZS5Wb2x1bWUoLTEyKTtcblx0XHQgKiBpbnN0cnVtZW50LmNoYWluKHZvbCwgVG9uZS5NYXN0ZXIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Wb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWyd2b2x1bWUnXSwgVG9uZS5Wb2x1bWUpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiB0aGUgb3V0cHV0IG5vZGVcblx0XHRcdCAqIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5HYWluKG9wdGlvbnMudm9sdW1lLCBUb25lLlR5cGUuRGVjaWJlbHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIHVubXV0ZWQgdm9sdW1lXG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdW5tdXRlZFZvbHVtZSA9IG9wdGlvbnMudm9sdW1lO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB2b2x1bWUgY29udHJvbCBpbiBkZWNpYmVscy5cblx0XHRcdCAqICBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSB0aGlzLm91dHB1dC5nYWluO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCd2b2x1bWUnKTtcblx0ICAgICAgICAvL3NldCB0aGUgbXV0ZSBpbml0aWFsbHlcblx0ICAgICAgICB0aGlzLm11dGUgPSBvcHRpb25zLm11dGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Wb2x1bWUsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBEZWZhdWx0c1xuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuVm9sdW1lLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd2b2x1bWUnOiAwLFxuXHQgICAgICAgICdtdXRlJzogZmFsc2Vcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBNdXRlIHRoZSBvdXRwdXQuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuVm9sdW1lI1xuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBuYW1lIG11dGVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vbXV0ZSB0aGUgb3V0cHV0XG5cdFx0ICogdm9sdW1lLm11dGUgPSB0cnVlO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVm9sdW1lLnByb3RvdHlwZSwgJ211dGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnZvbHVtZS52YWx1ZSA9PT0gLUluZmluaXR5O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobXV0ZSkge1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMubXV0ZSAmJiBtdXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl91bm11dGVkVm9sdW1lID0gdGhpcy52b2x1bWUudmFsdWU7XG5cdCAgICAgICAgICAgICAgICAvL21heWJlIGl0IHNob3VsZCByYW1wIGhlcmU/XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZvbHVtZS52YWx1ZSA9IC1JbmZpbml0eTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm11dGUgJiYgIW11dGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lLnZhbHVlID0gdGhpcy5fdW5tdXRlZFZvbHVtZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlZvbHVtZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Wb2x1bWUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5pbnB1dC5kaXNwb3NlKCk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgndm9sdW1lJyk7XG5cdCAgICAgICAgdGhpcy52b2x1bWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Wb2x1bWU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQSBzaW5nbGUgbWFzdGVyIG91dHB1dCB3aGljaCBpcyBjb25uZWN0ZWQgdG8gdGhlXG5cdFx0ICogICAgICAgICAgQXVkaW9EZXN0aW5hdGlvbk5vZGUgKGFrYSB5b3VyIHNwZWFrZXJzKS5cblx0XHQgKiAgICAgICAgICBJdCBwcm92aWRlcyB1c2VmdWwgY29udmVuaWVuY2VzIHN1Y2ggYXMgdGhlIGFiaWxpdHlcblx0XHQgKiAgICAgICAgICB0byBzZXQgdGhlIHZvbHVtZSBhbmQgbXV0ZSB0aGUgZW50aXJlIGFwcGxpY2F0aW9uLlxuXHRcdCAqICAgICAgICAgIEl0IGFsc28gZ2l2ZXMgeW91IHRoZSBhYmlsaXR5IHRvIGFwcGx5IG1hc3RlciBlZmZlY3RzIHRvIHlvdXIgYXBwbGljYXRpb24uXG5cdFx0ICogICAgICAgICAgPGJyPjxicj5cblx0XHQgKiAgICAgICAgICBMaWtlIFRvbmUuVHJhbnNwb3J0LCBBIHNpbmdsZSBUb25lLk1hc3RlciBpcyBjcmVhdGVkXG5cdFx0ICogICAgICAgICAgb24gaW5pdGlhbGl6YXRpb24gYW5kIHlvdSBkbyBub3QgbmVlZCB0byBleHBsaWNpdGx5IGNvbnN0cnVjdCBvbmUuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAc2luZ2xldG9uXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy90aGUgYXVkaW8gd2lsbCBnbyBmcm9tIHRoZSBvc2NpbGxhdG9yIHRvIHRoZSBzcGVha2Vyc1xuXHRcdCAqIG9zY2lsbGF0b3IuY29ubmVjdChUb25lLk1hc3Rlcik7XG5cdFx0ICogLy9hIGNvbnZlbmllbmNlIGZvciBjb25uZWN0aW5nIHRvIHRoZSBtYXN0ZXIgb3V0cHV0IGlzIGFsc28gcHJvdmlkZWQ6XG5cdFx0ICogb3NjaWxsYXRvci50b01hc3RlcigpO1xuXHRcdCAqIC8vdGhlIGFib3ZlIHR3byBleGFtcGxlcyBhcmUgZXF1aXZhbGVudC5cblx0XHQgKi9cblx0ICAgIFRvbmUuTWFzdGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgVG9uZS5nZXRDb250ZXh0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDEsIDApO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIFRoZSBwcml2YXRlIHZvbHVtZSBub2RlXG5cdFx0XHRcdCAqICBAdHlwZSAge1RvbmUuVm9sdW1lfVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX3ZvbHVtZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuVm9sdW1lKCk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiBUaGUgdm9sdW1lIG9mIHRoZSBtYXN0ZXIgb3V0cHV0LlxuXHRcdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHRcdCAqIEBzaWduYWxcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMudm9sdW1lID0gdGhpcy5fdm9sdW1lLnZvbHVtZTtcblx0ICAgICAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ3ZvbHVtZScpO1xuXHQgICAgICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgICAgIHRoaXMuaW5wdXQuY2hhaW4odGhpcy5vdXRwdXQsIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1hc3RlciwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5NYXN0ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3ZvbHVtZSc6IDAsXG5cdCAgICAgICAgJ211dGUnOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIE11dGUgdGhlIG91dHB1dC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5NYXN0ZXIjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9tdXRlIHRoZSBvdXRwdXRcblx0XHQgKiBUb25lLk1hc3Rlci5tdXRlID0gdHJ1ZTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk1hc3Rlci5wcm90b3R5cGUsICdtdXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdm9sdW1lLm11dGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtdXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3ZvbHVtZS5tdXRlID0gbXV0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGQgYSBtYXN0ZXIgZWZmZWN0cyBjaGFpbi4gTk9URTogdGhpcyB3aWxsIGRpc2Nvbm5lY3QgYW55IG5vZGVzIHdoaWNoIHdlcmUgcHJldmlvdXNseVxuXHRcdCAqICBjaGFpbmVkIGluIHRoZSBtYXN0ZXIgZWZmZWN0cyBjaGFpbi5cblx0XHQgKiAgQHBhcmFtIHtBdWRpb05vZGV8VG9uZX0gYXJncy4uLiBBbGwgYXJndW1lbnRzIHdpbGwgYmUgY29ubmVjdGVkIGluIGEgcm93XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHRoZSBNYXN0ZXIgd2lsbCBiZSByb3V0ZWQgdGhyb3VnaCBpdC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTWFzdGVyfSAgdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vc29tZSBvdmVyYWxsIGNvbXByZXNzaW9uIHRvIGtlZXAgdGhlIGxldmVscyBpbiBjaGVja1xuXHRcdCAqIHZhciBtYXN0ZXJDb21wcmVzc29yID0gbmV3IFRvbmUuQ29tcHJlc3Nvcih7XG5cdFx0ICogXHRcInRocmVzaG9sZFwiIDogLTYsXG5cdFx0ICogXHRcInJhdGlvXCIgOiAzLFxuXHRcdCAqIFx0XCJhdHRhY2tcIiA6IDAuNSxcblx0XHQgKiBcdFwicmVsZWFzZVwiIDogMC4xXG5cdFx0ICogfSk7XG5cdFx0ICogLy9naXZlIGEgbGl0dGxlIGJvb3N0IHRvIHRoZSBsb3dzXG5cdFx0ICogdmFyIGxvd0J1bXAgPSBuZXcgVG9uZS5GaWx0ZXIoMjAwLCBcImxvd3NoZWxmXCIpO1xuXHRcdCAqIC8vcm91dGUgZXZlcnl0aGluZyB0aHJvdWdoIHRoZSBmaWx0ZXJcblx0XHQgKiAvL2FuZCBjb21wcmVzc29yIGJlZm9yZSBnb2luZyB0byB0aGUgc3BlYWtlcnNcblx0XHQgKiBUb25lLk1hc3Rlci5jaGFpbihsb3dCdW1wLCBtYXN0ZXJDb21wcmVzc29yKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTWFzdGVyLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmlucHV0LmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLmlucHV0LmNoYWluLmFwcGx5KHRoaXMuaW5wdXQsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuTWFzdGVyfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NYXN0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgndm9sdW1lJyk7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRBVUdNRU5UIFRPTkUncyBQUk9UT1RZUEVcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIENvbm5lY3QgJ3RoaXMnIHRvIHRoZSBtYXN0ZXIgb3V0cHV0LiBTaG9ydGhhbmQgZm9yIHRoaXMuY29ubmVjdChUb25lLk1hc3Rlcilcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQXVkaW9Ob2RlfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9jb25uZWN0IGFuIG9zY2lsbGF0b3IgdG8gdGhlIG1hc3RlciBvdXRwdXRcblx0XHQgKiB2YXIgb3NjID0gbmV3IFRvbmUuT3NjaWxsYXRvcigpLnRvTWFzdGVyKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUudG9NYXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jb25uZWN0KFRvbmUuTWFzdGVyKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBpZiAod2luZG93LkF1ZGlvTm9kZSkge1xuXHQgICAgICAgIC8vIEFsc28gYXVnbWVudCBBdWRpb05vZGUncyBwcm90b3R5cGUgdG8gaW5jbHVkZSB0b01hc3RlciBhcyBhIGNvbnZlbmllbmNlXG5cdCAgICAgICAgQXVkaW9Ob2RlLnByb3RvdHlwZS50b01hc3RlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5jb25uZWN0KFRvbmUuTWFzdGVyKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHRcdCAqICBpbml0aWFsaXplIHRoZSBtb2R1bGUgYW5kIGxpc3RlbiBmb3IgbmV3IGF1ZGlvIGNvbnRleHRzXG5cdFx0ICovXG5cdCAgICB2YXIgTWFzdGVyQ29uc3RydWN0b3IgPSBUb25lLk1hc3Rlcjtcblx0ICAgIFRvbmUuTWFzdGVyID0gbmV3IE1hc3RlckNvbnN0cnVjdG9yKCk7XG5cdCAgICBUb25lLkNvbnRleHQub24oJ2luaXQnLCBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgICAgIC8vIGlmIGl0IGFscmVhZHkgZXhpc3RzLCBqdXN0IHJlc3RvcmUgaXRcblx0ICAgICAgICBpZiAoY29udGV4dC5NYXN0ZXIgaW5zdGFuY2VvZiBNYXN0ZXJDb25zdHJ1Y3Rvcikge1xuXHQgICAgICAgICAgICBUb25lLk1hc3RlciA9IGNvbnRleHQuTWFzdGVyO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIFRvbmUuTWFzdGVyID0gbmV3IE1hc3RlckNvbnN0cnVjdG9yKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvbnRleHQuTWFzdGVyID0gVG9uZS5NYXN0ZXI7XG5cdCAgICB9KTtcblx0ICAgIFRvbmUuQ29udGV4dC5vbignY2xvc2UnLCBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgICAgIGlmIChjb250ZXh0Lk1hc3RlciBpbnN0YW5jZW9mIE1hc3RlckNvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgICAgIGNvbnRleHQuTWFzdGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBUb25lLk1hc3Rlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBCYXNlIGNsYXNzIGZvciBzb3VyY2VzLiBTb3VyY2VzIGhhdmUgc3RhcnQvc3RvcCBtZXRob2RzXG5cdFx0ICogICAgICAgICAgYW5kIHRoZSBhYmlsaXR5IHRvIGJlIHN5bmNlZCB0byB0aGVcblx0XHQgKiAgICAgICAgICBzdGFydC9zdG9wIG9mIFRvbmUuVHJhbnNwb3J0LlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9NdWx0aXBsZSBzdGF0ZSBjaGFuZ2UgZXZlbnRzIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLFxuXHRcdCAqIC8vYnV0IG11c3QgYmUgc2V0IGluIHRoZSBjb3JyZWN0IG9yZGVyIGFuZCB3aXRoIGFzY2VuZGluZyB0aW1lc1xuXHRcdCAqXG5cdFx0ICogLy8gT0tcblx0XHQgKiBzdGF0ZS5zdGFydCgpLnN0b3AoXCIrMC4yXCIpO1xuXHRcdCAqIC8vIEFORFxuXHRcdCAqIHN0YXRlLnN0YXJ0KCkuc3RvcChcIiswLjJcIikuc3RhcnQoXCIrMC40XCIpLnN0b3AoXCIrMC43XCIpXG5cdFx0ICpcblx0XHQgKiAvLyBCQURcblx0XHQgKiBzdGF0ZS5zdG9wKFwiKzAuMlwiKS5zdGFydCgpO1xuXHRcdCAqIC8vIE9SXG5cdFx0ICogc3RhdGUuc3RhcnQoXCIrMC4zXCIpLnN0b3AoXCIrMC4yXCIpO1xuXHRcdCAqXG5cdFx0ICovXG5cdCAgICBUb25lLlNvdXJjZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLlNvdXJjZS5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3V0cHV0IHZvbHVtZSBub2RlXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLlZvbHVtZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5Wb2x1bWUob3B0aW9ucy52b2x1bWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIHZvbHVtZSBvZiB0aGUgb3V0cHV0IGluIGRlY2liZWxzLlxuXHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHNvdXJjZS52b2x1bWUudmFsdWUgPSAtNjtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gdGhpcy5fdm9sdW1lLnZvbHVtZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgndm9sdW1lJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBcdEtlZXAgdHJhY2sgb2YgdGhlIHNjaGVkdWxlZCBzdGF0ZS5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5UaW1lbGluZVN0YXRlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBUb25lLlRpbWVsaW5lU3RhdGUoVG9uZS5TdGF0ZS5TdG9wcGVkKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5tZW1vcnkgPSAxMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc3luY2VkIGBzdGFydGAgY2FsbGJhY2sgZnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNwb3J0XG5cdFx0XHQgKiAgQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zeW5jZWQgPSBmYWxzZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBLZWVwIHRyYWNrIG9mIGFsbCBvZiB0aGUgc2NoZWR1bGVkIGV2ZW50IGlkc1xuXHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IFtdO1xuXHQgICAgICAgIC8vbWFrZSB0aGUgb3V0cHV0IGV4cGxpY2l0bHkgc3RlcmVvXG5cdCAgICAgICAgdGhpcy5fdm9sdW1lLm91dHB1dC5vdXRwdXQuY2hhbm5lbENvdW50ID0gMjtcblx0ICAgICAgICB0aGlzLl92b2x1bWUub3V0cHV0Lm91dHB1dC5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0Jztcblx0ICAgICAgICAvL211dGUgaW5pdGlhbGx5XG5cdCAgICAgICAgdGhpcy5tdXRlID0gb3B0aW9ucy5tdXRlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU291cmNlLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb3VyY2UuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3ZvbHVtZSc6IDAsXG5cdCAgICAgICAgJ211dGUnOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgc291cmNlLCBlaXRoZXIgXCJzdGFydGVkXCIgb3IgXCJzdG9wcGVkXCIuXG5cdFx0ICogIEB0eXBlIHtUb25lLlN0YXRlfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuU291cmNlI1xuXHRcdCAqICBAbmFtZSBzdGF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU291cmNlLnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc3luY2VkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5UcmFuc3BvcnQuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZShUb25lLlRyYW5zcG9ydC5zZWNvbmRzKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRvbmUuU3RhdGUuU3RvcHBlZDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aGlzLm5vdygpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogTXV0ZSB0aGUgb3V0cHV0LlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlNvdXJjZSNcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbmFtZSBtdXRlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvL211dGUgdGhlIG91dHB1dFxuXHRcdCAqIHNvdXJjZS5tdXRlID0gdHJ1ZTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNvdXJjZS5wcm90b3R5cGUsICdtdXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdm9sdW1lLm11dGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtdXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3ZvbHVtZS5tdXRlID0gbXV0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8vb3ZlcndyaXRlIHRoZXNlIGZ1bmN0aW9uc1xuXHQgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLl9zdGFydCA9IFRvbmUubm9PcDtcblx0ICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5fc3RvcCA9IFRvbmUubm9PcDtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgc291cmNlIGF0IHRoZSBzcGVjaWZpZWQgdGltZS4gSWYgbm8gdGltZSBpcyBnaXZlbixcblx0XHQgKiAgc3RhcnQgdGhlIHNvdXJjZSBub3cuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gV2hlbiB0aGUgc291cmNlIHNob3VsZCBiZSBzdGFydGVkLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Tb3VyY2V9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBzb3VyY2Uuc3RhcnQoXCIrMC41XCIpOyAvL3N0YXJ0cyB0aGUgc291cmNlIDAuNSBzZWNvbmRzIGZyb20gbm93XG5cdFx0ICovXG5cdCAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSwgb2Zmc2V0LCBkdXJhdGlvbikge1xuXHQgICAgICAgIGlmIChUb25lLmlzVW5kZWYodGltZSkgJiYgdGhpcy5fc3luY2VkKSB7XG5cdCAgICAgICAgICAgIHRpbWUgPSBUb25lLlRyYW5zcG9ydC5zZWNvbmRzO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9pZiBpdCdzIHN0YXJ0ZWQsIHN0b3AgaXQgYW5kIHJlc3RhcnQgaXRcblx0ICAgICAgICBpZiAoIXRoaXMucmV0cmlnZ2VyICYmIHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHRpbWUpID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgdGhpcy5zdG9wKHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0YXJ0ZWQsIHRpbWUpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zeW5jZWQpIHtcblx0ICAgICAgICAgICAgLy8gYWRkIHRoZSBvZmZzZXQgdGltZSB0byB0aGUgZXZlbnRcblx0ICAgICAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5fc3RhdGUuZ2V0KHRpbWUpO1xuXHQgICAgICAgICAgICBldmVudC5vZmZzZXQgPSBUb25lLmRlZmF1bHRBcmcob2Zmc2V0LCAwKTtcblx0ICAgICAgICAgICAgZXZlbnQuZHVyYXRpb24gPSBkdXJhdGlvbjtcblx0ICAgICAgICAgICAgdmFyIHNjaGVkID0gVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoZnVuY3Rpb24gKHQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0KHQsIG9mZnNldCwgZHVyYXRpb24pO1xuXHQgICAgICAgICAgICB9LmJpbmQodGhpcyksIHRpbWUpO1xuXHQgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZWQucHVzaChzY2hlZCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0b3AgdGhlIHNvdXJjZSBhdCB0aGUgc3BlY2lmaWVkIHRpbWUuIElmIG5vIHRpbWUgaXMgZ2l2ZW4sXG5cdFx0ICogIHN0b3AgdGhlIHNvdXJjZSBub3cuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gV2hlbiB0aGUgc291cmNlIHNob3VsZCBiZSBzdG9wcGVkLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Tb3VyY2V9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBzb3VyY2Uuc3RvcCgpOyAvLyBzdG9wcyB0aGUgc291cmNlIGltbWVkaWF0ZWx5XG5cdFx0ICovXG5cdCAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNVbmRlZih0aW1lKSAmJiB0aGlzLl9zeW5jZWQpIHtcblx0ICAgICAgICAgICAgdGltZSA9IFRvbmUuVHJhbnNwb3J0LnNlY29uZHM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9zdGF0ZS5jYW5jZWwodGltZSk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdG9wcGVkLCB0aW1lKTtcblx0ICAgICAgICBpZiAoIXRoaXMuX3N5bmNlZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdG9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIHNjaGVkID0gVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUodGhpcy5fc3RvcC5iaW5kKHRoaXMpLCB0aW1lKTtcblx0ICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVkLnB1c2goc2NoZWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3luYyB0aGUgc291cmNlIHRvIHRoZSBUcmFuc3BvcnQgc28gdGhhdCBhbGwgc3Vic2VxdWVudFxuXHRcdCAqICBjYWxscyB0byBgc3RhcnRgIGFuZCBgc3RvcGAgYXJlIHN5bmNlZCB0byB0aGUgVHJhbnNwb3J0VGltZVxuXHRcdCAqICBpbnN0ZWFkIG9mIHRoZSBBdWRpb0NvbnRleHQgdGltZS5cblx0XHQgKlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Tb3VyY2V9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3N5bmMgdGhlIHNvdXJjZSBzbyB0aGF0IGl0IHBsYXlzIGJldHdlZW4gMCBhbmQgMC4zIG9uIHRoZSBUcmFuc3BvcnQncyB0aW1lbGluZVxuXHRcdCAqIHNvdXJjZS5zeW5jKCkuc3RhcnQoMCkuc3RvcCgwLjMpO1xuXHRcdCAqIC8vc3RhcnQgdGhlIHRyYW5zcG9ydC5cblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zdGFydCgpO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zdGFydCB0aGUgdHJhbnNwb3J0IHdpdGggYW4gb2Zmc2V0IGFuZCB0aGUgc3luYydlZCBzb3VyY2VzXG5cdFx0ICogLy93aWxsIHN0YXJ0IGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uXG5cdFx0ICogc291cmNlLnN5bmMoKS5zdGFydCgwLjEpO1xuXHRcdCAqIC8vdGhlIHNvdXJjZSB3aWxsIGJlIGludm9rZWQgd2l0aCBhbiBvZmZzZXQgb2YgMC40XG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc3RhcnQoXCIrMC41XCIsIDAuNSk7XG5cdFx0ICovXG5cdCAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9zeW5jZWQgPSB0cnVlO1xuXHQgICAgICAgIHRoaXMuX3N5bmNlZFN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUsIG9mZnNldCkge1xuXHQgICAgICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuXHQgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBwbGF5YmFjayBzdGF0ZSBhdCB0aGF0IHRpbWVcblx0ICAgICAgICAgICAgICAgIHZhciBzdGF0ZUV2ZW50ID0gdGhpcy5fc3RhdGUuZ2V0KG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICAvLyBsaXN0ZW4gZm9yIHN0YXJ0IGV2ZW50cyB3aGljaCBtYXkgb2NjdXIgaW4gdGhlIG1pZGRsZSBvZiB0aGUgc3luYydlZCB0aW1lXG5cdCAgICAgICAgICAgICAgICBpZiAoc3RhdGVFdmVudCAmJiBzdGF0ZUV2ZW50LnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQgJiYgc3RhdGVFdmVudC50aW1lICE9PSBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIG9mZnNldFxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IG9mZnNldCAtIHRoaXMudG9TZWNvbmRzKHN0YXRlRXZlbnQudGltZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZUV2ZW50LmR1cmF0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy50b1NlY29uZHMoc3RhdGVFdmVudC5kdXJhdGlvbikgLSBzdGFydE9mZnNldDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQodGltZSwgdGhpcy50b1NlY29uZHMoc3RhdGVFdmVudC5vZmZzZXQpICsgc3RhcnRPZmZzZXQsIGR1cmF0aW9uKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zeW5jZWRTdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKFRvbmUuVHJhbnNwb3J0LnNlY29uZHMpID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N0b3AodGltZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LmJpbmQodGhpcyk7XG5cdCAgICAgICAgVG9uZS5UcmFuc3BvcnQub24oJ3N0YXJ0IGxvb3BTdGFydCcsIHRoaXMuX3N5bmNlZFN0YXJ0KTtcblx0ICAgICAgICBUb25lLlRyYW5zcG9ydC5vbignc3RvcCBwYXVzZSBsb29wRW5kJywgdGhpcy5fc3luY2VkU3RvcCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFVuc3luYyB0aGUgc291cmNlIHRvIHRoZSBUcmFuc3BvcnQuIFNlZSBUb25lLlNvdXJjZS5zeW5jXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNvdXJjZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLnVuc3luYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5fc3luY2VkKSB7XG5cdCAgICAgICAgICAgIFRvbmUuVHJhbnNwb3J0Lm9mZignc3RvcCBwYXVzZSBsb29wRW5kJywgdGhpcy5fc3luY2VkU3RvcCk7XG5cdCAgICAgICAgICAgIFRvbmUuVHJhbnNwb3J0Lm9mZignc3RhcnQgbG9vcFN0YXJ0JywgdGhpcy5fc3luY2VkU3RhcnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9zeW5jZWQgPSBmYWxzZTtcblx0ICAgICAgICAvLyBjbGVhciBhbGwgb2YgdGhlIHNjaGVkdWxlZCBpZHNcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NjaGVkdWxlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLl9zY2hlZHVsZWRbaV07XG5cdCAgICAgICAgICAgIFRvbmUuVHJhbnNwb3J0LmNsZWFyKGlkKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fc2NoZWR1bGVkID0gW107XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuY2FuY2VsKDApO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqXHRDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5Tb3VyY2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy51bnN5bmMoKTtcblx0ICAgICAgICB0aGlzLl9zY2hlZHVsZWQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCd2b2x1bWUnKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU291cmNlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBPc2NpbGxhdG9yTm9kZSBzaGltXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBpZiAod2luZG93Lk9zY2lsbGF0b3JOb2RlICYmICFPc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUuc3RhcnQpIHtcblx0ICAgICAgICBPc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUuc3RhcnQgPSBPc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUubm90ZU9uO1xuXHQgICAgICAgIE9zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5zdG9wID0gT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLm5vdGVPZmY7XG5cdCAgICAgICAgaWYgKCFPc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUuc2V0UGVyaW9kaWNXYXZlKSB7XG5cdCAgICAgICAgICAgIE9zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5zZXRQZXJpb2RpY1dhdmUgPSBPc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUuc2V0V2F2ZVRhYmxlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUGVyaW9kaWNXYXZlKSB7XG5cdCAgICAgICAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUGVyaW9kaWNXYXZlID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVXYXZlVGFibGU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLk9zY2lsbGF0b3Igc3VwcG9ydHMgYSBudW1iZXIgb2YgZmVhdHVyZXMgaW5jbHVkaW5nXG5cdFx0ICogICAgICAgICBwaGFzZSByb3RhdGlvbiwgbXVsdGlwbGUgb3NjaWxsYXRvciB0eXBlcyAoc2VlIFRvbmUuT3NjaWxsYXRvci50eXBlKSwgXG5cdFx0ICogICAgICAgICBhbmQgVHJhbnNwb3J0IHN5bmNpbmcgKHNlZSBUb25lLk9zY2lsbGF0b3Iuc3luY0ZyZXF1ZW5jeSkuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNvdXJjZX1cblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IFtmcmVxdWVuY3ldIFN0YXJ0aW5nIGZyZXF1ZW5jeVxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIFRoZSBvc2NpbGxhdG9yIHR5cGUuIFJlYWQgbW9yZSBhYm91dCB0eXBlIGJlbG93LlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vbWFrZSBhbmQgc3RhcnQgYSA0NDBoeiBzaW5lIHRvbmVcblx0XHQgKiB2YXIgb3NjID0gbmV3IFRvbmUuT3NjaWxsYXRvcig0NDAsIFwic2luZVwiKS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ3R5cGUnXG5cdCAgICAgICAgXSwgVG9uZS5Pc2NpbGxhdG9yKTtcblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBtYWluIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7T3NjaWxsYXRvck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGNvbnRyb2wgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmRldHVuZSwgVG9uZS5UeXBlLkNlbnRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgcGVyaW9kaWMgd2F2ZVxuXHRcdFx0ICogIEB0eXBlIHtQZXJpb2RpY1dhdmV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3dhdmUgPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBwYXJ0aWFscyBvZiB0aGUgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGFydGlhbHMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucy5wYXJ0aWFscywgWzFdKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgcGhhc2Ugb2YgdGhlIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBiZXR3ZWVuIDAgLSAzNjBcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9waGFzZSA9IG9wdGlvbnMucGhhc2U7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHR5cGUgb2YgdGhlIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7c3RyaW5nfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90eXBlID0gbnVsbDtcblx0ICAgICAgICAvL3NldHVwXG5cdCAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuXHQgICAgICAgIHRoaXMucGhhc2UgPSB0aGlzLl9waGFzZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuT3NjaWxsYXRvciwgVG9uZS5Tb3VyY2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJyxcblx0ICAgICAgICAnZnJlcXVlbmN5JzogNDQwLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdwaGFzZSc6IDAsXG5cdCAgICAgICAgJ3BhcnRpYWxzJzogW11cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIE9zY2lsbGF0b3IgdHlwZXNcblx0XHQgKiAgQGVudW0ge1N0cmluZ31cblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5UeXBlID0ge1xuXHQgICAgICAgIFNpbmU6ICdzaW5lJyxcblx0ICAgICAgICBUcmlhbmdsZTogJ3RyaWFuZ2xlJyxcblx0ICAgICAgICBTYXd0b290aDogJ3Nhd3Rvb3RoJyxcblx0ICAgICAgICBTcXVhcmU6ICdzcXVhcmUnLFxuXHQgICAgICAgIEN1c3RvbTogJ2N1c3RvbSdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICAvL25ldyBvc2NpbGxhdG9yIHdpdGggcHJldmlvdXMgdmFsdWVzXG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvciA9IHRoaXMuY29udGV4dC5jcmVhdGVPc2NpbGxhdG9yKCk7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zZXRQZXJpb2RpY1dhdmUodGhpcy5fd2F2ZSk7XG5cdCAgICAgICAgLy9jb25uZWN0IHRoZSBjb250cm9sIHNpZ25hbCB0byB0aGUgb3NjaWxsYXRvciBmcmVxdWVuY3kgJiBkZXR1bmVcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fb3NjaWxsYXRvci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLmNvbm5lY3QodGhpcy5fb3NjaWxsYXRvci5kZXR1bmUpO1xuXHQgICAgICAgIC8vc3RhcnQgdGhlIG9zY2lsbGF0b3Jcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnN0YXJ0KHRoaXMudG9TZWNvbmRzKHRpbWUpKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RvcCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIChvcHRpb25hbCkgdGltaW5nIHBhcmFtZXRlclxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Pc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5fb3NjaWxsYXRvcikge1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnN0b3AodGhpcy50b1NlY29uZHModGltZSkpO1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN5bmMgdGhlIHNpZ25hbCB0byB0aGUgVHJhbnNwb3J0J3MgYnBtLiBBbnkgY2hhbmdlcyB0byB0aGUgdHJhbnNwb3J0cyBicG0sXG5cdFx0ICogIHdpbGwgYWxzbyBhZmZlY3QgdGhlIG9zY2lsbGF0b3JzIGZyZXF1ZW5jeS4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk9zY2lsbGF0b3J9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5icG0udmFsdWUgPSAxMjA7XG5cdFx0ICogb3NjLmZyZXF1ZW5jeS52YWx1ZSA9IDQ0MDtcblx0XHQgKiAvL3RoZSByYXRpb24gYmV0d2VlbiB0aGUgYnBtIGFuZCB0aGUgZnJlcXVlbmN5IHdpbGwgYmUgbWFpbnRhaW5lZFxuXHRcdCAqIG9zYy5zeW5jRnJlcXVlbmN5KCk7XG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuYnBtLnZhbHVlID0gMjQwOyBcblx0XHQgKiAvLyB0aGUgZnJlcXVlbmN5IG9mIHRoZSBvc2NpbGxhdG9yIGlzIGRvdWJsZWQgdG8gODgwXG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLnN5bmNGcmVxdWVuY3kgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5UcmFuc3BvcnQuc3luY1NpZ25hbCh0aGlzLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFVuc3luYyB0aGUgb3NjaWxsYXRvcidzIGZyZXF1ZW5jeSBmcm9tIHRoZSBUcmFuc3BvcnQuIFxuXHRcdCAqICBTZWUgVG9uZS5Pc2NpbGxhdG9yLnN5bmNGcmVxdWVuY3lcblx0XHQgKiAgQHJldHVybnMge1RvbmUuT3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Pc2NpbGxhdG9yLnByb3RvdHlwZS51bnN5bmNGcmVxdWVuY3kgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5UcmFuc3BvcnQudW5zeW5jU2lnbmFsKHRoaXMuZnJlcXVlbmN5KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgb3NjaWxsYXRvcjogZWl0aGVyIHNpbmUsIHNxdWFyZSwgdHJpYW5nbGUsIG9yIHNhd3Rvb3RoLiBBbHNvIGNhcGFibGUgb2Zcblx0XHQgKiBzZXR0aW5nIHRoZSBmaXJzdCB4IG51bWJlciBvZiBwYXJ0aWFscyBvZiB0aGUgb3NjaWxsYXRvci4gRm9yIGV4YW1wbGU6IFwic2luZTRcIiB3b3VsZFxuXHRcdCAqIHNldCBiZSB0aGUgZmlyc3QgNCBwYXJ0aWFscyBvZiB0aGUgc2luZSB3YXZlIGFuZCBcInRyaWFuZ2xlOFwiIHdvdWxkIHNldCB0aGUgZmlyc3Rcblx0XHQgKiA4IHBhcnRpYWxzIG9mIHRoZSB0cmlhbmdsZSB3YXZlLlxuXHRcdCAqIDxicj48YnI+IFxuXHRcdCAqIFVzZXMgUGVyaW9kaWNXYXZlIGludGVybmFsbHkgZXZlbiBmb3IgbmF0aXZlIHR5cGVzIHNvIHRoYXQgaXQgY2FuIHNldCB0aGUgcGhhc2UuIFxuXHRcdCAqIFBlcmlvZGljV2F2ZSBlcXVhdGlvbnMgYXJlIGZyb20gdGhlIFxuXHRcdCAqIFtXZWJraXQgV2ViIEF1ZGlvIGltcGxlbWVudGF0aW9uXShodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2NvZGVzZWFyY2gjY2hyb21pdW0vc3JjL3RoaXJkX3BhcnR5L1dlYktpdC9Tb3VyY2UvbW9kdWxlcy93ZWJhdWRpby9QZXJpb2RpY1dhdmUuY3BwJnNxPXBhY2thZ2U6Y2hyb21pdW0pLlxuXHRcdCAqICBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9zZXQgaXQgdG8gYSBzcXVhcmUgd2F2ZVxuXHRcdCAqIG9zYy50eXBlID0gXCJzcXVhcmVcIjtcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vc2V0IHRoZSBmaXJzdCA2IHBhcnRpYWxzIG9mIGEgc2F3dG9vdGggd2F2ZVxuXHRcdCAqIG9zYy50eXBlID0gXCJzYXd0b290aDZcIjtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHZhciBjb2VmcyA9IHRoaXMuX2dldFJlYWxJbWFnaW5hcnkodHlwZSwgdGhpcy5fcGhhc2UpO1xuXHQgICAgICAgICAgICB2YXIgcGVyaW9kaWNXYXZlID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBlcmlvZGljV2F2ZShjb2Vmc1swXSwgY29lZnNbMV0pO1xuXHQgICAgICAgICAgICB0aGlzLl93YXZlID0gcGVyaW9kaWNXYXZlO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fb3NjaWxsYXRvciAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zZXRQZXJpb2RpY1dhdmUodGhpcy5fd2F2ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvbXBvbmVudHMgYmFzZWQgXG5cdFx0ICogIG9uIHRoZSBvc2NpbGxhdG9yIHR5cGUuXG5cdFx0ICogIEByZXR1cm5zIHtBcnJheX0gW3JlYWwsIGltYWdpbmFyeV1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUuX2dldFJlYWxJbWFnaW5hcnkgPSBmdW5jdGlvbiAodHlwZSwgcGhhc2UpIHtcblx0ICAgICAgICB2YXIgZmZ0U2l6ZSA9IDQwOTY7XG5cdCAgICAgICAgdmFyIHBlcmlvZGljV2F2ZVNpemUgPSBmZnRTaXplIC8gMjtcblx0ICAgICAgICB2YXIgcmVhbCA9IG5ldyBGbG9hdDMyQXJyYXkocGVyaW9kaWNXYXZlU2l6ZSk7XG5cdCAgICAgICAgdmFyIGltYWcgPSBuZXcgRmxvYXQzMkFycmF5KHBlcmlvZGljV2F2ZVNpemUpO1xuXHQgICAgICAgIHZhciBwYXJ0aWFsQ291bnQgPSAxO1xuXHQgICAgICAgIGlmICh0eXBlID09PSBUb25lLk9zY2lsbGF0b3IuVHlwZS5DdXN0b20pIHtcblx0ICAgICAgICAgICAgcGFydGlhbENvdW50ID0gdGhpcy5fcGFydGlhbHMubGVuZ3RoICsgMTtcblx0ICAgICAgICAgICAgcGVyaW9kaWNXYXZlU2l6ZSA9IHBhcnRpYWxDb3VudDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgcGFydGlhbCA9IC9eKHNpbmV8dHJpYW5nbGV8c3F1YXJlfHNhd3Rvb3RoKShcXGQrKSQvLmV4ZWModHlwZSk7XG5cdCAgICAgICAgICAgIGlmIChwYXJ0aWFsKSB7XG5cdCAgICAgICAgICAgICAgICBwYXJ0aWFsQ291bnQgPSBwYXJzZUludChwYXJ0aWFsWzJdKSArIDE7XG5cdCAgICAgICAgICAgICAgICB0eXBlID0gcGFydGlhbFsxXTtcblx0ICAgICAgICAgICAgICAgIHBhcnRpYWxDb3VudCA9IE1hdGgubWF4KHBhcnRpYWxDb3VudCwgMik7XG5cdCAgICAgICAgICAgICAgICBwZXJpb2RpY1dhdmVTaXplID0gcGFydGlhbENvdW50O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZvciAodmFyIG4gPSAxOyBuIDwgcGVyaW9kaWNXYXZlU2l6ZTsgKytuKSB7XG5cdCAgICAgICAgICAgIHZhciBwaUZhY3RvciA9IDIgLyAobiAqIE1hdGguUEkpO1xuXHQgICAgICAgICAgICB2YXIgYjtcblx0ICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgVG9uZS5Pc2NpbGxhdG9yLlR5cGUuU2luZTpcblx0ICAgICAgICAgICAgICAgIGIgPSBuIDw9IHBhcnRpYWxDb3VudCA/IDEgOiAwO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgVG9uZS5Pc2NpbGxhdG9yLlR5cGUuU3F1YXJlOlxuXHQgICAgICAgICAgICAgICAgYiA9IG4gJiAxID8gMiAqIHBpRmFjdG9yIDogMDtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuT3NjaWxsYXRvci5UeXBlLlNhd3Rvb3RoOlxuXHQgICAgICAgICAgICAgICAgYiA9IHBpRmFjdG9yICogKG4gJiAxID8gMSA6IC0xKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuT3NjaWxsYXRvci5UeXBlLlRyaWFuZ2xlOlxuXHQgICAgICAgICAgICAgICAgaWYgKG4gJiAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYiA9IDIgKiAocGlGYWN0b3IgKiBwaUZhY3RvcikgKiAobiAtIDEgPj4gMSAmIDEgPyAtMSA6IDEpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBiID0gMDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuT3NjaWxsYXRvci5UeXBlLkN1c3RvbTpcblx0ICAgICAgICAgICAgICAgIGIgPSB0aGlzLl9wYXJ0aWFsc1tuIC0gMV07XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RvbmUuT3NjaWxsYXRvcjogaW52YWxpZCB0eXBlOiAnICsgdHlwZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGIgIT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHJlYWxbbl0gPSAtYiAqIE1hdGguc2luKHBoYXNlICogbik7XG5cdCAgICAgICAgICAgICAgICBpbWFnW25dID0gYiAqIE1hdGguY29zKHBoYXNlICogbik7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZWFsW25dID0gMDtcblx0ICAgICAgICAgICAgICAgIGltYWdbbl0gPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBbXG5cdCAgICAgICAgICAgIHJlYWwsXG5cdCAgICAgICAgICAgIGltYWdcblx0ICAgICAgICBdO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb21wdXRlIHRoZSBpbnZlcnNlIEZGVCBmb3IgYSBnaXZlbiBwaGFzZS5cdFxuXHRcdCAqICBAcGFyYW0gIHtGbG9hdDMyQXJyYXl9ICByZWFsXG5cdFx0ICogIEBwYXJhbSAge0Zsb2F0MzJBcnJheX0gIGltYWcgXG5cdFx0ICogIEBwYXJhbSAge05vcm1hbFJhbmdlfSAgcGhhc2UgXG5cdFx0ICogIEByZXR1cm4gIHtBdWRpb1JhbmdlfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5faW52ZXJzZUZGVCA9IGZ1bmN0aW9uIChyZWFsLCBpbWFnLCBwaGFzZSkge1xuXHQgICAgICAgIHZhciBzdW0gPSAwO1xuXHQgICAgICAgIHZhciBsZW4gPSByZWFsLmxlbmd0aDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgICAgIHN1bSArPSByZWFsW2ldICogTWF0aC5jb3MoaSAqIHBoYXNlKSArIGltYWdbaV0gKiBNYXRoLnNpbihpICogcGhhc2UpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gc3VtO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBvc2NpbGxhdG9yLlxuXHRcdCAqICBAcmV0dXJuICB7QXVkaW9SYW5nZX1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUuX2dldEluaXRpYWxWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgY29lZnMgPSB0aGlzLl9nZXRSZWFsSW1hZ2luYXJ5KHRoaXMuX3R5cGUsIDApO1xuXHQgICAgICAgIHZhciByZWFsID0gY29lZnNbMF07XG5cdCAgICAgICAgdmFyIGltYWcgPSBjb2Vmc1sxXTtcblx0ICAgICAgICB2YXIgbWF4VmFsdWUgPSAwO1xuXHQgICAgICAgIHZhciB0d29QaSA9IE1hdGguUEkgKiAyO1xuXHQgICAgICAgIC8vY2hlY2sgZm9yIHBlYWtzIGluIDggcGxhY2VzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgbWF4VmFsdWUgPSBNYXRoLm1heCh0aGlzLl9pbnZlcnNlRkZUKHJlYWwsIGltYWcsIGkgLyA4ICogdHdvUGkpLCBtYXhWYWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAtdGhpcy5faW52ZXJzZUZGVChyZWFsLCBpbWFnLCB0aGlzLl9waGFzZSkgLyBtYXhWYWx1ZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGFydGlhbHMgb2YgdGhlIHdhdmVmb3JtLiBBIHBhcnRpYWwgcmVwcmVzZW50cyBcblx0XHQgKiB0aGUgYW1wbGl0dWRlIGF0IGEgaGFybW9uaWMuIFRoZSBmaXJzdCBoYXJtb25pYyBpcyB0aGUgXG5cdFx0ICogZnVuZGFtZW50YWwgZnJlcXVlbmN5LCB0aGUgc2Vjb25kIGlzIHRoZSBvY3RhdmUgYW5kIHNvIG9uXG5cdFx0ICogZm9sbG93aW5nIHRoZSBoYXJtb25pYyBzZXJpZXMuIFxuXHRcdCAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSB0eXBlIHRvIFwiY3VzdG9tXCIuIFxuXHRcdCAqIFRoZSB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZSB0eXBlIGlzIG5vdCBcImN1c3RvbVwiLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAbmFtZSBwYXJ0aWFsc1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogb3NjLnBhcnRpYWxzID0gWzEsIDAuMiwgMC4wMV07XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BhcnRpYWxzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fdHlwZSAhPT0gVG9uZS5Pc2NpbGxhdG9yLlR5cGUuQ3VzdG9tKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFydGlhbHM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBhcnRpYWxzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhcnRpYWxzID0gcGFydGlhbHM7XG5cdCAgICAgICAgICAgIHRoaXMudHlwZSA9IFRvbmUuT3NjaWxsYXRvci5UeXBlLkN1c3RvbTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwaGFzZSBvZiB0aGUgb3NjaWxsYXRvciBpbiBkZWdyZWVzLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtEZWdyZWVzfVxuXHRcdCAqIEBuYW1lIHBoYXNlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBvc2MucGhhc2UgPSAxODA7IC8vZmxpcHMgdGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BoYXNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGhhc2UgKiAoMTgwIC8gTWF0aC5QSSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwaGFzZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9waGFzZSA9IHBoYXNlICogTWF0aC5QSSAvIDE4MDtcblx0ICAgICAgICAgICAgLy9yZXNldCB0aGUgdHlwZVxuXHQgICAgICAgICAgICB0aGlzLnR5cGUgPSB0aGlzLl90eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIERpc3Bvc2UgYW5kIGRpc2Nvbm5lY3QuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuT3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgaWYgKHRoaXMuX29zY2lsbGF0b3IgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl93YXZlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9wYXJ0aWFscyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuT3NjaWxsYXRvcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlplcm8gb3V0cHV0cyAwJ3MgYXQgYXVkaW8tcmF0ZS4gVGhlIHJlYXNvbiB0aGlzIGhhcyB0byBiZVxuXHRcdCAqICAgICAgICAgaXQncyBvd24gY2xhc3MgaXMgdGhhdCBtYW55IGJyb3dzZXJzIG9wdGltaXplIG91dCBUb25lLlNpZ25hbFxuXHRcdCAqICAgICAgICAgd2l0aCBhIHZhbHVlIG9mIDAgYW5kIHdpbGwgbm90IHByb2Nlc3Mgbm9kZXMgZnVydGhlciBkb3duIHRoZSBncmFwaC5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuWmVybyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZ2FpbiBub2RlXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2dhaW4gPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmdldENvbnN0YW50KDApLmNvbm5lY3QodGhpcy5fZ2Fpbik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5aZXJvLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlplcm99ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlplcm8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZ2Fpbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZ2FpbiA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuWmVybztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBMRk8gc3RhbmRzIGZvciBsb3cgZnJlcXVlbmN5IG9zY2lsbGF0b3IuIFRvbmUuTEZPIHByb2R1Y2VzIGFuIG91dHB1dCBzaWduYWxcblx0XHQgKiAgICAgICAgICB3aGljaCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gQXVkaW9QYXJhbSBvciBUb25lLlNpZ25hbFxuXHRcdCAqICAgICAgICAgIGluIG9yZGVyIHRvIG1vZHVsYXRlIHRoYXQgcGFyYW1ldGVyIHdpdGggYW4gb3NjaWxsYXRvci4gVGhlIExGTyBjYW5cblx0XHQgKiAgICAgICAgICBhbHNvIGJlIHN5bmNlZCB0byB0aGUgdHJhbnNwb3J0IHRvIHN0YXJ0L3N0b3AgYW5kIGNoYW5nZSB3aGVuIHRoZSB0ZW1wbyBjaGFuZ2VzLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fE9iamVjdH0gW2ZyZXF1ZW5jeV0gVGhlIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRpb24uIFR5cGljYWxseSwgTEZPcyB3aWxsIGJlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGZyZXF1ZW5jeSByYW5nZSBvZiAwLjEgdG8gMTAgaGVydHouXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gbWluIFRoZSBtaW5pbXVtIG91dHB1dCB2YWx1ZSBvZiB0aGUgTEZPLlxuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IG1heCBUaGUgbWF4aW11bSB2YWx1ZSBvZiB0aGUgTEZPLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBsZm8gPSBuZXcgVG9uZS5MRk8oXCI0blwiLCA0MDAsIDQwMDApO1xuXHRcdCAqIGxmby5jb25uZWN0KGZpbHRlci5mcmVxdWVuY3kpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ21pbicsXG5cdCAgICAgICAgICAgICdtYXgnXG5cdCAgICAgICAgXSwgVG9uZS5MRk8pO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG9zY2lsbGF0b3IuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvciA9IG5ldyBUb25lLk9zY2lsbGF0b3Ioe1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jzogb3B0aW9ucy5mcmVxdWVuY3ksXG5cdCAgICAgICAgICAgICd0eXBlJzogb3B0aW9ucy50eXBlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxmbydzIGZyZXF1ZW5jeVxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSB0aGlzLl9vc2NpbGxhdG9yLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBhbXBsaXR1ZGUgb2YgdGhlIExGTywgd2hpY2ggY29udHJvbHMgdGhlIG91dHB1dCByYW5nZSBiZXR3ZWVuXG5cdFx0XHQgKiB0aGUgbWluIGFuZCBtYXggb3V0cHV0LiBGb3IgZXhhbXBsZSBpZiB0aGUgbWluIGlzIC0xMCBhbmQgdGhlIG1heFxuXHRcdFx0ICogaXMgMTAsIHNldHRpbmcgdGhlIGFtcGxpdHVkZSB0byAwLjUgd291bGQgbWFrZSB0aGUgTEZPIG1vZHVsYXRlXG5cdFx0XHQgKiBiZXR3ZWVuIC01IGFuZCA1LlxuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuYW1wbGl0dWRlID0gdGhpcy5fb3NjaWxsYXRvci52b2x1bWU7XG5cdCAgICAgICAgdGhpcy5hbXBsaXR1ZGUudW5pdHMgPSBUb25lLlR5cGUuTm9ybWFsUmFuZ2U7XG5cdCAgICAgICAgdGhpcy5hbXBsaXR1ZGUudmFsdWUgPSBvcHRpb25zLmFtcGxpdHVkZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc2lnbmFsIHdoaWNoIGlzIG91dHB1dCB3aGVuIHRoZSBMRk8gaXMgc3RvcHBlZFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5TaWduYWx9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N0b3BwZWRTaWduYWwgPSBuZXcgVG9uZS5TaWduYWwoMCwgVG9uZS5UeXBlLkF1ZGlvUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEp1c3Qgb3V0cHV0cyB6ZXJvcy5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5aZXJvfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl96ZXJvcyA9IG5ldyBUb25lLlplcm8oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdmFsdWUgdGhhdCB0aGUgTEZPIG91dHB1dHMgd2hlbiBpdCdzIHN0b3BwZWRcblx0XHRcdCAqICBAdHlwZSB7QXVkaW9SYW5nZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3RvcHBlZFZhbHVlID0gMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BdWRpb1RvR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYTJnID0gbmV3IFRvbmUuQXVkaW9Ub0dhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TY2FsZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2NhbGVyID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5TY2FsZShvcHRpb25zLm1pbiwgb3B0aW9ucy5tYXgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB1bml0cyBvZiB0aGUgTEZPICh1c2VkIGZvciBjb252ZXJ0aW5nKVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlR5cGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3VuaXRzID0gVG9uZS5UeXBlLkRlZmF1bHQ7XG5cdCAgICAgICAgdGhpcy51bml0cyA9IG9wdGlvbnMudW5pdHM7XG5cdCAgICAgICAgLy9jb25uZWN0IGl0IHVwXG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5jaGFpbih0aGlzLl9hMmcsIHRoaXMuX3NjYWxlcik7XG5cdCAgICAgICAgdGhpcy5femVyb3MuY29ubmVjdCh0aGlzLl9hMmcpO1xuXHQgICAgICAgIHRoaXMuX3N0b3BwZWRTaWduYWwuY29ubmVjdCh0aGlzLl9hMmcpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2FtcGxpdHVkZScsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5waGFzZSA9IG9wdGlvbnMucGhhc2U7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5MRk8sIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICpcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTEZPLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd0eXBlJzogJ3NpbmUnLFxuXHQgICAgICAgICdtaW4nOiAwLFxuXHQgICAgICAgICdtYXgnOiAxLFxuXHQgICAgICAgICdwaGFzZSc6IDAsXG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6ICc0bicsXG5cdCAgICAgICAgJ2FtcGxpdHVkZSc6IDEsXG5cdCAgICAgICAgJ3VuaXRzJzogVG9uZS5UeXBlLkRlZmF1bHRcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgdGhlIExGTy5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgTEZPIHdpbGwgc3RhcnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTEZPfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxGTy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsLnNldFZhbHVlQXRUaW1lKDAsIHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3RhcnQodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0b3AgdGhlIExGTy5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgTEZPIHdpbGwgc3RvcFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5MRk99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTEZPLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fc3RvcHBlZFNpZ25hbC5zZXRWYWx1ZUF0VGltZSh0aGlzLl9zdG9wcGVkVmFsdWUsIHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3RvcCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3luYyB0aGUgc3RhcnQvc3RvcC9wYXVzZSB0byB0aGUgdHJhbnNwb3J0XG5cdFx0ICogIGFuZCB0aGUgZnJlcXVlbmN5IHRvIHRoZSBicG0gb2YgdGhlIHRyYW5zcG9ydFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5MRk99IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgbGZvLmZyZXF1ZW5jeS52YWx1ZSA9IFwiOG5cIjtcblx0XHQgKiAgbGZvLnN5bmMoKS5zdGFydCgwKVxuXHRcdCAqICAvL3RoZSByYXRlIG9mIHRoZSBMRk8gd2lsbCBhbHdheXMgYmUgYW4gZWlnaHRoIG5vdGUsXG5cdFx0ICogIC8vZXZlbiBhcyB0aGUgdGVtcG8gY2hhbmdlc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8ucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zeW5jKCk7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zeW5jRnJlcXVlbmN5KCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHVuc3luYyB0aGUgTEZPIGZyb20gdHJhbnNwb3J0IGNvbnRyb2xcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTEZPfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxGTy5wcm90b3R5cGUudW5zeW5jID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IudW5zeW5jKCk7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci51bnN5bmNGcmVxdWVuY3koKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWluaXVtdW0gb3V0cHV0IG9mIHRoZSBMRk8uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTEZPI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgbWluXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MRk8ucHJvdG90eXBlLCAnbWluJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9Vbml0cyh0aGlzLl9zY2FsZXIubWluKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1pbikge1xuXHQgICAgICAgICAgICBtaW4gPSB0aGlzLl9mcm9tVW5pdHMobWluKTtcblx0ICAgICAgICAgICAgdGhpcy5fc2NhbGVyLm1pbiA9IG1pbjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIG91dHB1dCBvZiB0aGUgTEZPLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIG1heFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTEZPLnByb3RvdHlwZSwgJ21heCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvVW5pdHModGhpcy5fc2NhbGVyLm1heCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtYXgpIHtcblx0ICAgICAgICAgICAgbWF4ID0gdGhpcy5fZnJvbVVuaXRzKG1heCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlci5tYXggPSBtYXg7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgb3NjaWxsYXRvcjogc2luZSwgc3F1YXJlLCBzYXd0b290aCwgdHJpYW5nbGUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTEZPI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTEZPLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IudHlwZSA9IHR5cGU7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0b3BwZWRWYWx1ZSA9IHRoaXMuX29zY2lsbGF0b3IuX2dldEluaXRpYWxWYWx1ZSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsLnZhbHVlID0gdGhpcy5fc3RvcHBlZFZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBoYXNlIG9mIHRoZSBMRk8uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTEZPI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgcGhhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxGTy5wcm90b3R5cGUsICdwaGFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29zY2lsbGF0b3IucGhhc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwaGFzZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0b3BwZWRWYWx1ZSA9IHRoaXMuX29zY2lsbGF0b3IuX2dldEluaXRpYWxWYWx1ZSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsLnZhbHVlID0gdGhpcy5fc3RvcHBlZFZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG91dHB1dCB1bml0cyBvZiB0aGUgTEZPLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiBAdHlwZSB7VG9uZS5UeXBlfVxuXHRcdCAqIEBuYW1lIHVuaXRzXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MRk8ucHJvdG90eXBlLCAndW5pdHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl91bml0cztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICB2YXIgY3VycmVudE1pbiA9IHRoaXMubWluO1xuXHQgICAgICAgICAgICB2YXIgY3VycmVudE1heCA9IHRoaXMubWF4O1xuXHQgICAgICAgICAgICAvL2NvbnZlcnQgdGhlIG1pbiBhbmQgdGhlIG1heFxuXHQgICAgICAgICAgICB0aGlzLl91bml0cyA9IHZhbDtcblx0ICAgICAgICAgICAgdGhpcy5taW4gPSBjdXJyZW50TWluO1xuXHQgICAgICAgICAgICB0aGlzLm1heCA9IGN1cnJlbnRNYXg7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBNdXRlIHRoZSBvdXRwdXQuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTEZPI1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBuYW1lIG11dGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxGTy5wcm90b3R5cGUsICdtdXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci5tdXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobXV0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLm11dGUgPSBtdXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBzb3VyY2UsIGVpdGhlciBcInN0YXJ0ZWRcIiBvciBcInN0b3BwZWRcIi5cblx0XHQgKiAgQHR5cGUge1RvbmUuU3RhdGV9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5MRk8jXG5cdFx0ICogIEBuYW1lIHN0YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MRk8ucHJvdG90eXBlLCAnc3RhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLnN0YXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENvbm5lY3QgdGhlIG91dHB1dCBvZiB0aGUgTEZPIHRvIGFuIEF1ZGlvUGFyYW0sIEF1ZGlvTm9kZSwgb3IgVG9uZSBOb2RlLlxuXHRcdCAqICBUb25lLkxGTyB3aWxsIGF1dG9tYXRpY2FsbHkgY29udmVydCB0byB0aGUgZGVzdGluYXRpb24gdW5pdHMgb2YgdGhlXG5cdFx0ICogIHdpbGwgZ2V0IHRoZSB1bml0cyBmcm9tIHRoZSBjb25uZWN0ZWQgbm9kZS5cblx0XHQgKiAgQHBhcmFtICB7VG9uZSB8IEF1ZGlvUGFyYW0gfCBBdWRpb05vZGV9IG5vZGVcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtvdXRwdXROdW09MF0gb3B0aW9uYWxseSB3aGljaCBvdXRwdXQgdG8gY29ubmVjdCBmcm9tXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXROdW09MF0gb3B0aW9uYWxseSB3aGljaCBpbnB1dCB0byBjb25uZWN0IHRvXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkxGT30gdGhpc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgIGlmIChub2RlLmNvbnN0cnVjdG9yID09PSBUb25lLlNpZ25hbCB8fCBub2RlLmNvbnN0cnVjdG9yID09PSBUb25lLlBhcmFtIHx8IG5vZGUuY29uc3RydWN0b3IgPT09IFRvbmUuVGltZWxpbmVTaWduYWwpIHtcblx0ICAgICAgICAgICAgdGhpcy5jb252ZXJ0ID0gbm9kZS5jb252ZXJ0O1xuXHQgICAgICAgICAgICB0aGlzLnVuaXRzID0gbm9kZS51bml0cztcblx0ICAgICAgICB9XG5cdCAgICAgICAgVG9uZS5TaWduYWwucHJvdG90eXBlLmNvbm5lY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgcHJpdmF0ZSBtZXRob2QgYm9ycm93ZWQgZnJvbSBQYXJhbSBjb252ZXJ0c1xuXHRcdCAqICB1bml0cyBmcm9tIHRoZWlyIGRlc3RpbmF0aW9uIHZhbHVlXG5cdFx0ICogIEBmdW5jdGlvblxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8ucHJvdG90eXBlLl9mcm9tVW5pdHMgPSBUb25lLlBhcmFtLnByb3RvdHlwZS5fZnJvbVVuaXRzO1xuXHQgICAgLyoqXG5cdFx0ICogIHByaXZhdGUgbWV0aG9kIGJvcnJvd2VkIGZyb20gUGFyYW0gY29udmVydHNcblx0XHQgKiAgdW5pdHMgdG8gdGhlaXIgZGVzdGluYXRpb24gdmFsdWVcblx0XHQgKiAgQGZ1bmN0aW9uXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkxGTy5wcm90b3R5cGUuX3RvVW5pdHMgPSBUb25lLlBhcmFtLnByb3RvdHlwZS5fdG9Vbml0cztcblx0ICAgIC8qKlxuXHRcdCAqICBkaXNjb25uZWN0IGFuZCBkaXNwb3NlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkxGT30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdhbXBsaXR1ZGUnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3N0b3BwZWRTaWduYWwuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3N0b3BwZWRTaWduYWwgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3plcm9zLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl96ZXJvcyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc2NhbGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2EyZy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYTJnID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5hbXBsaXR1ZGUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkxGTztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuTGltaXRlciB3aWxsIGxpbWl0IHRoZSBsb3VkbmVzcyBvZiBhbiBpbmNvbWluZyBzaWduYWwuXG5cdFx0ICogICAgICAgICBJdCBpcyBjb21wb3NlZCBvZiBhIFRvbmUuQ29tcHJlc3NvciB3aXRoIGEgZmFzdCBhdHRhY2tcblx0XHQgKiAgICAgICAgIGFuZCByZWxlYXNlLiBMaW1pdGVycyBhcmUgY29tbW9ubHkgdXNlZCB0byBzYWZlZ3VhcmQgYWdhaW5zdFxuXHRcdCAqICAgICAgICAgc2lnbmFsIGNsaXBwaW5nLiBVbmxpa2UgYSBjb21wcmVzc29yLCBsaW1pdGVycyBkbyBub3QgcHJvdmlkZVxuXHRcdCAqICAgICAgICAgc21vb3RoIGdhaW4gcmVkdWN0aW9uIGFuZCBhbG1vc3QgY29tcGxldGVseSBwcmV2ZW50XG5cdFx0ICogICAgICAgICBhZGRpdGlvbmFsIGdhaW4gYWJvdmUgdGhlIHRocmVzaG9sZC5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkIFRoZSB0aGVzaG9sZCBhYm92ZSB3aGljaCB0aGUgbGltaXRpbmcgaXMgYXBwbGllZC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgdmFyIGxpbWl0ZXIgPSBuZXcgVG9uZS5MaW1pdGVyKC02KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTGltaXRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ3RocmVzaG9sZCddLCBUb25lLkxpbWl0ZXIpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGNvbXByZXNzb3Jcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkNvbXByZXNzb3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jb21wcmVzc29yID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuQ29tcHJlc3Nvcih7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAwMSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMC4wMDEsXG5cdCAgICAgICAgICAgICd0aHJlc2hvbGQnOiBvcHRpb25zLnRocmVzaG9sZFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIHRocmVzaG9sZCBvZiBvZiB0aGUgbGltaXRlclxuXHRcdFx0ICogQHR5cGUge0RlY2liZWx9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnRocmVzaG9sZCA9IHRoaXMuX2NvbXByZXNzb3IudGhyZXNob2xkO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCd0aHJlc2hvbGQnKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkxpbWl0ZXIsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZVxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MaW1pdGVyLmRlZmF1bHRzID0geyAndGhyZXNob2xkJzogLTEyIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkxpbWl0ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTGltaXRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2NvbXByZXNzb3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2NvbXByZXNzb3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCd0aHJlc2hvbGQnKTtcblx0ICAgICAgICB0aGlzLnRocmVzaG9sZCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTGltaXRlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuTG93cGFzcyBpcyBhIGxvd3Bhc3MgZmVlZGJhY2sgY29tYiBmaWx0ZXIuIEl0IGlzIHNpbWlsYXIgdG9cblx0XHQgKiAgICAgICAgIFRvbmUuRmVlZGJhY2tDb21iRmlsdGVyLCBidXQgaW5jbHVkZXMgYSBsb3dwYXNzIGZpbHRlci5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge1RpbWV8T2JqZWN0fSBbZGVsYXlUaW1lXSBUaGUgZGVsYXkgdGltZSBvZiB0aGUgY29tYiBmaWx0ZXJcblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZT19IHJlc29uYW5jZSBUaGUgcmVzb25hbmNlIChmZWVkYmFjaykgb2YgdGhlIGNvbWIgZmlsdGVyXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5PX0gZGFtcGVuaW5nIFRoZSBjdXRvZmYgb2YgdGhlIGxvd3Bhc3MgZmlsdGVyIGRhbXBlbnMgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbCBhcyBpdCBpcyBmZWRiYWNrLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5Mb3dwYXNzQ29tYkZpbHRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnLFxuXHQgICAgICAgICAgICAncmVzb25hbmNlJyxcblx0ICAgICAgICAgICAgJ2RhbXBlbmluZydcblx0ICAgICAgICBdLCBUb25lLkxvd3Bhc3NDb21iRmlsdGVyKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygxLCAxKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZGVsYXkgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtEZWxheU5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RlbGF5ID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLkRlbGF5KG9wdGlvbnMuZGVsYXlUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGVsYXlUaW1lIG9mIHRoZSBjb21iIGZpbHRlci5cblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IHRoaXMuX2RlbGF5LmRlbGF5VGltZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbG93cGFzcyBmaWx0ZXJcblx0XHRcdCAqICBAdHlwZSAge0JpcXVhZEZpbHRlck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvd3Bhc3MgPSB0aGlzLm91dHB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcblx0ICAgICAgICB0aGlzLl9sb3dwYXNzLlEudmFsdWUgPSAtMy4wMTAyOTk5NTY2Mzk4MTI1O1xuXHQgICAgICAgIHRoaXMuX2xvd3Bhc3MudHlwZSA9ICdsb3dwYXNzJztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGFtcGVuaW5nIGNvbnRyb2wgb2YgdGhlIGZlZWRiYWNrXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRhbXBlbmluZyA9IG5ldyBUb25lLlBhcmFtKHtcblx0ICAgICAgICAgICAgJ3BhcmFtJzogdGhpcy5fbG93cGFzcy5mcmVxdWVuY3ksXG5cdCAgICAgICAgICAgICd1bml0cyc6IFRvbmUuVHlwZS5GcmVxdWVuY3ksXG5cdCAgICAgICAgICAgICd2YWx1ZSc6IG9wdGlvbnMuZGFtcGVuaW5nXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGZlZWRiYWNrIGdhaW5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFjayA9IG5ldyBUb25lLkdhaW4ob3B0aW9ucy5yZXNvbmFuY2UsIFRvbmUuVHlwZS5Ob3JtYWxSYW5nZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBmZWVkYmFjayBvZiB0aGUgZGVsYXllZCBzaWduYWwuXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmVzb25hbmNlID0gdGhpcy5fZmVlZGJhY2suZ2Fpbjtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5fZGVsYXkuY2hhaW4odGhpcy5fbG93cGFzcywgdGhpcy5fZmVlZGJhY2ssIHRoaXMuX2RlbGF5KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnLFxuXHQgICAgICAgICAgICAncmVzb25hbmNlJyxcblx0ICAgICAgICAgICAgJ2RlbGF5VGltZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkxvd3Bhc3NDb21iRmlsdGVyLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Mb3dwYXNzQ29tYkZpbHRlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZGVsYXlUaW1lJzogMC4xLFxuXHQgICAgICAgICdyZXNvbmFuY2UnOiAwLjUsXG5cdCAgICAgICAgJ2RhbXBlbmluZyc6IDMwMDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkxvd3Bhc3NDb21iRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxvd3Bhc3NDb21iRmlsdGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZGFtcGVuaW5nJyxcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZScsXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGFtcGVuaW5nID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnJlc29uYW5jZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5yZXNvbmFuY2UgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xvd3Bhc3MuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2xvd3Bhc3MgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFjayA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTG93cGFzc0NvbWJGaWx0ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5NZXJnZSBicmluZ3MgdHdvIHNpZ25hbHMgaW50byB0aGUgbGVmdCBhbmQgcmlnaHRcblx0XHQgKiAgICAgICAgICBjaGFubmVscyBvZiBhIHNpbmdsZSBzdGVyZW8gY2hhbm5lbC5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBtZXJnZSA9IG5ldyBUb25lLk1lcmdlKCkudG9NYXN0ZXIoKTtcblx0XHQgKiAvL3JvdXRpbmcgYSBzaW5lIHRvbmUgaW4gdGhlIGxlZnQgY2hhbm5lbFxuXHRcdCAqIC8vYW5kIG5vaXNlIGluIHRoZSByaWdodCBjaGFubmVsXG5cdFx0ICogdmFyIG9zYyA9IG5ldyBUb25lLk9zY2lsbGF0b3IoKS5jb25uZWN0KG1lcmdlLmxlZnQpO1xuXHRcdCAqIHZhciBub2lzZSA9IG5ldyBUb25lLk5vaXNlKCkuY29ubmVjdChtZXJnZS5yaWdodCk7XG5cdFx0ICogLy9zdGFydGluZyBvdXIgb3NjaWxsYXRvcnNcblx0XHQgKiBub2lzZS5zdGFydCgpO1xuXHRcdCAqIG9zYy5zdGFydCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NZXJnZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygyLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbGVmdCBpbnB1dCBjaGFubmVsLlxuXHRcdFx0ICogIEFsaWFzIGZvciA8Y29kZT5pbnB1dFswXTwvY29kZT5cblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmxlZnQgPSB0aGlzLmlucHV0WzBdID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSByaWdodCBpbnB1dCBjaGFubmVsLlxuXHRcdFx0ICogIEFsaWFzIGZvciA8Y29kZT5pbnB1dFsxXTwvY29kZT4uXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHRoaXMuaW5wdXRbMV0gPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG1lcmdlciBub2RlIGZvciB0aGUgdHdvIGNoYW5uZWxzXG5cdFx0XHQgKiAgQHR5cGUge0NoYW5uZWxNZXJnZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tZXJnZXIgPSB0aGlzLm91dHB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKDIpO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmxlZnQuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDApO1xuXHQgICAgICAgIHRoaXMucmlnaHQuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMubGVmdC5jaGFubmVsQ291bnQgPSAxO1xuXHQgICAgICAgIHRoaXMucmlnaHQuY2hhbm5lbENvdW50ID0gMTtcblx0ICAgICAgICB0aGlzLmxlZnQuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG5cdCAgICAgICAgdGhpcy5yaWdodC5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0Jztcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1lcmdlLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1lcmdlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1lcmdlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5sZWZ0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmxlZnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMucmlnaHQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMucmlnaHQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21lcmdlci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fbWVyZ2VyID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5NZXJnZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLk1ldGVyIGdldHMgdGhlIFtSTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jvb3RfbWVhbl9zcXVhcmUpXG5cdFx0ICogICAgICAgICAgb2YgYW4gaW5wdXQgc2lnbmFsIHdpdGggc29tZSBhdmVyYWdpbmcgYXBwbGllZC4gSXQgY2FuIGFsc28gZ2V0IHRoZSByYXdcblx0XHQgKiAgICAgICAgICB2YWx1ZSBvZiB0aGUgaW5wdXQgc2lnbmFsLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEVpdGhlciBcImxldmVsXCIgb3IgXCJzaWduYWxcIi5cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IHNtb290aGluZyBUaGUgYW1vdW50IG9mIHNtb290aGluZyBhcHBsaWVkIGJldHdlZW4gZnJhbWVzLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBtZXRlciA9IG5ldyBUb25lLk1ldGVyKCk7XG5cdFx0ICogdmFyIG1pYyA9IG5ldyBUb25lLlVzZXJNZWRpYSgpLm9wZW4oKTtcblx0XHQgKiAvL2Nvbm5lY3QgbWljIHRvIHRoZSBtZXRlclxuXHRcdCAqIG1pYy5jb25uZWN0KG1ldGVyKTtcblx0XHQgKiAvL3RoZSBjdXJyZW50IGxldmVsIG9mIHRoZSBtaWMgaW5wdXRcblx0XHQgKiB2YXIgbGV2ZWwgPSBtZXRlci52YWx1ZTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndHlwZScsXG5cdCAgICAgICAgICAgICdzbW9vdGhpbmcnXG5cdCAgICAgICAgXSwgVG9uZS5NZXRlcik7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdHlwZSBvZiB0aGUgbWV0ZXIsIGVpdGhlciBcImxldmVsXCIgb3IgXCJzaWduYWxcIi5cblx0XHRcdCAqICBBIFwibGV2ZWxcIiBtZXRlciB3aWxsIHJldHVybiB0aGUgdm9sdW1lIGxldmVsIChybXMpIG9mIHRoZVxuXHRcdFx0ICogIGlucHV0IHNpZ25hbCBhbmQgYSBcInNpZ25hbFwiIG1ldGVyIHdpbGwgcmV0dXJuXG5cdFx0XHQgKiAgdGhlIHNpZ25hbCB2YWx1ZSBvZiB0aGUgaW5wdXQuXG5cdFx0XHQgKiAgQHR5cGUgIHtTdHJpbmd9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFuYWx5c2VyIG5vZGUgd2hpY2ggY29tcHV0ZXMgdGhlIGxldmVscy5cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5BbmFseXNlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IHRoaXMuX2FuYWx5c2VyID0gbmV3IFRvbmUuQW5hbHlzZXIoJ3dhdmVmb3JtJywgNTEyKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIGNhcnJ5b3ZlciBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCBsYXN0IGZyYW1lLlxuXHRcdFx0ICogIE9ubHkgYXBwbGllZCBtZXRlciBmb3IgXCJsZXZlbFwiIHR5cGUuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnNtb290aGluZyA9IG9wdGlvbnMuc21vb3RoaW5nO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBsYXN0IGNvbXB1dGVkIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGFzdFZhbHVlID0gMDtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1ldGVyLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQGVudW0ge1N0cmluZ31cblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0ZXIuVHlwZSA9IHtcblx0ICAgICAgICBMZXZlbDogJ2xldmVsJyxcblx0ICAgICAgICBTaWduYWw6ICdzaWduYWwnXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5NZXRlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnc21vb3RoaW5nJzogMC44LFxuXHQgICAgICAgICd0eXBlJzogVG9uZS5NZXRlci5UeXBlLkxldmVsXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIG1ldGVyLiBBIHZhbHVlIG9mIDEgaXNcblx0XHQgKiBcInVuaXR5XCIuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTWV0ZXIjXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSB2YWx1ZVxuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTWV0ZXIucHJvdG90eXBlLCAndmFsdWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBzaWduYWwgPSB0aGlzLl9hbmFseXNlci5hbmFseXNlKCk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFRvbmUuTWV0ZXIuVHlwZS5MZXZlbCkge1xuXHQgICAgICAgICAgICAgICAgLy9ybXNcblx0ICAgICAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduYWwubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdW0gKz0gTWF0aC5wb3coc2lnbmFsW2ldLCAyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBybXMgPSBNYXRoLnNxcnQoc3VtIC8gc2lnbmFsLmxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICAvL3Ntb290aCBpdFxuXHQgICAgICAgICAgICAgICAgcm1zID0gTWF0aC5tYXgocm1zLCB0aGlzLl9sYXN0VmFsdWUgKiB0aGlzLnNtb290aGluZyk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sYXN0VmFsdWUgPSBybXM7XG5cdCAgICAgICAgICAgICAgICAvL3NjYWxlIGl0XG5cdCAgICAgICAgICAgICAgICB2YXIgdW5pdHkgPSAwLjM1O1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHJtcyAvIHVuaXR5O1xuXHQgICAgICAgICAgICAgICAgLy9zY2FsZSB0aGUgb3V0cHV0IGN1cnZlXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHZhbCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsWzBdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1ldGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fYW5hbHlzZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2FuYWx5c2VyID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5NZXRlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKlx0QGNsYXNzICBUb25lLlNwbGl0IHNwbGl0cyBhbiBpbmNvbWluZyBzaWduYWwgaW50byBsZWZ0IGFuZCByaWdodCBjaGFubmVscy5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzcGxpdCA9IG5ldyBUb25lLlNwbGl0KCk7XG5cdFx0ICogc3RlcmVvU2lnbmFsLmNvbm5lY3Qoc3BsaXQpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TcGxpdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygwLCAyKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7Q2hhbm5lbFNwbGl0dGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3BsaXR0ZXIgPSB0aGlzLmlucHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcigyKTtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5jaGFubmVsQ291bnQgPSAyO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLmNoYW5uZWxDb3VudE1vZGUgPSAnZXhwbGljaXQnO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIExlZnQgY2hhbm5lbCBvdXRwdXQuXG5cdFx0XHQgKiAgQWxpYXMgZm9yIDxjb2RlPm91dHB1dFswXTwvY29kZT5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5vdXRwdXRbMF0gPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgUmlnaHQgY2hhbm5lbCBvdXRwdXQuXG5cdFx0XHQgKiAgQWxpYXMgZm9yIDxjb2RlPm91dHB1dFsxXTwvY29kZT5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHRoaXMub3V0cHV0WzFdID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMubGVmdCwgMCwgMCk7XG5cdCAgICAgICAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLnJpZ2h0LCAxLCAwKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlNwbGl0LCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNwbGl0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNwbGl0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc3BsaXR0ZXIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMubGVmdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnJpZ2h0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU3BsaXQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBNaWQvU2lkZSBwcm9jZXNzaW5nIHNlcGFyYXRlcyB0aGUgdGhlICdtaWQnIHNpZ25hbFxuXHRcdCAqICAgICAgICAgKHdoaWNoIGNvbWVzIG91dCBvZiBib3RoIHRoZSBsZWZ0IGFuZCB0aGUgcmlnaHQgY2hhbm5lbClcblx0XHQgKiAgICAgICAgIGFuZCB0aGUgJ3NpZGUnICh3aGljaCBvbmx5IGNvbWVzIG91dCBvZiB0aGUgdGhlIHNpZGUgY2hhbm5lbHMpLiA8YnI+PGJyPlxuXHRcdCAqICAgICAgICAgPGNvZGU+XG5cdFx0ICogICAgICAgICBNaWQgPSAoTGVmdCtSaWdodCkvc3FydCgyKTsgICAvLyBvYnRhaW4gbWlkLXNpZ25hbCBmcm9tIGxlZnQgYW5kIHJpZ2h0PGJyPlxuXHRcdCAqICAgICAgICAgU2lkZSA9IChMZWZ0LVJpZ2h0KS9zcXJ0KDIpOyAgIC8vIG9idGFpbiBzaWRlLXNpZ25hbCBmcm9tIGxlZnQgYW5kIHJpZ2g8YnI+XG5cdFx0ICogICAgICAgICA8L2NvZGU+XG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0ICAgIFRvbmUuTWlkU2lkZVNwbGl0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDAsIDIpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHNwbGl0IHRoZSBpbmNvbWluZyBzaWduYWwgaW50byBsZWZ0IGFuZCByaWdodCBjaGFubmVsc1xuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5TcGxpdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3BsaXQgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuU3BsaXQoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWlkIHNlbmQuIENvbm5lY3QgdG8gbWlkIHByb2Nlc3NpbmcuIEFsaWFzIGZvclxuXHRcdFx0ICogIDxjb2RlPm91dHB1dFswXTwvY29kZT5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5FeHByfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5taWQgPSB0aGlzLm91dHB1dFswXSA9IG5ldyBUb25lLkV4cHIoJygkMCArICQxKSAqICQyJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHNpZGUgb3V0cHV0LiBDb25uZWN0IHRvIHNpZGUgcHJvY2Vzc2luZy4gQWxpYXMgZm9yXG5cdFx0XHQgKiAgPGNvZGU+b3V0cHV0WzFdPC9jb2RlPlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkV4cHJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnNpZGUgPSB0aGlzLm91dHB1dFsxXSA9IG5ldyBUb25lLkV4cHIoJygkMCAtICQxKSAqICQyJyk7XG5cdCAgICAgICAgdGhpcy5fc3BsaXQuY29ubmVjdCh0aGlzLm1pZCwgMCwgMCk7XG5cdCAgICAgICAgdGhpcy5fc3BsaXQuY29ubmVjdCh0aGlzLm1pZCwgMSwgMSk7XG5cdCAgICAgICAgdGhpcy5fc3BsaXQuY29ubmVjdCh0aGlzLnNpZGUsIDAsIDApO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0LmNvbm5lY3QodGhpcy5zaWRlLCAxLCAxKTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZ2V0Q29uc3RhbnQoTWF0aC5TUVJUMV8yKS5jb25uZWN0KHRoaXMubWlkLCAwLCAyKTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZ2V0Q29uc3RhbnQoTWF0aC5TUVJUMV8yKS5jb25uZWN0KHRoaXMuc2lkZSwgMCwgMik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NaWRTaWRlU3BsaXQsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NaWRTaWRlU3BsaXR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWlkU2lkZVNwbGl0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5taWQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMubWlkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnNpZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuc2lkZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3BsaXQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5NaWRTaWRlU3BsaXQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBNaWQvU2lkZSBwcm9jZXNzaW5nIHNlcGFyYXRlcyB0aGUgdGhlICdtaWQnIHNpZ25hbFxuXHRcdCAqICAgICAgICAgKHdoaWNoIGNvbWVzIG91dCBvZiBib3RoIHRoZSBsZWZ0IGFuZCB0aGUgcmlnaHQgY2hhbm5lbClcblx0XHQgKiAgICAgICAgIGFuZCB0aGUgJ3NpZGUnICh3aGljaCBvbmx5IGNvbWVzIG91dCBvZiB0aGUgdGhlIHNpZGUgY2hhbm5lbHMpLlxuXHRcdCAqICAgICAgICAgTWlkU2lkZU1lcmdlIG1lcmdlcyB0aGUgbWlkIGFuZCBzaWRlIHNpZ25hbCBhZnRlciB0aGV5J3ZlIGJlZW4gc2VwZXJhdGVkXG5cdFx0ICogICAgICAgICBieSBUb25lLk1pZFNpZGVTcGxpdC48YnI+PGJyPlxuXHRcdCAqICAgICAgICAgPGNvZGU+XG5cdFx0ICogICAgICAgICBMZWZ0ID0gKE1pZCtTaWRlKS9zcXJ0KDIpOyAgIC8vIG9idGFpbiBsZWZ0IHNpZ25hbCBmcm9tIG1pZCBhbmQgc2lkZTxicj5cblx0XHQgKiAgICAgICAgIFJpZ2h0ID0gKE1pZC1TaWRlKS9zcXJ0KDIpOyAgIC8vIG9idGFpbiByaWdodCBzaWduYWwgZnJvbSBtaWQgYW5kIHNpZGU8YnI+XG5cdFx0ICogICAgICAgICA8L2NvZGU+XG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0ICAgIFRvbmUuTWlkU2lkZU1lcmdlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDIsIDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaWQgc2lnbmFsIGlucHV0LiBBbGlhcyBmb3Jcblx0XHRcdCAqICA8Y29kZT5pbnB1dFswXTwvY29kZT5cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuR2Fpbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWlkID0gdGhpcy5pbnB1dFswXSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICByZWNvbWJpbmUgdGhlIG1pZC9zaWRlIGludG8gTGVmdFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkV4cHJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xlZnQgPSBuZXcgVG9uZS5FeHByKCcoJDAgKyAkMSkgKiAkMicpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBzaWRlIHNpZ25hbCBpbnB1dC4gQWxpYXMgZm9yXG5cdFx0XHQgKiAgPGNvZGU+aW5wdXRbMV08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnNpZGUgPSB0aGlzLmlucHV0WzFdID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHJlY29tYmluZSB0aGUgbWlkL3NpZGUgaW50byBSaWdodFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkV4cHJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0ID0gbmV3IFRvbmUuRXhwcignKCQwIC0gJDEpICogJDInKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBNZXJnZSB0aGUgbGVmdC9yaWdodCBzaWduYWwgYmFjayBpbnRvIGEgc3RlcmVvIHNpZ25hbC5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NZXJnZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWVyZ2UgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLk1lcmdlKCk7XG5cdCAgICAgICAgdGhpcy5taWQuY29ubmVjdCh0aGlzLl9sZWZ0LCAwLCAwKTtcblx0ICAgICAgICB0aGlzLnNpZGUuY29ubmVjdCh0aGlzLl9sZWZ0LCAwLCAxKTtcblx0ICAgICAgICB0aGlzLm1pZC5jb25uZWN0KHRoaXMuX3JpZ2h0LCAwLCAwKTtcblx0ICAgICAgICB0aGlzLnNpZGUuY29ubmVjdCh0aGlzLl9yaWdodCwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy5fbGVmdC5jb25uZWN0KHRoaXMuX21lcmdlLCAwLCAwKTtcblx0ICAgICAgICB0aGlzLl9yaWdodC5jb25uZWN0KHRoaXMuX21lcmdlLCAwLCAxKTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZ2V0Q29uc3RhbnQoTWF0aC5TUVJUMV8yKS5jb25uZWN0KHRoaXMuX2xlZnQsIDAsIDIpO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5nZXRDb25zdGFudChNYXRoLlNRUlQxXzIpLmNvbm5lY3QodGhpcy5fcmlnaHQsIDAsIDIpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTWlkU2lkZU1lcmdlLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTWlkU2lkZU1lcmdlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1pZFNpZGVNZXJnZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMubWlkLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1pZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5zaWRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnNpZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xlZnQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xlZnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9yaWdodCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbWVyZ2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21lcmdlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5NaWRTaWRlTWVyZ2U7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLk1pZFNpZGVDb21wcmVzc29yIGFwcGxpZXMgdHdvIGRpZmZlcmVudCBjb21wcmVzc29ycyB0byB0aGUgbWlkXG5cdFx0ICogICAgICAgICBhbmQgc2lkZSBzaWduYWwgY29tcG9uZW50cy4gU2VlIFRvbmUuTWlkU2lkZVNwbGl0LlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSBtaWQgYW5kIHNpZGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3NvcnMuXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHQgICAgVG9uZS5NaWRTaWRlQ29tcHJlc3NvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuTWlkU2lkZUNvbXByZXNzb3IuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBtaWQvc2lkZSBzcGxpdFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5NaWRTaWRlU3BsaXR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVTcGxpdCA9IHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5NaWRTaWRlU3BsaXQoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbWlkL3NpZGUgcmVjb21iaW5hdGlvblxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5NaWRTaWRlTWVyZ2V9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVNZXJnZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuTWlkU2lkZU1lcmdlKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNvbXByZXNzb3IgYXBwbGllZCB0byB0aGUgbWlkIHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Db21wcmVzc29yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5taWQgPSBuZXcgVG9uZS5Db21wcmVzc29yKG9wdGlvbnMubWlkKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY29tcHJlc3NvciBhcHBsaWVkIHRvIHRoZSBzaWRlIHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Db21wcmVzc29yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5zaWRlID0gbmV3IFRvbmUuQ29tcHJlc3NvcihvcHRpb25zLnNpZGUpO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVTcGxpdC5taWQuY2hhaW4odGhpcy5taWQsIHRoaXMuX21pZFNpZGVNZXJnZS5taWQpO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVTcGxpdC5zaWRlLmNoYWluKHRoaXMuc2lkZSwgdGhpcy5fbWlkU2lkZU1lcmdlLnNpZGUpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ21pZCcsXG5cdCAgICAgICAgICAgICdzaWRlJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTWlkU2lkZUNvbXByZXNzb3IsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5NaWRTaWRlQ29tcHJlc3Nvci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnbWlkJzoge1xuXHQgICAgICAgICAgICAncmF0aW8nOiAzLFxuXHQgICAgICAgICAgICAndGhyZXNob2xkJzogLTI0LFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IDAuMDMsXG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAyLFxuXHQgICAgICAgICAgICAna25lZSc6IDE2XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnc2lkZSc6IHtcblx0ICAgICAgICAgICAgJ3JhdGlvJzogNixcblx0ICAgICAgICAgICAgJ3RocmVzaG9sZCc6IC0zMCxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjI1LFxuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC4wMyxcblx0ICAgICAgICAgICAgJ2tuZWUnOiAxMFxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1pZFNpZGVDb21wcmVzc29yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1pZFNpZGVDb21wcmVzc29yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnbWlkJyxcblx0ICAgICAgICAgICAgJ3NpZGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5taWQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMubWlkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnNpZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuc2lkZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZVNwbGl0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlU3BsaXQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVNZXJnZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZU1lcmdlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5NaWRTaWRlQ29tcHJlc3Nvcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuTW9ubyBjb2VyY2VzIHRoZSBpbmNvbWluZyBtb25vIG9yIHN0ZXJlbyBzaWduYWwgaW50byBhIG1vbm8gc2lnbmFsXG5cdFx0ICogICAgICAgICB3aGVyZSBib3RoIGxlZnQgYW5kIHJpZ2h0IGNoYW5uZWxzIGhhdmUgdGhlIHNhbWUgdmFsdWUuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuXHRcdCAqICAgICAgICAgZm9yIFtzdGVyZW8gaW1hZ2luZ10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RlcmVvX2ltYWdpbmcpLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMSwgMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgbWVyZ2UgdGhlIHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk1lcmdlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tZXJnZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuTWVyZ2UoKTtcblx0ICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fbWVyZ2UsIDAsIDApO1xuXHQgICAgICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl9tZXJnZSwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy5pbnB1dC5nYWluLnZhbHVlID0gVG9uZS5kYlRvR2FpbigtMTApO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTW9ubyk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9ub30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbWVyZ2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21lcmdlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Nb25vO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQSBjb21wcmVzc29yIHdpdGggc2VwZXJhdGUgY29udHJvbHMgb3ZlciBsb3cvbWlkL2hpZ2ggZHluYW1pY3Ncblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgbG93L21pZC9oaWdoIGNvbXByZXNzb3Igc2V0dGluZ3MuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIHZhciBtdWx0aWJhbmQgPSBuZXcgVG9uZS5NdWx0aWJhbmRDb21wcmVzc29yKHtcblx0XHQgKiAgXHRcImxvd0ZyZXF1ZW5jeVwiIDogMjAwLFxuXHRcdCAqICBcdFwiaGlnaEZyZXF1ZW5jeVwiIDogMTMwMFxuXHRcdCAqICBcdFwibG93XCIgOiB7XG5cdFx0ICogIFx0XHRcInRocmVzaG9sZFwiIDogLTEyXG5cdFx0ICogIFx0fVxuXHRcdCAqICB9KVxuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aWJhbmRDb21wcmVzc29yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcoYXJndW1lbnRzLCBUb25lLk11bHRpYmFuZENvbXByZXNzb3IuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHNwbGl0IHRoZSBpbmNvbWluZyBzaWduYWwgaW50byBoaWdoL21pZC9sb3dcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NdWx0aWJhbmRTcGxpdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3BsaXR0ZXIgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuTXVsdGliYW5kU3BsaXQoe1xuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5Jzogb3B0aW9ucy5sb3dGcmVxdWVuY3ksXG5cdCAgICAgICAgICAgICdoaWdoRnJlcXVlbmN5Jzogb3B0aW9ucy5oaWdoRnJlcXVlbmN5XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgbG93L21pZCBjcm9zc292ZXIgZnJlcXVlbmN5LlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kgPSB0aGlzLl9zcGxpdHRlci5sb3dGcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgbWlkL2hpZ2ggY3Jvc3NvdmVyIGZyZXF1ZW5jeS5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGlnaEZyZXF1ZW5jeSA9IHRoaXMuX3NwbGl0dGVyLmhpZ2hGcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG91dHB1dFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjb21wcmVzc29yIGFwcGxpZWQgdG8gdGhlIGxvdyBmcmVxdWVuY2llcy5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Db21wcmVzc29yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5sb3cgPSBuZXcgVG9uZS5Db21wcmVzc29yKG9wdGlvbnMubG93KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY29tcHJlc3NvciBhcHBsaWVkIHRvIHRoZSBtaWQgZnJlcXVlbmNpZXMuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ29tcHJlc3Nvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWlkID0gbmV3IFRvbmUuQ29tcHJlc3NvcihvcHRpb25zLm1pZCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNvbXByZXNzb3IgYXBwbGllZCB0byB0aGUgaGlnaCBmcmVxdWVuY2llcy5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Db21wcmVzc29yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oaWdoID0gbmV3IFRvbmUuQ29tcHJlc3NvcihvcHRpb25zLmhpZ2gpO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgY29tcHJlc3NvclxuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLmxvdy5jaGFpbih0aGlzLmxvdywgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLm1pZC5jaGFpbih0aGlzLm1pZCwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLmhpZ2guY2hhaW4odGhpcy5oaWdoLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnaGlnaCcsXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnbG93Jyxcblx0ICAgICAgICAgICAgJ2hpZ2hGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTXVsdGliYW5kQ29tcHJlc3NvciwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpYmFuZENvbXByZXNzb3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2xvdyc6IFRvbmUuQ29tcHJlc3Nvci5kZWZhdWx0cyxcblx0ICAgICAgICAnbWlkJzogVG9uZS5Db21wcmVzc29yLmRlZmF1bHRzLFxuXHQgICAgICAgICdoaWdoJzogVG9uZS5Db21wcmVzc29yLmRlZmF1bHRzLFxuXHQgICAgICAgICdsb3dGcmVxdWVuY3knOiAyNTAsXG5cdCAgICAgICAgJ2hpZ2hGcmVxdWVuY3knOiAyMDAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk11bHRpYmFuZENvbXByZXNzb3J9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGliYW5kQ29tcHJlc3Nvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdoaWdoJyxcblx0ICAgICAgICAgICAgJ21pZCcsXG5cdCAgICAgICAgICAgICdsb3cnLFxuXHQgICAgICAgICAgICAnaGlnaEZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdsb3dGcmVxdWVuY3knXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5sb3cuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMubWlkLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmhpZ2guZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmxvdyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5taWQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGlnaCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGlnaEZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTXVsdGliYW5kQ29tcHJlc3Nvcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLlBhbm5lciBpcyBhbiBlcXVhbCBwb3dlciBMZWZ0L1JpZ2h0IFBhbm5lciBhbmQgZG9lcyBub3Rcblx0XHQgKiAgICAgICAgICBzdXBwb3J0IDNELiBQYW5uZXIgdXNlcyB0aGUgU3RlcmVvUGFubmVyTm9kZSB3aGVuIGF2YWlsYWJsZS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbaW5pdGlhbFBhbj0wXSBUaGUgaW5pdGFpbCBwYW5uZXIgdmFsdWUgKGNlbnRlcikuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIC8vcGFuIHRoZSBpbnB1dCBzaWduYWwgaGFyZCByaWdodC5cblx0XHQgKiAgdmFyIHBhbm5lciA9IG5ldyBUb25lLlBhbm5lcigxKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyID0gZnVuY3Rpb24gKGluaXRpYWxQYW4pIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGlmIChUb25lLlBhbm5lci5oYXNTdGVyZW9QYW5uZXIpIHtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICB0aGUgcGFubmVyIG5vZGVcblx0XHRcdFx0ICogIEB0eXBlIHtTdGVyZW9QYW5uZXJOb2RlfVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lciA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVTdGVyZW9QYW5uZXIoKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBUaGUgcGFuIGNvbnRyb2wuIC0xID0gaGFyZCBsZWZ0LCAxID0gaGFyZCByaWdodC5cblx0XHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdFx0ICogIEBzaWduYWxcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMucGFuID0gdGhpcy5fcGFubmVyLnBhbjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIHRoZSBkcnkvd2V0IGtub2Jcblx0XHRcdFx0ICogIEB0eXBlIHtUb25lLkNyb3NzRmFkZX1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9jcm9zc0ZhZGUgPSBuZXcgVG9uZS5Dcm9zc0ZhZGUoKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBAdHlwZSB7VG9uZS5NZXJnZX1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9tZXJnZXIgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLk1lcmdlKCk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgQHR5cGUge1RvbmUuU3BsaXR9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fc3BsaXR0ZXIgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuU3BsaXQoKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBUaGUgcGFuIGNvbnRyb2wuIC0xID0gaGFyZCBsZWZ0LCAxID0gaGFyZCByaWdodC5cblx0XHRcdFx0ICogIEB0eXBlIHtBdWRpb1JhbmdlfVxuXHRcdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5wYW4gPSBuZXcgVG9uZS5TaWduYWwoMCwgVG9uZS5UeXBlLkF1ZGlvUmFuZ2UpO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIGFsd2F5cyBzZW5kcyAwXG5cdFx0XHRcdCAqICBAdHlwZSB7VG9uZS5aZXJvfVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX3plcm8gPSBuZXcgVG9uZS5aZXJvKCk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgVGhlIGFuYWxvZyB0byBnYWluIGNvbnZlcnNpb25cblx0XHRcdFx0ICogIEB0eXBlICB7VG9uZS5BdWRpb1RvR2Fpbn1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9hMmcgPSBuZXcgVG9uZS5BdWRpb1RvR2FpbigpO1xuXHQgICAgICAgICAgICAvL0NPTk5FQ1RJT05TOlxuXHQgICAgICAgICAgICB0aGlzLl96ZXJvLmNvbm5lY3QodGhpcy5fYTJnKTtcblx0ICAgICAgICAgICAgdGhpcy5wYW4uY2hhaW4odGhpcy5fYTJnLCB0aGlzLl9jcm9zc0ZhZGUuZmFkZSk7XG5cdCAgICAgICAgICAgIC8vbGVmdCBjaGFubmVsIGlzIGEsIHJpZ2h0IGNoYW5uZWwgaXMgYlxuXHQgICAgICAgICAgICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMuX2Nyb3NzRmFkZSwgMCwgMCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QodGhpcy5fY3Jvc3NGYWRlLCAxLCAxKTtcblx0ICAgICAgICAgICAgLy9tZXJnZSBpdCBiYWNrIHRvZ2V0aGVyXG5cdCAgICAgICAgICAgIHRoaXMuX2Nyb3NzRmFkZS5hLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAwKTtcblx0ICAgICAgICAgICAgdGhpcy5fY3Jvc3NGYWRlLmIuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2luaXRpYWwgdmFsdWVcblx0ICAgICAgICB0aGlzLnBhbi52YWx1ZSA9IFRvbmUuZGVmYXVsdEFyZyhpbml0aWFsUGFuLCAwKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgncGFuJyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QYW5uZXIsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbmRpY2F0ZXMgaWYgdGhlIHBhbm5lciBpcyB1c2luZyB0aGUgbmV3IFN0ZXJlb1Bhbm5lck5vZGUgaW50ZXJuYWxseVxuXHRcdCAqICBAdHlwZSAge0Jvb2xlYW59XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lci5oYXNTdGVyZW9QYW5uZXIgPSBUb25lLmNvbnRleHQgJiYgVG9uZS5pc0Z1bmN0aW9uKFRvbmUuY29udGV4dC5jcmVhdGVTdGVyZW9QYW5uZXIpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYW5uZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ3BhbicpO1xuXHQgICAgICAgIGlmIChUb25lLlBhbm5lci5oYXNTdGVyZW9QYW5uZXIpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGFubmVyLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fcGFubmVyID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5wYW4gPSBudWxsO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3plcm8uZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB0aGlzLl96ZXJvID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5fY3Jvc3NGYWRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5fY3Jvc3NGYWRlID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5fc3BsaXR0ZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9zcGxpdHRlciA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX21lcmdlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX21lcmdlciA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMucGFuLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5wYW4gPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLl9hMmcuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9hMmcgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QYW5uZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQSBzcGF0aWFsaXplZCBwYW5uZXIgbm9kZSB3aGljaCBzdXBwb3J0cyBlcXVhbHBvd2VyIG9yIEhSVEYgcGFubmluZy5cblx0XHQgKiAgICAgICAgICBUcmllcyB0byBub3JtYWxpemUgdGhlIEFQSSBhY3Jvc3MgdmFyaW91cyBicm93c2Vycy4gU2VlIFRvbmUuTGlzdGVuZXJcblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gcG9zaXRpb25YIFRoZSBpbml0aWFsIHggcG9zaXRpb24uXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvblkgVGhlIGluaXRpYWwgeSBwb3NpdGlvbi5cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uWiBUaGUgaW5pdGlhbCB6IHBvc2l0aW9uLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdwb3NpdGlvblgnLFxuXHQgICAgICAgICAgICAncG9zaXRpb25ZJyxcblx0ICAgICAgICAgICAgJ3Bvc2l0aW9uWidcblx0ICAgICAgICBdLCBUb25lLlBhbm5lcjNEKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBwYW5uZXIgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtQYW5uZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYW5uZXIgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XG5cdCAgICAgICAgLy9zZXQgc29tZSB2YWx1ZXNcblx0ICAgICAgICB0aGlzLl9wYW5uZXIucGFubmluZ01vZGVsID0gb3B0aW9ucy5wYW5uaW5nTW9kZWw7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLm1heERpc3RhbmNlID0gb3B0aW9ucy5tYXhEaXN0YW5jZTtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIuZGlzdGFuY2VNb2RlbCA9IG9wdGlvbnMuZGlzdGFuY2VNb2RlbDtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIuY29uZU91dGVyR2FpbiA9IG9wdGlvbnMuY29uZU91dGVyR2Fpbjtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIuY29uZU91dGVyQW5nbGUgPSBvcHRpb25zLmNvbmVPdXRlckFuZ2xlO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5jb25lSW5uZXJBbmdsZSA9IG9wdGlvbnMuY29uZUlubmVyQW5nbGU7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLnJlZkRpc3RhbmNlID0gb3B0aW9ucy5yZWZEaXN0YW5jZTtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIucm9sbG9mZkZhY3RvciA9IG9wdGlvbnMucm9sbG9mZkZhY3Rvcjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIb2xkcyB0aGUgY3VycmVudCBvcmllbnRhdGlvblxuXHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gW1xuXHQgICAgICAgICAgICBvcHRpb25zLm9yaWVudGF0aW9uWCxcblx0ICAgICAgICAgICAgb3B0aW9ucy5vcmllbnRhdGlvblksXG5cdCAgICAgICAgICAgIG9wdGlvbnMub3JpZW50YXRpb25aXG5cdCAgICAgICAgXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIb2xkcyB0aGUgY3VycmVudCBwb3NpdGlvblxuXHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gW1xuXHQgICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uWCxcblx0ICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvblksXG5cdCAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb25aXG5cdCAgICAgICAgXTtcblx0ICAgICAgICAvLyBzZXQgdGhlIGRlZmF1bHQgcG9zaXRpb24vb3JpZW50YXRpb25cblx0ICAgICAgICB0aGlzLm9yaWVudGF0aW9uWCA9IG9wdGlvbnMub3JpZW50YXRpb25YO1xuXHQgICAgICAgIHRoaXMub3JpZW50YXRpb25ZID0gb3B0aW9ucy5vcmllbnRhdGlvblk7XG5cdCAgICAgICAgdGhpcy5vcmllbnRhdGlvblogPSBvcHRpb25zLm9yaWVudGF0aW9uWjtcblx0ICAgICAgICB0aGlzLnBvc2l0aW9uWCA9IG9wdGlvbnMucG9zaXRpb25YO1xuXHQgICAgICAgIHRoaXMucG9zaXRpb25ZID0gb3B0aW9ucy5wb3NpdGlvblk7XG5cdCAgICAgICAgdGhpcy5wb3NpdGlvblogPSBvcHRpb25zLnBvc2l0aW9uWjtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBhbm5lcjNELCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgRGVmYXVsdHMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdwb3NpdGlvblgnOiAwLFxuXHQgICAgICAgICdwb3NpdGlvblknOiAwLFxuXHQgICAgICAgICdwb3NpdGlvblonOiAwLFxuXHQgICAgICAgICdvcmllbnRhdGlvblgnOiAwLFxuXHQgICAgICAgICdvcmllbnRhdGlvblknOiAwLFxuXHQgICAgICAgICdvcmllbnRhdGlvblonOiAwLFxuXHQgICAgICAgICdwYW5uaW5nTW9kZWwnOiAnZXF1YWxwb3dlcicsXG5cdCAgICAgICAgJ21heERpc3RhbmNlJzogMTAwMDAsXG5cdCAgICAgICAgJ2Rpc3RhbmNlTW9kZWwnOiAnaW52ZXJzZScsXG5cdCAgICAgICAgJ2NvbmVPdXRlckdhaW4nOiAwLFxuXHQgICAgICAgICdjb25lT3V0ZXJBbmdsZSc6IDM2MCxcblx0ICAgICAgICAnY29uZUlubmVyQW5nbGUnOiAzNjAsXG5cdCAgICAgICAgJ3JlZkRpc3RhbmNlJzogMSxcblx0ICAgICAgICAncm9sbG9mZkZhY3Rvcic6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcmFtcCB0aW1lIHdoaWNoIGlzIGFwcGxpZWQgdG8gdGhlIHNldFRhcmdldEF0VGltZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QucHJvdG90eXBlLl9yYW1wVGltZUNvbnN0YW50ID0gMC4wMTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgc291cmNlIGluIDNkIHNwYWNlLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB4XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHlcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgelxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlBhbm5lcjNEfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3Bhbm5lci5wb3NpdGlvblgpIHtcblx0ICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5wb3NpdGlvblguc2V0VGFyZ2V0QXRUaW1lKHgsIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5wb3NpdGlvblkuc2V0VGFyZ2V0QXRUaW1lKHksIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5wb3NpdGlvblouc2V0VGFyZ2V0QXRUaW1lKHosIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGFubmVyLnNldFBvc2l0aW9uKHgsIHksIHopO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldHMgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBzb3VyY2UgaW4gM2Qgc3BhY2UuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHhcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgeVxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB6XG5cdFx0ICogIEByZXR1cm4ge1RvbmUuUGFubmVyM0R9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QucHJvdG90eXBlLnNldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKHgsIHksIHopIHtcblx0ICAgICAgICBpZiAodGhpcy5fcGFubmVyLm9yaWVudGF0aW9uWCkge1xuXHQgICAgICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICAgICAgdGhpcy5fcGFubmVyLm9yaWVudGF0aW9uWC5zZXRUYXJnZXRBdFRpbWUoeCwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICAgICAgdGhpcy5fcGFubmVyLm9yaWVudGF0aW9uWS5zZXRUYXJnZXRBdFRpbWUoeSwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICAgICAgdGhpcy5fcGFubmVyLm9yaWVudGF0aW9uWi5zZXRUYXJnZXRBdFRpbWUoeiwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9wYW5uZXIuc2V0T3JpZW50YXRpb24oeCwgeSwgeik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHggcG9zaXRpb24gb2YgdGhlIHBhbm5lciBvYmplY3QuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBwb3NpdGlvblhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhbm5lcjNELnByb3RvdHlwZSwgJ3Bvc2l0aW9uWCcsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25bMF0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24uYXBwbHkodGhpcywgdGhpcy5fcG9zaXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblswXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgcGFubmVyIG9iamVjdC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIHBvc2l0aW9uWVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFubmVyM0QucHJvdG90eXBlLCAncG9zaXRpb25ZJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblsxXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9wb3NpdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWzFdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB6IHBvc2l0aW9uIG9mIHRoZSBwYW5uZXIgb2JqZWN0LlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgcG9zaXRpb25aXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYW5uZXIzRC5wcm90b3R5cGUsICdwb3NpdGlvblonLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uWzJdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX3Bvc2l0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25bMl07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHggb3JpZW50YXRpb24gb2YgdGhlIHBhbm5lciBvYmplY3QuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBvcmllbnRhdGlvblhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhbm5lcjNELnByb3RvdHlwZSwgJ29yaWVudGF0aW9uWCcsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25bMF0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb24uYXBwbHkodGhpcywgdGhpcy5fb3JpZW50YXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvblswXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeSBvcmllbnRhdGlvbiBvZiB0aGUgcGFubmVyIG9iamVjdC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIG9yaWVudGF0aW9uWVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFubmVyM0QucHJvdG90eXBlLCAnb3JpZW50YXRpb25ZJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblsxXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRPcmllbnRhdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9vcmllbnRhdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWzFdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB6IG9yaWVudGF0aW9uIG9mIHRoZSBwYW5uZXIgb2JqZWN0LlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgb3JpZW50YXRpb25aXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYW5uZXIzRC5wcm90b3R5cGUsICdvcmllbnRhdGlvblonLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uWzJdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldE9yaWVudGF0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX29yaWVudGF0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25bMl07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgUHJveHkgYSBwcm9wZXJ0eSBvbiB0aGUgcGFubmVyIHRvIGFuIGV4cG9zZWQgcHVibGljIHByb3Blcnlcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgcHJvcFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5fYWxpYXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wKSB7XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFubmVyM0QucHJvdG90eXBlLCBwcm9wLCB7XG5cdCAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcGFubmVyW3Byb3BdID0gdmFsO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYW5uZXJbcHJvcF07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHBhbm5pbmcgbW9kZWwuIEVpdGhlciBcImVxdWFscG93ZXJcIiBvciBcIkhSVEZcIi5cblx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIHBhbm5pbmdNb2RlbFxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5fYWxpYXNQcm9wZXJ0eSgncGFubmluZ01vZGVsJyk7XG5cdCAgICAvKipcblx0XHQgKiAgQSByZWZlcmVuY2UgZGlzdGFuY2UgZm9yIHJlZHVjaW5nIHZvbHVtZSBhcyBzb3VyY2UgbW92ZSBmdXJ0aGVyIGZyb20gdGhlIGxpc3RlbmVyXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSByZWZEaXN0YW5jZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5fYWxpYXNQcm9wZXJ0eSgncmVmRGlzdGFuY2UnKTtcblx0ICAgIC8qKlxuXHRcdCAqICBEZXNjcmliZXMgaG93IHF1aWNrbHkgdGhlIHZvbHVtZSBpcyByZWR1Y2VkIGFzIHNvdXJjZSBtb3ZlcyBhd2F5IGZyb20gbGlzdGVuZXIuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSByb2xsb2ZmRmFjdG9yXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELl9hbGlhc1Byb3BlcnR5KCdyb2xsb2ZmRmFjdG9yJyk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRpc3RhbmNlIG1vZGVsIHVzZWQgYnksICBcImxpbmVhclwiLCBcImludmVyc2VcIiwgb3IgXCJleHBvbmVudGlhbFwiLlxuXHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgZGlzdGFuY2VNb2RlbFxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5fYWxpYXNQcm9wZXJ0eSgnZGlzdGFuY2VNb2RlbCcpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBhbmdsZSwgaW4gZGVncmVlcywgaW5zaWRlIG9mIHdoaWNoIHRoZXJlIHdpbGwgYmUgbm8gdm9sdW1lIHJlZHVjdGlvblxuXHRcdCAqICBAdHlwZSB7RGVncmVlc31cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIGNvbmVJbm5lckFuZ2xlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELl9hbGlhc1Byb3BlcnR5KCdjb25lSW5uZXJBbmdsZScpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBhbmdsZSwgaW4gZGVncmVlcywgb3V0c2lkZSBvZiB3aGljaCB0aGUgdm9sdW1lIHdpbGwgYmUgcmVkdWNlZFxuXHRcdCAqICB0byBhIGNvbnN0YW50IHZhbHVlIG9mIGNvbmVPdXRlckdhaW5cblx0XHQgKiAgQHR5cGUge0RlZ3JlZXN9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBjb25lT3V0ZXJBbmdsZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5fYWxpYXNQcm9wZXJ0eSgnY29uZU91dGVyQW5nbGUnKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZ2FpbiBvdXRzaWRlIG9mIHRoZSBjb25lT3V0ZXJBbmdsZVxuXHRcdCAqICBAdHlwZSB7R2Fpbn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIGNvbmVPdXRlckdhaW5cblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ2NvbmVPdXRlckdhaW4nKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbWF4aW11bSBkaXN0YW5jZSBiZXR3ZWVuIHNvdXJjZSBhbmQgbGlzdGVuZXIsXG5cdFx0ICogIGFmdGVyIHdoaWNoIHRoZSB2b2x1bWUgd2lsbCBub3QgYmUgcmVkdWNlZCBhbnkgZnVydGhlci5cblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgbWF4RGlzdGFuY2Vcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ21heERpc3RhbmNlJyk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhbm5lcjNEfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGFubmVyM0Q7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlBhblZvbCBpcyBhIFRvbmUuUGFubmVyIGFuZCBUb25lLlZvbHVtZSBpbiBvbmUuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtBdWRpb1JhbmdlfSBwYW4gdGhlIGluaXRpYWwgcGFuXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgVGhlIG91dHB1dCB2b2x1bWUuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9wYW4gdGhlIGluY29taW5nIHNpZ25hbCBsZWZ0IGFuZCBkcm9wIHRoZSB2b2x1bWVcblx0XHQgKiB2YXIgcGFuVm9sID0gbmV3IFRvbmUuUGFuVm9sKC0wLjI1LCAtMTIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5Wb2wgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAncGFuJyxcblx0ICAgICAgICAgICAgJ3ZvbHVtZSdcblx0ICAgICAgICBdLCBUb25lLlBhblZvbCk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGFubmluZyBub2RlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuUGFubmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYW5uZXIgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuUGFubmVyKG9wdGlvbnMucGFuKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgTC9SIHBhbm5pbmcgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7QXVkaW9SYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnBhbiA9IHRoaXMuX3Bhbm5lci5wYW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZvbHVtZSBub2RlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuVm9sdW1lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlZvbHVtZShvcHRpb25zLnZvbHVtZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZvbHVtZSBjb250cm9sIGluIGRlY2liZWxzLlxuXHRcdFx0ICogIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IHRoaXMuX3ZvbHVtZS52b2x1bWU7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5jb25uZWN0KHRoaXMuX3ZvbHVtZSk7XG5cdCAgICAgICAgdGhpcy5tdXRlID0gb3B0aW9ucy5tdXRlO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ3BhbicsXG5cdCAgICAgICAgICAgICd2b2x1bWUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QYW5Wb2wsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLlBhblZvbC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncGFuJzogMCxcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogTXV0ZS91bm11dGUgdGhlIHZvbHVtZVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBhblZvbCNcblx0XHQgKiBAbmFtZSBtdXRlXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYW5Wb2wucHJvdG90eXBlLCAnbXV0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZS5tdXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobXV0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl92b2x1bWUubXV0ZSA9IG11dGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFuVm9sfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhblZvbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3BhbicsXG5cdCAgICAgICAgICAgICd2b2x1bWUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMucGFuID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl92b2x1bWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBhblZvbDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlNvbG8gbGV0cyB5b3UgaXNvbGF0ZSBhIHNwZWNpZmljIGF1ZGlvIHN0cmVhbS4gV2hlblxuXHRcdCAqICAgICAgICAgYW4gaW5zdGFuY2UgaXMgc2V0IHRvIGBzb2xvPXRydWVgLCBpdCB3aWxsIG11dGUgYWxsIG90aGVyIGluc3RhbmNlcy5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzb2xvQSA9IG5ldyBUb25lLlNvbG8oKVxuXHRcdCAqIHZhciBzb2xvQiA9IG5ldyBUb25lLlNvbG8oKVxuXHRcdCAqIHNvbG9BLnNvbG8gPSB0cnVlXG5cdFx0ICogLy9ubyBhdWRpbyB3aWxsIHBhc3MgdGhyb3VnaCBzb2xvQlxuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb2xvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsnc29sbyddLCBUb25lLlNvbG8pO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGlucHV0IGFuZCBvdXRwdXQgbm9kZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5HYWlufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgYm91bmQgX3NvbG9lZCBtZXRob2Rcblx0XHRcdCAqICBAdHlwZSAge0Z1bmN0aW9ufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zb2xvQmluZCA9IHRoaXMuX3NvbG9lZC5iaW5kKHRoaXMpO1xuXHQgICAgICAgIC8vbGlzdGVuIGZvciBzb2xvIGV2ZW50cyBjbGFzcy13aWRlLlxuXHQgICAgICAgIHRoaXMuY29udGV4dC5vbignc29sbycsIHRoaXMuX3NvbG9CaW5kKTtcblx0ICAgICAgICAvL3NldCBpbml0aWFsbHlcblx0ICAgICAgICB0aGlzLnNvbG8gPSBvcHRpb25zLnNvbG87XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Tb2xvLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLlNvbG8uZGVmYXVsdHMgPSB7IHNvbG86IGZhbHNlIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXNvbGF0ZXMgdGhpcyBpbnN0YW5jZSBhbmQgbXV0ZXMgYWxsIG90aGVyIGluc3RhbmNlcyBvZiBUb25lLlNvbG8uXG5cdFx0ICogIE9ubHkgb25lIGluc3RhbmNlIGNhbiBiZSBzb2xvZWQgYXQgYSB0aW1lLiBBIHNvbG9lZFxuXHRcdCAqICBpbnN0YW5jZSB3aWxsIHJlcG9ydCBgc29sbz1mYWxzZWAgd2hlbiBhbm90aGVyIGluc3RhbmNlIGlzIHNvbG9lZC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuU29sbyNcblx0XHQgKiAgQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogIEBuYW1lIHNvbG9cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNvbG8ucHJvdG90eXBlLCAnc29sbycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzU29sb2VkKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzb2xvKSB7XG5cdCAgICAgICAgICAgIGlmIChzb2xvKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hZGRTb2xvKCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVTb2xvKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmVtaXQoJ3NvbG8nLCB0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBJZiB0aGUgY3VycmVudCBpbnN0YW5jZSBpcyBtdXRlZCwgaS5lLiBhbm90aGVyIGluc3RhbmNlIGlzIHNvbG9lZFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Tb2xvI1xuXHRcdCAqICBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiAgQG5hbWUgbXV0ZWRcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Tb2xvLnByb3RvdHlwZSwgJ211dGVkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5nYWluLnZhbHVlID09PSAwO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogQWRkIHRoaXMgdG8gdGhlIHNvbG9lZCBhcnJheVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlNvbG8ucHJvdG90eXBlLl9hZGRTb2xvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICghVG9uZS5pc0FycmF5KHRoaXMuY29udGV4dC5fY3VycmVudFNvbG8pKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5fY3VycmVudFNvbG8gPSBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCF0aGlzLl9pc1NvbG9lZCgpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5fY3VycmVudFNvbG8ucHVzaCh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogUmVtb3ZlIHRoaXMgZnJvbSB0aGUgc29sb2VkIGFycmF5XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuU29sby5wcm90b3R5cGUuX3JlbW92ZVNvbG8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2lzU29sb2VkKCkpIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb250ZXh0Ll9jdXJyZW50U29sby5pbmRleE9mKHRoaXMpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuX2N1cnJlbnRTb2xvLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IElzIHRoaXMgb24gdGhlIHNvbG9lZCBhcnJheVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlNvbG8ucHJvdG90eXBlLl9pc1NvbG9lZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc0FycmF5KHRoaXMuY29udGV4dC5fY3VycmVudFNvbG8pKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuX2N1cnJlbnRTb2xvLmxlbmd0aCAhPT0gMCAmJiB0aGlzLmNvbnRleHQuX2N1cnJlbnRTb2xvLmluZGV4T2YodGhpcykgIT09IC0xO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIG5vIG9uZSBpcyBzb2xvZWRcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb2xvLnByb3RvdHlwZS5fbm9Tb2xvcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gIVRvbmUuaXNBcnJheSh0aGlzLmNvbnRleHQuX2N1cnJlbnRTb2xvKSB8fCB0aGlzLmNvbnRleHQuX2N1cnJlbnRTb2xvLmxlbmd0aCA9PT0gMDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU29sbyB0aGUgY3VycmVudCBpbnN0YW5jZSBhbmQgdW5zb2xvIGFsbCBvdGhlciBpbnN0YW5jZXMuXG5cdFx0ICogIEBwYXJhbSAge1RvbmUuU29sb30gIGluc3RhbmNlICBUaGUgaW5zdGFuY2Ugd2hpY2ggaXMgYmVpbmcgc29sb2VkL3Vuc29sb2VkLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb2xvLnByb3RvdHlwZS5fc29sb2VkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9pc1NvbG9lZCgpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaW5wdXQuZ2Fpbi52YWx1ZSA9IDE7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ub1NvbG9zKCkpIHtcblx0ICAgICAgICAgICAgLy9ubyBvbmUgaXMgc29sb2VkXG5cdCAgICAgICAgICAgIHRoaXMuaW5wdXQuZ2Fpbi52YWx1ZSA9IDE7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5pbnB1dC5nYWluLnZhbHVlID0gMDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlNvbG99ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNvbG8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0Lm9mZignc29sbycsIHRoaXMuX3NvbG9CaW5kKTtcblx0ICAgICAgICB0aGlzLl9yZW1vdmVTb2xvKCk7XG5cdCAgICAgICAgdGhpcy5fc29sb0JpbmQgPSBudWxsO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU29sbztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQ3RybEludGVycG9sYXRlIHdpbGwgaW50ZXJwb2xhdGUgYmV0d2VlbiBnaXZlbiB2YWx1ZXMgYmFzZWRcblx0XHQgKiAgICAgICAgIG9uIHRoZSBcImluZGV4XCIgcHJvcGVydHkuIFBhc3NpbmcgaW4gYW4gYXJyYXkgb3Igb2JqZWN0IGxpdGVyYWxcblx0XHQgKiAgICAgICAgIHdpbGwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgcGFyYW1ldGVycy4gTm90ZSAoaS5lLiBcIkMzXCIpXG5cdFx0ICogICAgICAgICBhbmQgVGltZSAoaS5lLiBcIjRuICsgMlwiKSBjYW4gYmUgaW50ZXJwb2xhdGVkLiBBbGwgb3RoZXIgdmFsdWVzIGFyZVxuXHRcdCAqICAgICAgICAgYXNzdW1lZCB0byBiZSBudW1iZXJzLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgaW50ZXJwID0gbmV3IFRvbmUuQ3RybEludGVycG9sYXRlKFswLCAyLCA5LCA0XSk7XG5cdFx0ICogaW50ZXJwLmluZGV4ID0gMC43NTtcblx0XHQgKiBpbnRlcnAudmFsdWU7IC8vcmV0dXJucyAxLjVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBpbnRlcnAgPSBuZXcgVG9uZS5DdHJsSW50ZXJwb2xhdGUoW1xuXHRcdCAqIFx0WzIsIDQsIDVdLFxuXHRcdCAqIFx0WzksIDMsIDJdLFxuXHRcdCAqIF0pO1xuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGludGVycG9sYXRlIG92ZXJcblx0XHQgKiBAcGFyYW0ge1Bvc2l0aXZlfSBpbmRleCBUaGUgaW5pdGlhbCBpbnRlcnBvbGF0aW9uIGluZGV4LlxuXHRcdCAqIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsSW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndmFsdWVzJyxcblx0ICAgICAgICAgICAgJ2luZGV4J1xuXHQgICAgICAgIF0sIFRvbmUuQ3RybEludGVycG9sYXRlKTtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuXG5cdFx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGludGVycG9sYXRlZCBpbmRleCBiZXR3ZWVuIHZhbHVlcy4gRm9yIGV4YW1wbGU6IGEgdmFsdWUgb2YgMS41XG5cdFx0XHQgKiAgd291bGQgaW50ZXJwb2xhdGUgZXF1YWxseSBiZXR3ZWVuIHRoZSB2YWx1ZSBhdCBpbmRleCAxXG5cdFx0XHQgKiAgYW5kIHRoZSB2YWx1ZSBhdCBpbmRleCAyLiBcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogaW50ZXJwLmluZGV4ID0gMDsgXG5cdFx0XHQgKiBpbnRlcnAudmFsdWU7IC8vcmV0dXJucyB0aGUgdmFsdWUgYXQgMFxuXHRcdFx0ICogaW50ZXJwLmluZGV4ID0gMC41O1xuXHRcdFx0ICogaW50ZXJwLnZhbHVlOyAvL3JldHVybnMgdGhlIHZhbHVlIGJldHdlZW4gaW5kaWNlcyAwIGFuZCAxLiBcblx0XHRcdCAqICBAdHlwZSAge1Bvc2l0aXZlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5DdHJsSW50ZXJwb2xhdGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxJbnRlcnBvbGF0ZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnaW5kZXgnOiAwLFxuXHQgICAgICAgICd2YWx1ZXMnOiBbXVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgY3VycmVudCBpbnRlcnBvbGF0ZWQgdmFsdWUgYmFzZWQgb24gdGhlIGluZGV4XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5DdHJsSW50ZXJwb2xhdGUjXG5cdFx0ICogIEB0eXBlIHsqfVxuXHRcdCAqICBAbmFtZSB2YWx1ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ3RybEludGVycG9sYXRlLnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0aGlzLnZhbHVlcy5sZW5ndGggLSAxKTtcblx0ICAgICAgICAgICAgdmFyIGxvd2VyUG9zaXRpb24gPSBNYXRoLmZsb29yKGluZGV4KTtcblx0ICAgICAgICAgICAgdmFyIGxvd2VyID0gdGhpcy52YWx1ZXNbbG93ZXJQb3NpdGlvbl07XG5cdCAgICAgICAgICAgIHZhciB1cHBlciA9IHRoaXMudmFsdWVzW01hdGguY2VpbChpbmRleCldO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJwb2xhdGUoaW5kZXggLSBsb3dlclBvc2l0aW9uLCBsb3dlciwgdXBwZXIpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIEludGVybmFsIGludGVycG9sYXRpb24gcm91dGluZVxuXHRcdCAqICBAcGFyYW0gIHtOb3JtYWxSYW5nZX0gIGluZGV4ICBUaGUgaW5kZXggYmV0d2VlbiB0aGUgbG93ZXIgYW5kIHVwcGVyXG5cdFx0ICogIEBwYXJhbSAgeyp9ICBsb3dlciBcblx0XHQgKiAgQHBhcmFtICB7Kn0gIHVwcGVyIFxuXHRcdCAqICBAcmV0dXJuICB7Kn0gIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybEludGVycG9sYXRlLnByb3RvdHlwZS5faW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoaW5kZXgsIGxvd2VyLCB1cHBlcikge1xuXHQgICAgICAgIGlmIChUb25lLmlzQXJyYXkobG93ZXIpKSB7XG5cdCAgICAgICAgICAgIHZhciByZXRBcnJheSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvd2VyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICByZXRBcnJheVtpXSA9IHRoaXMuX2ludGVycG9sYXRlKGluZGV4LCBsb3dlcltpXSwgdXBwZXJbaV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXRBcnJheTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNPYmplY3QobG93ZXIpKSB7XG5cdCAgICAgICAgICAgIHZhciByZXRPYmogPSB7fTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBsb3dlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0T2JqW2F0dHJdID0gdGhpcy5faW50ZXJwb2xhdGUoaW5kZXgsIGxvd2VyW2F0dHJdLCB1cHBlclthdHRyXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJldE9iajtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBsb3dlciA9IHRoaXMuX3RvTnVtYmVyKGxvd2VyKTtcblx0ICAgICAgICAgICAgdXBwZXIgPSB0aGlzLl90b051bWJlcih1cHBlcik7XG5cdCAgICAgICAgICAgIHJldHVybiAoMSAtIGluZGV4KSAqIGxvd2VyICsgaW5kZXggKiB1cHBlcjtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgZnJvbSB0aGUgZ2l2ZW4gdHlwZSBpbnRvIGEgbnVtYmVyXG5cdFx0ICogIEBwYXJhbSAge051bWJlcnxTdHJpbmd9ICB2YWx1ZVxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsSW50ZXJwb2xhdGUucHJvdG90eXBlLl90b051bWJlciA9IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc051bWJlcih2YWwpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy9vdGhlcndpc2UgYXNzdW1lIHRoYXQgaXQncyBUaW1lLi4uXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU2Vjb25kcyh2YWwpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuQ3RybEludGVycG9sYXRlfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsSW50ZXJwb2xhdGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy52YWx1ZXMgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkN0cmxJbnRlcnBvbGF0ZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQ3RybE1hcmtvdiByZXByZXNlbnRzIGEgTWFya292IENoYWluIHdoZXJlIGVhY2ggY2FsbFxuXHRcdCAqICAgICAgICAgdG8gVG9uZS5DdHJsTWFya292Lm5leHQgd2lsbCBtb3ZlIHRvIHRoZSBuZXh0IHN0YXRlLiBJZiB0aGUgbmV4dFxuXHRcdCAqICAgICAgICAgc3RhdGUgY2hvaWNlIGlzIGFuIGFycmF5LCB0aGUgbmV4dCBzdGF0ZSBpcyBjaG9zZW4gcmFuZG9tbHkgd2l0aFxuXHRcdCAqICAgICAgICAgZXZlbiBwcm9iYWJpbGl0eSBmb3IgYWxsIG9mIHRoZSBjaG9pY2VzLiBGb3IgYSB3ZWlnaHRlZCBwcm9iYWJpbGl0eVxuXHRcdCAqICAgICAgICAgb2YgdGhlIG5leHQgY2hvaWNlcywgcGFzcyBpbiBhbiBvYmplY3Qgd2l0aCBcInN0YXRlXCIgYW5kIFwicHJvYmFiaWxpdHlcIiBhdHRyaWJ1dGVzLiBcblx0XHQgKiAgICAgICAgIFRoZSBwcm9iYWJpbGl0aWVzIHdpbGwgYmUgbm9ybWFsaXplZCBhbmQgdGhlbiBjaG9zZW4uIElmIG5vIG5leHQgb3B0aW9uc1xuXHRcdCAqICAgICAgICAgYXJlIGdpdmVuIGZvciB0aGUgY3VycmVudCBzdGF0ZSwgdGhlIHN0YXRlIHdpbGwgc3RheSB0aGVyZS4gXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBjaGFpbiA9IG5ldyBUb25lLkN0cmxNYXJrb3Yoe1xuXHRcdCAqIFx0XCJiZWdpbm5pbmdcIiA6IFtcImVuZFwiLCBcIm1pZGRsZVwiXSxcblx0XHQgKiBcdFwibWlkZGxlXCIgOiBcImVuZFwiXG5cdFx0ICogfSk7XG5cdFx0ICogY2hhaW4udmFsdWUgPSBcImJlZ2lubmluZ1wiO1xuXHRcdCAqIGNoYWluLm5leHQoKTsgLy9yZXR1cm5zIFwiZW5kXCIgb3IgXCJtaWRkbGVcIiB3aXRoIDUwJSBwcm9iYWJpbGl0eVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGNoYWluID0gbmV3IFRvbmUuQ3RybE1hcmtvdih7XG5cdFx0ICogXHRcImJlZ2lubmluZ1wiIDogW3tcInZhbHVlXCIgOiBcImVuZFwiLCBcInByb2JhYmlsaXR5XCIgOiAwLjh9LCBcblx0XHQgKiBcdFx0XHRcdFx0e1widmFsdWVcIiA6IFwibWlkZGxlXCIsIFwicHJvYmFiaWxpdHlcIiA6IDAuMn1dLFxuXHRcdCAqIFx0XCJtaWRkbGVcIiA6IFwiZW5kXCJcblx0XHQgKiB9KTtcblx0XHQgKiBjaGFpbi52YWx1ZSA9IFwiYmVnaW5uaW5nXCI7XG5cdFx0ICogY2hhaW4ubmV4dCgpOyAvL3JldHVybnMgXCJlbmRcIiB3aXRoIDgwJSBwcm9iYWJpbGl0eSBvciBcIm1pZGRsZVwiIHdpdGggMjAlLlxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gdmFsdWVzIEFuIG9iamVjdCB3aXRoIHRoZSBzdGF0ZSBuYW1lcyBhcyB0aGUga2V5c1xuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgbmV4dCBzdGF0ZShzKSBhcyB0aGUgdmFsdWVzLiBcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybE1hcmtvdiA9IGZ1bmN0aW9uICh2YWx1ZXMsIGluaXRpYWwpIHtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIE1hcmtvdiB2YWx1ZXMgd2l0aCBzdGF0ZXMgYXMgdGhlIGtleXNcblx0XHRcdCAqICBhbmQgbmV4dCBzdGF0ZShzKSBhcyB0aGUgdmFsdWVzLiBcblx0XHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52YWx1ZXMgPSBUb25lLmRlZmF1bHRBcmcodmFsdWVzLCB7fSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIE1hcmtvdiB2YWx1ZXMuIFRoZSBuZXh0XG5cdFx0XHQgKiAgc3RhdGUgd2lsbCBiZSBldmFsdWF0ZWQgYW5kIHJldHVybmVkIHdoZW4gVG9uZS5DdHJsTWFya292Lm5leHRcblx0XHRcdCAqICBpcyBpbnZva2VkLlxuXHRcdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZhbHVlID0gVG9uZS5kZWZhdWx0QXJnKGluaXRpYWwsIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKVswXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5DdHJsTWFya292KTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBuZXh0IHN0YXRlIG9mIHRoZSBNYXJrb3YgdmFsdWVzLiBcblx0XHQgKiAgQHJldHVybiAge1N0cmluZ31cblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybE1hcmtvdi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy52YWx1ZXMuaGFzT3duUHJvcGVydHkodGhpcy52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLnZhbHVlc1t0aGlzLnZhbHVlXTtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNBcnJheShuZXh0KSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRpc3RyaWJ1dGlvbiA9IHRoaXMuX2dldFByb2JEaXN0cmlidXRpb24obmV4dCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmFuZCA9IE1hdGgucmFuZG9tKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXN0cmlidXRpb24ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGRpc3RyaWJ1dGlvbltpXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmFuZCA+IHRvdGFsICYmIHJhbmQgPCB0b3RhbCArIGRpc3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNob3NlbiA9IG5leHRbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChUb25lLmlzT2JqZWN0KGNob3NlbikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBjaG9zZW4udmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gY2hvc2VuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IGRpc3Q7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV4dDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2hvb3NlIHJhbmRvbWx5IGZyb20gYW4gYXJyYXkgd2VpZ2h0ZWQgb3B0aW9ucyBpbiB0aGUgZm9ybSBcblx0XHQgKiAge1wic3RhdGVcIiA6IHN0cmluZywgXCJwcm9iYWJpbGl0eVwiIDogbnVtYmVyfSBvciBhbiBhcnJheSBvZiB2YWx1ZXNcblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9ICBvcHRpb25zIFxuXHRcdCAqICBAcmV0dXJuICB7QXJyYXl9ICBUaGUgcmFuZG9tbHkgc2VsZWN0ZWQgY2hvaWNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxNYXJrb3YucHJvdG90eXBlLl9nZXRQcm9iRGlzdHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgZGlzdHJpYnV0aW9uID0gW107XG5cdCAgICAgICAgdmFyIHRvdGFsID0gMDtcblx0ICAgICAgICB2YXIgbmVlZHNOb3JtYWxpemluZyA9IGZhbHNlO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1tpXTtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNPYmplY3Qob3B0aW9uKSkge1xuXHQgICAgICAgICAgICAgICAgbmVlZHNOb3JtYWxpemluZyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25baV0gPSBvcHRpb24ucHJvYmFiaWxpdHk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25baV0gPSAxIC8gb3B0aW9ucy5sZW5ndGg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdG90YWwgKz0gZGlzdHJpYnV0aW9uW2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobmVlZHNOb3JtYWxpemluZykge1xuXHQgICAgICAgICAgICAvL25vcm1hbGl6ZSB0aGUgdmFsdWVzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGlzdHJpYnV0aW9uLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25bal0gPSBkaXN0cmlidXRpb25bal0gLyB0b3RhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZGlzdHJpYnV0aW9uO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5DdHJsTWFya292fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsTWFya292LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMudmFsdWVzID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5DdHJsTWFya292O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgR2VuZXJhdGUgcGF0dGVybnMgZnJvbSBhbiBhcnJheSBvZiB2YWx1ZXMuXG5cdFx0ICogICAgICAgICBIYXMgYSBudW1iZXIgb2YgYXJwZWdnaWF0aW9uIGFuZCByYW5kb21pemVkXG5cdFx0ICogICAgICAgICBzZWxlY3Rpb24gcGF0dGVybnMuIFxuXHRcdCAqICAgICAgICAgICA8dWw+XG5cdFx0ICogIFx0ICAgICAgICA8bGk+XCJ1cFwiIC0gY3ljbGVzIHVwd2FyZDwvbGk+XG5cdFx0ICogIFx0XHRcdDxsaT5cImRvd25cIiAtIGN5Y2xlcyBkb3dud2FyZDwvbGk+XG5cdFx0ICogIFx0XHRcdDxsaT5cInVwRG93blwiIC0gdXAgdGhlbiBhbmQgZG93bjwvbGk+XG5cdFx0ICogIFx0XHRcdDxsaT5cImRvd25VcFwiIC0gY3ljbGVzIGRvd24gdGhlbiBhbmQgdXA8L2xpPlxuXHRcdCAqICBcdFx0XHQ8bGk+XCJhbHRlcm5hdGVVcFwiIC0ganVtcCB1cCB0d28gYW5kIGRvd24gb25lPC9saT5cblx0XHQgKiAgXHRcdFx0PGxpPlwiYWx0ZXJuYXRlRG93blwiIC0ganVtcCBkb3duIHR3byBhbmQgdXAgb25lPC9saT5cblx0XHQgKiAgXHRcdFx0PGxpPlwicmFuZG9tXCIgLSByYW5kb21seSBzZWxlY3QgYW4gaW5kZXg8L2xpPlxuXHRcdCAqICBcdFx0XHQ8bGk+XCJyYW5kb21XYWxrXCIgLSByYW5kb21seSBtb3ZlcyBvbmUgaW5kZXggYXdheSBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uPC9saT5cblx0XHQgKiAgXHRcdFx0PGxpPlwicmFuZG9tT25jZVwiIC0gcmFuZG9tbHkgc2VsZWN0IGFuIGluZGV4IHdpdGhvdXQgcmVwZWF0aW5nIHVudGlsIGFsbCB2YWx1ZXMgaGF2ZSBiZWVuIGNob3Nlbi48L2xpPlxuXHRcdCAqICAgICBcdFx0PC91bD5cblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9ICB2YWx1ZXMgICBBbiBhcnJheSBvZiBvcHRpb25zIHRvIGNob29zZSBmcm9tLlxuXHRcdCAqICBAcGFyYW0gIHtUb25lLkN0cmxQYXR0ZXJuLlR5cGU9fSAgdHlwZSAgVGhlIG5hbWUgb2YgdGhlIHBhdHRlcm4uXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUGF0dGVybiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd2YWx1ZXMnLFxuXHQgICAgICAgICAgICAndHlwZSdcblx0ICAgICAgICBdLCBUb25lLkN0cmxQYXR0ZXJuKTtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFycmF5IG9mIHZhbHVlcyB0byBhcnBlZ2dpYXRlIG92ZXJcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSB2YWx1ZXMgYXJyYXlcblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB0eXBlIHBsYWNlaG9sZGVyXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ3RybFBhdHRlcm4uVHlwZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU2h1ZmZsZWQgdmFsdWVzIGZvciB0aGUgUmFuZG9tT25jZSB0eXBlXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zaHVmZmxlZCA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRpcmVjdGlvbiBvZiB0aGUgbW92ZW1lbnRcblx0XHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBudWxsO1xuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkN0cmxQYXR0ZXJuKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgQ29udHJvbCBQYXR0ZXJuc1xuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUGF0dGVybi5UeXBlID0ge1xuXHQgICAgICAgIFVwOiAndXAnLFxuXHQgICAgICAgIERvd246ICdkb3duJyxcblx0ICAgICAgICBVcERvd246ICd1cERvd24nLFxuXHQgICAgICAgIERvd25VcDogJ2Rvd25VcCcsXG5cdCAgICAgICAgQWx0ZXJuYXRlVXA6ICdhbHRlcm5hdGVVcCcsXG5cdCAgICAgICAgQWx0ZXJuYXRlRG93bjogJ2FsdGVybmF0ZURvd24nLFxuXHQgICAgICAgIFJhbmRvbTogJ3JhbmRvbScsXG5cdCAgICAgICAgUmFuZG9tV2FsazogJ3JhbmRvbVdhbGsnLFxuXHQgICAgICAgIFJhbmRvbU9uY2U6ICdyYW5kb21PbmNlJ1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXMuIFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybFBhdHRlcm4uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3R5cGUnOiBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXAsXG5cdCAgICAgICAgJ3ZhbHVlcyc6IFtdXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB2YWx1ZSBhdCB0aGUgY3VycmVudCBpbmRleCBvZiB0aGUgcGF0dGVybi5cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkN0cmxQYXR0ZXJuI1xuXHRcdCAqICBAdHlwZSB7Kn1cblx0XHQgKiAgQG5hbWUgdmFsdWVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkN0cmxQYXR0ZXJuLnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvL3NvbWUgc2FmZWd1YXJkc1xuXHQgICAgICAgICAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZXMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMF07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5pbmRleCA9IE1hdGgubWluKHRoaXMuaW5kZXgsIHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpO1xuXHQgICAgICAgICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZXNbdGhpcy5pbmRleF07XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5SYW5kb21PbmNlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoICE9PSB0aGlzLl9zaHVmZmxlZC5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaHVmZmxlVmFsdWVzKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLnZhbHVlc1t0aGlzLl9zaHVmZmxlZFt0aGlzLmluZGV4XV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgcGF0dGVybiB1c2VkIHRvIHNlbGVjdCB0aGUgbmV4dFxuXHRcdCAqICBpdGVtIGZyb20gdGhlIHZhbHVlcyBhcnJheVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5DdHJsUGF0dGVybiNcblx0XHQgKiAgQHR5cGUge1RvbmUuQ3RybFBhdHRlcm4uVHlwZX1cblx0XHQgKiAgQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ3RybFBhdHRlcm4ucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB0aGlzLl9zaHVmZmxlZCA9IG51bGw7XG5cdCAgICAgICAgICAgIC8vdGhlIGZpcnN0IGluZGV4XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXAgfHwgdGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwRG93biB8fCB0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuUmFuZG9tT25jZSB8fCB0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuQWx0ZXJuYXRlVXApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duIHx8IHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duVXAgfHwgdGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkFsdGVybmF0ZURvd24pIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnZhbHVlcy5sZW5ndGggLSAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vdGhlIGRpcmVjdGlvblxuXHQgICAgICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwRG93biB8fCB0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuQWx0ZXJuYXRlVXApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93blVwIHx8IHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5BbHRlcm5hdGVEb3duKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93bjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL3JhbmRvbXNcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5SYW5kb21PbmNlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zaHVmZmxlVmFsdWVzKCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5SYW5kb20pIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnZhbHVlcy5sZW5ndGgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSBuZXh0IHZhbHVlIGdpdmVuIHRoZSBjdXJyZW50IHBvc2l0aW9uXG5cdFx0ICogIGFuZCBwYXR0ZXJuLlxuXHRcdCAqICBAcmV0dXJuIHsqfSBUaGUgbmV4dCB2YWx1ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUGF0dGVybi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblx0ICAgICAgICAvL2Nob29zZSB0aGUgbmV4dCBpbmRleFxuXHQgICAgICAgIGlmICh0eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXApIHtcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93bikge1xuXHQgICAgICAgICAgICB0aGlzLmluZGV4LS07XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcERvd24gfHwgdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkRvd25VcCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgtLTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IDApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAxO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy52YWx1ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMjtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuUmFuZG9tKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnZhbHVlcy5sZW5ndGgpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlJhbmRvbVdhbGspIHtcblx0ICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgtLTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBNYXRoLm1heCh0aGlzLmluZGV4LCAwKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBNYXRoLm1pbih0aGlzLmluZGV4LCB0aGlzLnZhbHVlcy5sZW5ndGggLSAxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlJhbmRvbU9uY2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuXHQgICAgICAgICAgICAgICAgLy9yZXNodWZmbGUgdGhlIHZhbHVlcyBmb3IgbmV4dCB0aW1lXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zaHVmZmxlVmFsdWVzKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5BbHRlcm5hdGVVcCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCAtPSAxO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID49IHRoaXMudmFsdWVzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5BbHRlcm5hdGVEb3duKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAxO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkRvd247XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4IC09IDI7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPCAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTaHVmZmxlcyB0aGUgdmFsdWVzIGFuZCBwbGFjZXMgdGhlIHJlc3VsdHMgaW50byB0aGUgX3NodWZmbGVkXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxQYXR0ZXJuLnByb3RvdHlwZS5fc2h1ZmZsZVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgY29weSA9IFtdO1xuXHQgICAgICAgIHRoaXMuX3NodWZmbGVkID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBjb3B5W2ldID0gaTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgd2hpbGUgKGNvcHkubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICB2YXIgcmFuZFZhbCA9IGNvcHkuc3BsaWNlKE1hdGguZmxvb3IoY29weS5sZW5ndGggKiBNYXRoLnJhbmRvbSgpKSwgMSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NodWZmbGVkLnB1c2gocmFuZFZhbFswXSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5DdHJsUGF0dGVybn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUGF0dGVybi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9zaHVmZmxlZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy52YWx1ZXMgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkN0cmxQYXR0ZXJuO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIENob29zZSBhIHJhbmRvbSB2YWx1ZS5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHJhbmRvbVdhbGsgPSBuZXcgVG9uZS5DdHJsUmFuZG9tKHtcblx0XHQgKiBcdFwibWluXCIgOiAwLFxuXHRcdCAqIFx0XCJtYXhcIiA6IDEwLFxuXHRcdCAqIFx0XCJpbnRlZ2VyXCIgOiB0cnVlXG5cdFx0ICogfSk7XG5cdFx0ICogcmFuZG9tV2Fsay5ldmFsKCk7XG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ8VGltZT19IG1pbiBUaGUgbWluaW11bSByZXR1cm4gdmFsdWUuXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfFRpbWU9fSBtYXggVGhlIG1heGltdW0gcmV0dXJuIHZhbHVlLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUmFuZG9tID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ21pbicsXG5cdCAgICAgICAgICAgICdtYXgnXG5cdCAgICAgICAgXSwgVG9uZS5DdHJsUmFuZG9tKTtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pbmltdW0gcmV0dXJuIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ8VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWluID0gb3B0aW9ucy5taW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1heGltdW0gcmV0dXJuIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ8VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWF4ID0gb3B0aW9ucy5tYXg7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSWYgdGhlIHJldHVybiB2YWx1ZSBzaG91bGQgYmUgYW4gaW50ZWdlclxuXHRcdFx0ICogIEB0eXBlICB7Qm9vbGVhbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW50ZWdlciA9IG9wdGlvbnMuaW50ZWdlcjtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkN0cmxSYW5kb20pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxSYW5kb20uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgJ21heCc6IDEsXG5cdCAgICAgICAgJ2ludGVnZXInOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gYSByYW5kb20gdmFsdWUgYmV0d2VlbiBtaW4gYW5kIG1heC4gXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5DdHJsUmFuZG9tI1xuXHRcdCAqICBAdHlwZSB7Kn1cblx0XHQgKiAgQG5hbWUgdmFsdWVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkN0cmxSYW5kb20ucHJvdG90eXBlLCAndmFsdWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBtaW4gPSB0aGlzLnRvU2Vjb25kcyh0aGlzLm1pbik7XG5cdCAgICAgICAgICAgIHZhciBtYXggPSB0aGlzLnRvU2Vjb25kcyh0aGlzLm1heCk7XG5cdCAgICAgICAgICAgIHZhciByYW5kID0gTWF0aC5yYW5kb20oKTtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IHJhbmQgKiBtaW4gKyAoMSAtIHJhbmQpICogbWF4O1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pbnRlZ2VyKSB7XG5cdCAgICAgICAgICAgICAgICB2YWwgPSBNYXRoLmZsb29yKHZhbCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBUb25lLkN0cmxSYW5kb207XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEF1ZGlvQnVmZmVyLmNvcHlUb0NoYW5uZWwgcG9seWZpbGxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIGlmICh3aW5kb3cuQXVkaW9CdWZmZXIgJiYgIUF1ZGlvQnVmZmVyLnByb3RvdHlwZS5jb3B5VG9DaGFubmVsKSB7XG5cdCAgICAgICAgQXVkaW9CdWZmZXIucHJvdG90eXBlLmNvcHlUb0NoYW5uZWwgPSBmdW5jdGlvbiAoc3JjLCBjaGFuTnVtLCBzdGFydCkge1xuXHQgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuZ2V0Q2hhbm5lbERhdGEoY2hhbk51bSk7XG5cdCAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVsLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFubmVsW2kgKyBzdGFydF0gPSBzcmNbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIEF1ZGlvQnVmZmVyLnByb3RvdHlwZS5jb3B5RnJvbUNoYW5uZWwgPSBmdW5jdGlvbiAoZGVzdCwgY2hhbk51bSwgc3RhcnQpIHtcblx0ICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmdldENoYW5uZWxEYXRhKGNoYW5OdW0pO1xuXHQgICAgICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVzdC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZGVzdFtpXSA9IGNoYW5uZWxbaSArIHN0YXJ0XTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBCdWZmZXIgbG9hZGluZyBhbmQgc3RvcmFnZS4gVG9uZS5CdWZmZXIgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IGFsbCBcblx0XHQgKiAgICAgICAgICBjbGFzc2VzIHRoYXQgbWFrZSByZXF1ZXN0cyBmb3IgYXVkaW8gZmlsZXMgc3VjaCBhcyBUb25lLlBsYXllcixcblx0XHQgKiAgICAgICAgICBUb25lLlNhbXBsZXIgYW5kIFRvbmUuQ29udm9sdmVyLlxuXHRcdCAqICAgICAgICAgIFxuXHRcdCAqICAgICAgICAgIEFzaWRlIGZyb20gbG9hZCBjYWxsYmFja3MgZnJvbSBpbmRpdmlkdWFsIGJ1ZmZlcnMsIFRvbmUuQnVmZmVyIFxuXHRcdCAqICBcdFx0cHJvdmlkZXMgZXZlbnRzIHdoaWNoIGtlZXAgdHJhY2sgb2YgdGhlIGxvYWRpbmcgcHJvZ3Jlc3MgXG5cdFx0ICogIFx0XHRvZiBfYWxsXyBvZiB0aGUgYnVmZmVycy4gVGhlc2UgYXJlIFRvbmUuQnVmZmVyLm9uKFwibG9hZFwiIC8gXCJwcm9ncmVzc1wiIC8gXCJlcnJvclwiKVxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvciBcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSB7QXVkaW9CdWZmZXJ8U3RyaW5nfSB1cmwgVGhlIHVybCB0byBsb2FkLCBvciB0aGUgYXVkaW8gYnVmZmVyIHRvIHNldC4gXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb249fSBvbmxvYWQgQSBjYWxsYmFjayB3aGljaCBpcyBpbnZva2VkIGFmdGVyIHRoZSBidWZmZXIgaXMgbG9hZGVkLiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSBgVG9uZS5CdWZmZXIub24oJ2xvYWQnLCBjYWxsYmFjaylgIGluc3RlYWQgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luY2UgaXQgd2lsbCBnaXZlIHlvdSBhIGNhbGxiYWNrIHdoZW4gX2FsbF8gYnVmZmVycyBhcmUgbG9hZGVkLlxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9uPX0gb25lcnJvciBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGlmIHRoZXJlIGlzIGFuIGVycm9yXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGJ1ZmZlciA9IG5ldyBUb25lLkJ1ZmZlcihcInBhdGgvdG8vc291bmQubXAzXCIsIGZ1bmN0aW9uKCl7XG5cdFx0ICogXHQvL3RoZSBidWZmZXIgaXMgbm93IGF2YWlsYWJsZS5cblx0XHQgKiBcdHZhciBidWZmID0gYnVmZmVyLmdldCgpO1xuXHRcdCAqIH0pO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vY2FuIGxvYWQgcHJvdmlkZSBmYWxsYmFjayBleHRlbnNpb24gdHlwZXMgaWYgdGhlIGZpcnN0IHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cblx0XHQgKiB2YXIgYnVmZmVyID0gbmV3IFRvbmUuQnVmZmVyKFwicGF0aC90by9zb3VuZC5bbXAzfG9nZ3x3YXZdXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndXJsJyxcblx0ICAgICAgICAgICAgJ29ubG9hZCcsXG5cdCAgICAgICAgICAgICdvbmVycm9yJ1xuXHQgICAgICAgIF0sIFRvbmUuQnVmZmVyKTtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgc3RvcmVzIHRoZSBsb2FkZWQgQXVkaW9CdWZmZXJcblx0XHRcdCAqICBAdHlwZSB7QXVkaW9CdWZmZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgaW5kaWNhdGVzIGlmIHRoZSBidWZmZXIgc2hvdWxkIGJlIHJldmVyc2VkIG9yIG5vdFxuXHRcdFx0ICogIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9yZXZlcnNlZCA9IG9wdGlvbnMucmV2ZXJzZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgWEhSXG5cdFx0XHQgKiAgQHR5cGUgIHtYTUxIdHRwUmVxdWVzdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5feGhyID0gbnVsbDtcblx0ICAgICAgICBpZiAob3B0aW9ucy51cmwgaW5zdGFuY2VvZiBBdWRpb0J1ZmZlciB8fCBvcHRpb25zLnVybCBpbnN0YW5jZW9mIFRvbmUuQnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0KG9wdGlvbnMudXJsKTtcblx0ICAgICAgICAgICAgLy8gaW52b2tlIHRoZSBvbmxvYWQgY2FsbGJhY2tcblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMub25sb2FkKSB7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm9ubG9hZCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc1N0cmluZyhvcHRpb25zLnVybCkpIHtcblx0ICAgICAgICAgICAgdGhpcy5sb2FkKG9wdGlvbnMudXJsLCBvcHRpb25zLm9ubG9hZCwgb3B0aW9ucy5vbmVycm9yKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5CdWZmZXIpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd1cmwnOiB1bmRlZmluZWQsXG5cdCAgICAgICAgJ3JldmVyc2UnOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBQYXNzIGluIGFuIEF1ZGlvQnVmZmVyIG9yIFRvbmUuQnVmZmVyIHRvIHNldCB0aGUgdmFsdWVcblx0XHQgKiAgb2YgdGhpcyBidWZmZXIuXG5cdFx0ICogIEBwYXJhbSB7QXVkaW9CdWZmZXJ8VG9uZS5CdWZmZXJ9IGJ1ZmZlciB0aGUgYnVmZmVyXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkJ1ZmZlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChidWZmZXIpIHtcblx0ICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVG9uZS5CdWZmZXIpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYnVmZmVyID0gYnVmZmVyLmdldCgpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEByZXR1cm4ge0F1ZGlvQnVmZmVyfSBUaGUgYXVkaW8gYnVmZmVyIHN0b3JlZCBpbiB0aGUgb2JqZWN0LlxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBNYWtlcyBhbiB4aHIgcmVxZXN0IGZvciB0aGUgc2VsZWN0ZWQgdXJsIHRoZW4gZGVjb2Rlc1xuXHRcdCAqICB0aGUgZmlsZSBhcyBhbiBhdWRpbyBidWZmZXIuIEludm9rZXNcblx0XHQgKiAgdGhlIGNhbGxiYWNrIG9uY2UgdGhlIGF1ZGlvIGJ1ZmZlciBsb2Fkcy5cblx0XHQgKiAgQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgdXJsIG9mIHRoZSBidWZmZXIgdG8gbG9hZC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICBmaWxldHlwZSBzdXBwb3J0IGRlcGVuZHMgb24gdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5cblx0XHQgKiAgQHJldHVybnMge1Byb21pc2V9IHJldHVybnMgYSBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHdpdGggdGhlIFRvbmUuQnVmZmVyXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICh1cmwsIG9ubG9hZCwgb25lcnJvcikge1xuXHQgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKGxvYWQsIGVycm9yKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3hociA9IFRvbmUuQnVmZmVyLmxvYWQodXJsLCAvL3N1Y2Nlc3Ncblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGJ1ZmYpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3hociA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNldChidWZmKTtcblx0ICAgICAgICAgICAgICAgIGxvYWQodGhpcyk7XG5cdCAgICAgICAgICAgICAgICBpZiAob25sb2FkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb25sb2FkKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LmJpbmQodGhpcyksIC8vZXJyb3Jcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGVycikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5feGhyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIGVycm9yKGVycik7XG5cdCAgICAgICAgICAgICAgICBpZiAob25lcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIG9uZXJyb3IoZXJyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBkaXNwb3NlIGFuZCBkaXNjb25uZWN0XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkJ1ZmZlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICAgICAgaWYgKHRoaXMuX3hocikge1xuXHQgICAgICAgICAgICBUb25lLkJ1ZmZlci5fcmVtb3ZlRnJvbURvd25sb2FkUXVldWUodGhpcy5feGhyKTtcblx0ICAgICAgICAgICAgdGhpcy5feGhyLmFib3J0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3hociA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIHRoZSBidWZmZXIgaXMgbG9hZGVkIG9yIG5vdFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlciNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAbmFtZSBsb2FkZWRcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlci5wcm90b3R5cGUsICdsb2FkZWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZHVyYXRpb24gb2YgdGhlIGJ1ZmZlci4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgZHVyYXRpb25cblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlci5wcm90b3R5cGUsICdkdXJhdGlvbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5kdXJhdGlvbjtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaW4gc2FtcGxlc1xuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIGxlbmd0aFxuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQnVmZmVyLnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5sZW5ndGg7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBkaXNjcmV0ZSBhdWRpbyBjaGFubmVscy4gUmV0dXJucyAwIGlmIG5vIGJ1ZmZlclxuXHRcdCAqIGlzIGxvYWRlZC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXIjXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSBudW1iZXJPZkNoYW5uZWxzXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXIucHJvdG90eXBlLCAnbnVtYmVyT2ZDaGFubmVscycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5udW1iZXJPZkNoYW5uZWxzO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgdGhlIGF1ZGlvIGJ1ZmZlciBmcm9tIHRoZSBhcnJheS4gVG8gY3JlYXRlIGEgbXVsdGljaGFubmVsIEF1ZGlvQnVmZmVyLFxuXHRcdCAqICBwYXNzIGluIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheS4gXG5cdFx0ICogIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbCB0aGUgYXVkaW8gYnVmZmVyXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuQnVmZmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGFycmF5KSB7XG5cdCAgICAgICAgdmFyIGlzTXVsdGlkaW1lbnNpb25hbCA9IGFycmF5WzBdLmxlbmd0aCA+IDA7XG5cdCAgICAgICAgdmFyIGNoYW5uZWxzID0gaXNNdWx0aWRpbWVuc2lvbmFsID8gYXJyYXkubGVuZ3RoIDogMTtcblx0ICAgICAgICB2YXIgbGVuID0gaXNNdWx0aWRpbWVuc2lvbmFsID8gYXJyYXlbMF0ubGVuZ3RoIDogYXJyYXkubGVuZ3RoO1xuXHQgICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyKGNoYW5uZWxzLCBsZW4sIHRoaXMuY29udGV4dC5zYW1wbGVSYXRlKTtcblx0ICAgICAgICBpZiAoIWlzTXVsdGlkaW1lbnNpb25hbCAmJiBjaGFubmVscyA9PT0gMSkge1xuXHQgICAgICAgICAgICBhcnJheSA9IFthcnJheV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2hhbm5lbHM7IGMrKykge1xuXHQgICAgICAgICAgICBidWZmZXIuY29weVRvQ2hhbm5lbChhcnJheVtjXSwgYyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBcdFN1bXMgbXVsaXBsZSBjaGFubmVscyBpbnRvIDEgY2hhbm5lbFxuXHRcdCAqICBAcGFyYW0ge051bWJlcj19IGNoYW5uZWwgT3B0aW9uYWxseSBvbmx5IGNvcHkgYSBzaW5nbGUgY2hhbm5lbCBmcm9tIHRoZSBhcnJheS5cblx0XHQgKiAgQHJldHVybiB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUudG9Nb25vID0gZnVuY3Rpb24gKGNoYW5OdW0pIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc051bWJlcihjaGFuTnVtKSkge1xuXHQgICAgICAgICAgICB0aGlzLmZyb21BcnJheSh0aGlzLnRvQXJyYXkoY2hhbk51bSkpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBvdXRwdXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5sZW5ndGgpO1xuXHQgICAgICAgICAgICB2YXIgbnVtQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHM7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgbnVtQ2hhbm5lbHM7IGNoYW5uZWwrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWxBcnJheSA9IHRoaXMudG9BcnJheShjaGFubmVsKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3V0cHV0QXJyYXlbaV0gKz0gY2hhbm5lbEFycmF5W2ldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vZGl2aWRlIGJ5IHRoZSBudW1iZXIgb2YgY2hhbm5lbHNcblx0ICAgICAgICAgICAgb3V0cHV0QXJyYXkgPSBvdXRwdXRBcnJheS5tYXAoZnVuY3Rpb24gKHNhbXBsZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNhbXBsZSAvIG51bUNoYW5uZWxzO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhpcy5mcm9tQXJyYXkob3V0cHV0QXJyYXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBcdEdldCB0aGUgYnVmZmVyIGFzIGFuIGFycmF5LiBTaW5nbGUgY2hhbm5lbCBidWZmZXJzIHdpbGwgcmV0dXJuIGEgMS1kaW1lbnNpb25hbCBcblx0XHQgKiBcdEZsb2F0MzJBcnJheSwgYW5kIG11bHRpY2hhbm5lbCBidWZmZXJzIHdpbGwgcmV0dXJuIG11bHRpZGltZW5zaW9uYWwgYXJyYXlzLlxuXHRcdCAqICBAcGFyYW0ge051bWJlcj19IGNoYW5uZWwgT3B0aW9uYWxseSBvbmx5IGNvcHkgYSBzaW5nbGUgY2hhbm5lbCBmcm9tIHRoZSBhcnJheS5cblx0XHQgKiAgQHJldHVybiB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNOdW1iZXIoY2hhbm5lbCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbCk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLm51bWJlck9mQ2hhbm5lbHMgPT09IDEpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgwKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgcmV0ID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGhpcy5udW1iZXJPZkNoYW5uZWxzOyBjKyspIHtcblx0ICAgICAgICAgICAgICAgIHJldFtjXSA9IHRoaXMuZ2V0Q2hhbm5lbERhdGEoYyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIEZsb2F0MzJBcnJheSByZXByZXNlbnRpbmcgdGhlIFBDTSBhdWRpbyBkYXRhIGZvciB0aGUgc3BlY2lmaWMgY2hhbm5lbC5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgY2hhbm5lbCAgVGhlIGNoYW5uZWwgbnVtYmVyIHRvIHJldHVyblxuXHRcdCAqICBAcmV0dXJuICB7RmxvYXQzMkFycmF5fSAgVGhlIGF1ZGlvIGFzIGEgVHlwZWRBcnJheVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLmdldENoYW5uZWxEYXRhID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWwpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDdXQgYSBzdWJzZWN0aW9uIG9mIHRoZSBhcnJheSBhbmQgcmV0dXJuIGEgYnVmZmVyIG9mIHRoZVxuXHRcdCAqICBzdWJzZWN0aW9uLiBEb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGJ1ZmZlclxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHN0YXJ0IFRoZSB0aW1lIHRvIHN0YXJ0IHRoZSBzbGljZVxuXHRcdCAqICBAcGFyYW0ge1RpbWU9fSBlbmQgVGhlIGVuZCB0aW1lIHRvIHNsaWNlLiBJZiBub25lIGlzIGdpdmVuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICB3aWxsIGRlZmF1bHQgdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuQnVmZmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuXHQgICAgICAgIGVuZCA9IFRvbmUuZGVmYXVsdEFyZyhlbmQsIHRoaXMuZHVyYXRpb24pO1xuXHQgICAgICAgIHZhciBzdGFydFNhbXBsZXMgPSBNYXRoLmZsb29yKHRoaXMuY29udGV4dC5zYW1wbGVSYXRlICogdGhpcy50b1NlY29uZHMoc3RhcnQpKTtcblx0ICAgICAgICB2YXIgZW5kU2FtcGxlcyA9IE1hdGguZmxvb3IodGhpcy5jb250ZXh0LnNhbXBsZVJhdGUgKiB0aGlzLnRvU2Vjb25kcyhlbmQpKTtcblx0ICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtYmVyT2ZDaGFubmVsczsgaSsrKSB7XG5cdCAgICAgICAgICAgIHJlcGxhY2VtZW50W2ldID0gdGhpcy50b0FycmF5KGkpLnNsaWNlKHN0YXJ0U2FtcGxlcywgZW5kU2FtcGxlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXRCdWZmZXIgPSBuZXcgVG9uZS5CdWZmZXIoKS5mcm9tQXJyYXkocmVwbGFjZW1lbnQpO1xuXHQgICAgICAgIHJldHVybiByZXRCdWZmZXI7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldmVyc2UgdGhlIGJ1ZmZlci5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHJldHVybiB7VG9uZS5CdWZmZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLnByb3RvdHlwZS5fcmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5sb2FkZWQpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bWJlck9mQ2hhbm5lbHM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbCh0aGlzLmdldENoYW5uZWxEYXRhKGkpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBSZXZlcnNlIHRoZSBidWZmZXIuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyI1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBuYW1lIHJldmVyc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlci5wcm90b3R5cGUsICdyZXZlcnNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZWQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyZXYpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3JldmVyc2VkICE9PSByZXYpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JldmVyc2VkID0gcmV2O1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmV2ZXJzZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIFNUQVRJQyBNRVRIT0RTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vc3RhdGljYWxseSBpbmhlcml0cyBFbWl0dGVyIG1ldGhvZHNcblx0ICAgIFRvbmUuRW1pdHRlci5taXhpbihUb25lLkJ1ZmZlcik7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIHN0YXRpYyBxdWV1ZSBmb3IgYWxsIG9mIHRoZSB4aHIgcmVxdWVzdHNcblx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWUgPSBbXTtcblx0ICAgIC8qKlxuXHRcdCAqICBBIHBhdGggd2hpY2ggaXMgcHJlZml4ZWQgYmVmb3JlIGV2ZXJ5IHVybC5cblx0XHQgKiAgQHR5cGUgIHtTdHJpbmd9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLmJhc2VVcmwgPSAnJztcblx0ICAgIC8qKlxuXHRcdCAqICBDcmVhdGUgYSBUb25lLkJ1ZmZlciBmcm9tIHRoZSBhcnJheS4gVG8gY3JlYXRlIGEgbXVsdGljaGFubmVsIEF1ZGlvQnVmZmVyLFxuXHRcdCAqICBwYXNzIGluIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheS4gXG5cdFx0ICogIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbCB0aGUgYXVkaW8gYnVmZmVyXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuQnVmZmVyfSBBIFRvbmUuQnVmZmVyIGNyZWF0ZWQgZnJvbSB0aGUgYXJyYXlcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLmZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgVG9uZS5CdWZmZXIoKS5mcm9tQXJyYXkoYXJyYXkpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFJlbW92ZSBhbiB4aHIgcmVxdWVzdCBmcm9tIHRoZSBkb3dubG9hZCBxdWV1ZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5fcmVtb3ZlRnJvbURvd25sb2FkUXVldWUgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXHQgICAgICAgIHZhciBpbmRleCA9IFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLmluZGV4T2YocmVxdWVzdCk7XG5cdCAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICBUb25lLkJ1ZmZlci5fZG93bmxvYWRRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgTG9hZHMgYSB1cmwgdXNpbmcgWE1MSHR0cFJlcXVlc3QuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB1cmxcblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gb25sb2FkXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IG9uZXJyb3Jcblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gb25wcm9ncmVzc1xuXHRcdCAqICBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLmxvYWQgPSBmdW5jdGlvbiAodXJsLCBvbmxvYWQsIG9uZXJyb3IpIHtcblx0ICAgICAgICAvL2RlZmF1bHRcblx0ICAgICAgICBvbmxvYWQgPSBUb25lLmRlZmF1bHRBcmcob25sb2FkLCBUb25lLm5vT3ApO1xuXHQgICAgICAgIC8vIHRlc3QgaWYgdGhlIHVybCBjb250YWlucyBtdWx0aXBsZSBleHRlbnNpb25zXG5cdCAgICAgICAgdmFyIG1hdGNoZXMgPSB1cmwubWF0Y2goL1xcWyguK1xcfD8pK1xcXSQvKTtcblx0ICAgICAgICBpZiAobWF0Y2hlcykge1xuXHQgICAgICAgICAgICB2YXIgZXh0ZW5zaW9ucyA9IG1hdGNoZXNbMV0uc3BsaXQoJ3wnKTtcblx0ICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbMF07XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKFRvbmUuQnVmZmVyLnN1cHBvcnRzVHlwZShleHRlbnNpb25zW2ldKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UobWF0Y2hlc1swXSwgZXh0ZW5zaW9uKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gb25FcnJvcihlKSB7XG5cdCAgICAgICAgICAgIFRvbmUuQnVmZmVyLl9yZW1vdmVGcm9tRG93bmxvYWRRdWV1ZShyZXF1ZXN0KTtcblx0ICAgICAgICAgICAgVG9uZS5CdWZmZXIuZW1pdCgnZXJyb3InLCBlKTtcblx0ICAgICAgICAgICAgaWYgKG9uZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIG9uZXJyb3IoZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoKSB7XG5cdCAgICAgICAgICAgIC8vY2FsY3VsYXRlIHRoZSBwcm9ncmVzc1xuXHQgICAgICAgICAgICB2YXIgdG90YWxQcm9ncmVzcyA9IDA7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRvdGFsUHJvZ3Jlc3MgKz0gVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWVbaV0ucHJvZ3Jlc3M7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgVG9uZS5CdWZmZXIuZW1pdCgncHJvZ3Jlc3MnLCB0b3RhbFByb2dyZXNzIC8gVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWUubGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0ICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIFRvbmUuQnVmZmVyLmJhc2VVcmwgKyB1cmwsIHRydWUpO1xuXHQgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblx0ICAgICAgICAvL3N0YXJ0IG91dCBhcyAwXG5cdCAgICAgICAgcmVxdWVzdC5wcm9ncmVzcyA9IDA7XG5cdCAgICAgICAgVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWUucHVzaChyZXF1ZXN0KTtcblx0ICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XG5cdCAgICAgICAgICAgICAgICBUb25lLmNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHJlcXVlc3QucmVzcG9uc2UsIGZ1bmN0aW9uIChidWZmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5wcm9ncmVzcyA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcygpO1xuXHQgICAgICAgICAgICAgICAgICAgIG9ubG9hZChidWZmKTtcblx0ICAgICAgICAgICAgICAgICAgICBUb25lLkJ1ZmZlci5fcmVtb3ZlRnJvbURvd25sb2FkUXVldWUocmVxdWVzdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL2VtaXQgdGhlIGV2ZW50IGF0IHRoZSBlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgVG9uZS5CdWZmZXIuZW1pdCgnbG9hZCcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBUb25lLkJ1ZmZlci5fcmVtb3ZlRnJvbURvd25sb2FkUXVldWUocmVxdWVzdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgb25FcnJvcignVG9uZS5CdWZmZXI6IGNvdWxkIG5vdCBkZWNvZGUgYXVkaW8gZGF0YTogJyArIHVybCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG9uRXJyb3IoJ1RvbmUuQnVmZmVyOiBjb3VsZCBub3QgbG9jYXRlIGZpbGU6ICcgKyB1cmwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuXHQgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcblx0ICAgICAgICAgICAgICAgIC8vb25seSBnbyB0byA5NSUsIHRoZSBsYXN0IDUlIGlzIHdoZW4gdGhlIGF1ZGlvIGlzIGRlY29kZWRcblx0ICAgICAgICAgICAgICAgIHJlcXVlc3QucHJvZ3Jlc3MgPSBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbCAqIDAuOTU7XG5cdCAgICAgICAgICAgICAgICBvblByb2dyZXNzKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXF1ZXN0LnNlbmQoKTtcblx0ICAgICAgICByZXR1cm4gcmVxdWVzdDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCBhbGwgb2YgdGhlIGRvd25sb2FkcyBpbiBwcm9ncmVzc1xuXHRcdCAqICBAcmV0dXJuIHtUb25lLkJ1ZmZlcn1cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIuY2FuY2VsRG93bmxvYWRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCkge1xuXHQgICAgICAgICAgICBUb25lLkJ1ZmZlci5fcmVtb3ZlRnJvbURvd25sb2FkUXVldWUocmVxdWVzdCk7XG5cdCAgICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gVG9uZS5CdWZmZXI7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENoZWNrcyBhIHVybCdzIGV4dGVuc2lvbiB0byBzZWUgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBjYW4gcGxheSB0aGF0IGZpbGUgdHlwZS5cblx0XHQgKiAgQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgdXJsL2V4dGVuc2lvbiB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBmaWxlIGV4dGVuc2lvbiBjYW4gYmUgcGxheWVkXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLkJ1ZmZlci5zdXBwb3J0c1R5cGUoXCJ3YXZcIik7IC8vcmV0dXJucyB0cnVlXG5cdFx0ICogVG9uZS5CdWZmZXIuc3VwcG9ydHNUeXBlKFwicGF0aC90by9maWxlLndhdlwiKTsgLy9yZXR1cm5zIHRydWVcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLnN1cHBvcnRzVHlwZSA9IGZ1bmN0aW9uICh1cmwpIHtcblx0ICAgICAgICB2YXIgZXh0ZW5zaW9uID0gdXJsLnNwbGl0KCcuJyk7XG5cdCAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uW2V4dGVuc2lvbi5sZW5ndGggLSAxXTtcblx0ICAgICAgICB2YXIgcmVzcG9uc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpLmNhblBsYXlUeXBlKCdhdWRpby8nICsgZXh0ZW5zaW9uKTtcblx0ICAgICAgICByZXR1cm4gcmVzcG9uc2UgIT09ICcnO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIGEgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGFsbCBvZiB0aGUgYnVmZmVycyBoYXZlIGxvYWRlZFxuXHRcdCAqICBAcmV0dXJuIHtQcm9taXNlfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9ubG9hZCwgb25lcnJvcjtcblx0ICAgICAgICBmdW5jdGlvbiByZW1vdmVFdmVudHMoKSB7XG5cdCAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBldmVudHMgd2hlbiBpdCdzIHJlc29sdmVkXG5cdCAgICAgICAgICAgIFRvbmUuQnVmZmVyLm9mZignbG9hZCcsIG9ubG9hZCk7XG5cdCAgICAgICAgICAgIFRvbmUuQnVmZmVyLm9mZignZXJyb3InLCBvbmVycm9yKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBmYWlsKSB7XG5cdCAgICAgICAgICAgIG9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgb25lcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIGZhaWwoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgLy9hZGQgdGhlIGV2ZW50IGxpc3RlbmVyc1xuXHQgICAgICAgICAgICBUb25lLkJ1ZmZlci5vbignbG9hZCcsIG9ubG9hZCk7XG5cdCAgICAgICAgICAgIFRvbmUuQnVmZmVyLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXHQgICAgICAgIH0pLnRoZW4ocmVtb3ZlRXZlbnRzKS5jYXRjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICByZW1vdmVFdmVudHMoKTtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkJ1ZmZlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBIGRhdGEgc3RydWN0dXJlIGZvciBob2xkaW5nIG11bHRpcGxlIGJ1ZmZlcnMuXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtPYmplY3R8QXJyYXl9ICAgIHVybHMgICAgICBBbiBvYmplY3QgbGl0ZXJhbCBvciBhcnJheVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB1cmxzIHRvIGxvYWQuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9uPX0gIGNhbGxiYWNrICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBidWZmZXJzIGFyZSBsb2FkZWQuIFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2xvYWQgYSB3aG9sZSBiYW5rIG9mIHBpYW5vIHNhbXBsZXNcblx0XHQgKiB2YXIgcGlhbm9TYW1wbGVzID0gbmV3IFRvbmUuQnVmZmVycyh7XG5cdFx0ICogXHRcIkM0XCIgOiBcInBhdGgvdG8vQzQubXAzXCJcblx0XHQgKiBcdFwiQyM0XCIgOiBcInBhdGgvdG8vQyM0Lm1wM1wiXG5cdFx0ICogXHRcIkQ0XCIgOiBcInBhdGgvdG8vRDQubXAzXCJcblx0XHQgKiBcdFwiRCM0XCIgOiBcInBhdGgvdG8vRCM0Lm1wM1wiXG5cdFx0ICogXHQuLi5cblx0XHQgKiB9LCBmdW5jdGlvbigpe1xuXHRcdCAqIFx0Ly9wbGF5IG9uZSBvZiB0aGUgc2FtcGxlcyB3aGVuIHRoZXkgYWxsIGxvYWRcblx0XHQgKiBcdHBsYXllci5idWZmZXIgPSBwaWFub1NhbXBsZXMuZ2V0KFwiQzRcIik7XG5cdFx0ICogXHRwbGF5ZXIuc3RhcnQoKTtcblx0XHQgKiB9KTtcblx0XHQgKiBcdEBleGFtcGxlXG5cdFx0ICogLy9UbyBwYXNzIGluIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBpbiB0aGUgc2Vjb25kIHBhcmFtZXRlclxuXHRcdCAqIHZhciBidWZmZXJzID0gbmV3IFRvbmUuQnVmZmVycyh1cmxzLCB7XG5cdFx0ICogXHRcIm9ubG9hZFwiIDogY2FsbGJhY2ssXG5cdFx0ICogXHRcImJhc2VVcmxcIiA6IFwiLi4vcGF0aC90by9hdWRpby9cIlxuXHRcdCAqIH0pXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMgPSBmdW5jdGlvbiAodXJscykge1xuXHQgICAgICAgIC8vcmVtb3ZlIHRoZSB1cmxzIGZyb20gdGhlIG9wdGlvbnNcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgYXJncy5zaGlmdCgpO1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmdzLCBbXG5cdCAgICAgICAgICAgICdvbmxvYWQnLFxuXHQgICAgICAgICAgICAnYmFzZVVybCdcblx0ICAgICAgICBdLCBUb25lLkJ1ZmZlcnMpO1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbGwgb2YgdGhlIGJ1ZmZlcnNcblx0XHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYnVmZmVycyA9IHt9O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgcGF0aCB3aGljaCBpcyBwcmVmaXhlZCBiZWZvcmUgZXZlcnkgdXJsLlxuXHRcdFx0ICogIEB0eXBlICB7U3RyaW5nfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5iYXNlVXJsID0gb3B0aW9ucy5iYXNlVXJsO1xuXHQgICAgICAgIHRoaXMuX2xvYWRpbmdDb3VudCA9IDA7XG5cdCAgICAgICAgLy9hZGQgZWFjaCBvbmVcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gdXJscykge1xuXHQgICAgICAgICAgICB0aGlzLl9sb2FkaW5nQ291bnQrKztcblx0ICAgICAgICAgICAgdGhpcy5hZGQoa2V5LCB1cmxzW2tleV0sIHRoaXMuX2J1ZmZlckxvYWRlZC5iaW5kKHRoaXMsIG9wdGlvbnMub25sb2FkKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQnVmZmVycyk7XG5cdCAgICAvKipcblx0XHQgKiAgRGVmYXVsdHNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ29ubG9hZCc6IFRvbmUubm9PcCxcblx0ICAgICAgICAnYmFzZVVybCc6ICcnXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRydWUgaWYgdGhlIGJ1ZmZlcnMgb2JqZWN0IGhhcyBhIGJ1ZmZlciBieSB0aGF0IG5hbWUuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ9ICBuYW1lICBUaGUga2V5IG9yIGluZGV4IG9mIHRoZSBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5cblx0XHQgKiAgQHJldHVybiAge0Jvb2xlYW59XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcnMuaGFzT3duUHJvcGVydHkobmFtZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCBhIGJ1ZmZlciBieSBuYW1lLiBJZiBhbiBhcnJheSB3YXMgbG9hZGVkLCBcblx0XHQgKiAgdGhlbiB1c2UgdGhlIGFycmF5IGluZGV4LlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd8TnVtYmVyfSAgbmFtZSAgVGhlIGtleSBvciBpbmRleCBvZiB0aGUgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkJ1ZmZlcn1cblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5oYXMobmFtZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcnNbbmFtZV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLkJ1ZmZlcnM6IG5vIGJ1ZmZlciBuYW1lZCAnICsgbmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBIGJ1ZmZlciB3YXMgbG9hZGVkLiBkZWNyZW1lbnQgdGhlIGNvdW50ZXIuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMucHJvdG90eXBlLl9idWZmZXJMb2FkZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0ICAgICAgICB0aGlzLl9sb2FkaW5nQ291bnQtLTtcblx0ICAgICAgICBpZiAodGhpcy5fbG9hZGluZ0NvdW50ID09PSAwICYmIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBJZiB0aGUgYnVmZmVycyBhcmUgbG9hZGVkIG9yIG5vdFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlcnMjXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbG9hZGVkXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXJzLnByb3RvdHlwZSwgJ2xvYWRlZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGlzTG9hZGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgYnVmZk5hbWUgaW4gdGhpcy5fYnVmZmVycykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ1ZmYgPSB0aGlzLmdldChidWZmTmFtZSk7XG5cdCAgICAgICAgICAgICAgICBpc0xvYWRlZCA9IGlzTG9hZGVkICYmIGJ1ZmYubG9hZGVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBpc0xvYWRlZDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGQgYSBidWZmZXIgYnkgbmFtZSBhbmQgdXJsIHRvIHRoZSBCdWZmZXJzXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gICAgbmFtZSAgICAgIEEgdW5pcXVlIG5hbWUgdG8gZ2l2ZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYnVmZmVyXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ3xUb25lLkJ1ZmZlcnxBdWRpb2J1ZmZlcn0gIHVybCAgRWl0aGVyIHRoZSB1cmwgb2YgdGhlIGJ1ZmVyLCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhIGJ1ZmZlciB3aGljaCB3aWxsIGJlIGFkZGVkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb249fSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB0byBpbnZva2UgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIHRoZSB1cmwgaXMgbG9hZGVkLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobmFtZSwgdXJsLCBjYWxsYmFjaykge1xuXHQgICAgICAgIGNhbGxiYWNrID0gVG9uZS5kZWZhdWx0QXJnKGNhbGxiYWNrLCBUb25lLm5vT3ApO1xuXHQgICAgICAgIGlmICh1cmwgaW5zdGFuY2VvZiBUb25lLkJ1ZmZlcikge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXJzW25hbWVdID0gdXJsO1xuXHQgICAgICAgICAgICBjYWxsYmFjayh0aGlzKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHVybCBpbnN0YW5jZW9mIEF1ZGlvQnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlcnNbbmFtZV0gPSBuZXcgVG9uZS5CdWZmZXIodXJsKTtcblx0ICAgICAgICAgICAgY2FsbGJhY2sodGhpcyk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzU3RyaW5nKHVybCkpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYnVmZmVyc1tuYW1lXSA9IG5ldyBUb25lLkJ1ZmZlcih0aGlzLmJhc2VVcmwgKyB1cmwsIGNhbGxiYWNrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5CdWZmZXJzfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5fYnVmZmVycykge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXJzW25hbWVdLmRpc3Bvc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQnVmZmVycztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgYnVzZXMgYXJlIGFub3RoZXIgd2F5IG9mIHJvdXRpbmcgYXVkaW9cblx0XHQgKlxuXHRcdCAqICBhdWdtZW50cyBUb25lLnByb3RvdHlwZSB0byBpbmNsdWRlIHNlbmQgYW5kIHJlY2lldmVcblx0XHQgKi9cblx0ICAgIC8qKlxuXHRcdCAgKiAgQWxsIG9mIHRoZSByb3V0ZXNcblx0XHQgICogIFxuXHRcdCAgKiAgQHR5cGUge09iamVjdH1cblx0XHQgICogIEBzdGF0aWNcblx0XHQgICogIEBwcml2YXRlXG5cdFx0ICAqL1xuXHQgICAgdmFyIEJ1c2VzID0ge307XG5cdCAgICAvKipcblx0XHQgKiAgU2VuZCB0aGlzIHNpZ25hbCB0byB0aGUgY2hhbm5lbCBuYW1lLiBcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSBjaGFubmVsTmFtZSBBIG5hbWVkIGNoYW5uZWwgdG8gc2VuZCB0aGUgc2lnbmFsIHRvLlxuXHRcdCAqICBAcGFyYW0gIHtEZWNpYmVsc30gYW1vdW50IFRoZSBhbW91bnQgb2YgdGhlIHNvdXJjZSB0byBzZW5kIHRvIHRoZSBidXMuIFxuXHRcdCAqICBAcmV0dXJuIHtHYWluTm9kZX0gVGhlIGdhaW4gbm9kZSB3aGljaCBjb25uZWN0cyB0aGlzIG5vZGUgdG8gdGhlIGRlc2lyZWQgY2hhbm5lbC4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICBDYW4gYmUgdXNlZCB0byBhZGp1c3QgdGhlIGxldmVscyBvZiB0aGUgc2VuZC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBzb3VyY2Uuc2VuZChcInJldmVyYlwiLCAtMTIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChjaGFubmVsTmFtZSwgYW1vdW50KSB7XG5cdCAgICAgICAgaWYgKCFCdXNlcy5oYXNPd25Qcm9wZXJ0eShjaGFubmVsTmFtZSkpIHtcblx0ICAgICAgICAgICAgQnVzZXNbY2hhbm5lbE5hbWVdID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYW1vdW50ID0gVG9uZS5kZWZhdWx0QXJnKGFtb3VudCwgMCk7XG5cdCAgICAgICAgdmFyIHNlbmRLbm9iID0gbmV3IFRvbmUuR2FpbihhbW91bnQsIFRvbmUuVHlwZS5EZWNpYmVscyk7XG5cdCAgICAgICAgdGhpcy5vdXRwdXQuY2hhaW4oc2VuZEtub2IsIEJ1c2VzW2NoYW5uZWxOYW1lXSk7XG5cdCAgICAgICAgcmV0dXJuIHNlbmRLbm9iO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZWNpZXZlIHRoZSBpbnB1dCBmcm9tIHRoZSBkZXNpcmVkIGNoYW5uZWxOYW1lIHRvIHRoZSBpbnB1dFxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gY2hhbm5lbE5hbWUgQSBuYW1lZCBjaGFubmVsIHRvIHNlbmQgdGhlIHNpZ25hbCB0by5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyPX0gY2hhbm5lbE51bWJlciBUaGUgY2hhbm5lbCB0byBjb25uZWN0IHRvXG5cdFx0ICogIEByZXR1cm5zIHtUb25lfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogcmV2ZXJiRWZmZWN0LnJlY2VpdmUoXCJyZXZlcmJcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5yZWNlaXZlID0gZnVuY3Rpb24gKGNoYW5uZWxOYW1lLCBpbnB1dE51bSkge1xuXHQgICAgICAgIGlmICghQnVzZXMuaGFzT3duUHJvcGVydHkoY2hhbm5lbE5hbWUpKSB7XG5cdCAgICAgICAgICAgIEJ1c2VzW2NoYW5uZWxOYW1lXSA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIEJ1c2VzW2NoYW5uZWxOYW1lXS5jb25uZWN0KHRoaXMsIDAsIGlucHV0TnVtKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvL3JlbW92ZSBhbGwgdGhlIHNlbmQvcmVjZWl2ZXMgd2hlbiBhIG5ldyBhdWRpbyBjb250ZXh0IGlzIHBhc3NlZCBpblxuXHQgICAgVG9uZS5Db250ZXh0Lm9uKCdpbml0JywgZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgICBpZiAoY29udGV4dC5CdXNlcykge1xuXHQgICAgICAgICAgICBCdXNlcyA9IGNvbnRleHQuQnVzZXM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgQnVzZXMgPSB7fTtcblx0ICAgICAgICAgICAgY29udGV4dC5CdXNlcyA9IEJ1c2VzO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIFRvbmU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkRyYXcgaXMgdXNlZnVsIGZvciBzeW5jaHJvbml6aW5nIHZpc3VhbHMgYW5kIGF1ZGlvIGV2ZW50cy5cblx0XHQgKiAgICAgICAgIENhbGxiYWNrcyBmcm9tIFRvbmUuVHJhbnNwb3J0IG9yIGFueSBvZiB0aGUgVG9uZS5FdmVudCBjbGFzc2VzXG5cdFx0ICogICAgICAgICBhbHdheXMgaGFwcGVuIF9iZWZvcmVfIHRoZSBzY2hlZHVsZWQgdGltZSBhbmQgYXJlIG5vdCBzeW5jaHJvbml6ZWRcblx0XHQgKiAgICAgICAgIHRvIHRoZSBhbmltYXRpb24gZnJhbWUgc28gdGhleSBhcmUgbm90IGdvb2QgZm9yIHRyaWdnZXJpbmcgdGlnaHRseVxuXHRcdCAqICAgICAgICAgc3luY2hyb25pemVkIHZpc3VhbHMgYW5kIHNvdW5kLiBUb25lLkRyYXcgbWFrZXMgaXQgZWFzeSB0byBzY2hlZHVsZVxuXHRcdCAqICAgICAgICAgY2FsbGJhY2tzIHVzaW5nIHRoZSBBdWRpb0NvbnRleHQgdGltZSBhbmQgdXNlcyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG5cdFx0ICogICAgICAgICBcblx0XHQgKiAgQHNpbmdsZXRvblxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZShmdW5jdGlvbih0aW1lKXtcblx0XHQgKiBcdC8vdXNlIHRoZSB0aW1lIGFyZ3VtZW50IHRvIHNjaGVkdWxlIGEgY2FsbGJhY2sgd2l0aCBUb25lLkRyYXdcblx0XHQgKiBcdFRvbmUuRHJhdy5zY2hlZHVsZShmdW5jdGlvbigpe1xuXHRcdCAqIFx0XHQvL2RvIGRyYXdpbmcgb3IgRE9NIG1hbmlwdWxhdGlvbiBoZXJlXG5cdFx0ICogXHR9LCB0aW1lKVxuXHRcdCAqIH0sIFwiKzAuNVwiKVxuXHRcdCAqL1xuXHQgICAgVG9uZS5EcmF3ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbGwgb2YgdGhlIGV2ZW50cy5cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuVGltZWxpbmV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBUb25lLlRpbWVsaW5lKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGR1cmF0aW9uIGFmdGVyIHdoaWNoIGV2ZW50cyBhcmUgbm90IGludm9rZWQuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQGRlZmF1bHQgMC4yNVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5leHBpcmF0aW9uID0gMC4yNTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIHRpbWUgYmVmb3JlIHRoZSBzY2hlZHVsZWQgdGltZSBcblx0XHRcdCAqICB0aGF0IHRoZSBjYWxsYmFjayBjYW4gYmUgaW52b2tlZC4gRGVmYXVsdCBpc1xuXHRcdFx0ICogIGhhbGYgdGhlIHRpbWUgb2YgYW4gYW5pbWF0aW9uIGZyYW1lICgwLjAwOCBzZWNvbmRzKS5cblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAZGVmYXVsdCAwLjAwOFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5hbnRpY2lwYXRpb24gPSAwLjAwODtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZHJhdyBsb29wXG5cdFx0XHQgKiAgQHR5cGUgIHtGdW5jdGlvbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYm91bmREcmF3TG9vcCA9IHRoaXMuX2RyYXdMb29wLmJpbmQodGhpcyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5EcmF3KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZSBhIGZ1bmN0aW9uIGF0IHRoZSBnaXZlbiB0aW1lIHRvIGJlIGludm9rZWRcblx0XHQgKiAgb24gdGhlIG5lYXJlc3QgYW5pbWF0aW9uIGZyYW1lLlxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrICBDYWxsYmFjayBpcyBpbnZva2VkIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgICB0aW1lICAgICAgVGhlIHRpbWUgcmVsYXRpdmUgdG8gdGhlIEF1ZGlvQ29udGV4dCB0aW1lXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBpbnZva2UgdGhlIGNhbGxiYWNrLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5EcmF3fSAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkRyYXcucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLmFkZCh7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcblx0ICAgICAgICAgICAgdGltZTogdGhpcy50b1NlY29uZHModGltZSlcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBkcmF3IGxvb3Agb24gdGhlIGZpcnN0IGV2ZW50XG5cdCAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2JvdW5kRHJhd0xvb3ApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VsIGV2ZW50cyBzY2hlZHVsZWQgYWZ0ZXIgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtICB7VGltZT19ICBhZnRlciAgVGltZSBhZnRlciB3aGljaCBzY2hlZHVsZWQgZXZlbnRzIHdpbGwgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHJlbW92ZWQgZnJvbSB0aGUgc2NoZWR1bGluZyB0aW1lbGluZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuRHJhd30gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRHJhdy5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLmNhbmNlbCh0aGlzLnRvU2Vjb25kcyhhZnRlcikpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZHJhdyBsb29wXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkRyYXcucHJvdG90eXBlLl9kcmF3TG9vcCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm93ID0gVG9uZS5ub3coKTtcblx0ICAgICAgICB3aGlsZSAodGhpcy5fZXZlbnRzLmxlbmd0aCAmJiB0aGlzLl9ldmVudHMucGVlaygpLnRpbWUgLSB0aGlzLmFudGljaXBhdGlvbiA8PSBub3cpIHtcblx0ICAgICAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5fZXZlbnRzLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgIGlmIChub3cgLSBldmVudC50aW1lIDw9IHRoaXMuZXhwaXJhdGlvbikge1xuXHQgICAgICAgICAgICAgICAgZXZlbnQuY2FsbGJhY2soKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2JvdW5kRHJhd0xvb3ApO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvL21ha2UgYSBzaW5nbGV0b25cblx0ICAgIFRvbmUuRHJhdyA9IG5ldyBUb25lLkRyYXcoKTtcblx0ICAgIHJldHVybiBUb25lLkRyYXc7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQm90aCBUb25lLlBhbm5lcjNEIGFuZCBUb25lLkxpc3RlbmVyIGhhdmUgYSBwb3NpdGlvbiBpbiAzRCBzcGFjZSBcblx0XHQgKiAgICAgICAgICB1c2luZyBhIHJpZ2h0LWhhbmRlZCBjYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW0uIFxuXHRcdCAqICAgICAgICAgIFRoZSB1bml0cyB1c2VkIGluIHRoZSBjb29yZGluYXRlIHN5c3RlbSBhcmUgbm90IGRlZmluZWQ7IFxuXHRcdCAqICAgICAgICAgIHRoZXNlIGNvb3JkaW5hdGVzIGFyZSBpbmRlcGVuZGVudC9pbnZhcmlhbnQgb2YgYW55IHBhcnRpY3VsYXIgXG5cdFx0ICogICAgICAgICAgdW5pdHMgc3VjaCBhcyBtZXRlcnMgb3IgZmVldC4gVG9uZS5QYW5uZXIzRCBvYmplY3RzIGhhdmUgYW4gZm9yd2FyZCBcblx0XHQgKiAgICAgICAgICB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBkaXJlY3Rpb24gdGhlIHNvdW5kIGlzIHByb2plY3RpbmcuIEFkZGl0aW9uYWxseSwgXG5cdFx0ICogICAgICAgICAgdGhleSBoYXZlIGEgc291bmQgY29uZSByZXByZXNlbnRpbmcgaG93IGRpcmVjdGlvbmFsIHRoZSBzb3VuZCBpcy4gXG5cdFx0ICogICAgICAgICAgRm9yIGV4YW1wbGUsIHRoZSBzb3VuZCBjb3VsZCBiZSBvbW5pZGlyZWN0aW9uYWwsIGluIHdoaWNoIGNhc2UgaXQgd291bGQgXG5cdFx0ICogICAgICAgICAgYmUgaGVhcmQgYW55d2hlcmUgcmVnYXJkbGVzcyBvZiBpdHMgZm9yd2FyZCwgb3IgaXQgY2FuIGJlIG1vcmUgZGlyZWN0aW9uYWwgXG5cdFx0ICogICAgICAgICAgYW5kIGhlYXJkIG9ubHkgaWYgaXQgaXMgZmFjaW5nIHRoZSBsaXN0ZW5lci4gVG9uZS5MaXN0ZW5lciBvYmplY3RzIFxuXHRcdCAqICAgICAgICAgIChyZXByZXNlbnRpbmcgYSBwZXJzb24ncyBlYXJzKSBoYXZlIGFuIGZvcndhcmQgYW5kIHVwIHZlY3RvciBcblx0XHQgKiAgICAgICAgICByZXByZXNlbnRpbmcgaW4gd2hpY2ggZGlyZWN0aW9uIHRoZSBwZXJzb24gaXMgZmFjaW5nLiBCZWNhdXNlIGJvdGggdGhlIFxuXHRcdCAqICAgICAgICAgIHNvdXJjZSBzdHJlYW0gYW5kIHRoZSBsaXN0ZW5lciBjYW4gYmUgbW92aW5nLCB0aGV5IGJvdGggaGF2ZSBhIHZlbG9jaXR5IFxuXHRcdCAqICAgICAgICAgIHZlY3RvciByZXByZXNlbnRpbmcgYm90aCB0aGUgc3BlZWQgYW5kIGRpcmVjdGlvbiBvZiBtb3ZlbWVudC4gVGFrZW4gdG9nZXRoZXIsIFxuXHRcdCAqICAgICAgICAgIHRoZXNlIHR3byB2ZWxvY2l0aWVzIGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIGEgZG9wcGxlciBzaGlmdCBlZmZlY3Qgd2hpY2ggY2hhbmdlcyB0aGUgcGl0Y2guXG5cdFx0ICogICAgICAgICAgPGJyPjxicj5cblx0XHQgKiAgICAgICAgICBOb3RlOiB0aGUgcG9zaXRpb24gb2YgdGhlIExpc3RlbmVyIHdpbGwgaGF2ZSBubyBlZmZlY3Qgb24gbm9kZXMgbm90IGNvbm5lY3RlZCB0byBhIFRvbmUuUGFubmVyM0Rcblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHNpbmdsZXRvblxuXHRcdCAqL1xuXHQgICAgVG9uZS5MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSG9sZHMgdGhlIGN1cnJlbnQgZm9yd2FyZCBvcmllbnRhdGlvblxuXHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gW1xuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwXG5cdCAgICAgICAgXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIb2xkcyB0aGUgY3VycmVudCBwb3NpdGlvblxuXHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gW1xuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwXG5cdCAgICAgICAgXTtcblx0ICAgICAgICBUb25lLmdldENvbnRleHQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBzZXQgdGhlIGRlZmF1bHQgcG9zaXRpb24vZm9yd2FyZFxuXHQgICAgICAgICAgICB0aGlzLnNldChMaXN0ZW5lckNvbnN0cnVjdG9yLmRlZmF1bHRzKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTGlzdGVuZXIpO1xuXHQgICAgLyoqXG5cdFx0ICogIERlZmF1bHRzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvblxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5MaXN0ZW5lci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncG9zaXRpb25YJzogMCxcblx0ICAgICAgICAncG9zaXRpb25ZJzogMCxcblx0ICAgICAgICAncG9zaXRpb25aJzogMCxcblx0ICAgICAgICAnZm9yd2FyZFgnOiAwLFxuXHQgICAgICAgICdmb3J3YXJkWSc6IDAsXG5cdCAgICAgICAgJ2ZvcndhcmRaJzogMSxcblx0ICAgICAgICAndXBYJzogMCxcblx0ICAgICAgICAndXBZJzogMSxcblx0ICAgICAgICAndXBaJzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSByYW1wIHRpbWUgd2hpY2ggaXMgYXBwbGllZCB0byB0aGUgc2V0VGFyZ2V0QXRUaW1lXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUuX3JhbXBUaW1lQ29uc3RhbnQgPSAwLjAxO1xuXHQgICAgLyoqXG5cdFx0ICogIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsaXN0ZW5lciBpbiAzZCBzcGFjZS5cdFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB4XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHlcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgelxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkxpc3RlbmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxpc3RlbmVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5saXN0ZW5lci5wb3NpdGlvblgpIHtcblx0ICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci5wb3NpdGlvblguc2V0VGFyZ2V0QXRUaW1lKHgsIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci5wb3NpdGlvblkuc2V0VGFyZ2V0QXRUaW1lKHksIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci5wb3NpdGlvblouc2V0VGFyZ2V0QXRUaW1lKHosIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmxpc3RlbmVyLnNldFBvc2l0aW9uKHgsIHksIHopO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldHMgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBsaXN0ZW5lciB1c2luZyB0d28gdmVjdG9ycywgdGhlIGZvcndhcmRcblx0XHQgKiAgdmVjdG9yICh3aGljaCBkaXJlY3Rpb24gdGhlIGxpc3RlbmVyIGlzIGZhY2luZykgYW5kIHRoZSB1cCB2ZWN0b3IgXG5cdFx0ICogICh3aGljaCB0aGUgdXAgZGlyZWN0aW9uIG9mIHRoZSBsaXN0ZW5lcikuIEFuIHVwIHZlY3RvclxuXHRcdCAqICBvZiAwLCAwLCAxIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGxpc3RlbmVyIHN0YW5kaW5nIHVwIGluIHRoZSBaIGRpcmVjdGlvbi4gXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHhcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgeVxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB6XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHVwWFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB1cFlcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdXBaXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuTGlzdGVuZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLnNldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKHgsIHksIHosIHVwWCwgdXBZLCB1cFopIHtcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0Lmxpc3RlbmVyLmZvcndhcmRYKSB7XG5cdCAgICAgICAgICAgIHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGlzdGVuZXIuZm9yd2FyZFguc2V0VGFyZ2V0QXRUaW1lKHgsIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci5mb3J3YXJkWS5zZXRUYXJnZXRBdFRpbWUoeSwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmxpc3RlbmVyLmZvcndhcmRaLnNldFRhcmdldEF0VGltZSh6LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGlzdGVuZXIudXBYLnNldFRhcmdldEF0VGltZSh1cFgsIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci51cFkuc2V0VGFyZ2V0QXRUaW1lKHVwWSwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmxpc3RlbmVyLnVwWi5zZXRUYXJnZXRBdFRpbWUodXBaLCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci5zZXRPcmllbnRhdGlvbih4LCB5LCB6LCB1cFgsIHVwWSwgdXBaKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgcGFubmVyIG9iamVjdC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTGlzdGVuZXIjXG5cdFx0ICogIEBuYW1lIHBvc2l0aW9uWFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLCAncG9zaXRpb25YJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblswXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9wb3NpdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWzBdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBwYW5uZXIgb2JqZWN0LlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5MaXN0ZW5lciNcblx0XHQgKiAgQG5hbWUgcG9zaXRpb25ZXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUsICdwb3NpdGlvblknLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uWzFdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX3Bvc2l0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25bMV07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHogcG9zaXRpb24gb2YgdGhlIHBhbm5lciBvYmplY3QuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxpc3RlbmVyI1xuXHRcdCAqICBAbmFtZSBwb3NpdGlvblpcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxpc3RlbmVyLnByb3RvdHlwZSwgJ3Bvc2l0aW9uWicsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25bMl0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24uYXBwbHkodGhpcywgdGhpcy5fcG9zaXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblsyXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsaXN0ZW5lcnMgZnJvbnQgZGlyZWN0aW9uLiBpLmUuIFxuXHRcdCAqICB3aGljaCB3YXkgdGhleSBhcmUgZmFjaW5nLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5MaXN0ZW5lciNcblx0XHQgKiAgQG5hbWUgZm9yd2FyZFhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxpc3RlbmVyLnByb3RvdHlwZSwgJ2ZvcndhcmRYJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblswXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRPcmllbnRhdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9vcmllbnRhdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWzBdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxpc3RlbmVycyBmcm9udCBkaXJlY3Rpb24uIGkuZS4gXG5cdFx0ICogIHdoaWNoIHdheSB0aGV5IGFyZSBmYWNpbmcuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxpc3RlbmVyI1xuXHRcdCAqICBAbmFtZSBmb3J3YXJkWVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLCAnZm9yd2FyZFknLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uWzFdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldE9yaWVudGF0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX29yaWVudGF0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25bMV07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHogY29vcmRpbmF0ZSBvZiB0aGUgbGlzdGVuZXJzIGZyb250IGRpcmVjdGlvbi4gaS5lLiBcblx0XHQgKiAgd2hpY2ggd2F5IHRoZXkgYXJlIGZhY2luZy5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTGlzdGVuZXIjXG5cdFx0ICogIEBuYW1lIGZvcndhcmRaXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUsICdmb3J3YXJkWicsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25bMl0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb24uYXBwbHkodGhpcywgdGhpcy5fb3JpZW50YXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvblsyXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsaXN0ZW5lcidzIHVwIGRpcmVjdGlvbi4gaS5lLlxuXHRcdCAqICB0aGUgZGlyZWN0aW9uIHRoZSBsaXN0ZW5lciBpcyBzdGFuZGluZyBpbi5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTGlzdGVuZXIjXG5cdFx0ICogIEBuYW1lIHVwWFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLCAndXBYJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblszXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRPcmllbnRhdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9vcmllbnRhdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWzNdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxpc3RlbmVyJ3MgdXAgZGlyZWN0aW9uLiBpLmUuXG5cdFx0ICogIHRoZSBkaXJlY3Rpb24gdGhlIGxpc3RlbmVyIGlzIHN0YW5kaW5nIGluLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5MaXN0ZW5lciNcblx0XHQgKiAgQG5hbWUgdXBZXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUsICd1cFknLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uWzRdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldE9yaWVudGF0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX29yaWVudGF0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25bNF07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHogY29vcmRpbmF0ZSBvZiB0aGUgbGlzdGVuZXIncyB1cCBkaXJlY3Rpb24uIGkuZS5cblx0XHQgKiAgdGhlIGRpcmVjdGlvbiB0aGUgbGlzdGVuZXIgaXMgc3RhbmRpbmcgaW4uXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxpc3RlbmVyI1xuXHRcdCAqICBAbmFtZSB1cFpcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxpc3RlbmVyLnByb3RvdHlwZSwgJ3VwWicsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25bNV0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb24uYXBwbHkodGhpcywgdGhpcy5fb3JpZW50YXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbls1XTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuTGlzdGVuZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvL1NJTkdMRVRPTiBTRVRVUFxuXHQgICAgdmFyIExpc3RlbmVyQ29uc3RydWN0b3IgPSBUb25lLkxpc3RlbmVyO1xuXHQgICAgVG9uZS5MaXN0ZW5lciA9IG5ldyBMaXN0ZW5lckNvbnN0cnVjdG9yKCk7XG5cdCAgICBUb25lLkNvbnRleHQub24oJ2luaXQnLCBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgICAgIGlmIChjb250ZXh0Lkxpc3RlbmVyIGluc3RhbmNlb2YgTGlzdGVuZXJDb25zdHJ1Y3Rvcikge1xuXHQgICAgICAgICAgICAvL2Egc2luZ2xlIGxpc3RlbmVyIG9iamVjdFxuXHQgICAgICAgICAgICBUb25lLkxpc3RlbmVyID0gY29udGV4dC5MaXN0ZW5lcjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvL21ha2UgbmV3IExpc3RlbmVyIGluc2lkZXNcblx0ICAgICAgICAgICAgVG9uZS5MaXN0ZW5lciA9IG5ldyBMaXN0ZW5lckNvbnN0cnVjdG9yKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvbnRleHQuTGlzdGVuZXIgPSBUb25lLkxpc3RlbmVyO1xuXHQgICAgfSk7XG5cdCAgICAvL0VORCBTSU5HTEVUT04gU0VUVVBcblx0ICAgIHJldHVybiBUb25lLkxpc3RlbmVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgc2hpbVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgaWYgKCF3aW5kb3cuaGFzT3duUHJvcGVydHkoJ09mZmxpbmVBdWRpb0NvbnRleHQnKSAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ3dlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQnKSkge1xuXHQgICAgICAgIHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQ7XG5cdCAgICB9XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFdyYXBwZXIgYXJvdW5kIHRoZSBPZmZsaW5lQXVkaW9Db250ZXh0XG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkNvbnRleHR9XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIGNoYW5uZWxzICBUaGUgbnVtYmVyIG9mIGNoYW5uZWxzIHRvIHJlbmRlclxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICBkdXJhdGlvbiAgVGhlIGR1cmF0aW9uIHRvIHJlbmRlciBpbiBzYW1wbGVzXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBzYW1wbGVSYXRlIHRoZSBzYW1wbGUgcmF0ZSB0byByZW5kZXIgYXRcblx0XHQgKi9cblx0ICAgIFRvbmUuT2ZmbGluZUNvbnRleHQgPSBmdW5jdGlvbiAoY2hhbm5lbHMsIGR1cmF0aW9uLCBzYW1wbGVSYXRlKSB7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG9mZmxpbmUgY29udGV4dFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUgIHtPZmZsaW5lQXVkaW9Db250ZXh0fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdmFyIG9mZmxpbmVDb250ZXh0ID0gbmV3IE9mZmxpbmVBdWRpb0NvbnRleHQoY2hhbm5lbHMsIGR1cmF0aW9uICogc2FtcGxlUmF0ZSwgc2FtcGxlUmF0ZSk7XG5cdCAgICAgICAgLy93cmFwIHRoZSBtZXRob2RzL21lbWJlcnNcblx0ICAgICAgICBUb25lLkNvbnRleHQuY2FsbCh0aGlzLCB7XG5cdCAgICAgICAgICAgICdjb250ZXh0Jzogb2ZmbGluZUNvbnRleHQsXG5cdCAgICAgICAgICAgICdjbG9ja1NvdXJjZSc6ICdvZmZsaW5lJyxcblx0ICAgICAgICAgICAgJ2xvb2tBaGVhZCc6IDAsXG5cdCAgICAgICAgICAgICd1cGRhdGVJbnRlcnZhbCc6IDEyOCAvIHNhbXBsZVJhdGVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIHByaXZhdGUgcmVmZXJlbmNlIHRvIHRoZSBkdXJhdGlvblxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFuIGFydGlmaWNpYWwgY2xvY2sgc291cmNlXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk9mZmxpbmVDb250ZXh0LCBUb25lLkNvbnRleHQpO1xuXHQgICAgLyoqXG5cdFx0ICogIE92ZXJyaWRlIHRoZSBub3cgbWV0aG9kIHRvIHBvaW50IHRvIHRoZSBpbnRlcm5hbCBjbG9jayB0aW1lXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICovXG5cdCAgICBUb25lLk9mZmxpbmVDb250ZXh0LnByb3RvdHlwZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUaW1lO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW5kZXIgdGhlIG91dHB1dCBvZiB0aGUgT2ZmbGluZUNvbnRleHRcblx0XHQgKiAgQHJldHVybiAge1Byb21pc2V9XG5cdFx0ICovXG5cdCAgICBUb25lLk9mZmxpbmVDb250ZXh0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgd2hpbGUgKHRoaXMuX2R1cmF0aW9uIC0gdGhpcy5fY3VycmVudFRpbWUgPj0gMCkge1xuXHQgICAgICAgICAgICAvL2ludm9rZSBhbGwgdGhlIGNhbGxiYWNrcyBvbiB0aGF0IHRpbWVcblx0ICAgICAgICAgICAgdGhpcy5lbWl0KCd0aWNrJyk7XG5cdCAgICAgICAgICAgIC8vaW5jcmVtZW50IHRoZSBjbG9ja1xuXHQgICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSB0aGlzLmJsb2NrVGltZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9wcm9taXNlIHJldHVybmVkIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gYWxsIGJyb3dzZXJzXG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChkb25lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NvbnRleHQub25jb21wbGV0ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgICAgICBkb25lKGUucmVuZGVyZWRCdWZmZXIpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB0aGlzLl9jb250ZXh0LnN0YXJ0UmVuZGVyaW5nKCk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xvc2UgdGhlIGNvbnRleHRcblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKi9cblx0ICAgIFRvbmUuT2ZmbGluZUNvbnRleHQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk9mZmxpbmVDb250ZXh0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgR2VuZXJhdGUgYSBidWZmZXIgYnkgcmVuZGVyaW5nIGFsbCBvZiB0aGUgVG9uZS5qcyBjb2RlIHdpdGhpbiB0aGUgY2FsbGJhY2sgdXNpbmcgdGhlIE9mZmxpbmVBdWRpb0NvbnRleHQuIFxuXHRcdCAqICBUaGUgT2ZmbGluZUF1ZGlvQ29udGV4dCBpcyBjYXBhYmxlIG9mIHJlbmRlcmluZyBtdWNoIGZhc3RlciB0aGFuIHJlYWwgdGltZSBpbiBtYW55IGNhc2VzLiBcblx0XHQgKiAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGFsc28gcGFzc2VzIGluIGFuIG9mZmxpbmUgaW5zdGFuY2Ugb2YgVG9uZS5UcmFuc3BvcnQgd2hpY2ggY2FuIGJlIHVzZWRcblx0XHQgKiAgdG8gc2NoZWR1bGUgZXZlbnRzIGFsb25nIHRoZSBUcmFuc3BvcnQuIFxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrICBBbGwgVG9uZS5qcyBub2RlcyB3aGljaCBhcmUgY3JlYXRlZCBhbmQgc2NoZWR1bGVkIHdpdGhpbiB0aGlzIGNhbGxiYWNrIGFyZSByZWNvcmRlZCBpbnRvIHRoZSBvdXRwdXQgQnVmZmVyLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgZHVyYXRpb24gICAgIHRoZSBhbW91bnQgb2YgdGltZSB0byByZWNvcmQgZm9yLlxuXHRcdCAqICBAcmV0dXJuICB7UHJvbWlzZX0gIFRoZSBwcm9taXNlIHdoaWNoIGlzIGludm9rZWQgd2l0aCB0aGUgVG9uZS5CdWZmZXIgb2YgdGhlIHJlY29yZGVkIG91dHB1dC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3JlbmRlciAyIHNlY29uZHMgb2YgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiBUb25lLk9mZmxpbmUoZnVuY3Rpb24oKXtcblx0XHQgKiBcdC8vb25seSBub2RlcyBjcmVhdGVkIGluIHRoaXMgY2FsbGJhY2sgd2lsbCBiZSByZWNvcmRlZFxuXHRcdCAqIFx0dmFyIG9zY2lsbGF0b3IgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkudG9NYXN0ZXIoKS5zdGFydCgwKVxuXHRcdCAqIFx0Ly9zY2hlZHVsZSB0aGVpciBldmVudHNcblx0XHQgKiB9LCAyKS50aGVuKGZ1bmN0aW9uKGJ1ZmZlcil7XG5cdFx0ICogXHQvL2RvIHNvbWV0aGluZyB3aXRoIHRoZSBvdXRwdXQgYnVmZmVyXG5cdFx0ICogfSlcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vY2FuIGFsc28gc2NoZWR1bGUgZXZlbnRzIGFsb25nIHRoZSBUcmFuc3BvcnRcblx0XHQgKiAvL3VzaW5nIHRoZSBwYXNzZWQgaW4gT2ZmbGluZSBUcmFuc3BvcnRcblx0XHQgKiBUb25lLk9mZmxpbmUoZnVuY3Rpb24oVHJhbnNwb3J0KXtcblx0XHQgKiBcdHZhciBvc2MgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkudG9NYXN0ZXIoKVxuXHRcdCAqIFx0VHJhbnNwb3J0LnNjaGVkdWxlKGZ1bmN0aW9uKHRpbWUpe1xuXHRcdCAqIFx0XHRvc2Muc3RhcnQodGltZSkuc3RvcCh0aW1lICsgMC4xKVxuXHRcdCAqIFx0fSwgMSlcblx0XHQgKiBcdFRyYW5zcG9ydC5zdGFydCgwLjIpXG5cdFx0ICogfSwgNCkudGhlbihmdW5jdGlvbihidWZmZXIpe1xuXHRcdCAqIFx0Ly9kbyBzb21ldGhpbmcgd2l0aCB0aGUgb3V0cHV0IGJ1ZmZlclxuXHRcdCAqIH0pXG5cdFx0ICovXG5cdCAgICBUb25lLk9mZmxpbmUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGR1cmF0aW9uKSB7XG5cdCAgICAgICAgLy9zZXQgdGhlIE9mZmxpbmVBdWRpb0NvbnRleHRcblx0ICAgICAgICB2YXIgc2FtcGxlUmF0ZSA9IFRvbmUuY29udGV4dC5zYW1wbGVSYXRlO1xuXHQgICAgICAgIHZhciBvcmlnaW5hbENvbnRleHQgPSBUb25lLmNvbnRleHQ7XG5cdCAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgVG9uZS5PZmZsaW5lQ29udGV4dCgyLCBkdXJhdGlvbiwgc2FtcGxlUmF0ZSk7XG5cdCAgICAgICAgVG9uZS5jb250ZXh0ID0gY29udGV4dDtcblx0ICAgICAgICAvL2ludm9rZSB0aGUgY2FsbGJhY2svc2NoZWR1bGluZ1xuXHQgICAgICAgIGNhbGxiYWNrKFRvbmUuVHJhbnNwb3J0KTtcblx0ICAgICAgICAvL3Byb2Nlc3MgdGhlIGF1ZGlvXG5cdCAgICAgICAgdmFyIHJlbmRlcmVkID0gY29udGV4dC5yZW5kZXIoKTtcblx0ICAgICAgICAvL3JldHVybiB0aGUgb3JpZ2luYWwgQXVkaW9Db250ZXh0XG5cdCAgICAgICAgVG9uZS5jb250ZXh0ID0gb3JpZ2luYWxDb250ZXh0O1xuXHQgICAgICAgIC8vcmV0dXJuIHRoZSBhdWRpb1xuXHQgICAgICAgIHJldHVybiByZW5kZXJlZC50aGVuKGZ1bmN0aW9uIChidWZmZXIpIHtcblx0ICAgICAgICAgICAgLy93cmFwIGl0IGluIGEgVG9uZS5CdWZmZXJcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBUb25lLkJ1ZmZlcihidWZmZXIpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk9mZmxpbmU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogXHRAY2xhc3MgIFRvbmUuRWZmZWN0IGlzIHRoZSBiYXNlIGNsYXNzIGZvciBlZmZlY3RzLiBDb25uZWN0IHRoZSBlZmZlY3QgYmV0d2VlblxuXHRcdCAqIFx0ICAgICAgICB0aGUgZWZmZWN0U2VuZCBhbmQgZWZmZWN0UmV0dXJuIEdhaW5Ob2RlcywgdGhlbiBjb250cm9sIHRoZSBhbW91bnQgb2Zcblx0XHQgKiBcdCAgICAgICAgZWZmZWN0IHdoaWNoIGdvZXMgdG8gdGhlIG91dHB1dCB1c2luZyB0aGUgd2V0IGNvbnRyb2wuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZXxPYmplY3R9IFt3ZXRdIFRoZSBzdGFydGluZyB3ZXQgdmFsdWUuXG5cdFx0ICovXG5cdCAgICBUb25lLkVmZmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ3dldCddLCBUb25lLkVmZmVjdCk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMSwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGRyeXdldCBrbm9iIHRvIGNvbnRyb2wgdGhlIGFtb3VudCBvZiBlZmZlY3Rcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Dcm9zc0ZhZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RyeVdldCA9IG5ldyBUb25lLkNyb3NzRmFkZShvcHRpb25zLndldCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHdldCBjb250cm9sIGlzIGhvdyBtdWNoIG9mIHRoZSBlZmZlY3RlZFxuXHRcdFx0ICogIHdpbGwgcGFzcyB0aHJvdWdoIHRvIHRoZSBvdXRwdXQuIDEgPSAxMDAlIGVmZmVjdGVkXG5cdFx0XHQgKiAgc2lnbmFsLCAwID0gMTAwJSBkcnkgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLndldCA9IHRoaXMuX2RyeVdldC5mYWRlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGNvbm5lY3QgdGhlIGVmZmVjdFNlbmQgdG8gdGhlIGlucHV0IG9mIGh0ZSBlZmZlY3Rcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmQgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgY29ubmVjdCB0aGUgb3V0cHV0IG9mIHRoZSBlZmZlY3QgdG8gdGhlIGVmZmVjdFJldHVyblxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fZHJ5V2V0LmEpO1xuXHQgICAgICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLmVmZmVjdFNlbmQpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuLmNvbm5lY3QodGhpcy5fZHJ5V2V0LmIpO1xuXHQgICAgICAgIHRoaXMuX2RyeVdldC5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ3dldCddKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkVmZmVjdCwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRWZmZWN0LmRlZmF1bHRzID0geyAnd2V0JzogMSB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNoYWlucyB0aGUgZWZmZWN0IGluIGJldHdlZW4gdGhlIGVmZmVjdFNlbmQgYW5kIGVmZmVjdFJldHVyblxuXHRcdCAqICBAcGFyYW0gIHtUb25lfSBlZmZlY3Rcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRWZmZWN0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuY29ubmVjdEVmZmVjdCA9IGZ1bmN0aW9uIChlZmZlY3QpIHtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmQuY2hhaW4oZWZmZWN0LCB0aGlzLmVmZmVjdFJldHVybik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FZmZlY3R9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZHJ5V2V0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kcnlXZXQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVybi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm4gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsnd2V0J10pO1xuXHQgICAgICAgIHRoaXMud2V0ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5FZmZlY3Q7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkF1dG9GaWx0ZXIgaXMgYSBUb25lLkZpbHRlciB3aXRoIGEgVG9uZS5MRk8gY29ubmVjdGVkIHRvIHRoZSBmaWx0ZXIgY3V0b2ZmIGZyZXF1ZW5jeS5cblx0XHQgKiAgICAgICAgIFNldHRpbmcgdGhlIExGTyByYXRlIGFuZCBkZXB0aCBhbGxvd3MgZm9yIGNvbnRyb2wgb3ZlciB0aGUgZmlsdGVyIG1vZHVsYXRpb24gcmF0ZSBcblx0XHQgKiAgICAgICAgIGFuZCBkZXB0aC5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge1RpbWV8T2JqZWN0fSBbZnJlcXVlbmN5XSBUaGUgcmF0ZSBvZiB0aGUgTEZPLlxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeT19IGJhc2VGcmVxdWVuY3kgVGhlIGxvd2VyIHZhbHVlIG9mIHRoZSBMRk9zIG9zY2lsbGF0aW9uXG5cdCBcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeT19IG9jdGF2ZXMgVGhlIG51bWJlciBvZiBvY3RhdmVzIGFib3ZlIHRoZSBiYXNlRnJlcXVlbmN5XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9jcmVhdGUgYW4gYXV0b2ZpbHRlciBhbmQgc3RhcnQgaXQncyBMRk9cblx0XHQgKiB2YXIgYXV0b0ZpbHRlciA9IG5ldyBUb25lLkF1dG9GaWx0ZXIoXCI0blwiKS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICogLy9yb3V0ZSBhbiBvc2NpbGxhdG9yIHRocm91Z2ggdGhlIGZpbHRlciBhbmQgc3RhcnQgaXRcblx0XHQgKiB2YXIgb3NjaWxsYXRvciA9IG5ldyBUb25lLk9zY2lsbGF0b3IoKS5jb25uZWN0KGF1dG9GaWx0ZXIpLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2Jhc2VGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnb2N0YXZlcydcblx0ICAgICAgICBdLCBUb25lLkF1dG9GaWx0ZXIpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxmbyB3aGljaCBkcml2ZXMgdGhlIGZpbHRlciBjdXRvZmZcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmbyA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knOiBvcHRpb25zLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ2FtcGxpdHVkZSc6IG9wdGlvbnMuZGVwdGhcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSByYW5nZSBvZiB0aGUgZmlsdGVyIG1vZHVsYXRpbmcgYmV0d2VlbiB0aGUgbWluIGFuZCBtYXggZnJlcXVlbmN5LiBcblx0XHRcdCAqIDAgPSBubyBtb2R1bGF0aW9uLiAxID0gZnVsbCBtb2R1bGF0aW9uLlxuXHRcdFx0ICogQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMuX2xmby5hbXBsaXR1ZGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBIb3cgZmFzdCB0aGUgZmlsdGVyIG1vZHVsYXRlcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LiBcblx0XHRcdCAqIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMuX2xmby5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZpbHRlciBub2RlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRmlsdGVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5maWx0ZXIgPSBuZXcgVG9uZS5GaWx0ZXIob3B0aW9ucy5maWx0ZXIpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvY3RhdmVzIHBsYWNlaG9sZGVyXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vY3RhdmVzID0gMDtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5jb25uZWN0RWZmZWN0KHRoaXMuZmlsdGVyKTtcblx0ICAgICAgICB0aGlzLl9sZm8uY29ubmVjdCh0aGlzLmZpbHRlci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVwdGgnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5vY3RhdmVzID0gb3B0aW9ucy5vY3RhdmVzO1xuXHQgICAgICAgIHRoaXMuYmFzZUZyZXF1ZW5jeSA9IG9wdGlvbnMuYmFzZUZyZXF1ZW5jeTtcblx0ICAgIH07XG5cdCAgICAvL2V4dGVuZCBFZmZlY3Rcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQXV0b0ZpbHRlciwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHRzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b0ZpbHRlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogMSxcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJyxcblx0ICAgICAgICAnZGVwdGgnOiAxLFxuXHQgICAgICAgICdiYXNlRnJlcXVlbmN5JzogMjAwLFxuXHQgICAgICAgICdvY3RhdmVzJzogMi42LFxuXHQgICAgICAgICdmaWx0ZXInOiB7XG5cdCAgICAgICAgICAgICd0eXBlJzogJ2xvd3Bhc3MnLFxuXHQgICAgICAgICAgICAncm9sbG9mZic6IC0xMixcblx0ICAgICAgICAgICAgJ1EnOiAxXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFN0YXJ0IHRoZSBlZmZlY3QuXG5cdFx0ICogQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIExGTyB3aWxsIHN0YXJ0LiBcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9sZm8uc3RhcnQodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3RvcCB0aGUgZWZmZWN0LlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBMRk8gd2lsbCBzdG9wLiBcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2xmby5zdG9wKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFN5bmMgdGhlIGZpbHRlciB0byB0aGUgdHJhbnNwb3J0LlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW2RlbGF5PTBdIERlbGF5IHRpbWUgYmVmb3JlIHN0YXJ0aW5nIHRoZSBlZmZlY3QgYWZ0ZXIgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNwb3J0IGhhcyBzdGFydGVkLiBcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoZGVsYXkpIHtcblx0ICAgICAgICB0aGlzLl9sZm8uc3luYyhkZWxheSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVW5zeW5jIHRoZSBmaWx0ZXIgZnJvbSB0aGUgdHJhbnNwb3J0LlxuXHRcdCAqIEByZXR1cm5zIHtUb25lLkF1dG9GaWx0ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b0ZpbHRlci5wcm90b3R5cGUudW5zeW5jID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2xmby51bnN5bmMoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUeXBlIG9mIG9zY2lsbGF0b3IgYXR0YWNoZWQgdG8gdGhlIEF1dG9GaWx0ZXIuIFxuXHRcdCAqIFBvc3NpYmxlIHZhbHVlczogXCJzaW5lXCIsIFwic3F1YXJlXCIsIFwidHJpYW5nbGVcIiwgXCJzYXd0b290aFwiLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkF1dG9GaWx0ZXIjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BdXRvRmlsdGVyLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZm8udHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1pbmltdW0gdmFsdWUgb2YgdGhlIGZpbHRlcidzIGN1dG9mZiBmcmVxdWVuY3kuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXV0b0ZpbHRlciNcblx0XHQgKiBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdCAqIEBuYW1lIG1pblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXV0b0ZpbHRlci5wcm90b3R5cGUsICdiYXNlRnJlcXVlbmN5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGZvLm1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGZyZXEpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvLm1pbiA9IHRoaXMudG9GcmVxdWVuY3koZnJlcSk7XG5cdCAgICAgICAgICAgIC8vYW5kIHNldCB0aGUgbWF4XG5cdCAgICAgICAgICAgIHRoaXMub2N0YXZlcyA9IHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWF4aW11bSB2YWx1ZSBvZiB0aGUgZmlsdGVyJ3MgY3V0b2ZmIGZyZXF1ZW5jeS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXV0b0ZpbHRlciNcblx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogQG5hbWUgb2N0YXZlc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXV0b0ZpbHRlci5wcm90b3R5cGUsICdvY3RhdmVzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9jdCkge1xuXHQgICAgICAgICAgICB0aGlzLl9vY3RhdmVzID0gb2N0O1xuXHQgICAgICAgICAgICB0aGlzLl9sZm8ubWF4ID0gdGhpcy5iYXNlRnJlcXVlbmN5ICogTWF0aC5wb3coMiwgb2N0KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkF1dG9GaWx0ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b0ZpbHRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2xmby5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZpbHRlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5maWx0ZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXB0aCdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQXV0b0ZpbHRlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQXV0b1Bhbm5lciBpcyBhIFRvbmUuUGFubmVyIHdpdGggYW4gTEZPIGNvbm5lY3RlZCB0byB0aGUgcGFuIGFtb3VudC4gXG5cdFx0ICogICAgICAgICBNb3JlIG9uIHVzaW5nIGF1dG9wYW5uZXJzIFtoZXJlXShodHRwczovL3d3dy5hYmxldG9uLmNvbS9lbi9ibG9nL2F1dG9wYW4tY2hvcHBlci1lZmZlY3QtYW5kLW1vcmUtbGl2ZXNjaG9vbC8pLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FZmZlY3R9XG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fE9iamVjdH0gW2ZyZXF1ZW5jeV0gUmF0ZSBvZiBsZWZ0LXJpZ2h0IG9zY2lsbGF0aW9uLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2NyZWF0ZSBhbiBhdXRvcGFubmVyIGFuZCBzdGFydCBpdCdzIExGT1xuXHRcdCAqIHZhciBhdXRvUGFubmVyID0gbmV3IFRvbmUuQXV0b1Bhbm5lcihcIjRuXCIpLnRvTWFzdGVyKCkuc3RhcnQoKTtcblx0XHQgKiAvL3JvdXRlIGFuIG9zY2lsbGF0b3IgdGhyb3VnaCB0aGUgcGFubmVyIGFuZCBzdGFydCBpdFxuXHRcdCAqIHZhciBvc2NpbGxhdG9yID0gbmV3IFRvbmUuT3NjaWxsYXRvcigpLmNvbm5lY3QoYXV0b1Bhbm5lcikuc3RhcnQoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1Bhbm5lciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ2ZyZXF1ZW5jeSddLCBUb25lLkF1dG9QYW5uZXIpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxmbyB3aGljaCBkcml2ZXMgdGhlIHBhbm5pbmdcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmbyA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knOiBvcHRpb25zLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ2FtcGxpdHVkZSc6IG9wdGlvbnMuZGVwdGgsXG5cdCAgICAgICAgICAgICdtaW4nOiAtMSxcblx0ICAgICAgICAgICAgJ21heCc6IDFcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBhbW91bnQgb2YgcGFubmluZyBiZXR3ZWVuIGxlZnQgYW5kIHJpZ2h0LiBcblx0XHRcdCAqIDAgPSBhbHdheXMgY2VudGVyLiAxID0gZnVsbCByYW5nZSBiZXR3ZWVuIGxlZnQgYW5kIHJpZ2h0LiBcblx0XHRcdCAqIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLl9sZm8uYW1wbGl0dWRlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBwYW5uZXIgbm9kZSB3aGljaCBkb2VzIHRoZSBwYW5uaW5nXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuUGFubmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYW5uZXIgPSBuZXcgVG9uZS5QYW5uZXIoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIEhvdyBmYXN0IHRoZSBwYW5uZXIgbW9kdWxhdGVzIGJldHdlZW4gbGVmdCBhbmQgcmlnaHQuIFxuXHRcdFx0ICogQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5fbGZvLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5jb25uZWN0RWZmZWN0KHRoaXMuX3Bhbm5lcik7XG5cdCAgICAgICAgdGhpcy5fbGZvLmNvbm5lY3QodGhpcy5fcGFubmVyLnBhbik7XG5cdCAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2RlcHRoJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICAvL2V4dGVuZCBFZmZlY3Rcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQXV0b1Bhbm5lciwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHRzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1Bhbm5lci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogMSxcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJyxcblx0ICAgICAgICAnZGVwdGgnOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3RhcnQgdGhlIGVmZmVjdC5cblx0XHQgKiBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gV2hlbiB0aGUgTEZPIHdpbGwgc3RhcnQuIFxuXHRcdCAqIEByZXR1cm5zIHtUb25lLkF1dG9QYW5uZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1Bhbm5lci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2xmby5zdGFydCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTdG9wIHRoZSBlZmZlY3QuXG5cdFx0ICogQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIExGTyB3aWxsIHN0b3AuIFxuXHRcdCAqIEByZXR1cm5zIHtUb25lLkF1dG9QYW5uZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1Bhbm5lci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fbGZvLnN0b3AodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3luYyB0aGUgcGFubmVyIHRvIHRoZSB0cmFuc3BvcnQuXG5cdFx0ICogQHBhcmFtIHtUaW1lfSBbZGVsYXk9MF0gRGVsYXkgdGltZSBiZWZvcmUgc3RhcnRpbmcgdGhlIGVmZmVjdCBhZnRlciB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc3BvcnQgaGFzIHN0YXJ0ZWQuIFxuXHRcdCAqIEByZXR1cm5zIHtUb25lLkF1dG9QYW5uZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1Bhbm5lci5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIChkZWxheSkge1xuXHQgICAgICAgIHRoaXMuX2xmby5zeW5jKGRlbGF5KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBVbnN5bmMgdGhlIHBhbm5lciBmcm9tIHRoZSB0cmFuc3BvcnRcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvUGFubmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9QYW5uZXIucHJvdG90eXBlLnVuc3luYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9sZm8udW5zeW5jKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVHlwZSBvZiBvc2NpbGxhdG9yIGF0dGFjaGVkIHRvIHRoZSBBdXRvRmlsdGVyLiBcblx0XHQgKiBQb3NzaWJsZSB2YWx1ZXM6IFwic2luZVwiLCBcInNxdWFyZVwiLCBcInRyaWFuZ2xlXCIsIFwic2F3dG9vdGhcIi5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5BdXRvRmlsdGVyI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXV0b1Bhbm5lci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGZvLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmby50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BdXRvUGFubmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9QYW5uZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9sZm8uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xmbyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2RlcHRoJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQXV0b1Bhbm5lcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLkF1dG9XYWggY29ubmVjdHMgYSBUb25lLkZvbGxvd2VyIHRvIGEgYmFuZHBhc3MgZmlsdGVyIChUb25lLkZpbHRlcikuXG5cdFx0ICogICAgICAgICAgVGhlIGZyZXF1ZW5jeSBvZiB0aGUgZmlsdGVyIGlzIGFkanVzdGVkIHByb3BvcnRpb25hbGx5IHRvIHRoZSBcblx0XHQgKiAgICAgICAgICBpbmNvbWluZyBzaWduYWwncyBhbXBsaXR1ZGUuIEluc3BpcmF0aW9uIGZyb20gW1R1bmEuanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9EaW5haG1vZS90dW5hKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeXxPYmplY3R9IFtiYXNlRnJlcXVlbmN5XSBUaGUgZnJlcXVlbmN5IHRoZSBmaWx0ZXIgaXMgc2V0IFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhdCB0aGUgbG93IHBvaW50IG9mIHRoZSB3YWhcblx0XHQgKiAgQHBhcmFtIHtQb3NpdGl2ZX0gW29jdGF2ZXNdIFRoZSBudW1iZXIgb2Ygb2N0YXZlcyBhYm92ZSB0aGUgYmFzZUZyZXF1ZW5jeVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZmlsdGVyIHdpbGwgc3dlZXAgdG8gd2hlbiBmdWxseSBvcGVuXG5cdFx0ICogIEBwYXJhbSB7RGVjaWJlbHN9IFtzZW5zaXRpdml0eV0gVGhlIGRlY2liZWwgdGhyZXNob2xkIHNlbnNpdGl2aXR5IGZvciBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGluY29taW5nIHNpZ25hbC4gTm9ybWFsIHJhbmdlIG9mIC00MCB0byAwLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgYXV0b1dhaCA9IG5ldyBUb25lLkF1dG9XYWgoNTAsIDYsIC0zMCkudG9NYXN0ZXIoKTtcblx0XHQgKiAvL2luaXRpYWxpemUgdGhlIHN5bnRoIGFuZCBjb25uZWN0IHRvIGF1dG93YWhcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgU3ludGguY29ubmVjdChhdXRvV2FoKTtcblx0XHQgKiAvL1EgdmFsdWUgaW5mbHVlbmNlcyB0aGUgZWZmZWN0IG9mIHRoZSB3YWggLSBkZWZhdWx0IGlzIDJcblx0XHQgKiBhdXRvV2FoLlEudmFsdWUgPSA2O1xuXHRcdCAqIC8vbW9yZSBhdWRpYmxlIG9uIGhpZ2hlciBub3Rlc1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzRcIiwgXCI4blwiKVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvV2FoID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2Jhc2VGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnb2N0YXZlcycsXG5cdCAgICAgICAgICAgICdzZW5zaXRpdml0eSdcblx0ICAgICAgICBdLCBUb25lLkF1dG9XYWgpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGVudmVsb3BlIGZvbGxvd2VyLiBTZXQgdGhlIGF0dGFjay9yZWxlYXNlXG5cdFx0XHQgKiAgdGltaW5nIHRvIGFkanVzdCBob3cgdGhlIGVudmVsb3BlIGlzIGZvbGxvd2VkLiBcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Gb2xsb3dlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mb2xsb3dlciA9IG5ldyBUb25lLkZvbGxvd2VyKG9wdGlvbnMuZm9sbG93ZXIpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHNjYWxlcyB0aGUgZm9sbG93ZXIgdmFsdWUgdG8gdGhlIGZyZXF1ZW5jeSBkb21haW5cblx0XHRcdCAqICBAdHlwZSB7VG9uZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZSA9IG5ldyBUb25lLlNjYWxlRXhwKDAsIDEsIDAuNSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYmFzZUZyZXF1ZW5jeSA9IG9wdGlvbnMuYmFzZUZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vY3RhdmVzID0gb3B0aW9ucy5vY3RhdmVzO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBpbnB1dCBnYWluIHRvIGFkanVzdCB0aGUgc2Vuc2l0aXZpdHlcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9pbnB1dEJvb3N0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtCaXF1YWRGaWx0ZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9iYW5kcGFzcyA9IG5ldyBUb25lLkZpbHRlcih7XG5cdCAgICAgICAgICAgICdyb2xsb2ZmJzogLTQ4LFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5JzogMCxcblx0ICAgICAgICAgICAgJ1EnOiBvcHRpb25zLlFcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5GaWx0ZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BlYWtpbmcgPSBuZXcgVG9uZS5GaWx0ZXIoMCwgJ3BlYWtpbmcnKTtcblx0ICAgICAgICB0aGlzLl9wZWFraW5nLmdhaW4udmFsdWUgPSBvcHRpb25zLmdhaW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgZ2FpbiBvZiB0aGUgZmlsdGVyLlxuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZ2FpbiA9IHRoaXMuX3BlYWtpbmcuZ2Fpbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBxdWFsaXR5IG9mIHRoZSBmaWx0ZXIuXG5cdFx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLlEgPSB0aGlzLl9iYW5kcGFzcy5RO1xuXHQgICAgICAgIC8vdGhlIGNvbnRyb2wgc2lnbmFsIHBhdGhcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmQuY2hhaW4odGhpcy5faW5wdXRCb29zdCwgdGhpcy5mb2xsb3dlciwgdGhpcy5fc3dlZXBSYW5nZSk7XG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZS5jb25uZWN0KHRoaXMuX2JhbmRwYXNzLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZS5jb25uZWN0KHRoaXMuX3BlYWtpbmcuZnJlcXVlbmN5KTtcblx0ICAgICAgICAvL3RoZSBmaWx0ZXJlZCBwYXRoXG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kLmNoYWluKHRoaXMuX2JhbmRwYXNzLCB0aGlzLl9wZWFraW5nLCB0aGlzLmVmZmVjdFJldHVybik7XG5cdCAgICAgICAgLy9zZXQgdGhlIGluaXRpYWwgdmFsdWVcblx0ICAgICAgICB0aGlzLl9zZXRTd2VlcFJhbmdlKCk7XG5cdCAgICAgICAgdGhpcy5zZW5zaXRpdml0eSA9IG9wdGlvbnMuc2Vuc2l0aXZpdHk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZ2FpbicsXG5cdCAgICAgICAgICAgICdRJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQXV0b1dhaCwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1dhaC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnYmFzZUZyZXF1ZW5jeSc6IDEwMCxcblx0ICAgICAgICAnb2N0YXZlcyc6IDYsXG5cdCAgICAgICAgJ3NlbnNpdGl2aXR5JzogMCxcblx0ICAgICAgICAnUSc6IDIsXG5cdCAgICAgICAgJ2dhaW4nOiAyLFxuXHQgICAgICAgICdmb2xsb3dlcic6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMyxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBvY3RhdmVzIHRoYXQgdGhlIGZpbHRlciB3aWxsIHN3ZWVwIGFib3ZlIHRoZSBcblx0XHQgKiBiYXNlRnJlcXVlbmN5LiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5BdXRvV2FoI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgb2N0YXZlc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXV0b1dhaC5wcm90b3R5cGUsICdvY3RhdmVzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9jdGF2ZXMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb2N0YXZlcyA9IG9jdGF2ZXM7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFN3ZWVwUmFuZ2UoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBiYXNlIGZyZXF1ZW5jeSBmcm9tIHdoaWNoIHRoZSBzd2VlcCB3aWxsIHN0YXJ0IGZyb20uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXV0b1dhaCNcblx0XHQgKiBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdCAqIEBuYW1lIGJhc2VGcmVxdWVuY3lcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1dG9XYWgucHJvdG90eXBlLCAnYmFzZUZyZXF1ZW5jeScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VGcmVxdWVuY3k7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChiYXNlRnJlcSkge1xuXHQgICAgICAgICAgICB0aGlzLl9iYXNlRnJlcXVlbmN5ID0gYmFzZUZyZXE7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFN3ZWVwUmFuZ2UoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBzZW5zaXRpdml0eSB0byBjb250cm9sIGhvdyByZXNwb25zaXZlIHRvIHRoZSBpbnB1dCBzaWduYWwgdGhlIGZpbHRlciBpcy4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXV0b1dhaCNcblx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0ICogQG5hbWUgc2Vuc2l0aXZpdHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1dG9XYWgucHJvdG90eXBlLCAnc2Vuc2l0aXZpdHknLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLmdhaW5Ub0RiKDEgLyB0aGlzLl9pbnB1dEJvb3N0LmdhaW4udmFsdWUpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2Vuc2l0aXZ5KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2lucHV0Qm9vc3QuZ2Fpbi52YWx1ZSA9IDEgLyBUb25lLmRiVG9HYWluKHNlbnNpdGl2eSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgc2V0cyB0aGUgc3dlZXAgcmFuZ2Ugb2YgdGhlIHNjYWxlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvV2FoLnByb3RvdHlwZS5fc2V0U3dlZXBSYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9zd2VlcFJhbmdlLm1pbiA9IHRoaXMuX2Jhc2VGcmVxdWVuY3k7XG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZS5tYXggPSBNYXRoLm1pbih0aGlzLl9iYXNlRnJlcXVlbmN5ICogTWF0aC5wb3coMiwgdGhpcy5fb2N0YXZlcyksIHRoaXMuY29udGV4dC5zYW1wbGVSYXRlIC8gMik7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BdXRvV2FofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9XYWgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmZvbGxvd2VyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZvbGxvd2VyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zd2VlcFJhbmdlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zd2VlcFJhbmdlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9iYW5kcGFzcy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYmFuZHBhc3MgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3BlYWtpbmcuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3BlYWtpbmcgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2lucHV0Qm9vc3QuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2lucHV0Qm9vc3QgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2dhaW4nLFxuXHQgICAgICAgICAgICAnUSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmdhaW4gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuUSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQXV0b1dhaDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQml0Y3J1c2hlciBkb3duc2FtcGxlcyB0aGUgaW5jb21pbmcgc2lnbmFsIHRvIGEgZGlmZmVyZW50IGJpdGRlcHRoLiBcblx0XHQgKiAgICAgICAgIExvd2VyaW5nIHRoZSBiaXRkZXB0aCBvZiB0aGUgc2lnbmFsIGNyZWF0ZXMgZGlzdG9ydGlvbi4gUmVhZCBtb3JlIGFib3V0IEJpdGNydXNoaW5nXG5cdFx0ICogICAgICAgICBvbiBbV2lraXBlZGlhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CaXRjcnVzaGVyKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gYml0cyBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gZG93bnNhbXBsZSB0aGUgc2lnbmFsLiBOb21pbmFsIHJhbmdlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgIG9mIDEgdG8gOC4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9pbml0aWFsaXplIGNydXNoZXIgYW5kIHJvdXRlIGEgc3ludGggdGhyb3VnaCBpdFxuXHRcdCAqIHZhciBjcnVzaGVyID0gbmV3IFRvbmUuQml0Q3J1c2hlcig0KS50b01hc3RlcigpO1xuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBUb25lLk1vbm9TeW50aCgpLmNvbm5lY3QoY3J1c2hlcik7XG5cdFx0ICovXG5cdCAgICBUb25lLkJpdENydXNoZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydiaXRzJ10sIFRvbmUuQml0Q3J1c2hlcik7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICB2YXIgaW52U3RlcFNpemUgPSAxIC8gTWF0aC5wb3coMiwgb3B0aW9ucy5iaXRzIC0gMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU3VidHJhY3QgdGhlIGlucHV0IHNpZ25hbCBhbmQgdGhlIG1vZHVsdXMgb2YgdGhlIGlucHV0IHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN1YnRyYWN0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdWJ0cmFjdCA9IG5ldyBUb25lLlN1YnRyYWN0KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZCBmdW5jdGlvblxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Nb2R1bG99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsbyA9IG5ldyBUb25lLk1vZHVsbyhpbnZTdGVwU2l6ZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAga2VlcHMgdHJhY2sgb2YgdGhlIGJpdHNcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9iaXRzID0gb3B0aW9ucy5iaXRzO1xuXHQgICAgICAgIC8vY29ubmVjdCBpdCB1cFxuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZC5mYW4odGhpcy5fc3VidHJhY3QsIHRoaXMuX21vZHVsbyk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxvLmNvbm5lY3QodGhpcy5fc3VidHJhY3QsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuX3N1YnRyYWN0LmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm4pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQml0Q3J1c2hlciwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkJpdENydXNoZXIuZGVmYXVsdHMgPSB7ICdiaXRzJzogNCB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGJpdCBkZXB0aCBvZiB0aGUgZWZmZWN0LiBOb21pbmFsIHJhbmdlIG9mIDEtOC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQml0Q3J1c2hlciNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIGJpdHNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJpdENydXNoZXIucHJvdG90eXBlLCAnYml0cycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpdHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChiaXRzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2JpdHMgPSBiaXRzO1xuXHQgICAgICAgICAgICB2YXIgaW52U3RlcFNpemUgPSAxIC8gTWF0aC5wb3coMiwgYml0cyAtIDEpO1xuXHQgICAgICAgICAgICB0aGlzLl9tb2R1bG8udmFsdWUgPSBpbnZTdGVwU2l6ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkJpdENydXNoZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQml0Q3J1c2hlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3N1YnRyYWN0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdWJ0cmFjdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxvLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bG8gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkJpdENydXNoZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkNoZWJ5U2hldiBpcyBhIENoZWJ5c2hldiB3YXZlc2hhcGVyLCBhbiBlZmZlY3Qgd2hpY2ggaXMgZ29vZCBcblx0XHQgKiAgICAgICAgIGZvciBtYWtpbmcgZGlmZmVyZW50IHR5cGVzIG9mIGRpc3RvcnRpb24gc291bmRzLlxuXHRcdCAqICAgICAgICAgTm90ZSB0aGF0IG9kZCBvcmRlcnMgc291bmQgdmVyeSBkaWZmZXJlbnQgZnJvbSBldmVuIG9uZXMsIFxuXHRcdCAqICAgICAgICAgYW5kIG9yZGVyID0gMSBpcyBubyBjaGFuZ2UuIFxuXHRcdCAqICAgICAgICAgUmVhZCBtb3JlIGF0IFttdXNpYy5jb2x1bWJpYS5lZHVdKGh0dHA6Ly9tdXNpYy5jb2x1bWJpYS5lZHUvY21jL211c2ljYW5kY29tcHV0ZXJzL2NoYXB0ZXI0LzA0XzA2LnBocCkuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtQb3NpdGl2ZXxPYmplY3R9IFtvcmRlcl0gVGhlIG9yZGVyIG9mIHRoZSBjaGVieXNoZXYgcG9seW5vbWlhbC4gTm9ybWFsIHJhbmdlIGJldHdlZW4gMS0xMDAuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vY3JlYXRlIGEgbmV3IGNoZWJ5XG5cdFx0ICogdmFyIGNoZWJ5ID0gbmV3IFRvbmUuQ2hlYnlzaGV2KDUwKTtcblx0XHQgKiAvL2NyZWF0ZSBhIG1vbm9zeW50aCBjb25uZWN0ZWQgdG8gb3VyIGNoZWJ5XG5cdFx0ICogc3ludGggPSBuZXcgVG9uZS5Nb25vU3ludGgoKS5jb25uZWN0KGNoZWJ5KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQ2hlYnlzaGV2ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsnb3JkZXInXSwgVG9uZS5DaGVieXNoZXYpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1dhdmVTaGFwZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zaGFwZXIgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKDQwOTYpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogaG9sZHMgb250byB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlclxuXHRcdFx0ICogQHR5cGUge251bWJlcn1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vcmRlciA9IG9wdGlvbnMub3JkZXI7XG5cdCAgICAgICAgdGhpcy5jb25uZWN0RWZmZWN0KHRoaXMuX3NoYXBlcik7XG5cdCAgICAgICAgdGhpcy5vcmRlciA9IG9wdGlvbnMub3JkZXI7XG5cdCAgICAgICAgdGhpcy5vdmVyc2FtcGxlID0gb3B0aW9ucy5vdmVyc2FtcGxlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ2hlYnlzaGV2LCBUb25lLkVmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ2hlYnlzaGV2LmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdvcmRlcic6IDEsXG5cdCAgICAgICAgJ292ZXJzYW1wbGUnOiAnbm9uZSdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgZ2V0IHRoZSBjb2VmZmljaWVudCBmb3IgdGhhdCBkZWdyZWVcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHggdGhlIHggdmFsdWVcblx0XHQgKiAgQHBhcmFtICAge251bWJlcn0gZGVncmVlIFxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gbWVtbyBtZW1vaXplIHRoZSBjb21wdXRlZCB2YWx1ZS4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgIHRoaXMgc3BlZWRzIHVwIGNvbXB1dGF0aW9uIGdyZWF0bHkuIFxuXHRcdCAqICBAcmV0dXJuICB7bnVtYmVyfSAgICAgICB0aGUgY29lZmZpY2llbnQgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkNoZWJ5c2hldi5wcm90b3R5cGUuX2dldENvZWZmaWNpZW50ID0gZnVuY3Rpb24gKHgsIGRlZ3JlZSwgbWVtbykge1xuXHQgICAgICAgIGlmIChtZW1vLmhhc093blByb3BlcnR5KGRlZ3JlZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG1lbW9bZGVncmVlXTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGRlZ3JlZSA9PT0gMCkge1xuXHQgICAgICAgICAgICBtZW1vW2RlZ3JlZV0gPSAwO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoZGVncmVlID09PSAxKSB7XG5cdCAgICAgICAgICAgIG1lbW9bZGVncmVlXSA9IHg7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgbWVtb1tkZWdyZWVdID0gMiAqIHggKiB0aGlzLl9nZXRDb2VmZmljaWVudCh4LCBkZWdyZWUgLSAxLCBtZW1vKSAtIHRoaXMuX2dldENvZWZmaWNpZW50KHgsIGRlZ3JlZSAtIDIsIG1lbW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbWVtb1tkZWdyZWVdO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBvcmRlciBvZiB0aGUgQ2hlYnlzaGV2IHBvbHlub21pYWwgd2hpY2ggY3JlYXRlc1xuXHRcdCAqIHRoZSBlcXVhdGlvbiB3aGljaCBpcyBhcHBsaWVkIHRvIHRoZSBpbmNvbWluZyBcblx0XHQgKiBzaWduYWwgdGhyb3VnaCBhIFRvbmUuV2F2ZVNoYXBlci4gVGhlIGVxdWF0aW9uc1xuXHRcdCAqIGFyZSBpbiB0aGUgZm9ybTo8YnI+XG5cdFx0ICogb3JkZXIgMjogMnheMiArIDE8YnI+XG5cdFx0ICogb3JkZXIgMzogNHheMyArIDN4IDxicj5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5DaGVieXNoZXYjXG5cdFx0ICogQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqIEBuYW1lIG9yZGVyXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DaGVieXNoZXYucHJvdG90eXBlLCAnb3JkZXInLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmRlcjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9yZGVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yZGVyID0gb3JkZXI7XG5cdCAgICAgICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBBcnJheSg0MDk2KTtcblx0ICAgICAgICAgICAgdmFyIGxlbiA9IGN1cnZlLmxlbmd0aDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHggPSBpICogMiAvIGxlbiAtIDE7XG5cdCAgICAgICAgICAgICAgICBpZiAoeCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vc2hvdWxkIG91dHB1dCAwIHdoZW4gaW5wdXQgaXMgMFxuXHQgICAgICAgICAgICAgICAgICAgIGN1cnZlW2ldID0gMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY3VydmVbaV0gPSB0aGlzLl9nZXRDb2VmZmljaWVudCh4LCBvcmRlciwge30pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3NoYXBlci5jdXJ2ZSA9IGN1cnZlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG92ZXJzYW1wbGluZyBvZiB0aGUgZWZmZWN0LiBDYW4gZWl0aGVyIGJlIFwibm9uZVwiLCBcIjJ4XCIgb3IgXCI0eFwiLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkNoZWJ5c2hldiNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIG92ZXJzYW1wbGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNoZWJ5c2hldi5wcm90b3R5cGUsICdvdmVyc2FtcGxlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hhcGVyLm92ZXJzYW1wbGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvdmVyc2FtcGxpbmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2hhcGVyLm92ZXJzYW1wbGUgPSBvdmVyc2FtcGxpbmc7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5DaGVieXNoZXZ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ2hlYnlzaGV2LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zaGFwZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkNoZWJ5c2hldjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEJhc2UgY2xhc3MgZm9yIFN0ZXJlbyBlZmZlY3RzLiBQcm92aWRlcyBlZmZlY3RTZW5kTC9SIGFuZCBlZmZlY3RSZXR1cm5ML1IuXG5cdFx0ICpcblx0XHQgKlx0QGNvbnN0cnVjdG9yXG5cdFx0ICpcdEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuU3RlcmVvRWZmZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vZ2V0IHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWyd3ZXQnXSwgVG9uZS5FZmZlY3QpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygxLCAxKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZHJ5d2V0IGtub2IgdG8gY29udHJvbCB0aGUgYW1vdW50IG9mIGVmZmVjdFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkNyb3NzRmFkZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZHJ5V2V0ID0gbmV3IFRvbmUuQ3Jvc3NGYWRlKG9wdGlvbnMud2V0KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgd2V0IGNvbnRyb2wsIGkuZS4gaG93IG11Y2ggb2YgdGhlIGVmZmVjdGVkXG5cdFx0XHQgKiAgd2lsbCBwYXNzIHRocm91Z2ggdG8gdGhlIG91dHB1dC5cblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy53ZXQgPSB0aGlzLl9kcnlXZXQuZmFkZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGVuIHNwbGl0IGl0XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU3BsaXR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NwbGl0ID0gbmV3IFRvbmUuU3BsaXQoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZWZmZWN0cyBzZW5kIExFRlRcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwgPSB0aGlzLl9zcGxpdC5sZWZ0O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBlZmZlY3RzIHNlbmQgUklHSFRcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZFIgPSB0aGlzLl9zcGxpdC5yaWdodDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgc3RlcmVvIGVmZmVjdCBtZXJnZXJcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NZXJnZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWVyZ2UgPSBuZXcgVG9uZS5NZXJnZSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBlZmZlY3QgcmV0dXJuIExFRlRcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuTCA9IHRoaXMuX21lcmdlLmxlZnQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGVmZmVjdCByZXR1cm4gUklHSFRcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuUiA9IHRoaXMuX21lcmdlLnJpZ2h0O1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fc3BsaXQpO1xuXHQgICAgICAgIC8vZHJ5IHdldCBjb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl9kcnlXZXQsIDAsIDApO1xuXHQgICAgICAgIHRoaXMuX21lcmdlLmNvbm5lY3QodGhpcy5fZHJ5V2V0LCAwLCAxKTtcblx0ICAgICAgICB0aGlzLl9kcnlXZXQuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoWyd3ZXQnXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TdGVyZW9FZmZlY3QsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuU3RlcmVvRWZmZWN0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlN0ZXJlb0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2RyeVdldC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZHJ5V2V0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zcGxpdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3BsaXQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21lcmdlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tZXJnZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kTCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kUiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm5MID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVyblIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsnd2V0J10pO1xuXHQgICAgICAgIHRoaXMud2V0ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TdGVyZW9FZmZlY3Q7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogXHRAY2xhc3MgIFRvbmUuRmVlZGJhY2tFZmZlY3QgcHJvdmlkZXMgYSBsb29wIGJldHdlZW4gYW4gXG5cdFx0ICogXHQgICAgICAgIGF1ZGlvIHNvdXJjZSBhbmQgaXRzIG93biBvdXRwdXQuIFRoaXMgaXMgYSBiYXNlLWNsYXNzXG5cdFx0ICogXHQgICAgICAgIGZvciBmZWVkYmFjayBlZmZlY3RzLiBcblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfE9iamVjdH0gW2ZlZWRiYWNrXSBUaGUgaW5pdGlhbCBmZWVkYmFjayB2YWx1ZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuRmVlZGJhY2tFZmZlY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydmZWVkYmFjayddLCBUb25lLkZlZWRiYWNrRWZmZWN0KTtcblx0ICAgICAgICBUb25lLkVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBnYWluIHdoaWNoIGNvbnRyb2xzIHRoZSBmZWVkYmFja1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrR2FpbiA9IG5ldyBUb25lLkdhaW4ob3B0aW9ucy5mZWVkYmFjaywgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIHNpZ25hbCB3aGljaCBpcyBmZWQgYmFjayBpbnRvIHRoZSBlZmZlY3QgaW5wdXQuIFxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZlZWRiYWNrID0gdGhpcy5fZmVlZGJhY2tHYWluLmdhaW47XG5cdCAgICAgICAgLy90aGUgZmVlZGJhY2sgbG9vcFxuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuLmNoYWluKHRoaXMuX2ZlZWRiYWNrR2FpbiwgdGhpcy5lZmZlY3RTZW5kKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ2ZlZWRiYWNrJ10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRmVlZGJhY2tFZmZlY3QsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkZlZWRiYWNrRWZmZWN0LmRlZmF1bHRzID0geyAnZmVlZGJhY2snOiAwLjEyNSB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRmVlZGJhY2tFZmZlY3R9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRmVlZGJhY2tFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbJ2ZlZWRiYWNrJ10pO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrR2Fpbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tHYWluID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZlZWRiYWNrID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5GZWVkYmFja0VmZmVjdDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEp1c3QgbGlrZSBhIHN0ZXJlbyBmZWVkYmFjayBlZmZlY3QsIGJ1dCB0aGUgZmVlZGJhY2sgaXMgcm91dGVkIGZyb20gbGVmdCB0byByaWdodFxuXHRcdCAqICAgICAgICAgYW5kIHJpZ2h0IHRvIGxlZnQgaW5zdGVhZCBvZiBvbiB0aGUgc2FtZSBjaGFubmVsLlxuXHRcdCAqXG5cdFx0ICpcdEBjb25zdHJ1Y3RvclxuXHRcdCAqXHRAZXh0ZW5kcyB7VG9uZS5TdGVyZW9FZmZlY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ2ZlZWRiYWNrJ10sIFRvbmUuRmVlZGJhY2tFZmZlY3QpO1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBmZWVkYmFjayBmcm9tIHRoZSBvdXRwdXRcblx0XHRcdCAqICBiYWNrIGludG8gdGhlIGlucHV0IG9mIHRoZSBlZmZlY3QgKHJvdXRlZFxuXHRcdFx0ICogIGFjcm9zcyBsZWZ0IGFuZCByaWdodCBjaGFubmVscykuXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmVlZGJhY2sgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5mZWVkYmFjaywgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbGVmdCBzaWRlIGZlZWJhY2tcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0xSID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSByaWdodCBzaWRlIGZlZWJhY2tcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFja1JMID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8vY29ubmVjdCBpdCB1cFxuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuTC5jaGFpbih0aGlzLl9mZWVkYmFja0xSLCB0aGlzLmVmZmVjdFNlbmRSKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVyblIuY2hhaW4odGhpcy5fZmVlZGJhY2tSTCwgdGhpcy5lZmZlY3RTZW5kTCk7XG5cdCAgICAgICAgdGhpcy5mZWVkYmFjay5mYW4odGhpcy5fZmVlZGJhY2tMUi5nYWluLCB0aGlzLl9mZWVkYmFja1JMLmdhaW4pO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsnZmVlZGJhY2snXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QsIFRvbmUuU3RlcmVvRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3R9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoWydmZWVkYmFjayddKTtcblx0ICAgICAgICB0aGlzLmZlZWRiYWNrLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZlZWRiYWNrID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0xSLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0xSID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja1JMLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja1JMID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3Q7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkNob3J1cyBpcyBhIHN0ZXJlbyBjaG9ydXMgZWZmZWN0IHdpdGggZmVlZGJhY2sgY29tcG9zZWQgb2YgXG5cdFx0ICogICAgICAgICBhIGxlZnQgYW5kIHJpZ2h0IGRlbGF5IHdpdGggYSBUb25lLkxGTyBhcHBsaWVkIHRvIHRoZSBkZWxheVRpbWUgb2YgZWFjaCBjaGFubmVsLiBcblx0XHQgKiAgICAgICAgIEluc3BpcmF0aW9uIGZyb20gW1R1bmEuanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9EaW5haG1vZS90dW5hL2Jsb2IvbWFzdGVyL3R1bmEuanMpLlxuXHRcdCAqICAgICAgICAgUmVhZCBtb3JlIG9uIHRoZSBjaG9ydXMgZWZmZWN0IG9uIFtTb3VuZE9uU291bmRdKGh0dHA6Ly93d3cuc291bmRvbnNvdW5kLmNvbS9zb3MvanVuMDQvYXJ0aWNsZXMvc3ludGhzZWNyZXRzLmh0bSkuXG5cdFx0ICpcblx0XHQgKlx0QGNvbnN0cnVjdG9yXG5cdFx0ICpcdEBleHRlbmRzIHtUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdH1cblx0XHQgKlx0QHBhcmFtIHtGcmVxdWVuY3l8T2JqZWN0fSBbZnJlcXVlbmN5XSBUaGUgZnJlcXVlbmN5IG9mIHRoZSBMRk8uXG5cdFx0ICpcdEBwYXJhbSB7TWlsbGlzZWNvbmRzfSBbZGVsYXlUaW1lXSBUaGUgZGVsYXkgb2YgdGhlIGNob3J1cyBlZmZlY3QgaW4gbXMuIFxuXHRcdCAqXHRAcGFyYW0ge05vcm1hbFJhbmdlfSBbZGVwdGhdIFRoZSBkZXB0aCBvZiB0aGUgY2hvcnVzLlxuXHRcdCAqXHRAZXhhbXBsZVxuXHRcdCAqIHZhciBjaG9ydXMgPSBuZXcgVG9uZS5DaG9ydXMoNCwgMi41LCAwLjUpO1xuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBUb25lLlBvbHlTeW50aCg0LCBUb25lLk1vbm9TeW50aCkuY29ubmVjdChjaG9ydXMpO1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFtcIkMzXCIsXCJFM1wiLFwiRzNcIl0sIFwiOG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkNob3J1cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJyxcblx0ICAgICAgICAgICAgJ2RlcHRoJ1xuXHQgICAgICAgIF0sIFRvbmUuQ2hvcnVzKTtcblx0ICAgICAgICBUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZXB0aCBvZiB0aGUgY2hvcnVzXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVwdGggPSBvcHRpb25zLmRlcHRoO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZWxheVRpbWVcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheVRpbWUgPSBvcHRpb25zLmRlbGF5VGltZSAvIDEwMDA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxmbyB3aGljaCBjb250cm9scyB0aGUgZGVsYXlUaW1lXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9MID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSc6IG9wdGlvbnMuZnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAnbWluJzogMCxcblx0ICAgICAgICAgICAgJ21heCc6IDFcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBhbm90aGVyIExGTyBmb3IgdGhlIHJpZ2h0IHNpZGUgd2l0aCBhIDE4MCBkZWdyZWUgcGhhc2UgZGlmZlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvUiA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knOiBvcHRpb25zLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgICAgICdtYXgnOiAxLFxuXHQgICAgICAgICAgICAncGhhc2UnOiAxODBcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBkZWxheSBmb3IgbGVmdFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkRlbGF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGVMID0gbmV3IFRvbmUuRGVsYXkoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBkZWxheSBmb3IgcmlnaHRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5EZWxheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlUiA9IG5ldyBUb25lLkRlbGF5KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBMRk8gd2hpY2ggbW9kdWxhdGVzIHRoZSBkZWxheVRpbWUuIFxuXHRcdFx0ICogQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5fbGZvTC5mcmVxdWVuY3k7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwuY2hhaW4odGhpcy5fZGVsYXlOb2RlTCwgdGhpcy5lZmZlY3RSZXR1cm5MKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRSLmNoYWluKHRoaXMuX2RlbGF5Tm9kZVIsIHRoaXMuZWZmZWN0UmV0dXJuUik7XG5cdCAgICAgICAgLy9hbmQgcGFzcyB0aHJvdWdoIHRvIG1ha2UgdGhlIGRldHVuZSBhcHBhcmVudFxuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwuY29ubmVjdCh0aGlzLmVmZmVjdFJldHVybkwpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZFIuY29ubmVjdCh0aGlzLmVmZmVjdFJldHVyblIpO1xuXHQgICAgICAgIC8vbGZvIHNldHVwXG5cdCAgICAgICAgdGhpcy5fbGZvTC5jb25uZWN0KHRoaXMuX2RlbGF5Tm9kZUwuZGVsYXlUaW1lKTtcblx0ICAgICAgICB0aGlzLl9sZm9SLmNvbm5lY3QodGhpcy5fZGVsYXlOb2RlUi5kZWxheVRpbWUpO1xuXHQgICAgICAgIC8vc3RhcnQgdGhlIGxmb1xuXHQgICAgICAgIHRoaXMuX2xmb0wuc3RhcnQoKTtcblx0ICAgICAgICB0aGlzLl9sZm9SLnN0YXJ0KCk7XG5cdCAgICAgICAgLy9oYXZlIG9uZSBMRk8gZnJlcXVlbmN5IGNvbnRyb2wgdGhlIG90aGVyXG5cdCAgICAgICAgdGhpcy5fbGZvTC5mcmVxdWVuY3kuY29ubmVjdCh0aGlzLl9sZm9SLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLy9zZXQgdGhlIGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMuX2RlcHRoO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LnZhbHVlID0gb3B0aW9ucy5mcmVxdWVuY3k7XG5cdCAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsnZnJlcXVlbmN5J10pO1xuXHQgICAgICAgIHRoaXMuc3ByZWFkID0gb3B0aW9ucy5zcHJlYWQ7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5DaG9ydXMsIFRvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkNob3J1cy5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogMS41LFxuXHQgICAgICAgICdkZWxheVRpbWUnOiAzLjUsXG5cdCAgICAgICAgJ2RlcHRoJzogMC43LFxuXHQgICAgICAgICdmZWVkYmFjayc6IDAuMSxcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJyxcblx0ICAgICAgICAnc3ByZWFkJzogMTgwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGRlcHRoIG9mIHRoZSBlZmZlY3QuIEEgZGVwdGggb2YgMSBtYWtlcyB0aGUgZGVsYXlUaW1lXG5cdFx0ICogbW9kdWxhdGUgYmV0d2VlbiAwIGFuZCAyKmRlbGF5VGltZSAoY2VudGVyZWQgYXJvdW5kIHRoZSBkZWxheVRpbWUpLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5DaG9ydXMjXG5cdFx0ICogQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqIEBuYW1lIGRlcHRoXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DaG9ydXMucHJvdG90eXBlLCAnZGVwdGgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXB0aDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGRlcHRoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlcHRoID0gZGVwdGg7XG5cdCAgICAgICAgICAgIHZhciBkZXZpYXRpb24gPSB0aGlzLl9kZWxheVRpbWUgKiBkZXB0aDtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC5taW4gPSBNYXRoLm1heCh0aGlzLl9kZWxheVRpbWUgLSBkZXZpYXRpb24sIDApO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9MLm1heCA9IHRoaXMuX2RlbGF5VGltZSArIGRldmlhdGlvbjtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi5taW4gPSBNYXRoLm1heCh0aGlzLl9kZWxheVRpbWUgLSBkZXZpYXRpb24sIDApO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9SLm1heCA9IHRoaXMuX2RlbGF5VGltZSArIGRldmlhdGlvbjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBkZWxheVRpbWUgaW4gbWlsbGlzZWNvbmRzIG9mIHRoZSBjaG9ydXMuIEEgbGFyZ2VyIGRlbGF5VGltZVxuXHRcdCAqIHdpbGwgZ2l2ZSBhIG1vcmUgcHJvbm91bmNlZCBlZmZlY3QuIE5vbWluYWwgcmFuZ2UgYSBkZWxheVRpbWVcblx0XHQgKiBpcyBiZXR3ZWVuIDIgYW5kIDIwbXMuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkNob3J1cyNcblx0XHQgKiBAdHlwZSB7TWlsbGlzZWNvbmRzfVxuXHRcdCAqIEBuYW1lIGRlbGF5VGltZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ2hvcnVzLnByb3RvdHlwZSwgJ2RlbGF5VGltZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGF5VGltZSAqIDEwMDA7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkZWxheVRpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZGVsYXlUaW1lID0gZGVsYXlUaW1lIC8gMTAwMDtcblx0ICAgICAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMuX2RlcHRoO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG9zY2lsbGF0b3IgdHlwZSBvZiB0aGUgTEZPLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5DaG9ydXMjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DaG9ydXMucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xmb0wudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC50eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKiBcblx0XHQgKiBBbW91bnQgb2Ygc3RlcmVvIHNwcmVhZC4gV2hlbiBzZXQgdG8gMCwgYm90aCBMRk8ncyB3aWxsIGJlIHBhbm5lZCBjZW50cmFsbHkuXG5cdFx0ICogV2hlbiBzZXQgdG8gMTgwLCBMRk8ncyB3aWxsIGJlIHBhbm5lZCBoYXJkIGxlZnQgYW5kIHJpZ2h0IHJlc3BlY3RpdmVseS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5DaG9ydXMjXG5cdFx0ICogQHR5cGUge0RlZ3JlZXN9XG5cdFx0ICogQG5hbWUgc3ByZWFkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DaG9ydXMucHJvdG90eXBlLCAnc3ByZWFkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGZvUi5waGFzZSAtIHRoaXMuX2xmb0wucGhhc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzcHJlYWQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC5waGFzZSA9IDkwIC0gc3ByZWFkIC8gMjtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi5waGFzZSA9IHNwcmVhZCAvIDIgKyA5MDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNob3J1c30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DaG9ydXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9sZm9MLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9MID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZm9SLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9SID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGVMLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGVMID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGVSLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGVSID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgnZnJlcXVlbmN5Jyk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkNob3J1cztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLkNvbnZvbHZlciBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBOYXRpdmUgV2ViIEF1ZGlvIFxuXHRcdCAqICAgICAgICAgIFtDb252b2x2ZXJOb2RlXShodHRwOi8vd2ViYXVkaW8uZ2l0aHViLmlvL3dlYi1hdWRpby1hcGkvI3RoZS1jb252b2x2ZXJub2RlLWludGVyZmFjZSkuXG5cdFx0ICogICAgICAgICAgQ29udm9sdXRpb24gaXMgdXNlZnVsIGZvciByZXZlcmIgYW5kIGZpbHRlciBlbXVsYXRpb24uIFJlYWQgbW9yZSBhYm91dCBjb252b2x1dGlvbiByZXZlcmIgb25cblx0XHQgKiAgICAgICAgICBbV2lraXBlZGlhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db252b2x1dGlvbl9yZXZlcmIpLlxuXHRcdCAqICBcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd8VG9uZS5CdWZmZXJ8T2JqZWN0fSBbdXJsXSBUaGUgVVJMIG9mIHRoZSBpbXB1bHNlIHJlc3BvbnNlIG9yIHRoZSBUb25lLkJ1ZmZlclxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpYW5pbmcgdGhlIGltcHVsc2UgcmVzcG9uc2UuIFxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBvbmxvYWQgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIHRoZSB1cmwgaXMgbG9hZGVkLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vaW5pdGlhbGl6aW5nIHRoZSBjb252b2x2ZXIgd2l0aCBhbiBpbXB1bHNlIHJlc3BvbnNlXG5cdFx0ICogdmFyIGNvbnZvbHZlciA9IG5ldyBUb25lLkNvbnZvbHZlcihcIi4vcGF0aC90by9pci53YXZcIikudG9NYXN0ZXIoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udm9sdmVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3VybCcsXG5cdCAgICAgICAgICAgICdvbmxvYWQnXG5cdCAgICAgICAgXSwgVG9uZS5Db252b2x2ZXIpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgY29udm9sdmVyIG5vZGVcblx0XHRcdCAqICBAdHlwZSB7Q29udm9sdmVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY29udm9sdmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUNvbnZvbHZlcigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBjb252b2x1dGlvbiBidWZmZXJcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5CdWZmZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBUb25lLkJ1ZmZlcigpO1xuXHQgICAgICAgIGlmIChUb25lLmlzU3RyaW5nKG9wdGlvbnMudXJsKSkge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXIubG9hZChvcHRpb25zLnVybCwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm9ubG9hZCgpO1xuXHQgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy51cmwpIHtcblx0ICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBvcHRpb25zLnVybDtcblx0ICAgICAgICAgICAgb3B0aW9ucy5vbmxvYWQoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5jb25uZWN0RWZmZWN0KHRoaXMuX2NvbnZvbHZlcik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Db252b2x2ZXIsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udm9sdmVyLmRlZmF1bHRzID0geyAnb25sb2FkJzogVG9uZS5ub09wIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGNvbnZvbHZlcidzIGJ1ZmZlclxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Db252b2x2ZXIjXG5cdFx0ICogIEB0eXBlIHtBdWRpb0J1ZmZlcn1cblx0XHQgKiAgQG5hbWUgYnVmZmVyXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Db252b2x2ZXIucHJvdG90eXBlLCAnYnVmZmVyJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldCgpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5zZXQoYnVmZmVyKTtcblx0ICAgICAgICAgICAgdGhpcy5fY29udm9sdmVyLmJ1ZmZlciA9IHRoaXMuX2J1ZmZlci5nZXQoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBMb2FkIGFuIGltcHVsc2UgcmVzcG9uc2UgdXJsIGFzIGFuIGF1ZGlvIGJ1ZmZlci5cblx0XHQgKiAgRGVjb2RlcyB0aGUgYXVkaW8gYXN5bmNocm9ub3VzbHkgYW5kIGludm9rZXNcblx0XHQgKiAgdGhlIGNhbGxiYWNrIG9uY2UgdGhlIGF1ZGlvIGJ1ZmZlciBsb2Fkcy5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgdXJsIG9mIHRoZSBidWZmZXIgdG8gbG9hZC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICBmaWxldHlwZSBzdXBwb3J0IGRlcGVuZHMgb24gdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5cblx0XHQgKiAgQHBhcmFtICB7ZnVuY3Rpb249fSBjYWxsYmFja1xuXHRcdCAqICBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udm9sdmVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2spIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmxvYWQodXJsLCBmdW5jdGlvbiAoYnVmZikge1xuXHQgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmY7XG5cdCAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuXHQgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ29udm9sdmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnZvbHZlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2NvbnZvbHZlci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fY29udm9sdmVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9idWZmZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQ29udm9sdmVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5EaXN0b3J0aW9uIGlzIGEgc2ltcGxlIGRpc3RvcnRpb24gZWZmZWN0IHVzaW5nIFRvbmUuV2F2ZVNoYXBlci5cblx0XHQgKiAgICAgICAgIEFsZ29yaXRobSBmcm9tIFthIHN0YWNrb3ZlcmZsb3cgYW5zd2VyXShodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjMxMzQwOCkuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGlzdG9ydGlvbl0gVGhlIGFtb3VudCBvZiBkaXN0b3J0aW9uIChub21pbmFsIHJhbmdlIG9mIDAtMSlcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgZGlzdCA9IG5ldyBUb25lLkRpc3RvcnRpb24oMC44KS50b01hc3RlcigpO1xuXHRcdCAqIHZhciBmbSA9IG5ldyBUb25lLlNpbXBsZUZNKCkuY29ubmVjdChkaXN0KTtcblx0XHQgKiAvL3RoaXMgc291bmRzIGdvb2Qgb24gYmFzcyBub3Rlc1xuXHRcdCAqIGZtLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQTFcIiwgXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRGlzdG9ydGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ2Rpc3RvcnRpb24nXSwgVG9uZS5EaXN0b3J0aW9uKTtcblx0ICAgICAgICBUb25lLkVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLldhdmVTaGFwZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NoYXBlciA9IG5ldyBUb25lLldhdmVTaGFwZXIoNDA5Nik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBob2xkcyB0aGUgZGlzdG9ydGlvbiBhbW91bnRcblx0XHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGlzdG9ydGlvbiA9IG9wdGlvbnMuZGlzdG9ydGlvbjtcblx0ICAgICAgICB0aGlzLmNvbm5lY3RFZmZlY3QodGhpcy5fc2hhcGVyKTtcblx0ICAgICAgICB0aGlzLmRpc3RvcnRpb24gPSBvcHRpb25zLmRpc3RvcnRpb247XG5cdCAgICAgICAgdGhpcy5vdmVyc2FtcGxlID0gb3B0aW9ucy5vdmVyc2FtcGxlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRGlzdG9ydGlvbiwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkRpc3RvcnRpb24uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2Rpc3RvcnRpb24nOiAwLjQsXG5cdCAgICAgICAgJ292ZXJzYW1wbGUnOiAnbm9uZSdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgYW1vdW50IG9mIGRpc3RvcnRpb24uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRGlzdG9ydGlvbiNcblx0XHQgKiBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0ICogQG5hbWUgZGlzdG9ydGlvblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRGlzdG9ydGlvbi5wcm90b3R5cGUsICdkaXN0b3J0aW9uJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzdG9ydGlvbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGFtb3VudCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kaXN0b3J0aW9uID0gYW1vdW50O1xuXHQgICAgICAgICAgICB2YXIgayA9IGFtb3VudCAqIDEwMDtcblx0ICAgICAgICAgICAgdmFyIGRlZyA9IE1hdGguUEkgLyAxODA7XG5cdCAgICAgICAgICAgIHRoaXMuX3NoYXBlci5zZXRNYXAoZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh4KSA8IDAuMDAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9zaG91bGQgb3V0cHV0IDAgd2hlbiBpbnB1dCBpcyAwXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMyArIGspICogeCAqIDIwICogZGVnIC8gKE1hdGguUEkgKyBrICogTWF0aC5hYnMoeCkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBvdmVyc2FtcGxpbmcgb2YgdGhlIGVmZmVjdC4gQ2FuIGVpdGhlciBiZSBcIm5vbmVcIiwgXCIyeFwiIG9yIFwiNHhcIi5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5EaXN0b3J0aW9uI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgb3ZlcnNhbXBsZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRGlzdG9ydGlvbi5wcm90b3R5cGUsICdvdmVyc2FtcGxlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hhcGVyLm92ZXJzYW1wbGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvdmVyc2FtcGxpbmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2hhcGVyLm92ZXJzYW1wbGUgPSBvdmVyc2FtcGxpbmc7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5EaXN0b3J0aW9ufSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkRpc3RvcnRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zaGFwZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NoYXBlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRGlzdG9ydGlvbjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLkZlZWRiYWNrRGVsYXkgaXMgYSBEZWxheU5vZGUgaW4gd2hpY2ggcGFydCBvZiBvdXRwdXRcblx0XHQgKiAgICAgICAgICBzaWduYWwgaXMgZmVkIGJhY2sgaW50byB0aGUgZGVsYXkuIFxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5GZWVkYmFja0VmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2RlbGF5VGltZV0gVGhlIGRlbGF5IGFwcGxpZWQgdG8gdGhlIGluY29taW5nIHNpZ25hbC4gXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2U9fSBmZWVkYmFjayBUaGUgYW1vdW50IG9mIHRoZSBlZmZlY3RlZCBzaWduYWwgd2hpY2ggXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgZmVkIGJhY2sgdGhyb3VnaCB0aGUgZGVsYXkuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGZlZWRiYWNrRGVsYXkgPSBuZXcgVG9uZS5GZWVkYmFja0RlbGF5KFwiOG5cIiwgMC41KS50b01hc3RlcigpO1xuXHRcdCAqIHZhciB0b20gPSBuZXcgVG9uZS5EcnVtU3ludGgoe1xuXHRcdCAqIFx0XCJvY3RhdmVzXCIgOiA0LFxuXHRcdCAqIFx0XCJwaXRjaERlY2F5XCIgOiAwLjFcblx0XHQgKiB9KS5jb25uZWN0KGZlZWRiYWNrRGVsYXkpO1xuXHRcdCAqIHRvbS50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkEyXCIsXCIzMm5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkZlZWRiYWNrRGVsYXkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJyxcblx0ICAgICAgICAgICAgJ2ZlZWRiYWNrJ1xuXHQgICAgICAgIF0sIFRvbmUuRmVlZGJhY2tEZWxheSk7XG5cdCAgICAgICAgVG9uZS5GZWVkYmFja0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZWxheSBub2RlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRGVsYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Tm9kZSA9IG5ldyBUb25lLkRlbGF5KG9wdGlvbnMuZGVsYXlUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGVsYXlUaW1lIG9mIHRoZSBEZWxheU5vZGUuIFxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gdGhpcy5fZGVsYXlOb2RlLmRlbGF5VGltZTtcblx0ICAgICAgICAvLyBjb25uZWN0IGl0IHVwXG5cdCAgICAgICAgdGhpcy5jb25uZWN0RWZmZWN0KHRoaXMuX2RlbGF5Tm9kZSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoWydkZWxheVRpbWUnXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5GZWVkYmFja0RlbGF5LCBUb25lLkZlZWRiYWNrRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXMuIFxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GZWVkYmFja0RlbGF5LmRlZmF1bHRzID0geyAnZGVsYXlUaW1lJzogMC4yNSB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZlZWRiYWNrRGVsYXl9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRmVlZGJhY2tEZWxheS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkZlZWRiYWNrRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsnZGVsYXlUaW1lJ10pO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5GZWVkYmFja0RlbGF5O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBhbiBhcnJheSBvZiBjb21iIGZpbHRlciBkZWxheSB2YWx1ZXMgZnJvbSBGcmVldmVyYiBpbXBsZW1lbnRhdGlvblxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0ICAgIHZhciBjb21iRmlsdGVyVHVuaW5ncyA9IFtcblx0ICAgICAgICAxNTU3IC8gNDQxMDAsXG5cdCAgICAgICAgMTYxNyAvIDQ0MTAwLFxuXHQgICAgICAgIDE0OTEgLyA0NDEwMCxcblx0ICAgICAgICAxNDIyIC8gNDQxMDAsXG5cdCAgICAgICAgMTI3NyAvIDQ0MTAwLFxuXHQgICAgICAgIDEzNTYgLyA0NDEwMCxcblx0ICAgICAgICAxMTg4IC8gNDQxMDAsXG5cdCAgICAgICAgMTExNiAvIDQ0MTAwXG5cdCAgICBdO1xuXHQgICAgLyoqXG5cdFx0ICogIGFuIGFycmF5IG9mIGFsbHBhc3MgZmlsdGVyIGZyZXF1ZW5jeSB2YWx1ZXMgZnJvbSBGcmVldmVyYiBpbXBsZW1lbnRhdGlvblxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0ICAgIHZhciBhbGxwYXNzRmlsdGVyRnJlcXVlbmNpZXMgPSBbXG5cdCAgICAgICAgMjI1LFxuXHQgICAgICAgIDU1Nixcblx0ICAgICAgICA0NDEsXG5cdCAgICAgICAgMzQxXG5cdCAgICBdO1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkZyZWV2ZXJiIGlzIGEgcmV2ZXJiIGJhc2VkIG9uIFtGcmVldmVyYl0oaHR0cHM6Ly9jY3JtYS5zdGFuZm9yZC5lZHUvfmpvcy9wYXNwL0ZyZWV2ZXJiLmh0bWwpLlxuXHRcdCAqICAgICAgICAgUmVhZCBtb3JlIG9uIHJldmVyYiBvbiBbU291bmQgT24gU291bmRdKGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE2MDQwNDA4MzkwMi9odHRwOi8vd3d3LnNvdW5kb25zb3VuZC5jb206ODAvc29zL2ZlYjAxL2FydGljbGVzL3N5bnRoc2VjcmV0cy5hc3ApLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V8T2JqZWN0fSBbcm9vbVNpemVdIENvcnJlbGF0ZWQgdG8gdGhlIGRlY2F5IHRpbWUuXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBbZGFtcGVuaW5nXSBUaGUgY3V0b2ZmIGZyZXF1ZW5jeSBvZiBhIGxvd3Bhc3MgZmlsdGVyIGFzIHBhcnRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSByZXZlcmIuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGZyZWV2ZXJiID0gbmV3IFRvbmUuRnJlZXZlcmIoKS50b01hc3RlcigpO1xuXHRcdCAqIGZyZWV2ZXJiLmRhbXBlbmluZy52YWx1ZSA9IDEwMDA7XG5cdFx0ICogLy9yb3V0aW5nIHN5bnRoIHRocm91Z2ggdGhlIHJldmVyYlxuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBUb25lLkFNU3ludGgoKS5jb25uZWN0KGZyZWV2ZXJiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlZXZlcmIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAncm9vbVNpemUnLFxuXHQgICAgICAgICAgICAnZGFtcGVuaW5nJ1xuXHQgICAgICAgIF0sIFRvbmUuRnJlZXZlcmIpO1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHJvb21TaXplIHZhbHVlIGJldHdlZW4uIEEgbGFyZ2VyIHJvb21TaXplXG5cdFx0XHQgKiAgd2lsbCByZXN1bHQgaW4gYSBsb25nZXIgZGVjYXkuXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucm9vbVNpemUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5yb29tU2l6ZSwgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIGRhbXBlbmluZyBvZiB0aGUgcmV2ZXJiZXJhbnQgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kYW1wZW5pbmcsIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBjb21iIGZpbHRlcnNcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NvbWJGaWx0ZXJzID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGFsbHBhc3MgZmlsdGVycyBvbiB0aGUgbGVmdFxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNMID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGFsbHBhc3MgZmlsdGVycyBvbiB0aGUgcmlnaHRcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzUiA9IFtdO1xuXHQgICAgICAgIC8vbWFrZSB0aGUgYWxscGFzcyBmaWx0ZXJzIG9uIHRoZSByaWdodFxuXHQgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgYWxscGFzc0ZpbHRlckZyZXF1ZW5jaWVzLmxlbmd0aDsgbCsrKSB7XG5cdCAgICAgICAgICAgIHZhciBhbGxwYXNzTCA9IHRoaXMuY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcblx0ICAgICAgICAgICAgYWxscGFzc0wudHlwZSA9ICdhbGxwYXNzJztcblx0ICAgICAgICAgICAgYWxscGFzc0wuZnJlcXVlbmN5LnZhbHVlID0gYWxscGFzc0ZpbHRlckZyZXF1ZW5jaWVzW2xdO1xuXHQgICAgICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc0wucHVzaChhbGxwYXNzTCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vbWFrZSB0aGUgYWxscGFzcyBmaWx0ZXJzIG9uIHRoZSBsZWZ0XG5cdCAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBhbGxwYXNzRmlsdGVyRnJlcXVlbmNpZXMubGVuZ3RoOyByKyspIHtcblx0ICAgICAgICAgICAgdmFyIGFsbHBhc3NSID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuXHQgICAgICAgICAgICBhbGxwYXNzUi50eXBlID0gJ2FsbHBhc3MnO1xuXHQgICAgICAgICAgICBhbGxwYXNzUi5mcmVxdWVuY3kudmFsdWUgPSBhbGxwYXNzRmlsdGVyRnJlcXVlbmNpZXNbcl07XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzUi5wdXNoKGFsbHBhc3NSKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9tYWtlIHRoZSBjb21iIGZpbHRlcnNcblx0ICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbWJGaWx0ZXJUdW5pbmdzLmxlbmd0aDsgYysrKSB7XG5cdCAgICAgICAgICAgIHZhciBsZnBmID0gbmV3IFRvbmUuTG93cGFzc0NvbWJGaWx0ZXIoY29tYkZpbHRlclR1bmluZ3NbY10pO1xuXHQgICAgICAgICAgICBpZiAoYyA8IGNvbWJGaWx0ZXJUdW5pbmdzLmxlbmd0aCAvIDIpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwuY2hhaW4obGZwZiwgdGhpcy5fYWxscGFzc0ZpbHRlcnNMWzBdKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0U2VuZFIuY2hhaW4obGZwZiwgdGhpcy5fYWxscGFzc0ZpbHRlcnNSWzBdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnJvb21TaXplLmNvbm5lY3QobGZwZi5yZXNvbmFuY2UpO1xuXHQgICAgICAgICAgICB0aGlzLmRhbXBlbmluZy5jb25uZWN0KGxmcGYuZGFtcGVuaW5nKTtcblx0ICAgICAgICAgICAgdGhpcy5fY29tYkZpbHRlcnMucHVzaChsZnBmKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9jaGFpbiB0aGUgYWxscGFzcyBmaWx0ZXJzIHRvZ2V0ZWhyXG5cdCAgICAgICAgVG9uZS5jb25uZWN0U2VyaWVzLmFwcGx5KFRvbmUsIHRoaXMuX2FsbHBhc3NGaWx0ZXJzTCk7XG5cdCAgICAgICAgVG9uZS5jb25uZWN0U2VyaWVzLmFwcGx5KFRvbmUsIHRoaXMuX2FsbHBhc3NGaWx0ZXJzUik7XG5cdCAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNMW3RoaXMuX2FsbHBhc3NGaWx0ZXJzTC5sZW5ndGggLSAxXS5jb25uZWN0KHRoaXMuZWZmZWN0UmV0dXJuTCk7XG5cdCAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNSW3RoaXMuX2FsbHBhc3NGaWx0ZXJzUi5sZW5ndGggLSAxXS5jb25uZWN0KHRoaXMuZWZmZWN0UmV0dXJuUik7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAncm9vbVNpemUnLFxuXHQgICAgICAgICAgICAnZGFtcGVuaW5nJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRnJlZXZlcmIsIFRvbmUuU3RlcmVvRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkZyZWV2ZXJiLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdyb29tU2l6ZSc6IDAuNyxcblx0ICAgICAgICAnZGFtcGVuaW5nJzogMzAwMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuRnJlZXZlcmJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlZXZlcmIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICBmb3IgKHZhciBhbCA9IDA7IGFsIDwgdGhpcy5fYWxscGFzc0ZpbHRlcnNMLmxlbmd0aDsgYWwrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc0xbYWxdLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNMW2FsXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzTCA9IG51bGw7XG5cdCAgICAgICAgZm9yICh2YXIgYXIgPSAwOyBhciA8IHRoaXMuX2FsbHBhc3NGaWx0ZXJzUi5sZW5ndGg7IGFyKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNSW2FyXS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzUlthcl0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc1IgPSBudWxsO1xuXHQgICAgICAgIGZvciAodmFyIGNmID0gMDsgY2YgPCB0aGlzLl9jb21iRmlsdGVycy5sZW5ndGg7IGNmKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fY29tYkZpbHRlcnNbY2ZdLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5fY29tYkZpbHRlcnNbY2ZdID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fY29tYkZpbHRlcnMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3Jvb21TaXplJyxcblx0ICAgICAgICAgICAgJ2RhbXBlbmluZydcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLnJvb21TaXplLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnJvb21TaXplID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRhbXBlbmluZy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZyZWV2ZXJiO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBhbiBhcnJheSBvZiB0aGUgY29tYiBmaWx0ZXIgZGVsYXkgdGltZSB2YWx1ZXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgY29tYkZpbHRlckRlbGF5VGltZXMgPSBbXG5cdCAgICAgICAgMTY4NyAvIDI1MDAwLFxuXHQgICAgICAgIDE2MDEgLyAyNTAwMCxcblx0ICAgICAgICAyMDUzIC8gMjUwMDAsXG5cdCAgICAgICAgMjI1MSAvIDI1MDAwXG5cdCAgICBdO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSByZXNvbmFuY2VzIG9mIGVhY2ggb2YgdGhlIGNvbWIgZmlsdGVyc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0ICAgIHZhciBjb21iRmlsdGVyUmVzb25hbmNlcyA9IFtcblx0ICAgICAgICAwLjc3Myxcblx0ICAgICAgICAwLjgwMixcblx0ICAgICAgICAwLjc1Myxcblx0ICAgICAgICAwLjczM1xuXHQgICAgXTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgYWxscGFzcyBmaWx0ZXIgZnJlcXVlbmNpZXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgYWxscGFzc0ZpbHRlckZyZXFzID0gW1xuXHQgICAgICAgIDM0Nyxcblx0ICAgICAgICAxMTMsXG5cdCAgICAgICAgMzdcblx0ICAgIF07XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuSkNSZXZlcmIgaXMgYSBzaW1wbGUgW1NjaHJvZWRlciBSZXZlcmJlcmF0b3JdKGh0dHBzOi8vY2NybWEuc3RhbmZvcmQuZWR1L35qb3MvcGFzcC9TY2hyb2VkZXJfUmV2ZXJiZXJhdG9ycy5odG1sKVxuXHRcdCAqICAgICAgICAgdHVuZWQgYnkgSm9obiBDaG93bmluZyBpbiAxOTcwLlxuXHRcdCAqICAgICAgICAgSXQgaXMgbWFkZSB1cCBvZiB0aHJlZSBhbGxwYXNzIGZpbHRlcnMgYW5kIGZvdXIgVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXIuIFxuXHRcdCAqICAgICAgICAgXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZXxPYmplY3R9IFtyb29tU2l6ZV0gQ29vcmVsYXRlcyB0byB0aGUgZGVjYXkgdGltZS5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgcmV2ZXJiID0gbmV3IFRvbmUuSkNSZXZlcmIoMC40KS5jb25uZWN0KFRvbmUuTWFzdGVyKTtcblx0XHQgKiB2YXIgZGVsYXkgPSBuZXcgVG9uZS5GZWVkYmFja0RlbGF5KDAuNSk7IFxuXHRcdCAqIC8vY29ubmVjdGluZyB0aGUgc3ludGggdG8gcmV2ZXJiIHRocm91Z2ggZGVsYXlcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5EdW9TeW50aCgpLmNoYWluKGRlbGF5LCByZXZlcmIpO1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQTRcIixcIjhuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5KQ1JldmVyYiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ3Jvb21TaXplJ10sIFRvbmUuSkNSZXZlcmIpO1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgcm9vbSBzaXplIGNvbnRyb2wgdmFsdWVzIGJldHdlZW4gWzAsMV1cblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5yb29tU2l6ZSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLnJvb21TaXplLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHNjYWxlIHRoZSByb29tIHNpemVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TY2FsZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2NhbGVSb29tU2l6ZSA9IG5ldyBUb25lLlNjYWxlKC0wLjczMywgMC4xOTcpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGEgc2VyaWVzIG9mIGFsbHBhc3MgZmlsdGVyc1xuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnMgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBwYXJhbGxlbCBmZWVkYmFjayBjb21iIGZpbHRlcnNcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrQ29tYkZpbHRlcnMgPSBbXTtcblx0ICAgICAgICAvL21ha2UgdGhlIGFsbHBhc3MgZmlsdGVyc1xuXHQgICAgICAgIGZvciAodmFyIGFmID0gMDsgYWYgPCBhbGxwYXNzRmlsdGVyRnJlcXMubGVuZ3RoOyBhZisrKSB7XG5cdCAgICAgICAgICAgIHZhciBhbGxwYXNzID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuXHQgICAgICAgICAgICBhbGxwYXNzLnR5cGUgPSAnYWxscGFzcyc7XG5cdCAgICAgICAgICAgIGFsbHBhc3MuZnJlcXVlbmN5LnZhbHVlID0gYWxscGFzc0ZpbHRlckZyZXFzW2FmXTtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnMucHVzaChhbGxwYXNzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9hbmQgdGhlIGNvbWIgZmlsdGVyc1xuXHQgICAgICAgIGZvciAodmFyIGNmID0gMDsgY2YgPCBjb21iRmlsdGVyRGVsYXlUaW1lcy5sZW5ndGg7IGNmKyspIHtcblx0ICAgICAgICAgICAgdmFyIGZiY2YgPSBuZXcgVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXIoY29tYkZpbHRlckRlbGF5VGltZXNbY2ZdLCAwLjEpO1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZVJvb21TaXplLmNvbm5lY3QoZmJjZi5yZXNvbmFuY2UpO1xuXHQgICAgICAgICAgICBmYmNmLnJlc29uYW5jZS52YWx1ZSA9IGNvbWJGaWx0ZXJSZXNvbmFuY2VzW2NmXTtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNbdGhpcy5fYWxscGFzc0ZpbHRlcnMubGVuZ3RoIC0gMV0uY29ubmVjdChmYmNmKTtcblx0ICAgICAgICAgICAgaWYgKGNmIDwgY29tYkZpbHRlckRlbGF5VGltZXMubGVuZ3RoIC8gMikge1xuXHQgICAgICAgICAgICAgICAgZmJjZi5jb25uZWN0KHRoaXMuZWZmZWN0UmV0dXJuTCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmYmNmLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm5SKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9mZWVkYmFja0NvbWJGaWx0ZXJzLnB1c2goZmJjZik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vY2hhaW4gdGhlIGFsbHBhc3MgZmlsdGVycyB0b2dldGhlclxuXHQgICAgICAgIHRoaXMucm9vbVNpemUuY29ubmVjdCh0aGlzLl9zY2FsZVJvb21TaXplKTtcblx0ICAgICAgICBUb25lLmNvbm5lY3RTZXJpZXMuYXBwbHkoVG9uZSwgdGhpcy5fYWxscGFzc0ZpbHRlcnMpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwuY29ubmVjdCh0aGlzLl9hbGxwYXNzRmlsdGVyc1swXSk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kUi5jb25uZWN0KHRoaXMuX2FsbHBhc3NGaWx0ZXJzWzBdKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ3Jvb21TaXplJ10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuSkNSZXZlcmIsIFRvbmUuU3RlcmVvRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuSkNSZXZlcmIuZGVmYXVsdHMgPSB7ICdyb29tU2l6ZSc6IDAuNSB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuSkNSZXZlcmJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuSkNSZXZlcmIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICBmb3IgKHZhciBhcGYgPSAwOyBhcGYgPCB0aGlzLl9hbGxwYXNzRmlsdGVycy5sZW5ndGg7IGFwZisrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzW2FwZl0uZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc1thcGZdID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnMgPSBudWxsO1xuXHQgICAgICAgIGZvciAodmFyIGZiY2YgPSAwOyBmYmNmIDwgdGhpcy5fZmVlZGJhY2tDb21iRmlsdGVycy5sZW5ndGg7IGZiY2YrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9mZWVkYmFja0NvbWJGaWx0ZXJzW2ZiY2ZdLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5fZmVlZGJhY2tDb21iRmlsdGVyc1tmYmNmXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrQ29tYkZpbHRlcnMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsncm9vbVNpemUnXSk7XG5cdCAgICAgICAgdGhpcy5yb29tU2l6ZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5yb29tU2l6ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc2NhbGVSb29tU2l6ZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGVSb29tU2l6ZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuSkNSZXZlcmI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBNaWQvU2lkZSBwcm9jZXNzaW5nIHNlcGFyYXRlcyB0aGUgdGhlICdtaWQnIHNpZ25hbCBcblx0XHQgKiAgICAgICAgICh3aGljaCBjb21lcyBvdXQgb2YgYm90aCB0aGUgbGVmdCBhbmQgdGhlIHJpZ2h0IGNoYW5uZWwpIFxuXHRcdCAqICAgICAgICAgYW5kIHRoZSAnc2lkZScgKHdoaWNoIG9ubHkgY29tZXMgb3V0IG9mIHRoZSB0aGUgc2lkZSBjaGFubmVscykgXG5cdFx0ICogICAgICAgICBhbmQgZWZmZWN0cyB0aGVtIHNlcGFyYXRlbHkgYmVmb3JlIGJlaW5nIHJlY29tYmluZWQuXG5cdFx0ICogICAgICAgICBBcHBsaWVzIGEgTWlkL1NpZGUgc2VwZXJhdGlvbiBhbmQgcmVjb21iaW5hdGlvbi5cblx0XHQgKiAgICAgICAgIEFsZ29yaXRobSBmb3VuZCBpbiBba3ZyYXVkaW8gZm9ydW1zXShodHRwOi8vd3d3Lmt2cmF1ZGlvLmNvbS9mb3J1bS92aWV3dG9waWMucGhwP3Q9MjEyNTg3KS5cblx0XHQgKiAgICAgICAgIDxicj48YnI+XG5cdFx0ICogICAgICAgICBUaGlzIGlzIGEgYmFzZS1jbGFzcyBmb3IgTWlkL1NpZGUgRWZmZWN0cy4gXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0ICAgIFRvbmUuTWlkU2lkZUVmZmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaWQvc2lkZSBzcGxpdFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5NaWRTaWRlU3BsaXR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVTcGxpdCA9IG5ldyBUb25lLk1pZFNpZGVTcGxpdCgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaWQvc2lkZSBtZXJnZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5NaWRTaWRlTWVyZ2V9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVNZXJnZSA9IG5ldyBUb25lLk1pZFNpZGVNZXJnZSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaWQgc2VuZC4gQ29ubmVjdCB0byBtaWQgcHJvY2Vzc2luZ1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkV4cHJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWlkU2VuZCA9IHRoaXMuX21pZFNpZGVTcGxpdC5taWQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHNpZGUgc2VuZC4gQ29ubmVjdCB0byBzaWRlIHByb2Nlc3Npbmdcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5FeHByfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnNpZGVTZW5kID0gdGhpcy5fbWlkU2lkZVNwbGl0LnNpZGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pZCByZXR1cm4gY29ubmVjdGlvblxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5taWRSZXR1cm4gPSB0aGlzLl9taWRTaWRlTWVyZ2UubWlkO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBzaWRlIHJldHVybiBjb25uZWN0aW9uXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnNpZGVSZXR1cm4gPSB0aGlzLl9taWRTaWRlTWVyZ2Uuc2lkZTtcblx0ICAgICAgICAvL3RoZSBjb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZC5jb25uZWN0KHRoaXMuX21pZFNpZGVTcGxpdCk7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZU1lcmdlLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm4pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTWlkU2lkZUVmZmVjdCwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTWlkU2lkZUVmZmVjdH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NaWRTaWRlRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZVNwbGl0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlU3BsaXQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVNZXJnZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZU1lcmdlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1pZFNlbmQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuc2lkZVNlbmQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubWlkUmV0dXJuID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnNpZGVSZXR1cm4gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk1pZFNpZGVFZmZlY3Q7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlBoYXNlciBpcyBhIHBoYXNlciBlZmZlY3QuIFBoYXNlcnMgd29yayBieSBjaGFuZ2luZyB0aGUgcGhhc2Vcblx0XHQgKiAgICAgICAgIG9mIGRpZmZlcmVudCBmcmVxdWVuY3kgY29tcG9uZW50cyBvZiBhbiBpbmNvbWluZyBzaWduYWwuIFJlYWQgbW9yZSBvbiBcblx0XHQgKiAgICAgICAgIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BoYXNlcl8oZWZmZWN0KSkuIFxuXHRcdCAqICAgICAgICAgSW5zcGlyYXRpb24gZm9yIHRoaXMgcGhhc2VyIGNvbWVzIGZyb20gW1R1bmEuanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9EaW5haG1vZS90dW5hLykuXG5cdFx0ICpcblx0XHQgKlx0QGV4dGVuZHMge1RvbmUuU3RlcmVvRWZmZWN0fVxuXHRcdCAqXHRAY29uc3RydWN0b3Jcblx0XHQgKlx0QHBhcmFtIHtGcmVxdWVuY3l8T2JqZWN0fSBbZnJlcXVlbmN5XSBUaGUgc3BlZWQgb2YgdGhlIHBoYXNpbmcuIFxuXHRcdCAqXHRAcGFyYW0ge251bWJlcn0gW29jdGF2ZXNdIFRoZSBvY3RhdmVzIG9mIHRoZSBlZmZlY3QuIFxuXHRcdCAqXHRAcGFyYW0ge0ZyZXF1ZW5jeX0gW2Jhc2VGcmVxdWVuY3ldIFRoZSBiYXNlIGZyZXF1ZW5jeSBvZiB0aGUgZmlsdGVycy4gXG5cdFx0ICpcdEBleGFtcGxlXG5cdFx0ICogdmFyIHBoYXNlciA9IG5ldyBUb25lLlBoYXNlcih7XG5cdFx0ICogXHRcImZyZXF1ZW5jeVwiIDogMTUsIFxuXHRcdCAqIFx0XCJvY3RhdmVzXCIgOiA1LCBcblx0XHQgKiBcdFwiYmFzZUZyZXF1ZW5jeVwiIDogMTAwMFxuXHRcdCAqIH0pLnRvTWFzdGVyKCk7XG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFRvbmUuRk1TeW50aCgpLmNvbm5lY3QocGhhc2VyKTtcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkUzXCIsIFwiMm5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBoYXNlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvL3NldCB0aGUgZGVmYXVsdHNcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnb2N0YXZlcycsXG5cdCAgICAgICAgICAgICdiYXNlRnJlcXVlbmN5J1xuXHQgICAgICAgIF0sIFRvbmUuUGhhc2VyKTtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBsZm8gd2hpY2ggY29udHJvbHMgdGhlIGZyZXF1ZW5jeSBvbiB0aGUgbGVmdCBzaWRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9MID0gbmV3IFRvbmUuTEZPKG9wdGlvbnMuZnJlcXVlbmN5LCAwLCAxKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbGZvIHdoaWNoIGNvbnRyb2xzIHRoZSBmcmVxdWVuY3kgb24gdGhlIHJpZ2h0IHNpZGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmb1IgPSBuZXcgVG9uZS5MRk8ob3B0aW9ucy5mcmVxdWVuY3ksIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuX2xmb1IucGhhc2UgPSAxODA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGJhc2UgbW9kdWxhdGlvbiBmcmVxdWVuY3lcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9iYXNlRnJlcXVlbmN5ID0gb3B0aW9ucy5iYXNlRnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBvY3RhdmVzIG9mIHRoZSBwaGFzaW5nXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcXVhbGl0eSBmYWN0b3Igb2YgdGhlIGZpbHRlcnNcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5RID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuUSwgVG9uZS5UeXBlLlBvc2l0aXZlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgYXJyYXkgb2YgZmlsdGVycyBmb3IgdGhlIGxlZnQgc2lkZVxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmlsdGVyc0wgPSB0aGlzLl9tYWtlRmlsdGVycyhvcHRpb25zLnN0YWdlcywgdGhpcy5fbGZvTCwgdGhpcy5RKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgYXJyYXkgb2YgZmlsdGVycyBmb3IgdGhlIGxlZnQgc2lkZVxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmlsdGVyc1IgPSB0aGlzLl9tYWtlRmlsdGVycyhvcHRpb25zLnN0YWdlcywgdGhpcy5fbGZvUiwgdGhpcy5RKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIHRoZSBmcmVxdWVuY3kgb2YgdGhlIGVmZmVjdFxuXHRcdFx0ICogQHR5cGUge1RvbmUuU2lnbmFsfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSB0aGlzLl9sZm9MLmZyZXF1ZW5jeTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS52YWx1ZSA9IG9wdGlvbnMuZnJlcXVlbmN5O1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGVtIHVwXG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kTC5jb25uZWN0KHRoaXMuX2ZpbHRlcnNMWzBdKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRSLmNvbm5lY3QodGhpcy5fZmlsdGVyc1JbMF0pO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnNMW29wdGlvbnMuc3RhZ2VzIC0gMV0uY29ubmVjdCh0aGlzLmVmZmVjdFJldHVybkwpO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnNSW29wdGlvbnMuc3RhZ2VzIC0gMV0uY29ubmVjdCh0aGlzLmVmZmVjdFJldHVyblIpO1xuXHQgICAgICAgIC8vY29udHJvbCB0aGUgZnJlcXVlbmN5IHdpdGggb25lIExGT1xuXHQgICAgICAgIHRoaXMuX2xmb0wuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fbGZvUi5mcmVxdWVuY3kpO1xuXHQgICAgICAgIC8vc2V0IHRoZSBvcHRpb25zXG5cdCAgICAgICAgdGhpcy5iYXNlRnJlcXVlbmN5ID0gb3B0aW9ucy5iYXNlRnJlcXVlbmN5O1xuXHQgICAgICAgIHRoaXMub2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBsZm9cblx0ICAgICAgICB0aGlzLl9sZm9MLnN0YXJ0KCk7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5zdGFydCgpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdRJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGhhc2VyLCBUb25lLlN0ZXJlb0VmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdHNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7b2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QaGFzZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDAuNSxcblx0ICAgICAgICAnb2N0YXZlcyc6IDMsXG5cdCAgICAgICAgJ3N0YWdlcyc6IDEwLFxuXHQgICAgICAgICdRJzogMTAsXG5cdCAgICAgICAgJ2Jhc2VGcmVxdWVuY3knOiAzNTBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHN0YWdlc1xuXHRcdCAqICBAcmV0dXJucyB7QXJyYXl9IHRoZSBudW1iZXIgb2YgZmlsdGVycyBhbGwgY29ubmVjdGVkIHRvZ2V0aGVyXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBoYXNlci5wcm90b3R5cGUuX21ha2VGaWx0ZXJzID0gZnVuY3Rpb24gKHN0YWdlcywgY29ubmVjdFRvRnJlcSwgUSkge1xuXHQgICAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEFycmF5KHN0YWdlcyk7XG5cdCAgICAgICAgLy9tYWtlIGFsbCB0aGUgZmlsdGVyc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhZ2VzOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcblx0ICAgICAgICAgICAgZmlsdGVyLnR5cGUgPSAnYWxscGFzcyc7XG5cdCAgICAgICAgICAgIFEuY29ubmVjdChmaWx0ZXIuUSk7XG5cdCAgICAgICAgICAgIGNvbm5lY3RUb0ZyZXEuY29ubmVjdChmaWx0ZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICAgICAgZmlsdGVyc1tpXSA9IGZpbHRlcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgVG9uZS5jb25uZWN0U2VyaWVzLmFwcGx5KFRvbmUsIGZpbHRlcnMpO1xuXHQgICAgICAgIHJldHVybiBmaWx0ZXJzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2Ygb2N0YXZlcyB0aGUgcGhhc2UgZ29lcyBhYm92ZVxuXHRcdCAqIHRoZSBiYXNlRnJlcXVlbmN5XG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGhhc2VyI1xuXHRcdCAqIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiBAbmFtZSBvY3RhdmVzXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QaGFzZXIucHJvdG90eXBlLCAnb2N0YXZlcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvY3RhdmVzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29jdGF2ZXMgPSBvY3RhdmVzO1xuXHQgICAgICAgICAgICB2YXIgbWF4ID0gdGhpcy5fYmFzZUZyZXF1ZW5jeSAqIE1hdGgucG93KDIsIG9jdGF2ZXMpO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9MLm1heCA9IG1heDtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi5tYXggPSBtYXg7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdGhlIGJhc2UgZnJlcXVlbmN5IG9mIHRoZSBmaWx0ZXJzLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QaGFzZXIjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBiYXNlRnJlcXVlbmN5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QaGFzZXIucHJvdG90eXBlLCAnYmFzZUZyZXF1ZW5jeScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VGcmVxdWVuY3k7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChmcmVxKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2Jhc2VGcmVxdWVuY3kgPSBmcmVxO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9MLm1pbiA9IGZyZXE7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb1IubWluID0gZnJlcTtcblx0ICAgICAgICAgICAgdGhpcy5vY3RhdmVzID0gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QaGFzZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGhhc2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ1EnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5RLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLlEgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xmb0wuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xmb0wgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xmb1IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xmb1IgPSBudWxsO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZmlsdGVyc0wubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fZmlsdGVyc0xbaV0uZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9maWx0ZXJzTFtpXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnNMID0gbnVsbDtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX2ZpbHRlcnNSLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNSW2pdLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fZmlsdGVyc1Jbal0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9maWx0ZXJzUiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBoYXNlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLlBpbmdQb25nRGVsYXkgaXMgYSBmZWVkYmFjayBkZWxheSBlZmZlY3Qgd2hlcmUgdGhlIGVjaG8gaXMgaGVhcmRcblx0XHQgKiAgICAgICAgICBmaXJzdCBpbiBvbmUgY2hhbm5lbCBhbmQgbmV4dCBpbiB0aGUgb3Bwb3NpdGUgY2hhbm5lbC4gSW4gYSBzdGVyZW9cblx0XHQgKiAgICAgICAgICBzeXN0ZW0gdGhlc2UgYXJlIHRoZSByaWdodCBhbmQgbGVmdCBjaGFubmVscy5cblx0XHQgKiAgICAgICAgICBQaW5nUG9uZ0RlbGF5IGluIG1vcmUgc2ltcGxpZmllZCB0ZXJtcyBpcyB0d28gVG9uZS5GZWVkYmFja0RlbGF5cyBcblx0XHQgKiAgICAgICAgICB3aXRoIGluZGVwZW5kZW50IGRlbGF5IHZhbHVlcy4gRWFjaCBkZWxheSBpcyByb3V0ZWQgdG8gb25lIGNoYW5uZWxcblx0XHQgKiAgICAgICAgICAobGVmdCBvciByaWdodCksIGFuZCB0aGUgY2hhbm5lbCB0cmlnZ2VyZWQgc2Vjb25kIHdpbGwgYWx3YXlzIFxuXHRcdCAqICAgICAgICAgIHRyaWdnZXIgYXQgdGhlIHNhbWUgaW50ZXJ2YWwgYWZ0ZXIgdGhlIGZpcnN0LlxuXHRcdCAqXG5cdFx0ICogXHRAY29uc3RydWN0b3Jcblx0XHQgKiBcdEBleHRlbmRzIHtUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2RlbGF5VGltZV0gVGhlIGRlbGF5VGltZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIGVjaG9zLlxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlPX0gZmVlZGJhY2sgVGhlIGFtb3VudCBvZiB0aGUgZWZmZWN0ZWQgc2lnbmFsIHdoaWNoIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgZmVkIGJhY2sgdGhyb3VnaCB0aGUgZGVsYXkuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHBpbmdQb25nID0gbmV3IFRvbmUuUGluZ1BvbmdEZWxheShcIjRuXCIsIDAuMikudG9NYXN0ZXIoKTtcblx0XHQgKiB2YXIgZHJ1bSA9IG5ldyBUb25lLkRydW1TeW50aCgpLmNvbm5lY3QocGluZ1BvbmcpO1xuXHRcdCAqIGRydW0udHJpZ2dlckF0dGFja1JlbGVhc2UoXCJDNFwiLCBcIjMyblwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGluZ1BvbmdEZWxheSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnLFxuXHQgICAgICAgICAgICAnZmVlZGJhY2snXG5cdCAgICAgICAgXSwgVG9uZS5QaW5nUG9uZ0RlbGF5KTtcblx0ICAgICAgICBUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZWxheSBub2RlIG9uIHRoZSBsZWZ0IHNpZGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5EZWxheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGVmdERlbGF5ID0gbmV3IFRvbmUuRGVsYXkoMCwgb3B0aW9ucy5tYXhEZWxheVRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZWxheSBub2RlIG9uIHRoZSByaWdodCBzaWRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRGVsYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0RGVsYXkgPSBuZXcgVG9uZS5EZWxheSgwLCBvcHRpb25zLm1heERlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHByZWRlbGF5IG9uIHRoZSByaWdodCBzaWRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRGVsYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0UHJlRGVsYXkgPSBuZXcgVG9uZS5EZWxheSgwLCBvcHRpb25zLm1heERlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGRlbGF5IHRpbWUgc2lnbmFsXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZWxheVRpbWUsIFRvbmUuVHlwZS5UaW1lKTtcblx0ICAgICAgICAvL2Nvbm5lY3QgaXQgdXBcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRMLmNoYWluKHRoaXMuX2xlZnREZWxheSwgdGhpcy5lZmZlY3RSZXR1cm5MKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRSLmNoYWluKHRoaXMuX3JpZ2h0UHJlRGVsYXksIHRoaXMuX3JpZ2h0RGVsYXksIHRoaXMuZWZmZWN0UmV0dXJuUik7XG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUuZmFuKHRoaXMuX2xlZnREZWxheS5kZWxheVRpbWUsIHRoaXMuX3JpZ2h0RGVsYXkuZGVsYXlUaW1lLCB0aGlzLl9yaWdodFByZURlbGF5LmRlbGF5VGltZSk7XG5cdCAgICAgICAgLy9yZWFycmFuZ2VkIHRoZSBmZWVkYmFjayB0byBiZSBhZnRlciB0aGUgcmlnaHRQcmVEZWxheVxuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrTFIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrTFIuY29ubmVjdCh0aGlzLl9yaWdodERlbGF5KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ2RlbGF5VGltZSddKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBpbmdQb25nRGVsYXksIFRvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBpbmdQb25nRGVsYXkuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2RlbGF5VGltZSc6IDAuMjUsXG5cdCAgICAgICAgJ21heERlbGF5VGltZSc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QaW5nUG9uZ0RlbGF5fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBpbmdQb25nRGVsYXkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9sZWZ0RGVsYXkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xlZnREZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcmlnaHREZWxheS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcmlnaHREZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcmlnaHRQcmVEZWxheS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcmlnaHRQcmVEZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoWydkZWxheVRpbWUnXSk7XG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QaW5nUG9uZ0RlbGF5O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5QaXRjaFNoaWZ0IGRvZXMgbmVhci1yZWFsdGltZSBwaXRjaCBzaGlmdGluZyB0byB0aGUgaW5jb21pbmcgc2lnbmFsLiBcblx0XHQgKiAgICAgICAgIFRoZSBlZmZlY3QgaXMgYWNoaWV2ZWQgYnkgc3BlZWRpbmcgdXAgb3Igc2xvd2luZyBkb3duIHRoZSBkZWxheVRpbWVcblx0XHQgKiAgICAgICAgIG9mIGEgRGVsYXlOb2RlIHVzaW5nIGEgc2F3dG9vdGggd2F2ZS4gXG5cdFx0ICogICAgICAgICBBbGdvcml0aG0gZm91bmQgaW4gW3RoaXMgcGRmXShodHRwOi8vZHNwLWJvb2submFyb2QucnUvc291bmRwcm9jLnBkZikuXG5cdFx0ICogICAgICAgICBBZGRpdGlvbmFsIHJlZmVyZW5jZSBieSBbTWlsbGVyIFB1Y2tldF0oaHR0cDovL21zcC51Y3NkLmVkdS90ZWNobmlxdWVzL3YwLjExL2Jvb2staHRtbC9ub2RlMTE1Lmh0bWwpLlxuXHRcdCAqICAgICAgICAgXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkZlZWRiYWNrRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge0ludGVydmFsPX0gcGl0Y2ggVGhlIGludGVydmFsIHRvIHRyYW5zcG9zZSB0aGUgaW5jb21pbmcgc2lnbmFsIGJ5LiBcblx0XHQgKi9cblx0ICAgIFRvbmUuUGl0Y2hTaGlmdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ3BpdGNoJ10sIFRvbmUuUGl0Y2hTaGlmdCk7XG5cdCAgICAgICAgVG9uZS5GZWVkYmFja0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBwaXRjaCBzaWduYWxcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuU2lnbmFsfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mcmVxdWVuY3kgPSBuZXcgVG9uZS5TaWduYWwoMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVXNlcyB0d28gRGVsYXlOb2RlcyB0byBjb3ZlciB1cCB0aGUganVtcCBpblxuXHRcdFx0ICogIHRoZSBzYXd0b290aCB3YXZlLiBcblx0XHRcdCAqICBAdHlwZSAge0RlbGF5Tm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXlBID0gbmV3IFRvbmUuRGVsYXkoMCwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZpcnN0IExGTy5cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9BID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgICAgICdtYXgnOiAwLjEsXG5cdCAgICAgICAgICAgICd0eXBlJzogJ3Nhd3Rvb3RoJ1xuXHQgICAgICAgIH0pLmNvbm5lY3QodGhpcy5fZGVsYXlBLmRlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHNlY29uZCBEZWxheU5vZGVcblx0XHRcdCAqICBAdHlwZSAge0RlbGF5Tm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXlCID0gbmV3IFRvbmUuRGVsYXkoMCwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZpcnN0IExGTy5cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9CID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgICAgICdtYXgnOiAwLjEsXG5cdCAgICAgICAgICAgICd0eXBlJzogJ3Nhd3Rvb3RoJyxcblx0ICAgICAgICAgICAgJ3BoYXNlJzogMTgwXG5cdCAgICAgICAgfSkuY29ubmVjdCh0aGlzLl9kZWxheUIuZGVsYXlUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBDcm9zc2ZhZGUgcXVpY2tseSBiZXR3ZWVuIHRoZSB0d28gZGVsYXkgbGluZXNcblx0XHRcdCAqICB0byBjb3ZlciB1cCB0aGUganVtcCBpbiB0aGUgc2F3dG9vdGggd2F2ZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Dcm9zc0ZhZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2Nyb3NzRmFkZSA9IG5ldyBUb25lLkNyb3NzRmFkZSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIExGTyB3aGljaCBhbHRlcm5hdGVzIGJldHdlZW4gdGhlIHR3b1xuXHRcdFx0ICogIGRlbGF5IGxpbmVzIHRvIGNvdmVyIHVwIHRoZSBkaXNwYXJpdHkgaW4gdGhlXG5cdFx0XHQgKiAgc2F3dG9vdGggd2F2ZS4gXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY3Jvc3NGYWRlTEZPID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgICAgICdtYXgnOiAxLFxuXHQgICAgICAgICAgICAndHlwZSc6ICd0cmlhbmdsZScsXG5cdCAgICAgICAgICAgICdwaGFzZSc6IDkwXG5cdCAgICAgICAgfSkuY29ubmVjdCh0aGlzLl9jcm9zc0ZhZGUuZmFkZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlbGF5IG5vZGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5EZWxheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tEZWxheSA9IG5ldyBUb25lLkRlbGF5KG9wdGlvbnMuZGVsYXlUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIGRlbGF5IG9uIHRoZSBpbnB1dCBzaWduYWxcblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IHRoaXMuX2ZlZWRiYWNrRGVsYXkuZGVsYXlUaW1lO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCdkZWxheVRpbWUnKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIb2xkIHRoZSBjdXJyZW50IHBpdGNoXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGl0Y2ggPSBvcHRpb25zLnBpdGNoO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEhvbGQgdGhlIGN1cnJlbnQgd2luZG93U2l6ZVxuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3dpbmRvd1NpemUgPSBvcHRpb25zLndpbmRvd1NpemU7XG5cdCAgICAgICAgLy9jb25uZWN0IHRoZSB0d28gZGVsYXkgbGluZXMgdXBcblx0ICAgICAgICB0aGlzLl9kZWxheUEuY29ubmVjdCh0aGlzLl9jcm9zc0ZhZGUuYSk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlCLmNvbm5lY3QodGhpcy5fY3Jvc3NGYWRlLmIpO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgZnJlcXVlbmN5XG5cdCAgICAgICAgdGhpcy5fZnJlcXVlbmN5LmZhbih0aGlzLl9sZm9BLmZyZXF1ZW5jeSwgdGhpcy5fbGZvQi5mcmVxdWVuY3ksIHRoaXMuX2Nyb3NzRmFkZUxGTy5mcmVxdWVuY3kpO1xuXHQgICAgICAgIC8vcm91dGUgdGhlIGlucHV0XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kLmZhbih0aGlzLl9kZWxheUEsIHRoaXMuX2RlbGF5Qik7XG5cdCAgICAgICAgdGhpcy5fY3Jvc3NGYWRlLmNoYWluKHRoaXMuX2ZlZWRiYWNrRGVsYXksIHRoaXMuZWZmZWN0UmV0dXJuKTtcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBMRk9zIGF0IHRoZSBzYW1lIHRpbWVcblx0ICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICB0aGlzLl9sZm9BLnN0YXJ0KG5vdyk7XG5cdCAgICAgICAgdGhpcy5fbGZvQi5zdGFydChub3cpO1xuXHQgICAgICAgIHRoaXMuX2Nyb3NzRmFkZUxGTy5zdGFydChub3cpO1xuXHQgICAgICAgIC8vc2V0IHRoZSBpbml0aWFsIHZhbHVlXG5cdCAgICAgICAgdGhpcy53aW5kb3dTaXplID0gdGhpcy5fd2luZG93U2l6ZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBpdGNoU2hpZnQsIFRvbmUuRmVlZGJhY2tFZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLlBpdGNoU2hpZnQuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3BpdGNoJzogMCxcblx0ICAgICAgICAnd2luZG93U2l6ZSc6IDAuMSxcblx0ICAgICAgICAnZGVsYXlUaW1lJzogMCxcblx0ICAgICAgICAnZmVlZGJhY2snOiAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogUmVwaXRjaCB0aGUgaW5jb21pbmcgc2lnbmFsIGJ5IHNvbWUgaW50ZXJ2YWwgKG1lYXN1cmVkXG5cdFx0ICogaW4gc2VtaS10b25lcykuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBpdGNoU2hpZnQjXG5cdFx0ICogQHR5cGUge0ludGVydmFsfVxuXHRcdCAqIEBuYW1lIHBpdGNoXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBwaXRjaFNoaWZ0LnBpdGNoID0gLTEyOyAvL2Rvd24gb25lIG9jdGF2ZVxuXHRcdCAqIHBpdGNoU2hpZnQucGl0Y2ggPSA3OyAvL3VwIGEgZmlmdGhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBpdGNoU2hpZnQucHJvdG90eXBlLCAncGl0Y2gnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9waXRjaDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGludGVydmFsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BpdGNoID0gaW50ZXJ2YWw7XG5cdCAgICAgICAgICAgIHZhciBmYWN0b3IgPSAwO1xuXHQgICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm9BLm1pbiA9IDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm9BLm1heCA9IHRoaXMuX3dpbmRvd1NpemU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm9CLm1pbiA9IDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm9CLm1heCA9IHRoaXMuX3dpbmRvd1NpemU7XG5cdCAgICAgICAgICAgICAgICBmYWN0b3IgPSBUb25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbyhpbnRlcnZhbCAtIDEpICsgMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xmb0EubWluID0gdGhpcy5fd2luZG93U2l6ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xmb0EubWF4ID0gMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xmb0IubWluID0gdGhpcy5fd2luZG93U2l6ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xmb0IubWF4ID0gMDtcblx0ICAgICAgICAgICAgICAgIGZhY3RvciA9IFRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKGludGVydmFsKSAtIDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fZnJlcXVlbmN5LnZhbHVlID0gZmFjdG9yICogKDEuMiAvIHRoaXMuX3dpbmRvd1NpemUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHdpbmRvdyBzaXplIGNvcnJlc3BvbmRzIHJvdWdobHkgdG8gdGhlIHNhbXBsZSBsZW5ndGggaW4gYSBsb29waW5nIHNhbXBsZXIuIFxuXHRcdCAqIFNtYWxsZXIgdmFsdWVzIGFyZSBkZXNpcmFibGUgZm9yIGEgbGVzcyBub3RpY2VhYmxlIGRlbGF5IHRpbWUgb2YgdGhlIHBpdGNoIHNoaWZ0ZWRcblx0XHQgKiBzaWduYWwsIGJ1dCBsYXJnZXIgdmFsdWVzIHdpbGwgcmVzdWx0IGluIHNtb290aGVyIHBpdGNoIHNoaWZ0aW5nIGZvciBsYXJnZXIgaW50ZXJ2YWxzLiBcblx0XHQgKiBBIG5vbWluYWwgcmFuZ2Ugb2YgMC4wMyB0byAwLjEgaXMgcmVjb21tZW5kZWQuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBpdGNoU2hpZnQjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgd2luZG93U2l6ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogcGl0Y2hTaGlmdC53aW5kb3dTaXplID0gMC4xO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGl0Y2hTaGlmdC5wcm90b3R5cGUsICd3aW5kb3dTaXplJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2luZG93U2l6ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNpemUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fd2luZG93U2l6ZSA9IHRoaXMudG9TZWNvbmRzKHNpemUpO1xuXHQgICAgICAgICAgICB0aGlzLnBpdGNoID0gdGhpcy5fcGl0Y2g7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlBpdGNoU2hpZnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBpdGNoU2hpZnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5GZWVkYmFja0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2ZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9kZWxheUEuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5QSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlCLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheUIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xmb0EuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xmb0EgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xmb0IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xmb0IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2Nyb3NzRmFkZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fY3Jvc3NGYWRlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9jcm9zc0ZhZGVMRk8uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2Nyb3NzRmFkZUxGTyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ2RlbGF5VGltZScpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrRGVsYXkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrRGVsYXkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QaXRjaFNoaWZ0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQmFzZSBjbGFzcyBmb3Igc3RlcmVvIGZlZWRiYWNrIGVmZmVjdHMgd2hlcmUgdGhlIGVmZmVjdFJldHVyblxuXHRcdCAqICAgICAgICAgaXMgZmVkIGJhY2sgaW50byB0aGUgc2FtZSBjaGFubmVsLiBcblx0XHQgKlxuXHRcdCAqXHRAY29uc3RydWN0b3Jcblx0XHQgKlx0QGV4dGVuZHMge1RvbmUuU3RlcmVvRWZmZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGVyZW9GZWVkYmFja0VmZmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ2ZlZWRiYWNrJ10sIFRvbmUuRmVlZGJhY2tFZmZlY3QpO1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgY29udHJvbHMgdGhlIGFtb3VudCBvZiBmZWVkYmFja1xuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZlZWRiYWNrID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZmVlZGJhY2ssIFRvbmUuVHlwZS5Ob3JtYWxSYW5nZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxlZnQgc2lkZSBmZWViYWNrXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tMID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSByaWdodCBzaWRlIGZlZWJhY2tcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFja1IgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLy9jb25uZWN0IGl0IHVwXG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm5MLmNoYWluKHRoaXMuX2ZlZWRiYWNrTCwgdGhpcy5lZmZlY3RTZW5kTCk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm5SLmNoYWluKHRoaXMuX2ZlZWRiYWNrUiwgdGhpcy5lZmZlY3RTZW5kUik7XG5cdCAgICAgICAgdGhpcy5mZWVkYmFjay5mYW4odGhpcy5fZmVlZGJhY2tMLmdhaW4sIHRoaXMuX2ZlZWRiYWNrUi5nYWluKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ2ZlZWRiYWNrJ10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU3RlcmVvRmVlZGJhY2tFZmZlY3QsIFRvbmUuU3RlcmVvRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TdGVyZW9GZWVkYmFja0VmZmVjdH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGVyZW9GZWVkYmFja0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsnZmVlZGJhY2snXSk7XG5cdCAgICAgICAgdGhpcy5mZWVkYmFjay5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mZWVkYmFjayA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tMLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0wgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrUi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tSID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TdGVyZW9GZWVkYmFja0VmZmVjdDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEFwcGxpZXMgYSB3aWR0aCBmYWN0b3IgdG8gdGhlIG1pZC9zaWRlIHNlcGVyYXRpb24uIFxuXHRcdCAqICAgICAgICAgMCBpcyBhbGwgbWlkIGFuZCAxIGlzIGFsbCBzaWRlLlxuXHRcdCAqICAgICAgICAgQWxnb3JpdGhtIGZvdW5kIGluIFtrdnJhdWRpbyBmb3J1bXNdKGh0dHA6Ly93d3cua3ZyYXVkaW8uY29tL2ZvcnVtL3ZpZXd0b3BpYy5waHA/dD0yMTI1ODcpLlxuXHRcdCAqICAgICAgICAgPGJyPjxicj5cblx0XHQgKiAgICAgICAgIDxjb2RlPlxuXHRcdCAqICAgICAgICAgTWlkICo9IDIqKDEtd2lkdGgpPGJyPlxuXHRcdCAqICAgICAgICAgU2lkZSAqPSAyKndpZHRoXG5cdFx0ICogICAgICAgICA8L2NvZGU+XG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuTWlkU2lkZUVmZmVjdH1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V8T2JqZWN0fSBbd2lkdGhdIFRoZSBzdGVyZW8gd2lkdGguIEEgd2lkdGggb2YgMCBpcyBtb25vIGFuZCAxIGlzIHN0ZXJlby4gMC41IGlzIG5vIGNoYW5nZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuU3RlcmVvV2lkZW5lciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ3dpZHRoJ10sIFRvbmUuU3RlcmVvV2lkZW5lcik7XG5cdCAgICAgICAgVG9uZS5NaWRTaWRlRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHdpZHRoIGNvbnRyb2wuIDAgPSAxMDAlIG1pZC4gMSA9IDEwMCUgc2lkZS4gMC41ID0gbm8gY2hhbmdlLiBcblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy53aWR0aCA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLndpZHRoLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIE1pZCBtdWx0aXBsaWVyXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRXhwcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWlkTXVsdCA9IG5ldyBUb25lLkV4cHIoJyQwICogKCQxICogKDEgLSAkMikpJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU2lkZSBtdWx0aXBsaWVyXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRXhwcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2lkZU11bHQgPSBuZXcgVG9uZS5FeHByKCckMCAqICgkMSAqICQyKScpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGNvbnN0YW50IG91dHB1dCBvZiAyXG5cdFx0XHQgKiAgQHR5cGUge1RvbmV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3R3byA9IG5ldyBUb25lLlNpZ25hbCgyKTtcblx0ICAgICAgICAvL3RoZSBtaWQgY2hhaW5cblx0ICAgICAgICB0aGlzLl90d28uY29ubmVjdCh0aGlzLl9taWRNdWx0LCAwLCAxKTtcblx0ICAgICAgICB0aGlzLndpZHRoLmNvbm5lY3QodGhpcy5fbWlkTXVsdCwgMCwgMik7XG5cdCAgICAgICAgLy90aGUgc2lkZSBjaGFpblxuXHQgICAgICAgIHRoaXMuX3R3by5jb25uZWN0KHRoaXMuX3NpZGVNdWx0LCAwLCAxKTtcblx0ICAgICAgICB0aGlzLndpZHRoLmNvbm5lY3QodGhpcy5fc2lkZU11bHQsIDAsIDIpO1xuXHQgICAgICAgIC8vY29ubmVjdCBpdCB0byB0aGUgZWZmZWN0IHNlbmQvcmV0dXJuXG5cdCAgICAgICAgdGhpcy5taWRTZW5kLmNoYWluKHRoaXMuX21pZE11bHQsIHRoaXMubWlkUmV0dXJuKTtcblx0ICAgICAgICB0aGlzLnNpZGVTZW5kLmNoYWluKHRoaXMuX3NpZGVNdWx0LCB0aGlzLnNpZGVSZXR1cm4pO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsnd2lkdGgnXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TdGVyZW9XaWRlbmVyLCBUb25lLk1pZFNpZGVFZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlN0ZXJlb1dpZGVuZXIuZGVmYXVsdHMgPSB7ICd3aWR0aCc6IDAuNSB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU3RlcmVvV2lkZW5lcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGVyZW9XaWRlbmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuTWlkU2lkZUVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsnd2lkdGgnXSk7XG5cdCAgICAgICAgdGhpcy53aWR0aC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy53aWR0aCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbWlkTXVsdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbWlkTXVsdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc2lkZU11bHQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NpZGVNdWx0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl90d28uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3R3byA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU3RlcmVvV2lkZW5lcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuVHJlbW9sbyBtb2R1bGF0ZXMgdGhlIGFtcGxpdHVkZSBvZiBhbiBpbmNvbWluZyBzaWduYWwgdXNpbmcgYSBUb25lLkxGTy5cblx0XHQgKiAgICAgICAgIFRoZSB0eXBlLCBmcmVxdWVuY3ksIGFuZCBkZXB0aCBvZiB0aGUgTEZPIGlzIGNvbnRyb2xsYWJsZS5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TdGVyZW9FZmZlY3R9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gW2ZyZXF1ZW5jeV0gVGhlIHJhdGUgb2YgdGhlIGVmZmVjdC5cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW2RlcHRoXSBUaGUgZGVwdGggb2YgdGhlIGVmZmVjdC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2NyZWF0ZSBhIHRyZW1vbG8gYW5kIHN0YXJ0IGl0J3MgTEZPXG5cdFx0ICogdmFyIHRyZW1vbG8gPSBuZXcgVG9uZS5UcmVtb2xvKDksIDAuNzUpLnRvTWFzdGVyKCkuc3RhcnQoKTtcblx0XHQgKiAvL3JvdXRlIGFuIG9zY2lsbGF0b3IgdGhyb3VnaCB0aGUgdHJlbW9sbyBhbmQgc3RhcnQgaXRcblx0XHQgKiB2YXIgb3NjaWxsYXRvciA9IG5ldyBUb25lLk9zY2lsbGF0b3IoKS5jb25uZWN0KHRyZW1vbG8pLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLlRyZW1vbG8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RlcHRoJ1xuXHQgICAgICAgIF0sIFRvbmUuVHJlbW9sbyk7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdHJlbWVsbyBMRk8gaW4gdGhlIGxlZnQgY2hhbm5lbFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmb0wgPSBuZXcgVG9uZS5MRk8oe1xuXHQgICAgICAgICAgICAncGhhc2UnOiBvcHRpb25zLnNwcmVhZCxcblx0ICAgICAgICAgICAgJ21pbic6IDEsXG5cdCAgICAgICAgICAgICdtYXgnOiAwXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHRyZW1lbG8gTEZPIGluIHRoZSBsZWZ0IGNoYW5uZWxcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9SID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ3BoYXNlJzogb3B0aW9ucy5zcHJlYWQsXG5cdCAgICAgICAgICAgICdtaW4nOiAxLFxuXHQgICAgICAgICAgICAnbWF4JzogMFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFdoZXJlIHRoZSBnYWluIGlzIG11bHRpcGxpZWRcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYW1wbGl0dWRlTCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBXaGVyZSB0aGUgZ2FpbiBpcyBtdWx0aXBsaWVkXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FtcGxpdHVkZVIgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZyZXF1ZW5jeSBvZiB0aGUgdHJlbW9sby5cblx0XHRcdCAqICBAdHlwZSAge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlcHRoIG9mIHRoZSBlZmZlY3QuIEEgZGVwdGggb2YgMCwgaGFzIG5vIGVmZmVjdFxuXHRcdFx0ICogIG9uIHRoZSBhbXBsaXR1ZGUsIGFuZCBhIGRlcHRoIG9mIDEgbWFrZXMgdGhlIGFtcGxpdHVkZVxuXHRcdFx0ICogIG1vZHVsYXRlIGZ1bGx5IGJldHdlZW4gMCBhbmQgMS5cblx0XHRcdCAqICBAdHlwZSAge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXB0aCwgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVwdGgnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kTC5jaGFpbih0aGlzLl9hbXBsaXR1ZGVMLCB0aGlzLmVmZmVjdFJldHVybkwpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZFIuY2hhaW4odGhpcy5fYW1wbGl0dWRlUiwgdGhpcy5lZmZlY3RSZXR1cm5SKTtcblx0ICAgICAgICB0aGlzLl9sZm9MLmNvbm5lY3QodGhpcy5fYW1wbGl0dWRlTC5nYWluKTtcblx0ICAgICAgICB0aGlzLl9sZm9SLmNvbm5lY3QodGhpcy5fYW1wbGl0dWRlUi5nYWluKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5mYW4odGhpcy5fbGZvTC5mcmVxdWVuY3ksIHRoaXMuX2xmb1IuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmRlcHRoLmZhbih0aGlzLl9sZm9SLmFtcGxpdHVkZSwgdGhpcy5fbGZvTC5hbXBsaXR1ZGUpO1xuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICB0aGlzLnNwcmVhZCA9IG9wdGlvbnMuc3ByZWFkO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVHJlbW9sbywgVG9uZS5TdGVyZW9FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlRyZW1vbG8uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDEwLFxuXHQgICAgICAgICd0eXBlJzogJ3NpbmUnLFxuXHQgICAgICAgICdkZXB0aCc6IDAuNSxcblx0ICAgICAgICAnc3ByZWFkJzogMTgwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3RhcnQgdGhlIHRyZW1vbG8uXG5cdFx0ICogQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIHRyZW1vbG8gYmVnaW5zLlxuXHRcdCAqIEByZXR1cm5zIHtUb25lLlRyZW1vbG99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJlbW9sby5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2xmb0wuc3RhcnQodGltZSk7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5zdGFydCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTdG9wIHRoZSB0cmVtb2xvLlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSB0cmVtb2xvIHN0b3BzLlxuXHRcdCAqIEByZXR1cm5zIHtUb25lLlRyZW1vbG99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJlbW9sby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fbGZvTC5zdG9wKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2xmb1Iuc3RvcCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTeW5jIHRoZSBlZmZlY3QgdG8gdGhlIHRyYW5zcG9ydC5cblx0XHQgKiBAcGFyYW0ge1RpbWV9IFtkZWxheT0wXSBEZWxheSB0aW1lIGJlZm9yZSBzdGFydGluZyB0aGUgZWZmZWN0IGFmdGVyIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNwb3J0IGhhcyBzdGFydGVkLlxuXHRcdCAqIEByZXR1cm5zIHtUb25lLkF1dG9GaWx0ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJlbW9sby5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIChkZWxheSkge1xuXHQgICAgICAgIHRoaXMuX2xmb0wuc3luYyhkZWxheSk7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5zeW5jKGRlbGF5KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBVbnN5bmMgdGhlIGZpbHRlciBmcm9tIHRoZSB0cmFuc3BvcnRcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5UcmVtb2xvfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyZW1vbG8ucHJvdG90eXBlLnVuc3luYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9sZm9MLnVuc3luYygpO1xuXHQgICAgICAgIHRoaXMuX2xmb1IudW5zeW5jKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIFRyZW1vbG8ncyBvc2NpbGxhdG9yIHR5cGUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuVHJlbW9sbyNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyZW1vbG8ucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xmb0wudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC50eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKiBcblx0XHQgKiBBbW91bnQgb2Ygc3RlcmVvIHNwcmVhZC4gV2hlbiBzZXQgdG8gMCwgYm90aCBMRk8ncyB3aWxsIGJlIHBhbm5lZCBjZW50cmFsbHkuXG5cdFx0ICogV2hlbiBzZXQgdG8gMTgwLCBMRk8ncyB3aWxsIGJlIHBhbm5lZCBoYXJkIGxlZnQgYW5kIHJpZ2h0IHJlc3BlY3RpdmVseS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5UcmVtb2xvI1xuXHRcdCAqIEB0eXBlIHtEZWdyZWVzfVxuXHRcdCAqIEBuYW1lIHNwcmVhZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJlbW9sby5wcm90b3R5cGUsICdzcHJlYWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZm9SLnBoYXNlIC0gdGhpcy5fbGZvTC5waGFzZTsgICAgLy8xODBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNwcmVhZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9MLnBoYXNlID0gOTAgLSBzcHJlYWQgLyAyO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9SLnBoYXNlID0gc3ByZWFkIC8gMiArIDkwO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyZW1vbG99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJlbW9sby5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXB0aCdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLl9sZm9MLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9MID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZm9SLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9SID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZGVMLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZGVMID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZGVSLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZGVSID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVHJlbW9sbztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEEgVmlicmF0byBlZmZlY3QgY29tcG9zZWQgb2YgYSBUb25lLkRlbGF5IGFuZCBhIFRvbmUuTEZPLiBUaGUgTEZPXG5cdFx0ICogICAgICAgICBtb2R1bGF0ZXMgdGhlIGRlbGF5VGltZSBvZiB0aGUgZGVsYXksIGNhdXNpbmcgdGhlIHBpdGNoIHRvIHJpc2Vcblx0XHQgKiAgICAgICAgIGFuZCBmYWxsLiBcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcXVlbmN5IFRoZSBmcmVxdWVuY3kgb2YgdGhlIHZpYnJhdG8uXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IGRlcHRoIFRoZSBhbW91bnQgdGhlIHBpdGNoIGlzIG1vZHVsYXRlZC5cblx0XHQgKi9cblx0ICAgIFRvbmUuVmlicmF0byA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVwdGgnXG5cdCAgICAgICAgXSwgVG9uZS5WaWJyYXRvKTtcblx0ICAgICAgICBUb25lLkVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZWxheSBub2RlIHVzZWQgZm9yIHRoZSB2aWJyYXRvIGVmZmVjdFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkRlbGF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGUgPSBuZXcgVG9uZS5EZWxheSgwLCBvcHRpb25zLm1heERlbGF5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgTEZPIHVzZWQgdG8gY29udHJvbCB0aGUgdmlicmF0b1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiBvcHRpb25zLnR5cGUsXG5cdCAgICAgICAgICAgICdtaW4nOiAwLFxuXHQgICAgICAgICAgICAnbWF4Jzogb3B0aW9ucy5tYXhEZWxheSxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSc6IG9wdGlvbnMuZnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAncGhhc2UnOiAtOTAgICAgLy9vZmZzZSB0aGUgcGhhc2Ugc28gdGhlIHJlc3RpbmcgcG9zaXRpb24gaXMgaW4gdGhlIGNlbnRlclxuXHQgICAgICAgIH0pLnN0YXJ0KCkuY29ubmVjdCh0aGlzLl9kZWxheU5vZGUuZGVsYXlUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IG9mIHRoZSB2aWJyYXRvXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMuX2xmby5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlcHRoIG9mIHRoZSB2aWJyYXRvLiBcblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMuX2xmby5hbXBsaXR1ZGU7XG5cdCAgICAgICAgdGhpcy5kZXB0aC52YWx1ZSA9IG9wdGlvbnMuZGVwdGg7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RlcHRoJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZC5jaGFpbih0aGlzLl9kZWxheU5vZGUsIHRoaXMuZWZmZWN0UmV0dXJuKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlZpYnJhdG8sIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5WaWJyYXRvLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdtYXhEZWxheSc6IDAuMDA1LFxuXHQgICAgICAgICdmcmVxdWVuY3knOiA1LFxuXHQgICAgICAgICdkZXB0aCc6IDAuMSxcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJ1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFR5cGUgb2Ygb3NjaWxsYXRvciBhdHRhY2hlZCB0byB0aGUgVmlicmF0by5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5WaWJyYXRvI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVmlicmF0by5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGZvLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmby50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVmlicmF0b30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5WaWJyYXRvLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xmby5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVwdGgnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlZpYnJhdG87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5FdmVudCBhYnN0cmFjdHMgYXdheSBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZSBhbmQgcHJvdmlkZXMgYSBzY2hlZHVsYWJsZVxuXHRcdCAqICAgICAgICAgIGNhbGxiYWNrIGZvciBhIHNpbmdsZSBvciByZXBlYXRhYmxlIGV2ZW50cyBhbG9uZyB0aGUgdGltZWxpbmUuIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGF0IHRoZSB0aW1lLiBcblx0XHQgKiAgQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb3IgdmFsdWVzIHdoaWNoIHNob3VsZCBiZSBwYXNzZWQgdG9cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gb24gaW52b2NhdGlvbi4gIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBjaG9yZCA9IG5ldyBUb25lLkV2ZW50KGZ1bmN0aW9uKHRpbWUsIGNob3JkKXtcblx0XHQgKiBcdC8vdGhlIGNob3JkIGFzIHdlbGwgYXMgdGhlIGV4YWN0IHRpbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogXHQvL2FyZSBwYXNzZWQgaW4gYXMgYXJndW1lbnRzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuXHRcdCAqIH0sIFtcIkQ0XCIsIFwiRTRcIiwgXCJGNFwiXSk7XG5cdFx0ICogLy9zdGFydCB0aGUgY2hvcmQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHJhbnNwb3J0IHRpbWVsaW5lXG5cdFx0ICogY2hvcmQuc3RhcnQoKTtcblx0XHQgKiAvL2xvb3AgaXQgZXZlcnkgbWVhc3VyZSBmb3IgOCBtZWFzdXJlc1xuXHRcdCAqIGNob3JkLmxvb3AgPSA4O1xuXHRcdCAqIGNob3JkLmxvb3BFbmQgPSBcIjFtXCI7XG5cdFx0ICovXG5cdCAgICBUb25lLkV2ZW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJyxcblx0ICAgICAgICAgICAgJ3ZhbHVlJ1xuXHQgICAgICAgIF0sIFRvbmUuRXZlbnQpO1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBMb29wIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUgIHtCb29sZWFufFBvc2l0aXZlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wID0gb3B0aW9ucy5sb29wO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYWxsYmFjayB0byBpbnZva2UuIFxuXHRcdFx0ICogIEB0eXBlICB7RnVuY3Rpb259XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdmFsdWUgd2hpY2ggaXMgcGFzc2VkIHRvIHRoZVxuXHRcdFx0ICogIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHRcdFx0ICogIEB0eXBlICB7Kn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgV2hlbiB0aGUgbm90ZSBpcyBzY2hlZHVsZWQgdG8gc3RhcnQuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3BTdGFydCA9IHRoaXMudG9UaWNrcyhvcHRpb25zLmxvb3BTdGFydCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgV2hlbiB0aGUgbm90ZSBpcyBzY2hlZHVsZWQgdG8gc3RhcnQuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3BFbmQgPSB0aGlzLnRvVGlja3Mob3B0aW9ucy5sb29wRW5kKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUcmFja3MgdGhlIHNjaGVkdWxlZCBldmVudHNcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5UaW1lbGluZVN0YXRlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBUb25lLlRpbWVsaW5lU3RhdGUoVG9uZS5TdGF0ZS5TdG9wcGVkKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG5vdGUuIEEgc3BlZWQgb2YgMVxuXHRcdFx0ICogIGlzIG5vIGNoYW5nZS4gXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSAxO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgZGVsYXkgdGltZSBmcm9tIHdoZW4gdGhlIGV2ZW50IGlzIHNjaGVkdWxlZCB0byBzdGFydFxuXHRcdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3RhcnRPZmZzZXQgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHByaXZhdGUgaG9sZGVyIG9mIHByb2JhYmlsaXR5IHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wcm9iYWJpbGl0eSA9IG9wdGlvbnMucHJvYmFiaWxpdHk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGFtb3VudCBvZiB2YXJpYXRpb24gZnJvbSB0aGVcblx0XHRcdCAqICBnaXZlbiB0aW1lLiBcblx0XHRcdCAqICBAdHlwZSB7Qm9vbGVhbnxUaW1lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9odW1hbml6ZSA9IG9wdGlvbnMuaHVtYW5pemU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSWYgbXV0ZSBpcyB0cnVlLCB0aGUgY2FsbGJhY2sgd29uJ3QgYmVcblx0XHRcdCAqICBpbnZva2VkLlxuXHRcdFx0ICogIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tdXRlID0gb3B0aW9ucy5tdXRlO1xuXHQgICAgICAgIC8vc2V0IHRoZSBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgIHRoaXMucGxheWJhY2tSYXRlID0gb3B0aW9ucy5wbGF5YmFja1JhdGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5FdmVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2NhbGxiYWNrJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdsb29wJzogZmFsc2UsXG5cdCAgICAgICAgJ2xvb3BFbmQnOiAnMW0nLFxuXHQgICAgICAgICdsb29wU3RhcnQnOiAwLFxuXHQgICAgICAgICdwbGF5YmFja1JhdGUnOiAxLFxuXHQgICAgICAgICd2YWx1ZSc6IG51bGwsXG5cdCAgICAgICAgJ3Byb2JhYmlsaXR5JzogMSxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlLFxuXHQgICAgICAgICdodW1hbml6ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlc2NoZWR1bGUgYWxsIG9mIHRoZSBldmVudHMgYWxvbmcgdGhlIHRpbWVsaW5lXG5cdFx0ICogIHdpdGggdGhlIHVwZGF0ZWQgdmFsdWVzLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGFmdGVyIE9ubHkgcmVzY2hlZHVsZXMgZXZlbnRzIGFmdGVyIHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FdmVudH0gIHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQucHJvdG90eXBlLl9yZXNjaGVkdWxlRXZlbnRzID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgLy9pZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgc2NoZWR1bGVzIGFsbCBvZiB0aGUgZXZlbnRzXG5cdCAgICAgICAgYWZ0ZXIgPSBUb25lLmRlZmF1bHRBcmcoYWZ0ZXIsIC0xKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5mb3JFYWNoRnJvbShhZnRlciwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIHZhciBkdXJhdGlvbjtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKGV2ZW50LmlkKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIFRvbmUuVHJhbnNwb3J0LmNsZWFyKGV2ZW50LmlkKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBzdGFydFRpY2sgPSBldmVudC50aW1lICsgTWF0aC5yb3VuZCh0aGlzLnN0YXJ0T2Zmc2V0IC8gdGhpcy5fcGxheWJhY2tSYXRlKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBJbmZpbml0eTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc051bWJlcih0aGlzLl9sb29wKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuX2xvb3AgKiB0aGlzLl9nZXRMb29wRHVyYXRpb24oKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRFdmVudCA9IHRoaXMuX3N0YXRlLmdldEFmdGVyKHN0YXJ0VGljayk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRFdmVudCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWluKGR1cmF0aW9uLCBuZXh0RXZlbnQudGltZSAtIHN0YXJ0VGljayk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiAhPT0gSW5maW5pdHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9zY2hlZHVsZSBhIHN0b3Agc2luY2UgaXQncyBmaW5pdGUgZHVyYXRpb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdG9wcGVkLCBzdGFydFRpY2sgKyBkdXJhdGlvbiArIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IFRvbmUuVGltZShkdXJhdGlvbiwgJ2knKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gVG9uZS5UaW1lKHRoaXMuX2dldExvb3BEdXJhdGlvbigpLCAnaScpO1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50LmlkID0gVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGVSZXBlYXQodGhpcy5fdGljay5iaW5kKHRoaXMpLCBpbnRlcnZhbCwgVG9uZS5UcmFuc3BvcnRUaW1lKHN0YXJ0VGljaywgJ2knKSwgZHVyYXRpb24pO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudC5pZCA9IFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKHRoaXMuX3RpY2suYmluZCh0aGlzKSwgc3RhcnRUaWNrICsgJ2knKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBub3RlLCBlaXRoZXIgXCJzdGFydGVkXCIgb3IgXCJzdG9wcGVkXCIuXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5FdmVudCNcblx0XHQgKiAgQG5hbWUgc3RhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUoVG9uZS5UcmFuc3BvcnQudGlja3MpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzdGFydCBmcm9tIHRoZSBzY2hlZHVsZWQgc3RhcnQgdGltZVxuXHRcdCAqICBAdHlwZSB7VGlja3N9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkV2ZW50I1xuXHRcdCAqICBAbmFtZSBzdGFydE9mZnNldFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRXZlbnQucHJvdG90eXBlLCAnc3RhcnRPZmZzZXQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydE9mZnNldDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdGFydE9mZnNldCA9IG9mZnNldDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgcHJvYmFiaWxpdHkgb2YgdGhlIG5vdGVzIGJlaW5nIHRyaWdnZXJlZC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuRXZlbnQjXG5cdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiAgQG5hbWUgcHJvYmFiaWxpdHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ3Byb2JhYmlsaXR5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvYmFiaWxpdHk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwcm9iKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2JhYmlsaXR5ID0gcHJvYjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBJZiBzZXQgdG8gdHJ1ZSwgd2lsbCBhcHBseSBzbWFsbCByYW5kb20gdmFyaWF0aW9uXG5cdFx0ICogIHRvIHRoZSBjYWxsYmFjayB0aW1lLiBJZiB0aGUgdmFsdWUgaXMgZ2l2ZW4gYXMgYSB0aW1lLCBpdCB3aWxsIHJhbmRvbWl6ZVxuXHRcdCAqICBieSB0aGF0IGFtb3VudC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBldmVudC5odW1hbml6ZSA9IHRydWU7XG5cdFx0ICogIEB0eXBlIHtCb29sZWFufFRpbWV9XG5cdFx0ICogIEBuYW1lIGh1bWFuaXplXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5FdmVudC5wcm90b3R5cGUsICdodW1hbml6ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2h1bWFuaXplO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFyaWF0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2h1bWFuaXplID0gdmFyaWF0aW9uO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IHRoZSBub3RlIGF0IHRoZSBnaXZlbiB0aW1lLiBcblx0XHQgKiAgQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbn0gIHRpbWUgIFdoZW4gdGhlIG5vdGUgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FdmVudH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1RpY2tzKHRpbWUpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKSA9PT0gVG9uZS5TdGF0ZS5TdG9wcGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlLmFkZCh7XG5cdCAgICAgICAgICAgICAgICAnc3RhdGUnOiBUb25lLlN0YXRlLlN0YXJ0ZWQsXG5cdCAgICAgICAgICAgICAgICAndGltZSc6IHRpbWUsXG5cdCAgICAgICAgICAgICAgICAnaWQnOiB1bmRlZmluZWRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Jlc2NoZWR1bGVFdmVudHModGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBFdmVudCBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbn0gIHRpbWUgIFdoZW4gdGhlIG5vdGUgc2hvdWxkIHN0b3AuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkV2ZW50fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FdmVudC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5jYW5jZWwodGltZSk7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSkgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0b3BwZWQsIHRpbWUpO1xuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNFdmVudCA9IHRoaXMuX3N0YXRlLmdldEJlZm9yZSh0aW1lKTtcblx0ICAgICAgICAgICAgdmFyIHJlc2NoZWR1bFRpbWUgPSB0aW1lO1xuXHQgICAgICAgICAgICBpZiAocHJldmlvdXNFdmVudCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmVzY2hlZHVsVGltZSA9IHByZXZpb3VzRXZlbnQudGltZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9yZXNjaGVkdWxlRXZlbnRzKHJlc2NoZWR1bFRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VsIGFsbCBzY2hlZHVsZWQgZXZlbnRzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lbGluZVBvc2l0aW9ufSAgW3RpbWU9MF0gIFRoZSB0aW1lIGFmdGVyIHdoaWNoIGV2ZW50cyB3aWxsIGJlIGNhbmNlbC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuRXZlbnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkV2ZW50LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSBUb25lLmRlZmF1bHRBcmcodGltZSwgLUluZmluaXR5KTtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1RpY2tzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmZvckVhY2hGcm9tKHRpbWUsIGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBUb25lLlRyYW5zcG9ydC5jbGVhcihldmVudC5pZCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuY2FuY2VsKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlci4gQWxzbyBcblx0XHQgKiAgY2hlY2tzIGlmIHRoZSBFdmVudCBpcyBkb25lIHBsYXlpbmdcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgb2YgdGhlIGV2ZW50IGluIHNlY29uZHNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAoIXRoaXMubXV0ZSAmJiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZShUb25lLlRyYW5zcG9ydC50aWNrcykgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5wcm9iYWJpbGl0eSA8IDEgJiYgTWF0aC5yYW5kb20oKSA+IHRoaXMucHJvYmFiaWxpdHkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodGhpcy5odW1hbml6ZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhcmlhdGlvbiA9IDAuMDI7XG5cdCAgICAgICAgICAgICAgICBpZiAoIVRvbmUuaXNCb29sZWFuKHRoaXMuaHVtYW5pemUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyaWF0aW9uID0gdGhpcy50b1NlY29uZHModGhpcy5odW1hbml6ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aW1lICs9IChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogdmFyaWF0aW9uO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGltZSwgdGhpcy52YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBsb29wLlxuXHRcdCAqICBAcmV0dXJuICB7VGlja3N9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV2ZW50LnByb3RvdHlwZS5fZ2V0TG9vcER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCh0aGlzLl9sb29wRW5kIC0gdGhpcy5fbG9vcFN0YXJ0KSAvIHRoaXMuX3BsYXliYWNrUmF0ZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIElmIHRoZSBub3RlIHNob3VsZCBsb29wIG9yIG5vdFxuXHRcdCAqICBiZXR3ZWVuIFRvbmUuRXZlbnQubG9vcFN0YXJ0IGFuZCBcblx0XHQgKiAgVG9uZS5FdmVudC5sb29wRW5kLiBBbiBpbnRlZ2VyXG5cdFx0ICogIHZhbHVlIGNvcnJlc3BvbmRzIHRvIHRoZSBudW1iZXIgb2Zcblx0XHQgKiAgbG9vcHMgdGhlIEV2ZW50IGRvZXMgYWZ0ZXIgaXQgc3RhcnRzLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5FdmVudCNcblx0XHQgKiAgQHR5cGUge0Jvb2xlYW58UG9zaXRpdmV9XG5cdFx0ICogIEBuYW1lIGxvb3Bcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ2xvb3AnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29wO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wID0gbG9vcDtcblx0ICAgICAgICAgICAgdGhpcy5fcmVzY2hlZHVsZUV2ZW50cygpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogXHRUaGUgcGxheWJhY2sgcmF0ZSBvZiB0aGUgbm90ZS4gRGVmYXVsdHMgdG8gMS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuRXZlbnQjXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgcGxheWJhY2tSYXRlXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogbm90ZS5sb29wID0gdHJ1ZTtcblx0XHQgKiAvL3JlcGVhdCB0aGUgbm90ZSB0d2ljZSBhcyBmYXN0XG5cdFx0ICogbm90ZS5wbGF5YmFja1JhdGUgPSAyO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRXZlbnQucHJvdG90eXBlLCAncGxheWJhY2tSYXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSByYXRlO1xuXHQgICAgICAgICAgICB0aGlzLl9yZXNjaGVkdWxlRXZlbnRzKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGxvb3BFbmQgcG9pbnQgaXMgdGhlIHRpbWUgdGhlIGV2ZW50IHdpbGwgbG9vcFxuXHRcdCAqICBpZiBUb25lLkV2ZW50Lmxvb3AgaXMgdHJ1ZS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuRXZlbnQjXG5cdFx0ICogIEB0eXBlIHtUcmFuc3BvcnRUaW1lfVxuXHRcdCAqICBAbmFtZSBsb29wRW5kXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5FdmVudC5wcm90b3R5cGUsICdsb29wRW5kJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX2xvb3BFbmQsICdpJykudG9Ob3RhdGlvbigpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcEVuZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gdGhpcy50b1RpY2tzKGxvb3BFbmQpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVzY2hlZHVsZUV2ZW50cygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHRpbWUgd2hlbiB0aGUgbG9vcCBzaG91bGQgc3RhcnQuIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5FdmVudCNcblx0XHQgKiAgQHR5cGUge1RyYW5zcG9ydFRpbWV9XG5cdFx0ICogIEBuYW1lIGxvb3BTdGFydFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRXZlbnQucHJvdG90eXBlLCAnbG9vcFN0YXJ0Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX2xvb3BTdGFydCwgJ2knKS50b05vdGF0aW9uKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wU3RhcnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcFN0YXJ0ID0gdGhpcy50b1RpY2tzKGxvb3BTdGFydCk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yZXNjaGVkdWxlRXZlbnRzKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgbG9vcCBpbnRlcnZhbC5cblx0XHQgKiAgUmV0dXJucyAwIGlmIHRoZSBldmVudCBpcyBub3Qgc3RhcnRlZCB5ZXQgb3Jcblx0XHQgKiAgaXQgaXMgbm90IHNldCB0byBsb29wLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5FdmVudCNcblx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqICBAbmFtZSBwcm9ncmVzc1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ3Byb2dyZXNzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRpY2tzID0gVG9uZS5UcmFuc3BvcnQudGlja3M7XG5cdCAgICAgICAgICAgICAgICB2YXIgbGFzdEV2ZW50ID0gdGhpcy5fc3RhdGUuZ2V0KHRpY2tzKTtcblx0ICAgICAgICAgICAgICAgIGlmIChsYXN0RXZlbnQgIT09IG51bGwgJiYgbGFzdEV2ZW50LnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbG9vcER1cmF0aW9uID0gdGhpcy5fZ2V0TG9vcER1cmF0aW9uKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gKHRpY2tzIC0gbGFzdEV2ZW50LnRpbWUpICUgbG9vcER1cmF0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9ncmVzcyAvIGxvb3BEdXJhdGlvbjtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkV2ZW50fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FdmVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmNhbmNlbCgpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRXZlbnQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5Mb29wIGNyZWF0ZXMgYSBsb29wZWQgY2FsbGJhY2sgYXQgdGhlIFxuXHRcdCAqICAgICAgICAgc3BlY2lmaWVkIGludGVydmFsLiBUaGUgY2FsbGJhY2sgY2FuIGJlIFxuXHRcdCAqICAgICAgICAgc3RhcnRlZCwgc3RvcHBlZCBhbmQgc2NoZWR1bGVkIGFsb25nXG5cdFx0ICogICAgICAgICB0aGUgVHJhbnNwb3J0J3MgdGltZWxpbmUuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBsb29wID0gbmV3IFRvbmUuTG9vcChmdW5jdGlvbih0aW1lKXtcblx0XHQgKiBcdC8vdHJpZ2dlcmVkIGV2ZXJ5IGVpZ2h0aCBub3RlLiBcblx0XHQgKiBcdGNvbnNvbGUubG9nKHRpbWUpO1xuXHRcdCAqIH0sIFwiOG5cIikuc3RhcnQoMCk7XG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc3RhcnQoKTtcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCB0aGUgZXZlbnQuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gaW50ZXJ2YWwgVGhlIHRpbWUgYmV0d2VlbiBzdWNjZXNzaXZlIGNhbGxiYWNrIGNhbGxzLiBcblx0XHQgKi9cblx0ICAgIFRvbmUuTG9vcCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdjYWxsYmFjaycsXG5cdCAgICAgICAgICAgICdpbnRlcnZhbCdcblx0ICAgICAgICBdLCBUb25lLkxvb3ApO1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZXZlbnQgd2hpY2ggcHJvZHVjZXMgdGhlIGNhbGxiYWNrc1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXZlbnQgPSBuZXcgVG9uZS5FdmVudCh7XG5cdCAgICAgICAgICAgICdjYWxsYmFjayc6IHRoaXMuX3RpY2suYmluZCh0aGlzKSxcblx0ICAgICAgICAgICAgJ2xvb3AnOiB0cnVlLFxuXHQgICAgICAgICAgICAnbG9vcEVuZCc6IG9wdGlvbnMuaW50ZXJ2YWwsXG5cdCAgICAgICAgICAgICdwbGF5YmFja1JhdGUnOiBvcHRpb25zLnBsYXliYWNrUmF0ZSxcblx0ICAgICAgICAgICAgJ3Byb2JhYmlsaXR5Jzogb3B0aW9ucy5wcm9iYWJpbGl0eVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCB0aGUgbmV4dCBldmVudCBpbiB0aGUgcGF0dGVyblxuXHRcdFx0ICogIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuXHQgICAgICAgIC8vc2V0IHRoZSBpdGVyYXRpb25zXG5cdCAgICAgICAgdGhpcy5pdGVyYXRpb25zID0gb3B0aW9ucy5pdGVyYXRpb25zO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTG9vcCk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTG9vcC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnaW50ZXJ2YWwnOiAnNG4nLFxuXHQgICAgICAgICdjYWxsYmFjayc6IFRvbmUubm9PcCxcblx0ICAgICAgICAncGxheWJhY2tSYXRlJzogMSxcblx0ICAgICAgICAnaXRlcmF0aW9ucyc6IEluZmluaXR5LFxuXHQgICAgICAgICdwcm9iYWJpbGl0eSc6IHRydWUsXG5cdCAgICAgICAgJ211dGUnOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgbG9vcCBhdCB0aGUgc3BlY2lmaWVkIHRpbWUgYWxvbmcgdGhlIFRyYW5zcG9ydCdzXG5cdFx0ICogIHRpbWVsaW5lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lbGluZVBvc2l0aW9uPX0gIHRpbWUgIFdoZW4gdG8gc3RhcnQgdGhlIExvb3AuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkxvb3B9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxvb3AucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9ldmVudC5zdGFydCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCB0aGUgbG9vcCBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbj19ICB0aW1lICBXaGVuIHRvIHN0b3AgdGhlIEFycGVnZ2lvXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkxvb3B9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxvb3AucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2V2ZW50LnN0b3AodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbmNlbCBhbGwgc2NoZWR1bGVkIGV2ZW50cyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbn0gIFt0aW1lPTBdICBUaGUgdGltZSBhZnRlciB3aGljaCBldmVudHMgd2lsbCBiZSBjYW5jZWwuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkxvb3B9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxvb3AucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fZXZlbnQuY2FuY2VsKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm90ZXMgc2hvdWxkIGJlIGNhbGxlZFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0aGUgZXZlbnQgb2NjdXJzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkxvb3AucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLmNhbGxiYWNrKHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgc3RhdGUgb2YgdGhlIExvb3AsIGVpdGhlciBzdGFydGVkIG9yIHN0b3BwZWQuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxvb3AjXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEBuYW1lIHN0YXRlXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTG9vcC5wcm90b3R5cGUsICdzdGF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50LnN0YXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwcm9ncmVzcyBvZiB0aGUgbG9vcCBhcyBhIHZhbHVlIGJldHdlZW4gMC0xLiAwLCB3aGVuXG5cdFx0ICogIHRoZSBsb29wIGlzIHN0b3BwZWQgb3IgZG9uZSBpdGVyYXRpbmcuIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Mb29wI1xuXHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0ICogIEBuYW1lIHByb2dyZXNzXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTG9vcC5wcm90b3R5cGUsICdwcm9ncmVzcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50LnByb2dyZXNzO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB0aW1lIGJldHdlZW4gc3VjY2Vzc2l2ZSBjYWxsYmFja3MuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIGxvb3AuaW50ZXJ2YWwgPSBcIjhuXCI7IC8vbG9vcCBldmVyeSA4blxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Mb29wI1xuXHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHQgKiAgQG5hbWUgaW50ZXJ2YWxcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxvb3AucHJvdG90eXBlLCAnaW50ZXJ2YWwnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudC5sb29wRW5kO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnQubG9vcEVuZCA9IGludGVydmFsO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwbGF5YmFjayByYXRlIG9mIHRoZSBsb29wLiBUaGUgbm9ybWFsIHBsYXliYWNrIHJhdGUgaXMgMSAobm8gY2hhbmdlKS4gXG5cdFx0ICogIEEgYHBsYXliYWNrUmF0ZWAgb2YgMiB3b3VsZCBiZSB0d2ljZSBhcyBmYXN0LiBcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTG9vcCNcblx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0ICogIEBuYW1lIHBsYXliYWNrUmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTG9vcC5wcm90b3R5cGUsICdwbGF5YmFja1JhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudC5wbGF5YmFja1JhdGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyYXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2V2ZW50LnBsYXliYWNrUmF0ZSA9IHJhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgUmFuZG9tIHZhcmlhdGlvbiArLy0wLjAxcyB0byB0aGUgc2NoZWR1bGVkIHRpbWUuIFxuXHRcdCAqICBPciBnaXZlIGl0IGEgdGltZSB2YWx1ZSB3aGljaCBpdCB3aWxsIHJhbmRvbWl6ZSBieS5cblx0XHQgKiAgQHR5cGUge0Jvb2xlYW58VGltZX1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTG9vcCNcblx0XHQgKiAgQG5hbWUgaHVtYW5pemVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxvb3AucHJvdG90eXBlLCAnaHVtYW5pemUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudC5odW1hbml6ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhcmlhdGlvbikge1xuXHQgICAgICAgICAgICB0aGlzLl9ldmVudC5odW1hbml6ZSA9IHZhcmlhdGlvbjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgcHJvYmFibHkgb2YgdGhlIGNhbGxiYWNrIGJlaW5nIGludm9rZWQuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxvb3AjXG5cdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiAgQG5hbWUgcHJvYmFiaWxpdHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxvb3AucHJvdG90eXBlLCAncHJvYmFiaWxpdHknLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudC5wcm9iYWJpbGl0eTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHByb2IpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnQucHJvYmFiaWxpdHkgPSBwcm9iO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIE11dGluZyB0aGUgTG9vcCBtZWFucyB0aGF0IG5vIGNhbGxiYWNrcyBhcmUgaW52b2tlZC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTG9vcCNcblx0XHQgKiAgQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogIEBuYW1lIG11dGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxvb3AucHJvdG90eXBlLCAnbXV0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50Lm11dGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtdXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2V2ZW50Lm11dGUgPSBtdXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyBvZiB0aGUgbG9vcC4gVGhlIGRlZmF1bHRcblx0XHQgKiAgdmFsdWUgaXMgSW5maW5pdHkgKGxvb3AgZm9yZXZlcikuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxvb3AjXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgaXRlcmF0aW9uc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTG9vcC5wcm90b3R5cGUsICdpdGVyYXRpb25zJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnQubG9vcCA9PT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50Lmxvb3A7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGl0ZXJzKSB7XG5cdCAgICAgICAgICAgIGlmIChpdGVycyA9PT0gSW5maW5pdHkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50Lmxvb3AgPSB0cnVlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnQubG9vcCA9IGl0ZXJzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuTG9vcH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTG9vcC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9ldmVudC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkxvb3A7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlBhcnQgaXMgYSBjb2xsZWN0aW9uIFRvbmUuRXZlbnRzIHdoaWNoIGNhbiBiZVxuXHRcdCAqICAgICAgICAgc3RhcnRlZC9zdG9wcGVkIGFuZCBsb29wZWQgYXMgYSBzaW5nbGUgdW5pdC5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FdmVudH1cblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBvbiBlYWNoIGV2ZW50XG5cdFx0ICogIEBwYXJhbSB7QXJyYXl9IGV2ZW50cyB0aGUgYXJyYXkgb2YgZXZlbnRzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHBhcnQgPSBuZXcgVG9uZS5QYXJ0KGZ1bmN0aW9uKHRpbWUsIG5vdGUpe1xuXHRcdCAqIFx0Ly90aGUgbm90ZXMgZ2l2ZW4gYXMgdGhlIHNlY29uZCBlbGVtZW50IGluIHRoZSBhcnJheVxuXHRcdCAqIFx0Ly93aWxsIGJlIHBhc3NlZCBpbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ICogXHRzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShub3RlLCBcIjhuXCIsIHRpbWUpO1xuXHRcdCAqIH0sIFtbMCwgXCJDMlwiXSwgW1wiMDoyXCIsIFwiQzNcIl0sIFtcIjA6MzoyXCIsIFwiRzJcIl1dKTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3VzZSBhbiBhcnJheSBvZiBvYmplY3RzIGFzIGxvbmcgYXMgdGhlIG9iamVjdCBoYXMgYSBcInRpbWVcIiBhdHRyaWJ1dGVcblx0XHQgKiB2YXIgcGFydCA9IG5ldyBUb25lLlBhcnQoZnVuY3Rpb24odGltZSwgdmFsdWUpe1xuXHRcdCAqIFx0Ly90aGUgdmFsdWUgaXMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGJvdGggdGhlIG5vdGUgYW5kIHRoZSB2ZWxvY2l0eVxuXHRcdCAqIFx0c3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UodmFsdWUubm90ZSwgXCI4blwiLCB0aW1lLCB2YWx1ZS52ZWxvY2l0eSk7XG5cdFx0ICogfSwgW3tcInRpbWVcIiA6IDAsIFwibm90ZVwiIDogXCJDM1wiLCBcInZlbG9jaXR5XCI6IDAuOX0sIFxuXHRcdCAqIFx0ICAge1widGltZVwiIDogXCIwOjJcIiwgXCJub3RlXCIgOiBcIkM0XCIsIFwidmVsb2NpdHlcIjogMC41fVxuXHRcdCAqIF0pLnN0YXJ0KDApO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJyxcblx0ICAgICAgICAgICAgJ2V2ZW50cydcblx0ICAgICAgICBdLCBUb25lLlBhcnQpO1xuXHQgICAgICAgIFRvbmUuRXZlbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbiBhcnJheSBvZiBPYmplY3RzLiBcblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcblx0ICAgICAgICAvL2FkZCB0aGUgZXZlbnRzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmV2ZW50c1tpXSkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWRkKG9wdGlvbnMuZXZlbnRzW2ldWzBdLCBvcHRpb25zLmV2ZW50c1tpXVsxXSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFkZChvcHRpb25zLmV2ZW50c1tpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QYXJ0LCBUb25lLkV2ZW50KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdjYWxsYmFjayc6IFRvbmUubm9PcCxcblx0ICAgICAgICAnbG9vcCc6IGZhbHNlLFxuXHQgICAgICAgICdsb29wRW5kJzogJzFtJyxcblx0ICAgICAgICAnbG9vcFN0YXJ0JzogMCxcblx0ICAgICAgICAncGxheWJhY2tSYXRlJzogMSxcblx0ICAgICAgICAncHJvYmFiaWxpdHknOiAxLFxuXHQgICAgICAgICdodW1hbml6ZSc6IGZhbHNlLFxuXHQgICAgICAgICdtdXRlJzogZmFsc2UsXG5cdCAgICAgICAgJ2V2ZW50cyc6IFtdXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IHRoZSBwYXJ0IGF0IHRoZSBnaXZlbiB0aW1lLiBcblx0XHQgKiAgQHBhcmFtICB7VHJhbnNwb3J0VGltZX0gIHRpbWUgICAgV2hlbiB0byBzdGFydCB0aGUgcGFydC5cblx0XHQgKiAgQHBhcmFtICB7VGltZT19ICBvZmZzZXQgIFRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHBhcnRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlZ2luIHBsYXlpbmcgYXQuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlBhcnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUsIG9mZnNldCkge1xuXHQgICAgICAgIHZhciB0aWNrcyA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGlja3MpICE9PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgICAgIG9mZnNldCA9IFRvbmUuZGVmYXVsdEFyZyhvZmZzZXQsIHRoaXMuX2xvb3BTdGFydCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBvZmZzZXQgPSBUb25lLmRlZmF1bHRBcmcob2Zmc2V0LCAwKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnRvVGlja3Mob2Zmc2V0KTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhdGUuYWRkKHtcblx0ICAgICAgICAgICAgICAgICdzdGF0ZSc6IFRvbmUuU3RhdGUuU3RhcnRlZCxcblx0ICAgICAgICAgICAgICAgICd0aW1lJzogdGlja3MsXG5cdCAgICAgICAgICAgICAgICAnb2Zmc2V0Jzogb2Zmc2V0XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnROb3RlKGV2ZW50LCB0aWNrcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGV2ZW50IGF0IHRoZSBjb3JyZWN0IHRpbWUgZ2l2ZW5cblx0XHQgKiAgdGhlIHRpY2tzIGFuZCBvZmZzZXQgYW5kIGxvb3BpbmcuXG5cdFx0ICogIEBwYXJhbSAge1RvbmUuRXZlbnR9ICBldmVudCBcblx0XHQgKiAgQHBhcmFtICB7VGlja3N9ICB0aWNrc1xuXHRcdCAqICBAcGFyYW0gIHtUaWNrc30gIG9mZnNldFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5fc3RhcnROb3RlID0gZnVuY3Rpb24gKGV2ZW50LCB0aWNrcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgdGlja3MgLT0gb2Zmc2V0O1xuXHQgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG5cdCAgICAgICAgICAgIGlmIChldmVudC5zdGFydE9mZnNldCA+PSB0aGlzLl9sb29wU3RhcnQgJiYgZXZlbnQuc3RhcnRPZmZzZXQgPCB0aGlzLl9sb29wRW5kKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc3RhcnRPZmZzZXQgPCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvL3N0YXJ0IGl0IG9uIHRoZSBuZXh0IGxvb3Bcblx0ICAgICAgICAgICAgICAgICAgICB0aWNrcyArPSB0aGlzLl9nZXRMb29wRHVyYXRpb24oKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGV2ZW50LnN0YXJ0KFRvbmUuVHJhbnNwb3J0VGltZSh0aWNrcywgJ2knKSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuc3RhcnRPZmZzZXQgPCB0aGlzLl9sb29wU3RhcnQgJiYgZXZlbnQuc3RhcnRPZmZzZXQgPj0gb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICBldmVudC5sb29wID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBldmVudC5zdGFydChUb25lLlRyYW5zcG9ydFRpbWUodGlja3MsICdpJykpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXJ0T2Zmc2V0ID49IG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgZXZlbnQuc3RhcnQoVG9uZS5UcmFuc3BvcnRUaW1lKHRpY2tzLCAnaScpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHN0YXJ0IGZyb20gdGhlIHNjaGVkdWxlZCBzdGFydCB0aW1lXG5cdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQG5hbWUgc3RhcnRPZmZzZXRcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcnQucHJvdG90eXBlLCAnc3RhcnRPZmZzZXQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydE9mZnNldDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdGFydE9mZnNldCA9IG9mZnNldDtcblx0ICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50LnN0YXJ0T2Zmc2V0ICs9IHRoaXMuX3N0YXJ0T2Zmc2V0O1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBwYXJ0IGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lbGluZVBvc2l0aW9ufSAgdGltZSAgV2hlbiB0byBzdG9wIHRoZSBwYXJ0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QYXJ0fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB2YXIgdGlja3MgPSB0aGlzLnRvVGlja3ModGltZSk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuY2FuY2VsKHRpY2tzKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0b3BwZWQsIHRpY2tzKTtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBldmVudC5zdG9wKHRpbWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQvU2V0IGFuIEV2ZW50J3MgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuIFxuXHRcdCAqICBJZiBhIHZhbHVlIGlzIHBhc3NlZCBpbiBhbmQgbm8gZXZlbnQgZXhpc3RzIGF0XG5cdFx0ICogIHRoZSBnaXZlbiB0aW1lLCBvbmUgd2lsbCBiZSBjcmVhdGVkIHdpdGggdGhhdCB2YWx1ZS4gXG5cdFx0ICogIElmIHR3byBldmVudHMgYXJlIGF0IHRoZSBzYW1lIHRpbWUsIHRoZSBmaXJzdCBvbmUgd2lsbFxuXHRcdCAqICBiZSByZXR1cm5lZC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBwYXJ0LmF0KFwiMW1cIik7IC8vcmV0dXJucyB0aGUgcGFydCBhdCB0aGUgZmlyc3QgbWVhc3VyZVxuXHRcdCAqXG5cdFx0ICogcGFydC5hdChcIjJtXCIsIFwiQzJcIik7IC8vc2V0IHRoZSB2YWx1ZSBhdCBcIjJtXCIgdG8gQzIuIFxuXHRcdCAqIC8vaWYgYW4gZXZlbnQgZGlkbid0IGV4aXN0IGF0IHRoYXQgdGltZSwgaXQgd2lsbCBiZSBjcmVhdGVkLlxuXHRcdCAqICBAcGFyYW0ge1RyYW5zcG9ydFRpbWV9IHRpbWUgVGhlIHRpbWUgb2YgdGhlIGV2ZW50IHRvIGdldCBvciBzZXQuXG5cdFx0ICogIEBwYXJhbSB7Kj19IHZhbHVlIElmIGEgdmFsdWUgaXMgcGFzc2VkIGluLCB0aGUgdmFsdWUgb2YgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgIGV2ZW50IGF0IHRoZSBnaXZlbiB0aW1lIHdpbGwgYmUgc2V0IHRvIGl0LlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkV2ZW50fSB0aGUgZXZlbnQgYXQgdGhlIHRpbWVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAodGltZSwgdmFsdWUpIHtcblx0ICAgICAgICB0aW1lID0gVG9uZS5UcmFuc3BvcnRUaW1lKHRpbWUpO1xuXHQgICAgICAgIHZhciB0aWNrVGltZSA9IFRvbmUuVGltZSgxLCAnaScpLnRvU2Vjb25kcygpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX2V2ZW50c1tpXTtcblx0ICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRpbWUudG9UaWNrcygpIC0gZXZlbnQuc3RhcnRPZmZzZXQpIDwgdGlja1RpbWUpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50LnZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9pZiB0aGVyZSB3YXMgbm8gZXZlbnQgYXQgdGhhdCB0aW1lLCBjcmVhdGUgb25lXG5cdCAgICAgICAgaWYgKCFUb25lLmlzVW5kZWYodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuYWRkKHRpbWUsIHZhbHVlKTtcblx0ICAgICAgICAgICAgLy9yZXR1cm4gdGhlIG5ldyBldmVudFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzW3RoaXMuX2V2ZW50cy5sZW5ndGggLSAxXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZCBhIGFuIGV2ZW50IHRvIHRoZSBwYXJ0LiBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSB0aW1lIFRoZSB0aW1lIHRoZSBub3RlIHNob3VsZCBzdGFydC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhbiBvYmplY3QgaXMgcGFzc2VkIGluLCBpdCBzaG91bGRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXZlIGEgJ3RpbWUnIGF0dHJpYnV0ZSBhbmQgdGhlIHJlc3Rcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyB0aGUgJ3ZhbHVlJy5cblx0XHQgKiAgQHBhcmFtICB7VG9uZS5FdmVudHwqfSAgdmFsdWUgXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcnR9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBwYXJ0LmFkZChcIjFtXCIsIFwiQyMrMTFcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0aW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIC8vZXh0cmFjdCB0aGUgcGFyYW1ldGVyc1xuXHQgICAgICAgIGlmICh0aW1lLmhhc093blByb3BlcnR5KCd0aW1lJykpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aW1lO1xuXHQgICAgICAgICAgICB0aW1lID0gdmFsdWUudGltZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICB2YXIgZXZlbnQ7XG5cdCAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVG9uZS5FdmVudCkge1xuXHQgICAgICAgICAgICBldmVudCA9IHZhbHVlO1xuXHQgICAgICAgICAgICBldmVudC5jYWxsYmFjayA9IHRoaXMuX3RpY2suYmluZCh0aGlzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBldmVudCA9IG5ldyBUb25lLkV2ZW50KHtcblx0ICAgICAgICAgICAgICAgICdjYWxsYmFjayc6IHRoaXMuX3RpY2suYmluZCh0aGlzKSxcblx0ICAgICAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL3RoZSBzdGFydCBvZmZzZXRcblx0ICAgICAgICBldmVudC5zdGFydE9mZnNldCA9IHRpbWU7XG5cdCAgICAgICAgLy9pbml0aWFsaXplIHRoZSB2YWx1ZXNcblx0ICAgICAgICBldmVudC5zZXQoe1xuXHQgICAgICAgICAgICAnbG9vcEVuZCc6IHRoaXMubG9vcEVuZCxcblx0ICAgICAgICAgICAgJ2xvb3BTdGFydCc6IHRoaXMubG9vcFN0YXJ0LFxuXHQgICAgICAgICAgICAnbG9vcCc6IHRoaXMubG9vcCxcblx0ICAgICAgICAgICAgJ2h1bWFuaXplJzogdGhpcy5odW1hbml6ZSxcblx0ICAgICAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IHRoaXMucGxheWJhY2tSYXRlLFxuXHQgICAgICAgICAgICAncHJvYmFiaWxpdHknOiB0aGlzLnByb2JhYmlsaXR5XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO1xuXHQgICAgICAgIC8vc3RhcnQgdGhlIG5vdGUgaWYgaXQgc2hvdWxkIGJlIHBsYXllZCByaWdodCBub3dcblx0ICAgICAgICB0aGlzLl9yZXN0YXJ0RXZlbnQoZXZlbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXN0YXJ0IHRoZSBnaXZlbiBldmVudFxuXHRcdCAqICBAcGFyYW0gIHtUb25lLkV2ZW50fSAgZXZlbnQgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLl9yZXN0YXJ0RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZUV2ZW50KSB7XG5cdCAgICAgICAgICAgIGlmIChzdGF0ZUV2ZW50LnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0Tm90ZShldmVudCwgc3RhdGVFdmVudC50aW1lLCBzdGF0ZUV2ZW50Lm9mZnNldCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvL3N0b3AgdGhlIG5vdGVcblx0ICAgICAgICAgICAgICAgIGV2ZW50LnN0b3AoVG9uZS5UcmFuc3BvcnRUaW1lKHN0YXRlRXZlbnQudGltZSwgJ2knKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgYW4gZXZlbnQgZnJvbSB0aGUgcGFydC4gV2lsbCByZWN1cnNpdmVseSBpdGVyYXRlXG5cdFx0ICogIGludG8gbmVzdGVkIHBhcnRzIHRvIGZpbmQgdGhlIGV2ZW50LlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHRpbWUgVGhlIHRpbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uYWxseSBzZWxlY3Qgb25seSBhIHNwZWNpZmljIGV2ZW50IHZhbHVlXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlBhcnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0aW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIC8vZXh0cmFjdCB0aGUgcGFyYW1ldGVyc1xuXHQgICAgICAgIGlmICh0aW1lLmhhc093blByb3BlcnR5KCd0aW1lJykpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aW1lO1xuXHQgICAgICAgICAgICB0aW1lID0gdmFsdWUudGltZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fZXZlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX2V2ZW50c1tpXTtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgVG9uZS5QYXJ0KSB7XG5cdCAgICAgICAgICAgICAgICBldmVudC5yZW1vdmUodGltZSwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXJ0T2Zmc2V0ID09PSB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFRvbmUuaXNVbmRlZih2YWx1ZSkgfHwgIVRvbmUuaXNVbmRlZih2YWx1ZSkgJiYgZXZlbnQudmFsdWUgPT09IHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlbW92ZSBhbGwgb2YgdGhlIG5vdGVzIGZyb20gdGhlIGdyb3VwLiBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuUGFydH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGV2ZW50LmRpc3Bvc2UoKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VsIHNjaGVkdWxlZCBzdGF0ZSBjaGFuZ2UgZXZlbnRzOiBpLmUuIFwic3RhcnRcIiBhbmQgXCJzdG9wXCIuXG5cdFx0ICogIEBwYXJhbSB7VGltZWxpbmVQb3NpdGlvbn0gYWZ0ZXIgVGhlIHRpbWUgYWZ0ZXIgd2hpY2ggdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgZXZlbnRzLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QYXJ0fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoYWZ0ZXIpIHtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBldmVudC5jYW5jZWwoYWZ0ZXIpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmNhbmNlbCh0aGlzLnRvVGlja3MoYWZ0ZXIpKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGFsbCBvZiB0aGUgZXZlbnRzXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBjdHggVGhlIGNvbnRleHRcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUuX2ZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9ldmVudHMpIHtcblx0ICAgICAgICAgICAgY3R4ID0gVG9uZS5kZWZhdWx0QXJnKGN0eCwgdGhpcyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9ldmVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5fZXZlbnRzW2ldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBUb25lLlBhcnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBlLl9mb3JFYWNoKGNhbGxiYWNrLCBjdHgpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCB0aGUgYXR0cmlidXRlIG9mIGFsbCBvZiB0aGUgZXZlbnRzXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIGF0dHIgIHRoZSBhdHRyaWJ1dGUgdG8gc2V0XG5cdFx0ICogIEBwYXJhbSAgeyp9ICB2YWx1ZSAgICAgIFRoZSB2YWx1ZSB0byBzZXQgaXQgdG9cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUuX3NldEFsbCA9IGZ1bmN0aW9uIChhdHRyLCB2YWx1ZSkge1xuXHQgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGV2ZW50W2F0dHJdID0gdmFsdWU7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEludGVybmFsIHRpY2sgbWV0aG9kXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIG9mIHRoZSBldmVudCBpbiBzZWNvbmRzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24gKHRpbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLm11dGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5jYWxsYmFjayh0aW1lLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBEZXRlcm1pbmUgaWYgdGhlIGV2ZW50IHNob3VsZCBiZSBjdXJyZW50bHkgbG9vcGluZ1xuXHRcdCAqICBnaXZlbiB0aGUgbG9vcCBib3VuZHJpZXMgb2YgdGhpcyBQYXJ0LlxuXHRcdCAqICBAcGFyYW0gIHtUb25lLkV2ZW50fSAgZXZlbnQgIFRoZSBldmVudCB0byB0ZXN0XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLl90ZXN0TG9vcEJvdW5kcmllcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIGlmIChldmVudC5zdGFydE9mZnNldCA8IHRoaXMuX2xvb3BTdGFydCB8fCBldmVudC5zdGFydE9mZnNldCA+PSB0aGlzLl9sb29wRW5kKSB7XG5cdCAgICAgICAgICAgIGV2ZW50LmNhbmNlbCgwKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvL3Jlc2NoZWR1bGUgaXQgaWYgaXQncyBzdG9wcGVkXG5cdCAgICAgICAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdG9wcGVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yZXN0YXJ0RXZlbnQoZXZlbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgcHJvYmFiaWxpdHkgb2YgdGhlIG5vdGVzIGJlaW5nIHRyaWdnZXJlZC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqICBAbmFtZSBwcm9iYWJpbGl0eVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFydC5wcm90b3R5cGUsICdwcm9iYWJpbGl0eScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2JhYmlsaXR5O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocHJvYikge1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9iYWJpbGl0eSA9IHByb2I7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldEFsbCgncHJvYmFiaWxpdHknLCBwcm9iKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBJZiBzZXQgdG8gdHJ1ZSwgd2lsbCBhcHBseSBzbWFsbCByYW5kb20gdmFyaWF0aW9uXG5cdFx0ICogIHRvIHRoZSBjYWxsYmFjayB0aW1lLiBJZiB0aGUgdmFsdWUgaXMgZ2l2ZW4gYXMgYSB0aW1lLCBpdCB3aWxsIHJhbmRvbWl6ZVxuXHRcdCAqICBieSB0aGF0IGFtb3VudC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBldmVudC5odW1hbml6ZSA9IHRydWU7XG5cdFx0ICogIEB0eXBlIHtCb29sZWFufFRpbWV9XG5cdFx0ICogIEBuYW1lIGh1bWFuaXplXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYXJ0LnByb3RvdHlwZSwgJ2h1bWFuaXplJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faHVtYW5pemU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YXJpYXRpb24pIHtcblx0ICAgICAgICAgICAgdGhpcy5faHVtYW5pemUgPSB2YXJpYXRpb247XG5cdCAgICAgICAgICAgIHRoaXMuX3NldEFsbCgnaHVtYW5pemUnLCB2YXJpYXRpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIElmIHRoZSBwYXJ0IHNob3VsZCBsb29wIG9yIG5vdFxuXHRcdCAqICBiZXR3ZWVuIFRvbmUuUGFydC5sb29wU3RhcnQgYW5kIFxuXHRcdCAqICBUb25lLlBhcnQubG9vcEVuZC4gQW4gaW50ZWdlclxuXHRcdCAqICB2YWx1ZSBjb3JyZXNwb25kcyB0byB0aGUgbnVtYmVyIG9mXG5cdFx0ICogIGxvb3BzIHRoZSBQYXJ0IGRvZXMgYWZ0ZXIgaXQgc3RhcnRzLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYXJ0I1xuXHRcdCAqICBAdHlwZSB7Qm9vbGVhbnxQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgbG9vcFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vbG9vcCB0aGUgcGFydCA4IHRpbWVzXG5cdFx0ICogcGFydC5sb29wID0gODtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcnQucHJvdG90eXBlLCAnbG9vcCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3A7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3AgPSBsb29wO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgZXZlbnQuX2xvb3BTdGFydCA9IHRoaXMuX2xvb3BTdGFydDtcblx0ICAgICAgICAgICAgICAgIGV2ZW50Ll9sb29wRW5kID0gdGhpcy5fbG9vcEVuZDtcblx0ICAgICAgICAgICAgICAgIGV2ZW50Lmxvb3AgPSBsb29wO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGVzdExvb3BCb3VuZHJpZXMoZXZlbnQpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbG9vcEVuZCBwb2ludCBkZXRlcm1pbmVzIHdoZW4gaXQgd2lsbCBcblx0XHQgKiAgbG9vcCBpZiBUb25lLlBhcnQubG9vcCBpcyB0cnVlLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYXJ0I1xuXHRcdCAqICBAdHlwZSB7VHJhbnNwb3J0VGltZX1cblx0XHQgKiAgQG5hbWUgbG9vcEVuZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFydC5wcm90b3R5cGUsICdsb29wRW5kJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX2xvb3BFbmQsICdpJykudG9Ob3RhdGlvbigpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcEVuZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gdGhpcy50b1RpY2tzKGxvb3BFbmQpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudC5sb29wRW5kID0gbG9vcEVuZDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXN0TG9vcEJvdW5kcmllcyhldmVudCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBsb29wU3RhcnQgcG9pbnQgZGV0ZXJtaW5lcyB3aGVuIGl0IHdpbGwgXG5cdFx0ICogIGxvb3AgaWYgVG9uZS5QYXJ0Lmxvb3AgaXMgdHJ1ZS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQHR5cGUge1RyYW5zcG9ydFRpbWV9XG5cdFx0ICogIEBuYW1lIGxvb3BTdGFydFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFydC5wcm90b3R5cGUsICdsb29wU3RhcnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydFRpbWUodGhpcy5fbG9vcFN0YXJ0LCAnaScpLnRvTm90YXRpb24oKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxvb3BTdGFydCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wU3RhcnQgPSB0aGlzLnRvVGlja3MobG9vcFN0YXJ0KTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXZlbnQubG9vcFN0YXJ0ID0gdGhpcy5sb29wU3RhcnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVzdExvb3BCb3VuZHJpZXMoZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFx0VGhlIHBsYXliYWNrIHJhdGUgb2YgdGhlIHBhcnRcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAbmFtZSBwbGF5YmFja1JhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcnQucHJvdG90eXBlLCAncGxheWJhY2tSYXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSByYXRlO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRBbGwoJ3BsYXliYWNrUmF0ZScsIHJhdGUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogXHRUaGUgbnVtYmVyIG9mIHNjaGVkdWxlZCBub3RlcyBpbiB0aGUgcGFydC4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhcnQjXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgbGVuZ3RoXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFydC5wcm90b3R5cGUsICdsZW5ndGgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubGVuZ3RoO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlBhcnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5yZW1vdmVBbGwoKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGFydDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlBhdHRlcm4gYXJwZWdnaWF0ZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gbm90ZXNcblx0XHQgKiAgICAgICAgIGluIGEgbnVtYmVyIG9mIHBhdHRlcm5zLiBTZWUgVG9uZS5DdHJsUGF0dGVybiBmb3Jcblx0XHQgKiAgICAgICAgIGEgZnVsbCBsaXN0IG9mIHBhdHRlcm5zLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBwYXR0ZXJuID0gbmV3IFRvbmUuUGF0dGVybihmdW5jdGlvbih0aW1lLCBub3RlKXtcblx0XHQgKiAgIC8vdGhlIG9yZGVyIG9mIHRoZSBub3RlcyBwYXNzZWQgaW4gZGVwZW5kcyBvbiB0aGUgcGF0dGVyblxuXHRcdCAqIH0sIFtcIkMyXCIsIFwiRDRcIiwgXCJFNVwiLCBcIkE2XCJdLCBcInVwRG93blwiKTtcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuTG9vcH1cblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5cblx0XHQgKiAgQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXJwZWdnaWF0ZSBvdmVyLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXR0ZXJuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJyxcblx0ICAgICAgICAgICAgJ3ZhbHVlcycsXG5cdCAgICAgICAgICAgICdwYXR0ZXJuJ1xuXHQgICAgICAgIF0sIFRvbmUuUGF0dGVybik7XG5cdCAgICAgICAgVG9uZS5Mb29wLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHBhdHRlcm4gbWFuYWdlclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkN0cmxQYXR0ZXJufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYXR0ZXJuID0gbmV3IFRvbmUuQ3RybFBhdHRlcm4oe1xuXHQgICAgICAgICAgICAndmFsdWVzJzogb3B0aW9ucy52YWx1ZXMsXG5cdCAgICAgICAgICAgICd0eXBlJzogb3B0aW9ucy5wYXR0ZXJuLFxuXHQgICAgICAgICAgICAnaW5kZXgnOiBvcHRpb25zLmluZGV4XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QYXR0ZXJuLCBUb25lLkxvb3ApO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBhdHRlcm4uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3BhdHRlcm4nOiBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXAsXG5cdCAgICAgICAgJ2NhbGxiYWNrJzogVG9uZS5ub09wLFxuXHQgICAgICAgICd2YWx1ZXMnOiBbXVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm90ZXMgc2hvdWxkIGJlIGNhbGxlZFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0aGUgZXZlbnQgb2NjdXJzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhdHRlcm4ucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLmNhbGxiYWNrKHRpbWUsIHRoaXMuX3BhdHRlcm4udmFsdWUpO1xuXHQgICAgICAgIHRoaXMuX3BhdHRlcm4ubmV4dCgpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgdmFsdWVzIGFycmF5LlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYXR0ZXJuI1xuXHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogIEBuYW1lIGluZGV4XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYXR0ZXJuLnByb3RvdHlwZSwgJ2luZGV4Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGF0dGVybi5pbmRleDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGkpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGF0dGVybi5pbmRleCA9IGk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGFycmF5IG9mIGV2ZW50cy5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGF0dGVybiNcblx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdCAqICBAbmFtZSB2YWx1ZXNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhdHRlcm4ucHJvdG90eXBlLCAndmFsdWVzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGF0dGVybi52YWx1ZXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWxzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4udmFsdWVzID0gdmFscztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgcGF0dGVybi5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGF0dGVybiNcblx0XHQgKiAgQHR5cGUgeyp9XG5cdFx0ICogIEBuYW1lIHZhbHVlXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGF0dGVybi5wcm90b3R5cGUsICd2YWx1ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhdHRlcm4udmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHBhdHRlcm4gdHlwZS4gU2VlIFRvbmUuQ3RybFBhdHRlcm4gZm9yIHRoZSBmdWxsIGxpc3Qgb2YgcGF0dGVybnMuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhdHRlcm4jXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEBuYW1lIHBhdHRlcm5cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhdHRlcm4ucHJvdG90eXBlLCAncGF0dGVybicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhdHRlcm4udHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBhdHRlcm4pIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGF0dGVybi50eXBlID0gcGF0dGVybjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QYXR0ZXJufSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXR0ZXJuLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuTG9vcC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3BhdHRlcm4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3BhdHRlcm4gPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBhdHRlcm47XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBIHNlcXVlbmNlIGlzIGFuIGFsdGVybmF0ZSBub3RhdGlvbiBvZiBhIHBhcnQuIEluc3RlYWRcblx0XHQgKiAgICAgICAgIG9mIHBhc3NpbmcgaW4gYW4gYXJyYXkgb2YgW3RpbWUsIGV2ZW50XSBwYWlycywgcGFzc1xuXHRcdCAqICAgICAgICAgaW4gYW4gYXJyYXkgb2YgZXZlbnRzIHdoaWNoIHdpbGwgYmUgc3BhY2VkIGF0IHRoZVxuXHRcdCAqICAgICAgICAgZ2l2ZW4gc3ViZGl2aXNpb24uIFN1Yi1hcnJheXMgd2lsbCBzdWJkaXZpZGUgdGhhdCBiZWF0XG5cdFx0ICogICAgICAgICBieSB0aGUgbnVtYmVyIG9mIGl0ZW1zIGFyZSBpbiB0aGUgYXJyYXkuIFxuXHRcdCAqICAgICAgICAgU2VxdWVuY2Ugbm90YXRpb24gaW5zcGlyYXRpb24gZnJvbSBbVGlkYWxdKGh0dHA6Ly95YXh1Lm9yZy90aWRhbC8pXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBub3RlXG5cdFx0ICogIEBwYXJhbSAge0FycmF5fSAgICBldmVudHMgIFRoZSBzZXF1ZW5jZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBzdWJkaXZpc2lvbiAgVGhlIHN1YmRpdmlzaW9uIGJldHdlZW4gd2hpY2ggZXZlbnRzIGFyZSBwbGFjZWQuIFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5QYXJ0fVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzZXEgPSBuZXcgVG9uZS5TZXF1ZW5jZShmdW5jdGlvbih0aW1lLCBub3RlKXtcblx0XHQgKiBcdGNvbnNvbGUubG9nKG5vdGUpO1xuXHRcdCAqIC8vc3RyYWlnaHQgcXVhdGVyIG5vdGVzXG5cdFx0ICogfSwgW1wiQzRcIiwgXCJFNFwiLCBcIkc0XCIsIFwiQTRcIl0sIFwiNG5cIik7XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHNlcSA9IG5ldyBUb25lLlNlcXVlbmNlKGZ1bmN0aW9uKHRpbWUsIG5vdGUpe1xuXHRcdCAqIFx0Y29uc29sZS5sb2cobm90ZSk7XG5cdFx0ICogLy9zdWJkaXZpc2lvbnMgYXJlIGdpdmVuIGFzIHN1YmFycmF5c1xuXHRcdCAqIH0sIFtcIkM0XCIsIFtcIkU0XCIsIFwiRDRcIiwgXCJFNFwiXSwgXCJHNFwiLCBbXCJBNFwiLCBcIkc0XCJdXSk7XG5cdFx0ICovXG5cdCAgICBUb25lLlNlcXVlbmNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJyxcblx0ICAgICAgICAgICAgJ2V2ZW50cycsXG5cdCAgICAgICAgICAgICdzdWJkaXZpc2lvbidcblx0ICAgICAgICBdLCBUb25lLlNlcXVlbmNlKTtcblx0ICAgICAgICAvL3JlbW92ZSB0aGUgZXZlbnRzXG5cdCAgICAgICAgdmFyIGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzO1xuXHQgICAgICAgIGRlbGV0ZSBvcHRpb25zLmV2ZW50cztcblx0ICAgICAgICBUb25lLlBhcnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc3ViZGl2aXNvbiBvZiBlYWNoIG5vdGVcblx0XHRcdCAqICBAdHlwZSAge1RpY2tzfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdWJkaXZpc2lvbiA9IHRoaXMudG9UaWNrcyhvcHRpb25zLnN1YmRpdmlzaW9uKTtcblx0ICAgICAgICAvL2lmIG5vIHRpbWUgd2FzIHBhc3NlZCBpbiwgdGhlIGxvb3AgZW5kIGlzIHRoZSBlbmQgb2YgdGhlIGN5Y2xlXG5cdCAgICAgICAgaWYgKFRvbmUuaXNVbmRlZihvcHRpb25zLmxvb3BFbmQpICYmICFUb25lLmlzVW5kZWYoZXZlbnRzKSkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gZXZlbnRzLmxlbmd0aCAqIHRoaXMuX3N1YmRpdmlzaW9uO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2RlZmF1bHRzIHRvIGxvb3Bpbmdcblx0ICAgICAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblx0ICAgICAgICAvL2FkZCBhbGwgb2YgdGhlIGV2ZW50c1xuXHQgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKGV2ZW50cykpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWRkKGksIGV2ZW50c1tpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TZXF1ZW5jZSwgVG9uZS5QYXJ0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXMuXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TZXF1ZW5jZS5kZWZhdWx0cyA9IHsgJ3N1YmRpdmlzaW9uJzogJzRuJyB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzdWJkaXZpc2lvbiBvZiB0aGUgc2VxdWVuY2UuIFRoaXMgY2FuIG9ubHkgYmUgXG5cdFx0ICogIHNldCBpbiB0aGUgY29uc3RydWN0b3IuIFRoZSBzdWJkaXZpc2lvbiBpcyB0aGUgXG5cdFx0ICogIGludGVydmFsIGJldHdlZW4gc3VjY2Vzc2l2ZSBzdGVwcy4gXG5cdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5TZXF1ZW5jZSNcblx0XHQgKiAgQG5hbWUgc3ViZGl2aXNpb25cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5TZXF1ZW5jZS5wcm90b3R5cGUsICdzdWJkaXZpc2lvbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVGltZSh0aGlzLl9zdWJkaXZpc2lvbiwgJ2knKS50b05vdGF0aW9uKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgR2V0L1NldCBhbiBpbmRleCBvZiB0aGUgc2VxdWVuY2UuIElmIHRoZSBpbmRleCBjb250YWlucyBhIHN1YmFycmF5LCBcblx0XHQgKiAgYSBUb25lLlNlcXVlbmNlIHJlcHJlc2VudGluZyB0aGF0IHN1Yi1hcnJheSB3aWxsIGJlIHJldHVybmVkLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc2VxdWVuY2UgPSBuZXcgVG9uZS5TZXF1ZW5jZShwbGF5Tm90ZSwgW1wiRTRcIiwgXCJDNFwiLCBcIkYjNFwiLCBbXCJBNFwiLCBcIkJiM1wiXV0pXG5cdFx0ICogc2VxdWVuY2UuYXQoMCkvLyA9PiByZXR1cm5zIFwiRTRcIlxuXHRcdCAqIC8vc2V0IGEgdmFsdWVcblx0XHQgKiBzZXF1ZW5jZS5hdCgwLCBcIkczXCIpO1xuXHRcdCAqIC8vZ2V0IGEgbmVzdGVkIHNlcXVlbmNlXG5cdFx0ICogc2VxdWVuY2UuYXQoMykuYXQoMSkvLyA9PiByZXR1cm5zIFwiQmIzXCJcblx0XHQgKiBAcGFyYW0ge1Bvc2l0aXZlfSBpbmRleCBUaGUgaW5kZXggdG8gZ2V0IG9yIHNldFxuXHRcdCAqIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uYWxseSBwYXNzIGluIHRoZSB2YWx1ZSB0byBzZXQgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHRcdCAqL1xuXHQgICAgVG9uZS5TZXF1ZW5jZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG5cdCAgICAgICAgLy9pZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXksIFxuXHQgICAgICAgIGlmIChUb25lLmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBjdXJyZW50IGV2ZW50IGF0IHRoYXQgaW5kZXhcblx0ICAgICAgICAgICAgdGhpcy5yZW1vdmUoaW5kZXgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2NhbGwgdGhlIHBhcmVudCdzIG1ldGhvZFxuXHQgICAgICAgIHJldHVybiBUb25lLlBhcnQucHJvdG90eXBlLmF0LmNhbGwodGhpcywgdGhpcy5faW5kZXhUaW1lKGluZGV4KSwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGQgYW4gZXZlbnQgYXQgYW4gaW5kZXgsIGlmIHRoZXJlJ3MgYWxyZWFkeSBzb21ldGhpbmdcblx0XHQgKiAgYXQgdGhhdCBpbmRleCwgb3ZlcndyaXRlIGl0LiBJZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBcblx0XHQgKiAgaXQgd2lsbCBiZSBwYXJzZWQgYXMgYSBzdWJzZXF1ZW5jZS5cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBhZGQgdGhlIGV2ZW50IHRvXG5cdFx0ICogIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZCBhdCB0aGF0IGluZGV4XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNlcXVlbmNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNlcXVlbmNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoVG9uZS5pc0FycmF5KHZhbHVlKSkge1xuXHQgICAgICAgICAgICAvL21ha2UgYSBzdWJzZXF1ZW5jZSBhbmQgYWRkIHRoYXQgdG8gdGhlIHNlcXVlbmNlXG5cdCAgICAgICAgICAgIHZhciBzdWJTdWJkaXZpc2lvbiA9IE1hdGgucm91bmQodGhpcy5fc3ViZGl2aXNpb24gLyB2YWx1ZS5sZW5ndGgpO1xuXHQgICAgICAgICAgICB2YWx1ZSA9IG5ldyBUb25lLlNlcXVlbmNlKHRoaXMuX3RpY2suYmluZCh0aGlzKSwgdmFsdWUsIFRvbmUuVGltZShzdWJTdWJkaXZpc2lvbiwgJ2knKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRvbmUuUGFydC5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgdGhpcy5faW5kZXhUaW1lKGluZGV4KSwgdmFsdWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgYSB2YWx1ZSBmcm9tIHRoZSBzZXF1ZW5jZSBieSBpbmRleFxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBldmVudCB0byByZW1vdmVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU2VxdWVuY2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2VxdWVuY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcblx0ICAgICAgICBUb25lLlBhcnQucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsIHRoaXMuX2luZGV4VGltZShpbmRleCksIHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSB0aW1lIG9mIHRoZSBpbmRleCBnaXZlbiB0aGUgU2VxdWVuY2UncyBzdWJkaXZpc2lvblxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICBpbmRleCBcblx0XHQgKiAgQHJldHVybiAge1RpbWV9ICBUaGUgdGltZSBvZiB0aGF0IGluZGV4XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlNlcXVlbmNlLnByb3RvdHlwZS5faW5kZXhUaW1lID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdCAgICAgICAgaWYgKGluZGV4IGluc3RhbmNlb2YgVG9uZS5UcmFuc3BvcnRUaW1lKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBpbmRleDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKGluZGV4ICogdGhpcy5fc3ViZGl2aXNpb24gKyB0aGlzLnN0YXJ0T2Zmc2V0LCAnaScpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuU2VxdWVuY2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2VxdWVuY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU2VxdWVuY2U7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlB1bHNlT3NjaWxsYXRvciBpcyBhIHB1bHNlIG9zY2lsbGF0b3Igd2l0aCBjb250cm9sIG92ZXIgcHVsc2Ugd2lkdGgsXG5cdFx0ICogICAgICAgICBhbHNvIGtub3duIGFzIHRoZSBkdXR5IGN5Y2xlLiBBdCA1MCUgZHV0eSBjeWNsZSAod2lkdGggPSAwLjUpIHRoZSB3YXZlIGlzIFxuXHRcdCAqICAgICAgICAgYSBzcXVhcmUgYW5kIG9ubHkgb2RkLW51bWJlcmVkIGhhcm1vbmljcyBhcmUgcHJlc2VudC4gQXQgYWxsIG90aGVyIHdpZHRocyBcblx0XHQgKiAgICAgICAgIGV2ZW4tbnVtYmVyZWQgaGFybW9uaWNzIGFyZSBwcmVzZW50LiBSZWFkIG1vcmUgXG5cdFx0ICogICAgICAgICBbaGVyZV0oaHR0cHM6Ly93aWdnbGV3YXZlLndvcmRwcmVzcy5jb20vMjAxNC8wOC8xNi9wdWxzZS13YXZlZm9ybXMtYW5kLWhhcm1vbmljcy8pLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Tb3VyY2V9XG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBbZnJlcXVlbmN5XSBUaGUgZnJlcXVlbmN5IG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IFt3aWR0aF0gVGhlIHdpZHRoIG9mIHRoZSBwdWxzZVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBwdWxzZSA9IG5ldyBUb25lLlB1bHNlT3NjaWxsYXRvcihcIkU1XCIsIDAuNCkudG9NYXN0ZXIoKS5zdGFydCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QdWxzZU9zY2lsbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ3dpZHRoJ1xuXHQgICAgICAgIF0sIFRvbmUuT3NjaWxsYXRvcik7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgd2lkdGggb2YgdGhlIHB1bHNlLiBcblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy53aWR0aCA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLndpZHRoLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGdhdGUgdGhlIHdpZHRoIGFtb3VudFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3dpZHRoR2F0ZSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgc2F3dG9vdGggb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3Nhd3Rvb3RoID0gbmV3IFRvbmUuT3NjaWxsYXRvcih7XG5cdCAgICAgICAgICAgIGZyZXF1ZW5jeTogb3B0aW9ucy5mcmVxdWVuY3ksXG5cdCAgICAgICAgICAgIGRldHVuZTogb3B0aW9ucy5kZXR1bmUsXG5cdCAgICAgICAgICAgIHR5cGU6ICdzYXd0b290aCcsXG5cdCAgICAgICAgICAgIHBoYXNlOiBvcHRpb25zLnBoYXNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZyZXF1ZW5jeSBjb250cm9sLlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSB0aGlzLl9zYXd0b290aC5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBpbiBjZW50cy4gXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gdGhpcy5fc2F3dG9vdGguZGV0dW5lO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRocmVzaG9sZCB0aGUgc2lnbmFsIHRvIHR1cm4gaXQgaW50byBhIHNxdWFyZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLldhdmVTaGFwZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3RocmVzaCA9IG5ldyBUb25lLldhdmVTaGFwZXIoZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICBpZiAodmFsIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5fc2F3dG9vdGguY2hhaW4odGhpcy5fdGhyZXNoLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy53aWR0aC5jaGFpbih0aGlzLl93aWR0aEdhdGUsIHRoaXMuX3RocmVzaCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnd2lkdGgnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlB1bHNlT3NjaWxsYXRvciwgVG9uZS5Tb3VyY2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlB1bHNlT3NjaWxsYXRvci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogNDQwLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdwaGFzZSc6IDAsXG5cdCAgICAgICAgJ3dpZHRoJzogMC4yXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWUgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlB1bHNlT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fc2F3dG9vdGguc3RhcnQodGltZSk7XG5cdCAgICAgICAgdGhpcy5fd2lkdGhHYXRlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMSwgdGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0b3AgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gdGltZSBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUHVsc2VPc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3Nhd3Rvb3RoLnN0b3AodGltZSk7XG5cdCAgICAgICAgLy90aGUgd2lkdGggaXMgc3RpbGwgY29ubmVjdGVkIHRvIHRoZSBvdXRwdXQuIFxuXHQgICAgICAgIC8vdGhhdCBuZWVkcyB0byBiZSBzdG9wcGVkIGFsc29cblx0ICAgICAgICB0aGlzLl93aWR0aEdhdGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGhhc2Ugb2YgdGhlIG9zY2lsbGF0b3IgaW4gZGVncmVlcy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QdWxzZU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0RlZ3JlZXN9XG5cdFx0ICogQG5hbWUgcGhhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlB1bHNlT3NjaWxsYXRvci5wcm90b3R5cGUsICdwaGFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Nhd3Rvb3RoLnBoYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2F3dG9vdGgucGhhc2UgPSBwaGFzZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBvc2NpbGxhdG9yLiBBbHdheXMgcmV0dXJucyBcInB1bHNlXCIuXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUHVsc2VPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUHVsc2VPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAncHVsc2UnO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSB3YXZlZm9ybS4gQ2Fubm90IHNldCBwYXJ0aWFscyBmb3IgdGhpcyB3YXZlZm9ybSB0eXBlXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUHVsc2VPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAbmFtZSBwYXJ0aWFsc1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QdWxzZU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGFydGlhbHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cCBtZXRob2QuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuUHVsc2VPc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlB1bHNlT3NjaWxsYXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3Nhd3Rvb3RoLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zYXd0b290aCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnd2lkdGgnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLndpZHRoLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLndpZHRoID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93aWR0aEdhdGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3dpZHRoR2F0ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdGhyZXNoLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl90aHJlc2ggPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUHVsc2VPc2NpbGxhdG9yO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5QV01Pc2NpbGxhdG9yIG1vZHVsYXRlcyB0aGUgd2lkdGggb2YgYSBUb25lLlB1bHNlT3NjaWxsYXRvciBcblx0XHQgKiAgICAgICAgIGF0IHRoZSBtb2R1bGF0aW9uRnJlcXVlbmN5LiBUaGlzIGhhcyB0aGUgZWZmZWN0IG9mIGNvbnRpbnVvdXNseVxuXHRcdCAqICAgICAgICAgY2hhbmdpbmcgdGhlIHRpbWJyZSBvZiB0aGUgb3NjaWxsYXRvciBieSBhbHRlcmluZyB0aGUgaGFybW9uaWNzIFxuXHRcdCAqICAgICAgICAgZ2VuZXJhdGVkLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNvdXJjZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIHN0YXJ0aW5nIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRvci4gXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBtb2R1bGF0aW9uRnJlcXVlbmN5IFRoZSBtb2R1bGF0aW9uIGZyZXF1ZW5jeSBvZiB0aGUgd2lkdGggb2YgdGhlIHB1bHNlLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgdmFyIHB3bSA9IG5ldyBUb25lLlBXTU9zY2lsbGF0b3IoXCJBYjNcIiwgMC4zKS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBXTU9zY2lsbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25GcmVxdWVuY3knXG5cdCAgICAgICAgXSwgVG9uZS5QV01Pc2NpbGxhdG9yKTtcblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBwdWxzZSBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuUHVsc2VPc2NpbGxhdG9yfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wdWxzZSA9IG5ldyBUb25lLlB1bHNlT3NjaWxsYXRvcihvcHRpb25zLm1vZHVsYXRpb25GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8vY2hhbmdlIHRoZSBwdWxzZSBvc2NpbGxhdG9yIHR5cGVcblx0ICAgICAgICB0aGlzLl9wdWxzZS5fc2F3dG9vdGgudHlwZSA9ICdzaW5lJztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbW9kdWxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yID0gbmV3IFRvbmUuT3NjaWxsYXRvcih7XG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knOiBvcHRpb25zLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ2RldHVuZSc6IG9wdGlvbnMuZGV0dW5lLFxuXHQgICAgICAgICAgICAncGhhc2UnOiBvcHRpb25zLnBoYXNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU2NhbGUgdGhlIG9zY2lsbGF0b3Igc28gaXQgZG9lc24ndCBnbyBzaWxlbnQgXG5cdFx0XHQgKiAgYXQgdGhlIGV4dHJlbWUgdmFsdWVzLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk11bHRpcGx5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IG5ldyBUb25lLk11bHRpcGx5KDIpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5fbW9kdWxhdG9yLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIG9mIHRoZSBvc2NpbGxhdG9yLlxuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IHRoaXMuX21vZHVsYXRvci5kZXR1bmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRpb24gcmF0ZSBvZiB0aGUgb3NjaWxsYXRvci4gXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25GcmVxdWVuY3kgPSB0aGlzLl9wdWxzZS5mcmVxdWVuY3k7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5jaGFpbih0aGlzLl9zY2FsZSwgdGhpcy5fcHVsc2Uud2lkdGgpO1xuXHQgICAgICAgIHRoaXMuX3B1bHNlLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25GcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBXTU9zY2lsbGF0b3IsIFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5QV01Pc2NpbGxhdG9yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiA0NDAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ3BoYXNlJzogMCxcblx0ICAgICAgICAnbW9kdWxhdGlvbkZyZXF1ZW5jeSc6IDAuNFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBXTU9zY2lsbGF0b3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5zdGFydCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9wdWxzZS5zdGFydCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RvcCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lIChvcHRpb25hbCkgdGltaW5nIHBhcmFtZXRlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QV01Pc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5zdG9wKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3B1bHNlLnN0b3AodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIG9zY2lsbGF0b3IuIEFsd2F5cyByZXR1cm5zIFwicHdtXCIuXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUFdNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBXTU9zY2lsbGF0b3IucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICdwd20nO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSB3YXZlZm9ybS4gQ2Fubm90IHNldCBwYXJ0aWFscyBmb3IgdGhpcyB3YXZlZm9ybSB0eXBlXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUFdNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQG5hbWUgcGFydGlhbHNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUFdNT3NjaWxsYXRvci5wcm90b3R5cGUsICdwYXJ0aWFscycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yIGluIGRlZ3JlZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUFdNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIHBoYXNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QV01Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BoYXNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9kdWxhdG9yLnBoYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuUFdNT3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QV01Pc2NpbGxhdG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fcHVsc2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3B1bHNlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zY2FsZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uRnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25GcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBXTU9zY2lsbGF0b3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkZNT3NjaWxsYXRvciBcblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Tb3VyY2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcXVlbmN5IFRoZSBzdGFydGluZyBmcmVxdWVuY3kgb2YgdGhlIG9zY2lsbGF0b3IuIFxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgY2FycmllciBvc2NpbGxhdG9yLlxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gbW9kdWxhdGlvblR5cGUgVGhlIHR5cGUgb2YgdGhlIG1vZHVsYXRvciBvc2NpbGxhdG9yLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vYSBzaW5lIG9zY2lsbGF0b3IgZnJlcXVlbmN5LW1vZHVsYXRlZCBieSBhIHNxdWFyZSB3YXZlXG5cdFx0ICogdmFyIGZtT3NjID0gbmV3IFRvbmUuRk1Pc2NpbGxhdG9yKFwiQWIzXCIsIFwic2luZVwiLCBcInNxdWFyZVwiKS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkZNT3NjaWxsYXRvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAndHlwZScsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uVHlwZSdcblx0ICAgICAgICBdLCBUb25lLkZNT3NjaWxsYXRvcik7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FycmllciBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY2FycmllciA9IG5ldyBUb25lLk9zY2lsbGF0b3Iob3B0aW9ucy5mcmVxdWVuY3ksIG9wdGlvbnMudHlwZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG9zY2lsbGF0b3IncyBmcmVxdWVuY3lcblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGNvbnRyb2wgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IHRoaXMuX2NhcnJpZXIuZGV0dW5lO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLnZhbHVlID0gb3B0aW9ucy5kZXR1bmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRpb24gaW5kZXggd2hpY2ggaXMgaW4gZXNzZW5jZSB0aGUgZGVwdGggb3IgYW1vdW50IG9mIHRoZSBtb2R1bGF0aW9uLiBJbiBvdGhlciB0ZXJtcyBpdCBpcyB0aGUgXG5cdFx0XHQgKiAgcmF0aW8gb2YgdGhlIGZyZXF1ZW5jeSBvZiB0aGUgbW9kdWxhdGluZyBzaWduYWwgKG1mKSB0byB0aGUgYW1wbGl0dWRlIG9mIHRoZSBcblx0XHRcdCAqICBtb2R1bGF0aW5nIHNpZ25hbCAobWEpIC0tIGFzIGluIG1hL21mLiBcblx0XHRcdCAqXHRAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKlx0QHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uSW5kZXggPSBuZXcgVG9uZS5NdWx0aXBseShvcHRpb25zLm1vZHVsYXRpb25JbmRleCk7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uSW5kZXgudW5pdHMgPSBUb25lLlR5cGUuUG9zaXRpdmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRpbmcgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKG9wdGlvbnMuZnJlcXVlbmN5LCBvcHRpb25zLm1vZHVsYXRpb25UeXBlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgZnJlcXVlbmN5IHJhdGlvIGJldHdlZW4gdGhlIGNhcnJpZXIgYW5kIHRoZSBtb2R1bGF0b3Igb3NjaWxsYXRvcnMuIFxuXHRcdFx0ICogIEEgaGFybW9uaWNpdHkgb2YgMSBnaXZlcyBib3RoIG9zY2lsbGF0b3JzIHRoZSBzYW1lIGZyZXF1ZW5jeS4gXG5cdFx0XHQgKiAgSGFybW9uaWNpdHkgPSAyIG1lYW5zIGEgY2hhbmdlIG9mIGFuIG9jdGF2ZS4gXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogLy9waXRjaCB0aGUgbW9kdWxhdG9yIGFuIG9jdGF2ZSBiZWxvdyBjYXJyaWVyXG5cdFx0XHQgKiBzeW50aC5oYXJtb25pY2l0eS52YWx1ZSA9IDAuNTtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBuZXcgVG9uZS5NdWx0aXBseShvcHRpb25zLmhhcm1vbmljaXR5KTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LnVuaXRzID0gVG9uZS5UeXBlLlBvc2l0aXZlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBub2RlIHdoZXJlIHRoZSBtb2R1bGF0aW9uIGhhcHBlbnNcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZSA9IG5ldyBUb25lLkdhaW4oMCk7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fY2Fycmllci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNoYWluKHRoaXMuaGFybW9uaWNpdHksIHRoaXMuX21vZHVsYXRvci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNoYWluKHRoaXMubW9kdWxhdGlvbkluZGV4LCB0aGlzLl9tb2R1bGF0aW9uTm9kZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLmNvbm5lY3QodGhpcy5fbW9kdWxhdGlvbk5vZGUuZ2Fpbik7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUuY29ubmVjdCh0aGlzLl9jYXJyaWVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5jb25uZWN0KHRoaXMuX21vZHVsYXRvci5kZXR1bmUpO1xuXHQgICAgICAgIHRoaXMucGhhc2UgPSBvcHRpb25zLnBoYXNlO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25JbmRleCcsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRk1Pc2NpbGxhdG9yLCBUb25lLlNvdXJjZSk7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1Pc2NpbGxhdG9yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiA0NDAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ3BoYXNlJzogMCxcblx0ICAgICAgICAnbW9kdWxhdGlvbkluZGV4JzogMixcblx0ICAgICAgICAnbW9kdWxhdGlvblR5cGUnOiAnc3F1YXJlJyxcblx0ICAgICAgICAnaGFybW9uaWNpdHknOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd11cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1Pc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3Iuc3RhcnQodGltZSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5zdGFydCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RvcCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lIChvcHRpb25hbCkgdGltaW5nIHBhcmFtZXRlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GTU9zY2lsbGF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnN0b3AodGltZSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5zdG9wKHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBjYXJyaWVyIG9zY2lsbGF0b3Jcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GTU9zY2lsbGF0b3IucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2Fycmllci50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBtb2R1bGF0b3Igb3NjaWxsYXRvclxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBuYW1lIG1vZHVsYXRpb25UeXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GTU9zY2lsbGF0b3IucHJvdG90eXBlLCAnbW9kdWxhdGlvblR5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2R1bGF0b3IudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yIGluIGRlZ3JlZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRk1Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgcGhhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZNT3NjaWxsYXRvci5wcm90b3R5cGUsICdwaGFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIucGhhc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwaGFzZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9jYXJyaWVyLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZHVsYXRvci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSBjYXJyaWVyIHdhdmVmb3JtLiBBIHBhcnRpYWwgcmVwcmVzZW50cyBcblx0XHQgKiB0aGUgYW1wbGl0dWRlIGF0IGEgaGFybW9uaWMuIFRoZSBmaXJzdCBoYXJtb25pYyBpcyB0aGUgXG5cdFx0ICogZnVuZGFtZW50YWwgZnJlcXVlbmN5LCB0aGUgc2Vjb25kIGlzIHRoZSBvY3RhdmUgYW5kIHNvIG9uXG5cdFx0ICogZm9sbG93aW5nIHRoZSBoYXJtb25pYyBzZXJpZXMuIFxuXHRcdCAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSB0eXBlIHRvIFwiY3VzdG9tXCIuIFxuXHRcdCAqIFRoZSB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZSB0eXBlIGlzIG5vdCBcImN1c3RvbVwiLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBuYW1lIHBhcnRpYWxzXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBvc2MucGFydGlhbHMgPSBbMSwgMC4yLCAwLjAxXTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZNT3NjaWxsYXRvci5wcm90b3R5cGUsICdwYXJ0aWFscycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIucGFydGlhbHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJ0aWFscykge1xuXHQgICAgICAgICAgICB0aGlzLl9jYXJyaWVyLnBhcnRpYWxzID0gcGFydGlhbHM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuRk1Pc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZNT3NjaWxsYXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25JbmRleCcsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkluZGV4LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25JbmRleCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRk1Pc2NpbGxhdG9yO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5BTU9zY2lsbGF0b3IgXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuT3NjaWxsYXRvcn1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIHN0YXJ0aW5nIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRvci4gXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBjYXJyaWVyIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGF0aW9uVHlwZSBUaGUgdHlwZSBvZiB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9hIHNpbmUgb3NjaWxsYXRvciBmcmVxdWVuY3ktbW9kdWxhdGVkIGJ5IGEgc3F1YXJlIHdhdmVcblx0XHQgKiB2YXIgZm1Pc2MgPSBuZXcgVG9uZS5BTU9zY2lsbGF0b3IoXCJBYjNcIiwgXCJzaW5lXCIsIFwic3F1YXJlXCIpLnRvTWFzdGVyKCkuc3RhcnQoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1Pc2NpbGxhdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICd0eXBlJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25UeXBlJ1xuXHQgICAgICAgIF0sIFRvbmUuQU1Pc2NpbGxhdG9yKTtcblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYXJyaWVyIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbmV3IFRvbmUuT3NjaWxsYXRvcihvcHRpb25zLmZyZXF1ZW5jeSwgb3B0aW9ucy50eXBlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3NjaWxsYXRvcidzIGZyZXF1ZW5jeVxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSB0aGlzLl9jYXJyaWVyLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGNvbnRyb2wgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IHRoaXMuX2NhcnJpZXIuZGV0dW5lO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLnZhbHVlID0gb3B0aW9ucy5kZXR1bmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRpbmcgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKG9wdGlvbnMuZnJlcXVlbmN5LCBvcHRpb25zLm1vZHVsYXRpb25UeXBlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBjb252ZXJ0IHRoZSAtMSwxIG91dHB1dCB0byAwLDFcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BdWRpb1RvR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvblNjYWxlID0gbmV3IFRvbmUuQXVkaW9Ub0dhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgZnJlcXVlbmN5IHJhdGlvIGJldHdlZW4gdGhlIGNhcnJpZXIgYW5kIHRoZSBtb2R1bGF0b3Igb3NjaWxsYXRvcnMuIFxuXHRcdFx0ICogIEEgaGFybW9uaWNpdHkgb2YgMSBnaXZlcyBib3RoIG9zY2lsbGF0b3JzIHRoZSBzYW1lIGZyZXF1ZW5jeS4gXG5cdFx0XHQgKiAgSGFybW9uaWNpdHkgPSAyIG1lYW5zIGEgY2hhbmdlIG9mIGFuIG9jdGF2ZS4gXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogLy9waXRjaCB0aGUgbW9kdWxhdG9yIGFuIG9jdGF2ZSBiZWxvdyBjYXJyaWVyXG5cdFx0XHQgKiBzeW50aC5oYXJtb25pY2l0eS52YWx1ZSA9IDAuNTtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBuZXcgVG9uZS5NdWx0aXBseShvcHRpb25zLmhhcm1vbmljaXR5KTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LnVuaXRzID0gVG9uZS5UeXBlLlBvc2l0aXZlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBub2RlIHdoZXJlIHRoZSBtb2R1bGF0aW9uIGhhcHBlbnNcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZSA9IG5ldyBUb25lLkdhaW4oMCk7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNoYWluKHRoaXMuaGFybW9uaWNpdHksIHRoaXMuX21vZHVsYXRvci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLmNvbm5lY3QodGhpcy5fbW9kdWxhdG9yLmRldHVuZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLmNoYWluKHRoaXMuX21vZHVsYXRpb25TY2FsZSwgdGhpcy5fbW9kdWxhdGlvbk5vZGUuZ2Fpbik7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5jaGFpbih0aGlzLl9tb2R1bGF0aW9uTm9kZSwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMucGhhc2UgPSBvcHRpb25zLnBoYXNlO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnaGFybW9uaWNpdHknXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5BTU9zY2lsbGF0b3IsIFRvbmUuT3NjaWxsYXRvcik7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1Pc2NpbGxhdG9yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiA0NDAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ3BoYXNlJzogMCxcblx0ICAgICAgICAnbW9kdWxhdGlvblR5cGUnOiAnc3F1YXJlJyxcblx0ICAgICAgICAnaGFybW9uaWNpdHknOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd11cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1Pc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3Iuc3RhcnQodGltZSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5zdGFydCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RvcCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lIChvcHRpb25hbCkgdGltaW5nIHBhcmFtZXRlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BTU9zY2lsbGF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnN0b3AodGltZSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5zdG9wKHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBjYXJyaWVyIG9zY2lsbGF0b3Jcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5BTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BTU9zY2lsbGF0b3IucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2Fycmllci50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBtb2R1bGF0b3Igb3NjaWxsYXRvclxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkFNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIG1vZHVsYXRpb25UeXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BTU9zY2lsbGF0b3IucHJvdG90eXBlLCAnbW9kdWxhdGlvblR5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2R1bGF0b3IudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yIGluIGRlZ3JlZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQU1Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgcGhhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkFNT3NjaWxsYXRvci5wcm90b3R5cGUsICdwaGFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIucGhhc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwaGFzZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9jYXJyaWVyLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZHVsYXRvci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSBjYXJyaWVyIHdhdmVmb3JtLiBBIHBhcnRpYWwgcmVwcmVzZW50cyBcblx0XHQgKiB0aGUgYW1wbGl0dWRlIGF0IGEgaGFybW9uaWMuIFRoZSBmaXJzdCBoYXJtb25pYyBpcyB0aGUgXG5cdFx0ICogZnVuZGFtZW50YWwgZnJlcXVlbmN5LCB0aGUgc2Vjb25kIGlzIHRoZSBvY3RhdmUgYW5kIHNvIG9uXG5cdFx0ICogZm9sbG93aW5nIHRoZSBoYXJtb25pYyBzZXJpZXMuIFxuXHRcdCAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSB0eXBlIHRvIFwiY3VzdG9tXCIuIFxuXHRcdCAqIFRoZSB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZSB0eXBlIGlzIG5vdCBcImN1c3RvbVwiLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5BTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBuYW1lIHBhcnRpYWxzXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBvc2MucGFydGlhbHMgPSBbMSwgMC4yLCAwLjAxXTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkFNT3NjaWxsYXRvci5wcm90b3R5cGUsICdwYXJ0aWFscycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIucGFydGlhbHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJ0aWFscykge1xuXHQgICAgICAgICAgICB0aGlzLl9jYXJyaWVyLnBhcnRpYWxzID0gcGFydGlhbHM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuQU1Pc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkFNT3NjaWxsYXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnaGFybW9uaWNpdHknXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uU2NhbGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25TY2FsZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQU1Pc2NpbGxhdG9yO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5GYXRPc2NpbGxhdG9yIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNvdXJjZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIHN0YXJ0aW5nIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRvci4gXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBjYXJyaWVyIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGF0aW9uVHlwZSBUaGUgdHlwZSBvZiB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9hIHNpbmUgb3NjaWxsYXRvciBmcmVxdWVuY3ktbW9kdWxhdGVkIGJ5IGEgc3F1YXJlIHdhdmVcblx0XHQgKiB2YXIgZm1Pc2MgPSBuZXcgVG9uZS5GYXRPc2NpbGxhdG9yKFwiQWIzXCIsIFwic2luZVwiLCBcInNxdWFyZVwiKS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkZhdE9zY2lsbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ3R5cGUnLFxuXHQgICAgICAgICAgICAnc3ByZWFkJ1xuXHQgICAgICAgIF0sIFRvbmUuRmF0T3NjaWxsYXRvcik7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3NjaWxsYXRvcidzIGZyZXF1ZW5jeVxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5mcmVxdWVuY3ksIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXR1bmUgY29udHJvbCBzaWduYWwuXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZGV0dW5lLCBUb25lLlR5cGUuQ2VudHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhcnJheSBvZiBvc2NpbGxhdG9yc1xuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvcnMgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdG90YWwgc3ByZWFkIG9mIHRoZSBvc2NpbGxhdG9yc1xuXHRcdFx0ICogIEB0eXBlICB7Q2VudHN9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NwcmVhZCA9IG9wdGlvbnMuc3ByZWFkO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB0eXBlIG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGhhc2Ugb2YgdGhlIG9zY2lsbGF0b3JzXG5cdFx0XHQgKiAgQHR5cGUge0RlZ3JlZXN9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BoYXNlID0gb3B0aW9ucy5waGFzZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGFydGlhbHMgYXJyYXlcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhcnRpYWxzID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMucGFydGlhbHMsIFtdKTtcblx0ICAgICAgICAvL3NldCB0aGUgY291bnQgaW5pdGlhbGx5XG5cdCAgICAgICAgdGhpcy5jb3VudCA9IG9wdGlvbnMuY291bnQ7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZhdE9zY2lsbGF0b3IsIFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5GYXRPc2NpbGxhdG9yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiA0NDAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ3BoYXNlJzogMCxcblx0ICAgICAgICAnc3ByZWFkJzogMjAsXG5cdCAgICAgICAgJ2NvdW50JzogMyxcblx0ICAgICAgICAndHlwZSc6ICdzYXd0b290aCdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgb3NjLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdG9wIHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWUgKG9wdGlvbmFsKSB0aW1pbmcgcGFyYW1ldGVyXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZhdE9zY2lsbGF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjKSB7XG5cdCAgICAgICAgICAgIG9zYy5zdG9wKHRpbWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgYWxsIG9mIHRoZSBvc2NpbGxhdG9yc1xuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGl0ZXJhdG9yICBUaGUgaXRlcmF0b3IgZnVuY3Rpb25cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRmF0T3NjaWxsYXRvci5wcm90b3R5cGUuX2ZvckVhY2ggPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29zY2lsbGF0b3JzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwodGhpcywgdGhpcy5fb3NjaWxsYXRvcnNbaV0sIGkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgY2FycmllciBvc2NpbGxhdG9yXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRmF0T3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZhdE9zY2lsbGF0b3IucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgICAgIG9zYy50eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZGV0dW5lIHNwcmVhZCBiZXR3ZWVuIHRoZSBvc2NpbGxhdG9ycy4gSWYgXCJjb3VudFwiIGlzXG5cdFx0ICogc2V0IHRvIDMgb3NjaWxsYXRvcnMgYW5kIHRoZSBcInNwcmVhZFwiIGlzIHNldCB0byA0MCxcblx0XHQgKiB0aGUgdGhyZWUgb3NjaWxsYXRvcnMgd291bGQgYmUgZGV0dW5lZCBsaWtlIHRoaXM6IFstMjAsIDAsIDIwXVxuXHRcdCAqIGZvciBhIHRvdGFsIGRldHVuZSBzcHJlYWQgb2YgNDAgY2VudHMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRmF0T3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7Q2VudHN9XG5cdFx0ICogQG5hbWUgc3ByZWFkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3NwcmVhZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NwcmVhZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNwcmVhZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zcHJlYWQgPSBzcHJlYWQ7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9vc2NpbGxhdG9ycy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSAtc3ByZWFkIC8gMjtcblx0ICAgICAgICAgICAgICAgIHZhciBzdGVwID0gc3ByZWFkIC8gKHRoaXMuX29zY2lsbGF0b3JzLmxlbmd0aCAtIDEpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjLCBpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3NjLmRldHVuZS52YWx1ZSA9IHN0YXJ0ICsgc3RlcCAqIGk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBkZXR1bmVkIG9zY2lsbGF0b3JzXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRmF0T3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIGNvdW50XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ2NvdW50Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvcnMubGVuZ3RoO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoY291bnQpIHtcblx0ICAgICAgICAgICAgY291bnQgPSBNYXRoLm1heChjb3VudCwgMSk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9vc2NpbGxhdG9ycy5sZW5ndGggIT09IGNvdW50KSB7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgcGFydGlhbHMgPSB0aGlzLnBhcnRpYWxzO1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cdCAgICAgICAgICAgICAgICAvL2Rpc3Bvc2UgdGhlIHByZXZpb3VzIG9zY2lsbGF0b3JzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvc2MuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9ycyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9zYyA9IG5ldyBUb25lLk9zY2lsbGF0b3IoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBUb25lLk9zY2lsbGF0b3IuVHlwZS5DdXN0b20pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3NjLnBhcnRpYWxzID0gdGhpcy5fcGFydGlhbHM7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3NjLnR5cGUgPSB0aGlzLl90eXBlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBvc2MucGhhc2UgPSB0aGlzLl9waGFzZTtcblx0ICAgICAgICAgICAgICAgICAgICBvc2Mudm9sdW1lLnZhbHVlID0gLTYgLSBjb3VudDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KG9zYy5mcmVxdWVuY3kpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0dW5lLmNvbm5lY3Qob3NjLmRldHVuZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgb3NjLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3JzW2ldID0gb3NjO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy9zZXQgdGhlIHNwcmVhZFxuXHQgICAgICAgICAgICAgICAgdGhpcy5zcHJlYWQgPSB0aGlzLl9zcHJlYWQ7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9zYy5zdGFydCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGhhc2Ugb2YgdGhlIG9zY2lsbGF0b3IgaW4gZGVncmVlcy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GYXRPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgcGhhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZhdE9zY2lsbGF0b3IucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9waGFzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBoYXNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKG9zYykge1xuXHQgICAgICAgICAgICAgICAgb3NjLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSBjYXJyaWVyIHdhdmVmb3JtLiBBIHBhcnRpYWwgcmVwcmVzZW50cyBcblx0XHQgKiB0aGUgYW1wbGl0dWRlIGF0IGEgaGFybW9uaWMuIFRoZSBmaXJzdCBoYXJtb25pYyBpcyB0aGUgXG5cdFx0ICogZnVuZGFtZW50YWwgZnJlcXVlbmN5LCB0aGUgc2Vjb25kIGlzIHRoZSBvY3RhdmUgYW5kIHNvIG9uXG5cdFx0ICogZm9sbG93aW5nIHRoZSBoYXJtb25pYyBzZXJpZXMuIFxuXHRcdCAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSB0eXBlIHRvIFwiY3VzdG9tXCIuIFxuXHRcdCAqIFRoZSB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZSB0eXBlIGlzIG5vdCBcImN1c3RvbVwiLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GYXRPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAbmFtZSBwYXJ0aWFsc1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogb3NjLnBhcnRpYWxzID0gWzEsIDAuMiwgMC4wMV07XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BhcnRpYWxzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFydGlhbHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJ0aWFscykge1xuXHQgICAgICAgICAgICB0aGlzLl9wYXJ0aWFscyA9IHBhcnRpYWxzO1xuXHQgICAgICAgICAgICB0aGlzLl90eXBlID0gVG9uZS5Pc2NpbGxhdG9yLlR5cGUuQ3VzdG9tO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgICAgIG9zYy5wYXJ0aWFscyA9IHBhcnRpYWxzO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5GYXRPc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZhdE9zY2lsbGF0b3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgb3NjLmRpc3Bvc2UoKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9ycyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcGFydGlhbHMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZhdE9zY2lsbGF0b3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLk9tbmlPc2NpbGxhdG9yIGFnZ3JlZ2F0ZXMgVG9uZS5Pc2NpbGxhdG9yLCBUb25lLlB1bHNlT3NjaWxsYXRvcixcblx0XHQgKiAgICAgICAgIFRvbmUuUFdNT3NjaWxsYXRvciwgVG9uZS5GTU9zY2lsbGF0b3IsIFRvbmUuQU1Pc2NpbGxhdG9yLCBhbmQgVG9uZS5GYXRPc2NpbGxhdG9yXG5cdFx0ICogICAgICAgICBpbnRvIG9uZSBjbGFzcy4gVGhlIG9zY2lsbGF0b3IgY2xhc3MgY2FuIGJlIGNoYW5nZWQgYnkgc2V0dGluZyB0aGUgYHR5cGVgLiBcblx0XHQgKiAgICAgICAgIGBvbW5pT3NjLnR5cGUgPSBcInB3bVwiYCB3aWxsIHNldCBpdCB0byB0aGUgVG9uZS5QV01Pc2NpbGxhdG9yLiBQcmVmaXhpbmdcblx0XHQgKiAgICAgICAgIGFueSBvZiB0aGUgYmFzaWMgdHlwZXMgKFwic2luZVwiLCBcInNxdWFyZTRcIiwgZXRjLikgd2l0aCBcImZtXCIsIFwiYW1cIiwgb3IgXCJmYXRcIlxuXHRcdCAqICAgICAgICAgd2lsbCB1c2UgdGhlIEZNT3NjaWxsYXRvciwgQU1Pc2NpbGxhdG9yIG9yIEZhdE9zY2lsbGF0b3IgcmVzcGVjdGl2ZWx5LiBcblx0XHQgKiAgICAgICAgIEZvciBleGFtcGxlOiBgb21uaU9zYy50eXBlID0gXCJmYXRzYXd0b290aFwiYCB3aWxsIGNyZWF0ZSBzZXQgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgICAgICAgIHRvIGEgRmF0T3NjaWxsYXRvciBvZiB0eXBlIFwic2F3dG9vdGhcIi4gXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU291cmNlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IGZyZXF1ZW5jeSBUaGUgaW5pdGlhbCBmcmVxdWVuY3kgb2YgdGhlIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBvc2NpbGxhdG9yLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICB2YXIgb21uaU9zYyA9IG5ldyBUb25lLk9tbmlPc2NpbGxhdG9yKFwiQyM0XCIsIFwicHdtXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5PbW5pT3NjaWxsYXRvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAndHlwZSdcblx0ICAgICAgICBdLCBUb25lLk9tbmlPc2NpbGxhdG9yKTtcblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGNvbnRyb2xcblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXR1bmUsIFRvbmUuVHlwZS5DZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHR5cGUgb2YgdGhlIG9zY2lsbGF0b3Igc291cmNlXG5cdFx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc291cmNlVHlwZSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIC8vc2V0IHRoZSBvc2NpbGxhdG9yXG5cdCAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgLy9zZXQgdGhlIG9wdGlvbnNcblx0ICAgICAgICB0aGlzLnNldChvcHRpb25zKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk9tbmlPc2NpbGxhdG9yLCBUb25lLlNvdXJjZSk7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuT21uaU9zY2lsbGF0b3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDQ0MCxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJyxcblx0ICAgICAgICAncGhhc2UnOiAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEBlbnVtIHtTdHJpbmd9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICB2YXIgT21uaU9zY1R5cGUgPSB7XG5cdCAgICAgICAgUHVsc2U6ICdQdWxzZU9zY2lsbGF0b3InLFxuXHQgICAgICAgIFBXTTogJ1BXTU9zY2lsbGF0b3InLFxuXHQgICAgICAgIE9zYzogJ09zY2lsbGF0b3InLFxuXHQgICAgICAgIEZNOiAnRk1Pc2NpbGxhdG9yJyxcblx0ICAgICAgICBBTTogJ0FNT3NjaWxsYXRvcicsXG5cdCAgICAgICAgRmF0OiAnRmF0T3NjaWxsYXRvcidcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRvIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3RhcnQodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0byBzdGFydCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3RvcCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgb3NjaWxsYXRvci4gQ2FuIGJlIGFueSBvZiB0aGUgYmFzaWMgdHlwZXM6IHNpbmUsIHNxdWFyZSwgdHJpYW5nbGUsIHNhd3Rvb3RoLiBPclxuXHRcdCAqIHByZWZpeCB0aGUgYmFzaWMgdHlwZXMgd2l0aCBcImZtXCIsIFwiYW1cIiwgb3IgXCJmYXRcIiB0byB1c2UgdGhlIEZNT3NjaWxsYXRvciwgQU1Pc2NpbGxhdG9yIG9yIEZhdE9zY2lsbGF0b3Jcblx0XHQgKiB0eXBlcy4gVGhlIG9zY2lsbGF0b3IgY291bGQgYWxzbyBiZSBzZXQgdG8gXCJwd21cIiBvciBcInB1bHNlXCIuIEFsbCBvZiB0aGUgcGFyYW1ldGVycyBvZiB0aGVcblx0XHQgKiBvc2NpbGxhdG9yJ3MgY2xhc3MgYXJlIGFjY2Vzc2libGUgd2hlbiB0aGUgb3NjaWxsYXRvciBpcyBzZXQgdG8gdGhhdCB0eXBlLCBidXQgdGhyb3dzIGFuIGVycm9yIFxuXHRcdCAqIHdoZW4gaXQncyBub3QuXG5cdFx0ICogXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT21uaU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBvbW5pT3NjLnR5cGUgPSBcInB3bVwiO1xuXHRcdCAqIC8vbW9kdWxhdGlvbkZyZXF1ZW5jeSBpcyBwYXJhbWV0ZXIgd2hpY2ggaXMgYXZhaWxhYmxlXG5cdFx0ICogLy9vbmx5IHdoZW4gdGhlIHR5cGUgaXMgXCJwd21cIi4gXG5cdFx0ICogb21uaU9zYy5tb2R1bGF0aW9uRnJlcXVlbmN5LnZhbHVlID0gMC41O1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9hbiBzcXVhcmUgd2F2ZSBmcmVxdWVuY3kgbW9kdWxhdGVkIGJ5IGEgc2F3dG9vdGhcblx0XHQgKiBvbW5pT3NjLnR5cGUgPSBcImZtc3F1YXJlXCI7XG5cdFx0ICogb21uaU9zYy5tb2R1bGF0aW9uVHlwZSA9IFwic2F3dG9vdGhcIjtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwcmVmaXggPSAnJztcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkZNKSB7XG5cdCAgICAgICAgICAgICAgICBwcmVmaXggPSAnZm0nO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkFNKSB7XG5cdCAgICAgICAgICAgICAgICBwcmVmaXggPSAnYW0nO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkZhdCkge1xuXHQgICAgICAgICAgICAgICAgcHJlZml4ID0gJ2ZhdCc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIHRoaXMuX29zY2lsbGF0b3IudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpID09PSAnZm0nKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVOZXdPc2NpbGxhdG9yKE9tbmlPc2NUeXBlLkZNKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IudHlwZSA9IHR5cGUuc3Vic3RyKDIpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUuc3Vic3RyKDAsIDIpID09PSAnYW0nKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVOZXdPc2NpbGxhdG9yKE9tbmlPc2NUeXBlLkFNKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IudHlwZSA9IHR5cGUuc3Vic3RyKDIpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUuc3Vic3RyKDAsIDMpID09PSAnZmF0Jykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlTmV3T3NjaWxsYXRvcihPbW5pT3NjVHlwZS5GYXQpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci50eXBlID0gdHlwZS5zdWJzdHIoMyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3B3bScpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU5ld09zY2lsbGF0b3IoT21uaU9zY1R5cGUuUFdNKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncHVsc2UnKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVOZXdPc2NpbGxhdG9yKE9tbmlPc2NUeXBlLlB1bHNlKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU5ld09zY2lsbGF0b3IoT21uaU9zY1R5cGUuT3NjKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IudHlwZSA9IHR5cGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwYXJ0aWFscyBvZiB0aGUgd2F2ZWZvcm0uIEEgcGFydGlhbCByZXByZXNlbnRzIFxuXHRcdCAqIHRoZSBhbXBsaXR1ZGUgYXQgYSBoYXJtb25pYy4gVGhlIGZpcnN0IGhhcm1vbmljIGlzIHRoZSBcblx0XHQgKiBmdW5kYW1lbnRhbCBmcmVxdWVuY3ksIHRoZSBzZWNvbmQgaXMgdGhlIG9jdGF2ZSBhbmQgc28gb25cblx0XHQgKiBmb2xsb3dpbmcgdGhlIGhhcm1vbmljIHNlcmllcy4gXG5cdFx0ICogU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBzZXQgdGhlIHR5cGUgdG8gXCJjdXN0b21cIi4gXG5cdFx0ICogVGhlIHZhbHVlIGlzIGFuIGVtcHR5IGFycmF5IHdoZW4gdGhlIHR5cGUgaXMgbm90IFwiY3VzdG9tXCIuIFxuXHRcdCAqIFRoaXMgaXMgbm90IGF2YWlsYWJsZSBvbiBcInB3bVwiIGFuZCBcInB1bHNlXCIgb3NjaWxsYXRvciB0eXBlcy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQG5hbWUgcGFydGlhbHNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIG9zYy5wYXJ0aWFscyA9IFsxLCAwLjIsIDAuMDFdO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT21uaU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGFydGlhbHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLnBhcnRpYWxzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGFydGlhbHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5wYXJ0aWFscyA9IHBhcnRpYWxzO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCBhIG1lbWJlci9hdHRyaWJ1dGUgb2YgdGhlIG9zY2lsbGF0b3IuIFxuXHRcdCAqICBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHBhcmFtc1xuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IHZhbHVlXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IHJhbXBUaW1lXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk9tbmlPc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZSkge1xuXHQgICAgICAgIC8vbWFrZSBzdXJlIHRoZSB0eXBlIGlzIHNldCBmaXJzdFxuXHQgICAgICAgIGlmIChwYXJhbXMgPT09ICd0eXBlJykge1xuXHQgICAgICAgICAgICB0aGlzLnR5cGUgPSB2YWx1ZTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNPYmplY3QocGFyYW1zKSAmJiBwYXJhbXMuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSkge1xuXHQgICAgICAgICAgICB0aGlzLnR5cGUgPSBwYXJhbXMudHlwZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy90aGVuIHNldCB0aGUgcmVzdFxuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjb25uZWN0IHRoZSBvc2NpbGxhdG9yIHRvIHRoZSBmcmVxdWVuY3kgYW5kIGRldHVuZSBzaWduYWxzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZS5fY3JlYXRlTmV3T3NjaWxsYXRvciA9IGZ1bmN0aW9uIChvc2NUeXBlKSB7XG5cdCAgICAgICAgaWYgKG9zY1R5cGUgIT09IHRoaXMuX3NvdXJjZVR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlVHlwZSA9IG9zY1R5cGU7XG5cdCAgICAgICAgICAgIHZhciBPc2NpbGxhdG9yQ29uc3RydWN0b3IgPSBUb25lW29zY1R5cGVdO1xuXHQgICAgICAgICAgICAvL3Nob3J0IGRlbGF5IHRvIGF2b2lkIGNsaWNrcyBvbiB0aGUgY2hhbmdlXG5cdCAgICAgICAgICAgIHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fb3NjaWxsYXRvciAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9sZE9zYyA9IHRoaXMuX29zY2lsbGF0b3I7XG5cdCAgICAgICAgICAgICAgICBvbGRPc2Muc3RvcChub3cpO1xuXHQgICAgICAgICAgICAgICAgLy9kaXNwb3NlIHRoZSBvbGQgb25lXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb2xkT3NjLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgICAgICAgICBvbGRPc2MgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgfSwgdGhpcy5ibG9ja1RpbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBuZXcgT3NjaWxsYXRvckNvbnN0cnVjdG9yKCk7XG5cdCAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fb3NjaWxsYXRvci5mcmVxdWVuY3kpO1xuXHQgICAgICAgICAgICB0aGlzLmRldHVuZS5jb25uZWN0KHRoaXMuX29zY2lsbGF0b3IuZGV0dW5lKTtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zdGFydChub3cpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwaGFzZSBvZiB0aGUgb3NjaWxsYXRvciBpbiBkZWdyZWVzLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7RGVncmVlc31cblx0XHQgKiBAbmFtZSBwaGFzZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT21uaU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLnBoYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHdpZHRoIG9mIHRoZSBvc2NpbGxhdG9yIChvbmx5IGlmIHRoZSBvc2NpbGxhdG9yIGlzIHNldCB0byBcInB1bHNlXCIpXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT21uaU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqIEBzaWduYWxcblx0XHQgKiBAbmFtZSB3aWR0aFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogdmFyIG9tbmlPc2MgPSBuZXcgVG9uZS5PbW5pT3NjaWxsYXRvcig0NDAsIFwicHVsc2VcIik7XG5cdFx0ICogLy9jYW4gYWNjZXNzIHRoZSB3aWR0aCBhdHRyaWJ1dGUgb25seSBpZiB0eXBlID09PSBcInB1bHNlXCJcblx0XHQgKiBvbW5pT3NjLndpZHRoLnZhbHVlID0gMC4yOyBcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3dpZHRoJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuUHVsc2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLndpZHRoO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGRldHVuZWQgb3NjaWxsYXRvcnNcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIGNvdW50XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUsICdjb3VudCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkZhdCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29zY2lsbGF0b3IuY291bnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGNvdW50KSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GYXQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IuY291bnQgPSBjb3VudDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGRldHVuZSBzcHJlYWQgYmV0d2VlbiB0aGUgb3NjaWxsYXRvcnMuIElmIFwiY291bnRcIiBpc1xuXHRcdCAqIHNldCB0byAzIG9zY2lsbGF0b3JzIGFuZCB0aGUgXCJzcHJlYWRcIiBpcyBzZXQgdG8gNDAsXG5cdFx0ICogdGhlIHRocmVlIG9zY2lsbGF0b3JzIHdvdWxkIGJlIGRldHVuZWQgbGlrZSB0aGlzOiBbLTIwLCAwLCAyMF1cblx0XHQgKiBmb3IgYSB0b3RhbCBkZXR1bmUgc3ByZWFkIG9mIDQwIGNlbnRzLiBTZWUgVG9uZS5GYXRPc2NpbGxhdG9yXG5cdFx0ICogZm9yIG1vcmUgaW5mby5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7Q2VudHN9XG5cdFx0ICogQG5hbWUgc3ByZWFkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUsICdzcHJlYWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GYXQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLnNwcmVhZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc3ByZWFkKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GYXQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3ByZWFkID0gc3ByZWFkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3IuIE9ubHkgaWYgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiBpcyBzZXQgdG8gXCJhbVwiIG9yIFwiZm1cIiB0eXBlcy4gc2VlLiBUb25lLkFNT3NjaWxsYXRvciBvciBUb25lLkZNT3NjaWxsYXRvclxuXHRcdCAqIGZvciBtb3JlIGluZm8uIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk9tbmlPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQG5hbWUgbW9kdWxhdGlvblR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ21vZHVsYXRpb25UeXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuRk0gfHwgdGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuQU0pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLm1vZHVsYXRpb25UeXBlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtVHlwZSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuRk0gfHwgdGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuQU0pIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IubW9kdWxhdGlvblR5cGUgPSBtVHlwZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1vZHVsYXRpb24gaW5kZXggd2hpY2ggaXMgaW4gZXNzZW5jZSB0aGUgZGVwdGggb3IgYW1vdW50IG9mIHRoZSBtb2R1bGF0aW9uLiBJbiBvdGhlciB0ZXJtcyBpdCBpcyB0aGUgXG5cdFx0ICogcmF0aW8gb2YgdGhlIGZyZXF1ZW5jeSBvZiB0aGUgbW9kdWxhdGluZyBzaWduYWwgKG1mKSB0byB0aGUgYW1wbGl0dWRlIG9mIHRoZSBcblx0XHQgKiBtb2R1bGF0aW5nIHNpZ25hbCAobWEpIC0tIGFzIGluIG1hL21mLiBcblx0XHQgKiBTZWUgVG9uZS5GTU9zY2lsbGF0b3IgZm9yIG1vcmUgaW5mby4gXG5cdFx0ICogQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqIEBzaWduYWxcblx0XHQgKiBAbmFtZSBtb2R1bGF0aW9uSW5kZXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ21vZHVsYXRpb25JbmRleCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkZNKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci5tb2R1bGF0aW9uSW5kZXg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgZnJlcXVlbmN5IHJhdGlvIGJldHdlZW4gdGhlIGNhcnJpZXIgYW5kIHRoZSBtb2R1bGF0b3Igb3NjaWxsYXRvcnMuIFxuXHRcdCAqICBBIGhhcm1vbmljaXR5IG9mIDEgZ2l2ZXMgYm90aCBvc2NpbGxhdG9ycyB0aGUgc2FtZSBmcmVxdWVuY3kuIFxuXHRcdCAqICBIYXJtb25pY2l0eSA9IDIgbWVhbnMgYSBjaGFuZ2Ugb2YgYW4gb2N0YXZlLiBTZWUgVG9uZS5BTU9zY2lsbGF0b3Igb3IgVG9uZS5GTU9zY2lsbGF0b3Jcblx0XHQgKiAgZm9yIG1vcmUgaW5mby4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLk9tbmlPc2NpbGxhdG9yI1xuXHRcdCAqICBAc2lnbmFsXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgaGFybW9uaWNpdHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ2hhcm1vbmljaXR5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuRk0gfHwgdGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuQU0pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLmhhcm1vbmljaXR5O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbW9kdWxhdGlvbkZyZXF1ZW5jeSBTaWduYWwgb2YgdGhlIG9zY2lsbGF0b3IgXG5cdFx0ICogKG9ubHkgaWYgdGhlIG9zY2lsbGF0b3IgdHlwZSBpcyBzZXQgdG8gcHdtKS4gU2VlIFxuXHRcdCAqIFRvbmUuUFdNT3NjaWxsYXRvciBmb3IgbW9yZSBpbmZvLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdCAqIEBzaWduYWxcblx0XHQgKiBAbmFtZSBtb2R1bGF0aW9uRnJlcXVlbmN5XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiB2YXIgb21uaU9zYyA9IG5ldyBUb25lLk9tbmlPc2NpbGxhdG9yKDQ0MCwgXCJwd21cIik7XG5cdFx0ICogLy9jYW4gYWNjZXNzIHRoZSBtb2R1bGF0aW9uRnJlcXVlbmN5IGF0dHJpYnV0ZSBvbmx5IGlmIHR5cGUgPT09IFwicHdtXCJcblx0XHQgKiBvbW5pT3NjLm1vZHVsYXRpb25GcmVxdWVuY3kudmFsdWUgPSAwLjI7IFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT21uaU9zY2lsbGF0b3IucHJvdG90eXBlLCAnbW9kdWxhdGlvbkZyZXF1ZW5jeScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLlBXTSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29zY2lsbGF0b3IubW9kdWxhdGlvbkZyZXF1ZW5jeTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLk9tbmlPc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc291cmNlVHlwZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuT21uaU9zY2lsbGF0b3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQmFzZS1jbGFzcyBmb3IgYWxsIGluc3RydW1lbnRzXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuSW5zdHJ1bWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgLy9nZXQgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLkluc3RydW1lbnQuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG91dHB1dCBhbmQgdm9sdW1lIHRyaW1pbmcgbm9kZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Wb2x1bWV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuVm9sdW1lKG9wdGlvbnMudm9sdW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSB2b2x1bWUgb2YgdGhlIG91dHB1dCBpbiBkZWNpYmVscy5cblx0XHRcdCAqIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBzb3VyY2Uudm9sdW1lLnZhbHVlID0gLTY7XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IHRoaXMuX3ZvbHVtZS52b2x1bWU7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ3ZvbHVtZScpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuSW5zdHJ1bWVudCwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IGF0dHJpYnV0ZXNcblx0XHQgKiAgQHR5cGUge29iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuSW5zdHJ1bWVudC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAvKiogdGhlIHZvbHVtZSBvZiB0aGUgb3V0cHV0IGluIGRlY2liZWxzICovXG5cdCAgICAgICAgJ3ZvbHVtZSc6IDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQGFic3RyYWN0XG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbm90ZSB0aGUgbm90ZSB0byB0cmlnZ2VyXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0byB0cmlnZ2VyIHRoZSBudG9lXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbdmVsb2NpdHk9MV0gdGhlIHZlbG9jaXR5IHRvIHRyaWdnZXIgdGhlIG5vdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IFRvbmUubm9PcDtcblx0ICAgIC8qKlxuXHRcdCAqICBAYWJzdHJhY3Rcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIHdoZW4gdG8gdHJpZ2dlciB0aGUgcmVsZWFzZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS50cmlnZ2VyUmVsZWFzZSA9IFRvbmUubm9PcDtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBhdHRhY2sgYW5kIHRoZW4gdGhlIHJlbGVhc2UgYWZ0ZXIgdGhlIGR1cmF0aW9uLlxuXHRcdCAqICBAcGFyYW0gIHtGcmVxdWVuY3l9IG5vdGUgICAgIFRoZSBub3RlIHRvIHRyaWdnZXIuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGR1cmF0aW9uIEhvdyBsb25nIHRoZSBub3RlIHNob3VsZCBiZSBoZWxkIGZvciBiZWZvcmVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmluZyB0aGUgcmVsZWFzZS4gVGhpcyB2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gIFdoZW4gdGhlIG5vdGUgc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHBhcmFtICB7Tm9ybWFsUmFuZ2V9IFt2ZWxvY2l0eT0xXSBUaGUgdmVsb2NpdHkgdGhlIG5vdGUgc2hvdWxkIGJlIHRyaWdnZXJlZCBhdC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuSW5zdHJ1bWVudH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdHJpZ2dlciBcIkM0XCIgZm9yIHRoZSBkdXJhdGlvbiBvZiBhbiA4dGggbm90ZVxuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzRcIiwgXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUudHJpZ2dlckF0dGFja1JlbGVhc2UgPSBmdW5jdGlvbiAobm90ZSwgZHVyYXRpb24sIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGR1cmF0aW9uID0gdGhpcy50b1NlY29uZHMoZHVyYXRpb24pO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlckF0dGFjayhub3RlLCB0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyUmVsZWFzZSh0aW1lICsgZHVyYXRpb24pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5JbnN0cnVtZW50fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkluc3RydW1lbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoWyd2b2x1bWUnXSk7XG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkluc3RydW1lbnQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBvdGhlciBtb25vcGhvbmljIGluc3RydW1lbnRzIHRvIFxuXHRcdCAqICAgICAgICAgIGV4dGVuZC4gSU1QT1JUQU5UOiBJdCBkb2VzIG5vdCBtYWtlIGFueSBzb3VuZCBvbiBpdHMgb3duIGFuZFxuXHRcdCAqICAgICAgICAgIHNob3VsZG4ndCBiZSBkaXJlY3RseSBpbnN0YW50aWF0ZWQuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBhYnN0cmFjdFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5JbnN0cnVtZW50fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vcGhvbmljID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICAvL2dldCB0aGUgZGVmYXVsdHNcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuTW9ub3Bob25pYy5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5JbnN0cnVtZW50LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGdsaWRlIHRpbWUgYmV0d2VlbiBub3Rlcy4gXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnBvcnRhbWVudG8gPSBvcHRpb25zLnBvcnRhbWVudG87XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Nb25vcGhvbmljLCBUb25lLkluc3RydW1lbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9waG9uaWMuZGVmYXVsdHMgPSB7ICdwb3J0YW1lbnRvJzogMCB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIGF0dGFjayBvZiB0aGUgbm90ZSBvcHRpb25hbGx5IHdpdGggYSBnaXZlbiB2ZWxvY2l0eS4gXG5cdFx0ICogIFxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7RnJlcXVlbmN5fSBub3RlICAgICBUaGUgbm90ZSB0byB0cmlnZ2VyLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddICAgICBXaGVuIHRoZSBub3RlIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSBbdmVsb2NpdHk9MV0gdmVsb2NpdHkgVGhlIHZlbG9jaXR5IHNjYWxlciBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lcyBob3cgXCJsb3VkXCIgdGhlIG5vdGUgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgdHJpZ2dlcmVkLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Nb25vcGhvbmljfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFjayhcIkM0XCIpO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdHJpZ2dlciB0aGUgbm90ZSBhIGhhbGYgc2Vjb25kIGZyb20gbm93IGF0IGhhbGYgdmVsb2NpdHlcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrKFwiQzRcIiwgXCIrMC41XCIsIDAuNSk7XG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAobm90ZSwgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fdHJpZ2dlckVudmVsb3BlQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLnNldE5vdGUobm90ZSwgdGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBJZiBubyB0aW1lIGlzIGdpdmVuLCB0aGUgcmVsZWFzZSBoYXBwZW5zIGltbWVkaWF0bHlcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9ub3Bob25pY30gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHN5bnRoLnRyaWdnZXJSZWxlYXNlKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fdHJpZ2dlckVudmVsb3BlUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgd2l0aCB0aGUgYWN0dWFsIG1ldGhvZFxuXHRcdCAqICBAYWJzdHJhY3Rcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub3Bob25pYy5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZUF0dGFjayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgd2l0aCB0aGUgYWN0dWFsIG1ldGhvZFxuXHRcdCAqICBAYWJzdHJhY3Rcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub3Bob25pYy5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZVJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCB0aGUgbm90ZSBhdCB0aGUgZ2l2ZW4gdGltZS4gSWYgbm8gdGltZSBpcyBnaXZlbiwgdGhlIG5vdGVcblx0XHQgKiAgd2lsbCBzZXQgaW1tZWRpYXRlbHkuIFxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gbm90ZSBUaGUgbm90ZSB0byBjaGFuZ2UgdG8uXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gVGhlIHRpbWUgd2hlbiB0aGUgbm90ZSBzaG91bGQgYmUgc2V0LiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9ub3Bob25pY30gdGhpc1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9jaGFuZ2UgdG8gRiM2IGluIG9uZSBxdWFydGVyIG5vdGUgZnJvbSBub3cuXG5cdFx0ICogc3ludGguc2V0Tm90ZShcIkYjNlwiLCBcIis0blwiKTtcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vY2hhbmdlIHRvIEJiNCByaWdodCBub3dcblx0XHQgKiBzeW50aC5zZXROb3RlKFwiQmI0XCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS5zZXROb3RlID0gZnVuY3Rpb24gKG5vdGUsIHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgaWYgKHRoaXMucG9ydGFtZW50byA+IDApIHtcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnROb3RlID0gdGhpcy5mcmVxdWVuY3kudmFsdWU7XG5cdCAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKGN1cnJlbnROb3RlLCB0aW1lKTtcblx0ICAgICAgICAgICAgdmFyIHBvcnRUaW1lID0gdGhpcy50b1NlY29uZHModGhpcy5wb3J0YW1lbnRvKTtcblx0ICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3kuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZShub3RlLCB0aW1lICsgcG9ydFRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKG5vdGUsIHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Nb25vcGhvbmljO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuU3ludGggaXMgY29tcG9zZWQgc2ltcGx5IG9mIGEgVG9uZS5PbW5pT3NjaWxsYXRvclxuXHRcdCAqICAgICAgICAgIHJvdXRlZCB0aHJvdWdoIGEgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZS4gXG5cdFx0ICogICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kcmF3aW5ncy9kLzEtMV8wWVcyWjFKMkVQSTM2UDhmTkNNY1pHN04xdzFHWmx1UHM0b2c0ZXZvL3B1Yj93PTExNjMmaD0yMzFcIj5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuTW9ub3Bob25pY31cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoZSBzeW50aCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFRvbmUuU3ludGgoKS50b01hc3RlcigpO1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzRcIiwgXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuU3ludGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIC8vZ2V0IHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5TeW50aC5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG9zY2lsbGF0b3IuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT21uaU9zY2lsbGF0b3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSBuZXcgVG9uZS5PbW5pT3NjaWxsYXRvcihvcHRpb25zLm9zY2lsbGF0b3IpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gdGhpcy5vc2NpbGxhdG9yLmRldHVuZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkFtcGxpdHVkZUVudmVsb3BlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG5ldyBUb25lLkFtcGxpdHVkZUVudmVsb3BlKG9wdGlvbnMuZW52ZWxvcGUpO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgb3NjaWxsYXRvcnMgdG8gdGhlIG91dHB1dFxuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvci5jaGFpbih0aGlzLmVudmVsb3BlLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgLy9zdGFydCB0aGUgb3NjaWxsYXRvcnNcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3Iuc3RhcnQoKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TeW50aCwgVG9uZS5Nb25vcGhvbmljKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnb3NjaWxsYXRvcic6IHsgJ3R5cGUnOiAndHJpYW5nbGUnIH0sXG5cdCAgICAgICAgJ2VudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC4wMDUsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAuMSxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nOiAwLjMsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIGF0dGFjayBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFt2ZWxvY2l0eT0xXSB0aGUgdmVsb2NpdHkgb2YgdGhlIG5vdGUgKDAtMSlcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU3ludGh9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICAvL3RoZSBlbnZlbG9wZXNcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgcmVsZWFzZSBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIHJlbGVhc2Ugc2hvdWxkIHN0YXJ0XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlN5bnRofSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlN5bnRoLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlUmVsZWFzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlN5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEFNU3ludGggdXNlcyB0aGUgb3V0cHV0IG9mIG9uZSBUb25lLlN5bnRoIHRvIG1vZHVsYXRlIHRoZVxuXHRcdCAqICAgICAgICAgIGFtcGxpdHVkZSBvZiBhbm90aGVyIFRvbmUuU3ludGguIFRoZSBoYXJtb25pY2l0eSAodGhlIHJhdGlvIGJldHdlZW5cblx0XHQgKiAgICAgICAgICB0aGUgdHdvIHNpZ25hbHMpIGFmZmVjdHMgdGhlIHRpbWJyZSBvZiB0aGUgb3V0cHV0IHNpZ25hbCBncmVhdGx5LlxuXHRcdCAqICAgICAgICAgIFJlYWQgbW9yZSBhYm91dCBBbXBsaXR1ZGUgTW9kdWxhdGlvbiBTeW50aGVzaXMgb25cblx0XHQgKiAgICAgICAgICBbU291bmRPblNvdW5kXShodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNjA0MDQxMDM2NTMvaHR0cDovL3d3dy5zb3VuZG9uc291bmQuY29tOjgwL3Nvcy9tYXIwMC9hcnRpY2xlcy9zeW50aHNlY3JldHMuaHRtKS5cblx0XHQgKiAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RyYXdpbmdzL2QvMVRRdThFZDRpRnIxWVRMS3BCM1UxX2h1ci1Vd0JyaDVnZEJYYzhCeGZHS3cvcHViP3c9MTAwOSZoPTQ1N1wiPlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Nb25vcGhvbmljfVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlIHN5bnRoXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFRvbmUuQU1TeW50aCgpLnRvTWFzdGVyKCk7XG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoXCJDNFwiLCBcIjRuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BTVN5bnRoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuQU1TeW50aC5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhcnJpZXIgdm9pY2UuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU3ludGh9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIgPSBuZXcgVG9uZS5TeW50aCgpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIudm9sdW1lLnZhbHVlID0gLTEwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYXJyaWVyJ3Mgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSB0aGlzLl9jYXJyaWVyLm9zY2lsbGF0b3I7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhcnJpZXIncyBlbnZlbG9wZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkFtcGxpdHVkZUVudmVsb3BlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IHRoaXMuX2NhcnJpZXIuZW52ZWxvcGUuc2V0KG9wdGlvbnMuZW52ZWxvcGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0b3Igdm9pY2UuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU3ludGh9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG5ldyBUb25lLlN5bnRoKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnZvbHVtZS52YWx1ZSA9IC0xMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdG9yJ3Mgb3NjaWxsYXRvciB3aGljaCBpcyBhcHBsaWVkXG5cdFx0XHQgKiAgdG8gdGhlIGFtcGxpdHVkZSBvZiB0aGUgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb24gPSB0aGlzLl9tb2R1bGF0b3Iub3NjaWxsYXRvci5zZXQob3B0aW9ucy5tb2R1bGF0aW9uKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdG9yJ3MgZW52ZWxvcGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BbXBsaXR1ZGVFbnZlbG9wZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlID0gdGhpcy5fbW9kdWxhdG9yLmVudmVsb3BlLnNldChvcHRpb25zLm1vZHVsYXRpb25FbnZlbG9wZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZyZXF1ZW5jeS5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKDQ0MCwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBpbiBjZW50c1xuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmRldHVuZSwgVG9uZS5UeXBlLkNlbnRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgcmF0aW8gYmV0d2VlbiB0aGUgdHdvIHZvaWNlcy4gQSBoYXJtb25pY2l0eSBvZlxuXHRcdFx0ICogIDEgaXMgbm8gY2hhbmdlLiBIYXJtb25pY2l0eSA9IDIgbWVhbnMgYSBjaGFuZ2Ugb2YgYW4gb2N0YXZlLlxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIC8vcGl0Y2ggdm9pY2UxIGFuIG9jdGF2ZSBiZWxvdyB2b2ljZTBcblx0XHRcdCAqIHN5bnRoLmhhcm1vbmljaXR5LnZhbHVlID0gMC41O1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eSA9IG5ldyBUb25lLk11bHRpcGx5KG9wdGlvbnMuaGFybW9uaWNpdHkpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkudW5pdHMgPSBUb25lLlR5cGUuUG9zaXRpdmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgY29udmVydCB0aGUgLTEsMSBvdXRwdXQgdG8gMCwxXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQXVkaW9Ub0dhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25TY2FsZSA9IG5ldyBUb25lLkF1ZGlvVG9HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG5vZGUgd2hlcmUgdGhlIG1vZHVsYXRpb24gaGFwcGVuc1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8vY29udHJvbCB0aGUgdHdvIHZvaWNlcyBmcmVxdWVuY3lcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KHRoaXMuX2NhcnJpZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jaGFpbih0aGlzLmhhcm1vbmljaXR5LCB0aGlzLl9tb2R1bGF0b3IuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5mYW4odGhpcy5fY2Fycmllci5kZXR1bmUsIHRoaXMuX21vZHVsYXRvci5kZXR1bmUpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5jaGFpbih0aGlzLl9tb2R1bGF0aW9uU2NhbGUsIHRoaXMuX21vZHVsYXRpb25Ob2RlLmdhaW4pO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuY2hhaW4odGhpcy5fbW9kdWxhdGlvbk5vZGUsIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnaGFybW9uaWNpdHknLFxuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25FbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5BTVN5bnRoLCBUb25lLk1vbm9waG9uaWMpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQU1TeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnaGFybW9uaWNpdHknOiAzLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdvc2NpbGxhdG9yJzogeyAndHlwZSc6ICdzaW5lJyB9LFxuXHQgICAgICAgICdlbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDEsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAuMDEsXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMSxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICB9LFxuXHQgICAgICAgICdtb2R1bGF0aW9uJzogeyAndHlwZSc6ICdzcXVhcmUnIH0sXG5cdCAgICAgICAgJ21vZHVsYXRpb25FbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuNSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMCxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IDAuNVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgdHJpZ2dlciB0aGUgYXR0YWNrIHBvcnRpb24gb2YgdGhlIG5vdGVcblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRoZSBub3RlIHdpbGwgb2NjdXJcblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BTVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkFNU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICAvL3RoZSBwb3J0IGdsaWRlXG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIC8vdGhlIGVudmVsb3Blc1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uRW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHRyaWdnZXIgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgbm90ZVxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIG5vdGUgd2lsbCByZWxlYXNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkFNU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZVJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uRW52ZWxvcGUudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkFNU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1TeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnaGFybW9uaWNpdHknLFxuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25FbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fY2FycmllciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uU2NhbGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25TY2FsZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb24gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkFNU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5Nb25vU3ludGggaXMgY29tcG9zZWQgb2Ygb25lIG9zY2lsbGF0b3IsIG9uZSBmaWx0ZXIsIGFuZCB0d28gZW52ZWxvcGVzLlxuXHRcdCAqICAgICAgICAgIFRoZSBhbXBsaXR1ZGUgb2YgdGhlIFRvbmUuT3NjaWxsYXRvciBhbmQgdGhlIGN1dG9mZiBmcmVxdWVuY3kgb2YgdGhlIFxuXHRcdCAqICAgICAgICAgIFRvbmUuRmlsdGVyIGFyZSBjb250cm9sbGVkIGJ5IFRvbmUuRW52ZWxvcGVzLiBcblx0XHQgKiAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RyYXdpbmdzL2QvMWdhWTFERjlfSHprb2RxZjhKSTFDZzJWWmZ3U0VscEZRZkk5NElRd2FkMzgvcHViP3c9OTI0Jmg9MjQwXCI+XG5cdFx0ICogICAgICAgICAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Nb25vcGhvbmljfVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlIHN5bnRoIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICBzZWUgZGVmYXVsdHMgYmVsb3dcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5Nb25vU3ludGgoe1xuXHRcdCAqIFx0XCJvc2NpbGxhdG9yXCIgOiB7XG5cdFx0ICogXHRcdFwidHlwZVwiIDogXCJzcXVhcmVcIlxuXHRcdCAqICB9LFxuXHRcdCAqICBcImVudmVsb3BlXCIgOiB7XG5cdFx0ICogIFx0XCJhdHRhY2tcIiA6IDAuMVxuXHRcdCAqICB9XG5cdFx0ICogfSkudG9NYXN0ZXIoKTtcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkM0XCIsIFwiOG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9TeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgLy9nZXQgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLk1vbm9TeW50aC5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG9zY2lsbGF0b3IuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT21uaU9zY2lsbGF0b3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSBuZXcgVG9uZS5PbW5pT3NjaWxsYXRvcihvcHRpb25zLm9zY2lsbGF0b3IpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gdGhpcy5vc2NpbGxhdG9yLmRldHVuZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmlsdGVyLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZpbHRlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmlsdGVyID0gbmV3IFRvbmUuRmlsdGVyKG9wdGlvbnMuZmlsdGVyKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmlsdGVyIGVudmVsb3BlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZyZXF1ZW5jeUVudmVsb3BlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5maWx0ZXJFbnZlbG9wZSA9IG5ldyBUb25lLkZyZXF1ZW5jeUVudmVsb3BlKG9wdGlvbnMuZmlsdGVyRW52ZWxvcGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQW1wbGl0dWRlRW52ZWxvcGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbmV3IFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUob3B0aW9ucy5lbnZlbG9wZSk7XG5cdCAgICAgICAgLy9jb25uZWN0IHRoZSBvc2NpbGxhdG9ycyB0byB0aGUgb3V0cHV0XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yLmNoYWluKHRoaXMuZmlsdGVyLCB0aGlzLmVudmVsb3BlLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgLy9zdGFydCB0aGUgb3NjaWxsYXRvcnNcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3Iuc3RhcnQoKTtcblx0ICAgICAgICAvL2Nvbm5lY3QgdGhlIGZpbHRlciBlbnZlbG9wZVxuXHQgICAgICAgIHRoaXMuZmlsdGVyRW52ZWxvcGUuY29ubmVjdCh0aGlzLmZpbHRlci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZScsXG5cdCAgICAgICAgICAgICdmaWx0ZXInLFxuXHQgICAgICAgICAgICAnZmlsdGVyRW52ZWxvcGUnLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Nb25vU3ludGgsIFRvbmUuTW9ub3Bob25pYyk7XG5cdCAgICAvKipcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub1N5bnRoLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiAnQzQnLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdvc2NpbGxhdG9yJzogeyAndHlwZSc6ICdzcXVhcmUnIH0sXG5cdCAgICAgICAgJ2ZpbHRlcic6IHtcblx0ICAgICAgICAgICAgJ1EnOiA2LFxuXHQgICAgICAgICAgICAndHlwZSc6ICdsb3dwYXNzJyxcblx0ICAgICAgICAgICAgJ3JvbGxvZmYnOiAtMjRcblx0ICAgICAgICB9LFxuXHQgICAgICAgICdlbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDA1LFxuXHQgICAgICAgICAgICAnZGVjYXknOiAwLjEsXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMC45LFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IDFcblx0ICAgICAgICB9LFxuXHQgICAgICAgICdmaWx0ZXJFbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDYsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAuMixcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nOiAwLjUsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMixcblx0ICAgICAgICAgICAgJ2Jhc2VGcmVxdWVuY3knOiAyMDAsXG5cdCAgICAgICAgICAgICdvY3RhdmVzJzogNyxcblx0ICAgICAgICAgICAgJ2V4cG9uZW50JzogMlxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIGF0dGFjayBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZSAoMC0xKVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Nb25vU3ludGh9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub1N5bnRoLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlQXR0YWNrID0gZnVuY3Rpb24gKHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgLy90aGUgZW52ZWxvcGVzXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLmZpbHRlckVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSByZWxlYXNlIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgcmVsZWFzZSBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9ub1N5bnRofSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZVJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgdGhpcy5maWx0ZXJFbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9ub1N5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9TeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnZmlsdGVyJyxcblx0ICAgICAgICAgICAgJ2ZpbHRlckVudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZpbHRlckVudmVsb3BlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZpbHRlckVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZpbHRlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5maWx0ZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTW9ub1N5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuRHVvU3ludGggaXMgYSBtb25vcGhvbmljIHN5bnRoIGNvbXBvc2VkIG9mIHR3byBcblx0XHQgKiAgICAgICAgICBNb25vU3ludGhzIHJ1biBpbiBwYXJhbGxlbCB3aXRoIGNvbnRyb2wgb3ZlciB0aGUgXG5cdFx0ICogICAgICAgICAgZnJlcXVlbmN5IHJhdGlvIGJldHdlZW4gdGhlIHR3byB2b2ljZXMgYW5kIHZpYnJhdG8gZWZmZWN0LlxuXHRcdCAqICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZHJhd2luZ3MvZC8xYkw0R1h2ZlJNTWxxUzdYeUJtOUNqTDlLSlBTVUtiY2RCTnBxT2xrRkx4ay9wdWI/dz0xMDEyJmg9NDQ4XCI+XG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLk1vbm9waG9uaWN9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGUgc3ludGggXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHNlZSBkZWZhdWx0cyBiZWxvd1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBkdW9TeW50aCA9IG5ldyBUb25lLkR1b1N5bnRoKCkudG9NYXN0ZXIoKTtcblx0XHQgKiBkdW9TeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkM0XCIsIFwiMm5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkR1b1N5bnRoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuRHVvU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuTW9ub3Bob25pYy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBmaXJzdCB2b2ljZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk1vbm9TeW50aH1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9pY2UwID0gbmV3IFRvbmUuTW9ub1N5bnRoKG9wdGlvbnMudm9pY2UwKTtcblx0ICAgICAgICB0aGlzLnZvaWNlMC52b2x1bWUudmFsdWUgPSAtMTA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHNlY29uZCB2b2ljZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk1vbm9TeW50aH1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9pY2UxID0gbmV3IFRvbmUuTW9ub1N5bnRoKG9wdGlvbnMudm9pY2UxKTtcblx0ICAgICAgICB0aGlzLnZvaWNlMS52b2x1bWUudmFsdWUgPSAtMTA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZpYnJhdG8gTEZPLiBcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3ZpYnJhdG8gPSBuZXcgVG9uZS5MRk8ob3B0aW9ucy52aWJyYXRvUmF0ZSwgLTUwLCA1MCk7XG5cdCAgICAgICAgdGhpcy5fdmlicmF0by5zdGFydCgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogdGhlIHZpYnJhdG8gZnJlcXVlbmN5XG5cdFx0XHQgKiBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52aWJyYXRvUmF0ZSA9IHRoaXMuX3ZpYnJhdG8uZnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB2aWJyYXRvIGdhaW5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl92aWJyYXRvR2FpbiA9IG5ldyBUb25lLkdhaW4ob3B0aW9ucy52aWJyYXRvQW1vdW50LCBUb25lLlR5cGUuUG9zaXRpdmUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGFtb3VudCBvZiB2aWJyYXRvXG5cdFx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZpYnJhdG9BbW91bnQgPSB0aGlzLl92aWJyYXRvR2Fpbi5nYWluO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBmcmVxdWVuY3kgY29udHJvbFxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBuZXcgVG9uZS5TaWduYWwoNDQwLCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgcmF0aW8gYmV0d2VlbiB0aGUgdHdvIHZvaWNlcy4gQSBoYXJtb25pY2l0eSBvZlxuXHRcdFx0ICogIDEgaXMgbm8gY2hhbmdlLiBIYXJtb25pY2l0eSA9IDIgbWVhbnMgYSBjaGFuZ2Ugb2YgYW4gb2N0YXZlLiBcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAvL3BpdGNoIHZvaWNlMSBhbiBvY3RhdmUgYmVsb3cgdm9pY2UwXG5cdFx0XHQgKiBkdW9TeW50aC5oYXJtb25pY2l0eS52YWx1ZSA9IDAuNTtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBuZXcgVG9uZS5NdWx0aXBseShvcHRpb25zLmhhcm1vbmljaXR5KTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LnVuaXRzID0gVG9uZS5UeXBlLlBvc2l0aXZlO1xuXHQgICAgICAgIC8vY29udHJvbCB0aGUgdHdvIHZvaWNlcyBmcmVxdWVuY3lcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KHRoaXMudm9pY2UwLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY2hhaW4odGhpcy5oYXJtb25pY2l0eSwgdGhpcy52b2ljZTEuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLl92aWJyYXRvLmNvbm5lY3QodGhpcy5fdmlicmF0b0dhaW4pO1xuXHQgICAgICAgIHRoaXMuX3ZpYnJhdG9HYWluLmZhbih0aGlzLnZvaWNlMC5kZXR1bmUsIHRoaXMudm9pY2UxLmRldHVuZSk7XG5cdCAgICAgICAgdGhpcy52b2ljZTAuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy52b2ljZTEuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAndm9pY2UwJyxcblx0ICAgICAgICAgICAgJ3ZvaWNlMScsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAndmlicmF0b0Ftb3VudCcsXG5cdCAgICAgICAgICAgICd2aWJyYXRvUmF0ZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkR1b1N5bnRoLCBUb25lLk1vbm9waG9uaWMpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRHVvU3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3ZpYnJhdG9BbW91bnQnOiAwLjUsXG5cdCAgICAgICAgJ3ZpYnJhdG9SYXRlJzogNSxcblx0ICAgICAgICAnaGFybW9uaWNpdHknOiAxLjUsXG5cdCAgICAgICAgJ3ZvaWNlMCc6IHtcblx0ICAgICAgICAgICAgJ3ZvbHVtZSc6IC0xMCxcblx0ICAgICAgICAgICAgJ3BvcnRhbWVudG8nOiAwLFxuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcic6IHsgJ3R5cGUnOiAnc2luZScgfSxcblx0ICAgICAgICAgICAgJ2ZpbHRlckVudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDEsXG5cdCAgICAgICAgICAgICAgICAnZGVjYXknOiAwLFxuXHQgICAgICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDEsXG5cdCAgICAgICAgICAgICAgICAnZGVjYXknOiAwLFxuXHQgICAgICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ3ZvaWNlMSc6IHtcblx0ICAgICAgICAgICAgJ3ZvbHVtZSc6IC0xMCxcblx0ICAgICAgICAgICAgJ3BvcnRhbWVudG8nOiAwLFxuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcic6IHsgJ3R5cGUnOiAnc2luZScgfSxcblx0ICAgICAgICAgICAgJ2ZpbHRlckVudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDEsXG5cdCAgICAgICAgICAgICAgICAnZGVjYXknOiAwLFxuXHQgICAgICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDEsXG5cdCAgICAgICAgICAgICAgICAnZGVjYXknOiAwLFxuXHQgICAgICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZXNcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgYXR0YWNrIHNob3VsZCBzdGFydFxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbdmVsb2NpdHk9MV0gdGhlIHZlbG9jaXR5IG9mIHRoZSBub3RlICgwLTEpXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkR1b1N5bnRofSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkR1b1N5bnRoLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlQXR0YWNrID0gZnVuY3Rpb24gKHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMudm9pY2UwLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHRoaXMudm9pY2UxLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHRoaXMudm9pY2UwLmZpbHRlckVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSk7XG5cdCAgICAgICAgdGhpcy52b2ljZTEuZmlsdGVyRW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVzXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIHJlbGVhc2Ugc2hvdWxkIHN0YXJ0XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkR1b1N5bnRofSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkR1b1N5bnRoLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlUmVsZWFzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy52b2ljZTAudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgdGhpcy52b2ljZTEudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkR1b1N5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkR1b1N5bnRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuTW9ub3Bob25pYy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3ZvaWNlMCcsXG5cdCAgICAgICAgICAgICd2b2ljZTEnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ3ZpYnJhdG9BbW91bnQnLFxuXHQgICAgICAgICAgICAndmlicmF0b1JhdGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy52b2ljZTAuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMudm9pY2UwID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnZvaWNlMS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy52b2ljZTEgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdmlicmF0b0dhaW4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3ZpYnJhdG9HYWluID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl92aWJyYXRvID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnZpYnJhdG9BbW91bnQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMudmlicmF0b0Ftb3VudCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy52aWJyYXRvUmF0ZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRHVvU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgRk1TeW50aCBpcyBjb21wb3NlZCBvZiB0d28gVG9uZS5TeW50aHMgd2hlcmUgb25lIFRvbmUuU3ludGggbW9kdWxhdGVzXG5cdFx0ICogICAgICAgICAgdGhlIGZyZXF1ZW5jeSBvZiBhIHNlY29uZCBUb25lLlN5bnRoLiBBIGxvdCBvZiBzcGVjdHJhbCBjb250ZW50IFxuXHRcdCAqICAgICAgICAgIGNhbiBiZSBleHBsb3JlZCB1c2luZyB0aGUgbW9kdWxhdGlvbkluZGV4IHBhcmFtZXRlci4gUmVhZCBtb3JlIGFib3V0XG5cdFx0ICogICAgICAgICAgZnJlcXVlbmN5IG1vZHVsYXRpb24gc3ludGhlc2lzIG9uIFNvdW5kIE9uIFNvdW5kOiBbUGFydCAxXShodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNjA0MDMxMjM3MDQvaHR0cDovL3d3dy5zb3VuZG9uc291bmQuY29tL3Nvcy9hcHIwMC9hcnRpY2xlcy9zeW50aHNlY3JldHMuaHRtKSwgW1BhcnQgMl0oaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTYwNDAzMTE1ODM1L2h0dHA6Ly93d3cuc291bmRvbnNvdW5kLmNvbS9zb3MvbWF5MDAvYXJ0aWNsZXMvc3ludGguaHRtKS5cblx0XHQgKiAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RyYXdpbmdzL2QvMWgwUFVEWlhQZ2k0SWt4NmJWVDZvbmNyWVBMbHVGS3k3bGo1M3B1eGotRE0vcHViP3c9OTAyJmg9NDYyXCI+XG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLk1vbm9waG9uaWN9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGUgc3ludGhcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGZtU3ludGggPSBuZXcgVG9uZS5GTVN5bnRoKCkudG9NYXN0ZXIoKTtcblx0XHQgKiBmbVN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzVcIiwgXCI0blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1TeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLkZNU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuTW9ub3Bob25pYy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYXJyaWVyIHZvaWNlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN5bnRofVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbmV3IFRvbmUuU3ludGgob3B0aW9ucy5jYXJyaWVyKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLnZvbHVtZS52YWx1ZSA9IC0xMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FycmllcidzIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gdGhpcy5fY2Fycmllci5vc2NpbGxhdG9yO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYXJyaWVyJ3MgZW52ZWxvcGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IHRoaXMuX2NhcnJpZXIuZW52ZWxvcGUuc2V0KG9wdGlvbnMuZW52ZWxvcGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0b3Igdm9pY2UuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU3ludGh9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG5ldyBUb25lLlN5bnRoKG9wdGlvbnMubW9kdWxhdG9yKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3Iudm9sdW1lLnZhbHVlID0gLTEwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0b3IncyBvc2NpbGxhdG9yIHdoaWNoIGlzIGFwcGxpZWRcblx0XHRcdCAqICB0byB0aGUgYW1wbGl0dWRlIG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbiA9IHRoaXMuX21vZHVsYXRvci5vc2NpbGxhdG9yLnNldChvcHRpb25zLm1vZHVsYXRpb24pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0b3IncyBlbnZlbG9wZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25FbnZlbG9wZSA9IHRoaXMuX21vZHVsYXRvci5lbnZlbG9wZS5zZXQob3B0aW9ucy5tb2R1bGF0aW9uRW52ZWxvcGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKDQ0MCwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBpbiBjZW50c1xuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmRldHVuZSwgVG9uZS5UeXBlLkNlbnRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgcmF0aW8gYmV0d2VlbiB0aGUgdHdvIHZvaWNlcy4gQSBoYXJtb25pY2l0eSBvZlxuXHRcdFx0ICogIDEgaXMgbm8gY2hhbmdlLiBIYXJtb25pY2l0eSA9IDIgbWVhbnMgYSBjaGFuZ2Ugb2YgYW4gb2N0YXZlLlxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIC8vcGl0Y2ggdm9pY2UxIGFuIG9jdGF2ZSBiZWxvdyB2b2ljZTBcblx0XHRcdCAqIHN5bnRoLmhhcm1vbmljaXR5LnZhbHVlID0gMC41O1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eSA9IG5ldyBUb25lLk11bHRpcGx5KG9wdGlvbnMuaGFybW9uaWNpdHkpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkudW5pdHMgPSBUb25lLlR5cGUuUG9zaXRpdmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRpb24gaW5kZXggd2hpY2ggZXNzZW50aWFsbHkgdGhlIGRlcHRoIG9yIGFtb3VudCBvZiB0aGUgbW9kdWxhdGlvbi4gSXQgaXMgdGhlXG5cdFx0XHQgKiAgcmF0aW8gb2YgdGhlIGZyZXF1ZW5jeSBvZiB0aGUgbW9kdWxhdGluZyBzaWduYWwgKG1mKSB0byB0aGUgYW1wbGl0dWRlIG9mIHRoZVxuXHRcdFx0ICogIG1vZHVsYXRpbmcgc2lnbmFsIChtYSkgLS0gYXMgaW4gbWEvbWYuXG5cdFx0XHQgKlx0QHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICpcdEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkluZGV4ID0gbmV3IFRvbmUuTXVsdGlwbHkob3B0aW9ucy5tb2R1bGF0aW9uSW5kZXgpO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkluZGV4LnVuaXRzID0gVG9uZS5UeXBlLlBvc2l0aXZlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBub2RlIHdoZXJlIHRoZSBtb2R1bGF0aW9uIGhhcHBlbnNcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbmV3IFRvbmUuR2FpbigwKTtcblx0ICAgICAgICAvL2NvbnRyb2wgdGhlIHR3byB2b2ljZXMgZnJlcXVlbmN5XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY29ubmVjdCh0aGlzLl9jYXJyaWVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY2hhaW4odGhpcy5oYXJtb25pY2l0eSwgdGhpcy5fbW9kdWxhdG9yLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY2hhaW4odGhpcy5tb2R1bGF0aW9uSW5kZXgsIHRoaXMuX21vZHVsYXRpb25Ob2RlKTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5mYW4odGhpcy5fY2Fycmllci5kZXR1bmUsIHRoaXMuX21vZHVsYXRvci5kZXR1bmUpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5jb25uZWN0KHRoaXMuX21vZHVsYXRpb25Ob2RlLmdhaW4pO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlLmNvbm5lY3QodGhpcy5fY2Fycmllci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5Jyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25JbmRleCcsXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJyxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb24nLFxuXHQgICAgICAgICAgICAnbW9kdWxhdGlvbkVudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZNU3ludGgsIFRvbmUuTW9ub3Bob25pYyk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GTVN5bnRoLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdoYXJtb25pY2l0eSc6IDMsXG5cdCAgICAgICAgJ21vZHVsYXRpb25JbmRleCc6IDEwLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdvc2NpbGxhdG9yJzogeyAndHlwZSc6ICdzaW5lJyB9LFxuXHQgICAgICAgICdlbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDEsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAuMDEsXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMSxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICB9LFxuXHQgICAgICAgICdtb2R1bGF0aW9uJzogeyAndHlwZSc6ICdzcXVhcmUnIH0sXG5cdCAgICAgICAgJ21vZHVsYXRpb25FbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuNSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMCxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IDAuNVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBcdHRyaWdnZXIgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBub3RlXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgbm90ZSB3aWxsIG9jY3VyXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbdmVsb2NpdHk9MV0gdGhlIHZlbG9jaXR5IG9mIHRoZSBub3RlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZNU3ludGh9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZUF0dGFjayA9IGZ1bmN0aW9uICh0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICAvL3RoZSBlbnZlbG9wZXNcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHRyaWdnZXIgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgbm90ZVxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIG5vdGUgd2lsbCByZWxlYXNlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZNU3ludGh9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZVJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5GTVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZNU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5Jyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25JbmRleCcsXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJyxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb24nLFxuXHQgICAgICAgICAgICAnbW9kdWxhdGlvbkVudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRldHVuZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkluZGV4LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25JbmRleCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb24gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZNU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5NZW1icmFuZVN5bnRoIG1ha2VzIGtpY2sgYW5kIHRvbSBzb3VuZHMgdXNpbmcgYSBzaW5nbGUgb3NjaWxsYXRvclxuXHRcdCAqICAgICAgICAgIHdpdGggYW4gYW1wbGl0dWRlIGVudmVsb3BlIGFuZCBmcmVxdWVuY3kgcmFtcC4gQSBUb25lLk9tbmlPc2NpbGxhdG9yXG5cdFx0ICogICAgICAgICAgaXMgcm91dGVkIHRocm91Z2ggYSBUb25lLkFtcGxpdHVkZUVudmVsb3BlIHRvIHRoZSBvdXRwdXQuIFRoZSBkcnVtXG5cdFx0ICogICAgICAgICAgcXVhbGl0eSBvZiB0aGUgc291bmQgY29tZXMgZnJvbSB0aGUgZnJlcXVlbmN5IGVudmVsb3BlIGFwcGxpZWRcblx0XHQgKiAgICAgICAgICBkdXJpbmcgZHVyaW5nIFRvbmUuTWVtYnJhbmVTeW50aC50cmlnZ2VyQXR0YWNrKG5vdGUpLiBUaGUgZnJlcXVlbmN5XG5cdFx0ICogICAgICAgICAgZW52ZWxvcGUgc3RhcnRzIGF0IDxjb2RlPm5vdGUgKiAub2N0YXZlczwvY29kZT4gYW5kIHJhbXBzIHRvIFxuXHRcdCAqICAgICAgICAgIDxjb2RlPm5vdGU8L2NvZGU+IG92ZXIgdGhlIGR1cmF0aW9uIG9mIDxjb2RlPi5waXRjaERlY2F5PC9jb2RlPi4gXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkluc3RydW1lbnR9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGUgc3ludGggXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHNlZSBkZWZhdWx0cyBiZWxvd1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBUb25lLk1lbWJyYW5lU3ludGgoKS50b01hc3RlcigpO1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzJcIiwgXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTWVtYnJhbmVTeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLk1lbWJyYW5lU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvc2NpbGxhdG9yLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9tbmlPc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gbmV3IFRvbmUuT21uaU9zY2lsbGF0b3Iob3B0aW9ucy5vc2NpbGxhdG9yKS5zdGFydCgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQW1wbGl0dWRlRW52ZWxvcGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbmV3IFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUob3B0aW9ucy5lbnZlbG9wZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG51bWJlciBvZiBvY3RhdmVzIHRoZSBwaXRjaCBlbnZlbG9wZSByYW1wcy5cblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm9jdGF2ZXMgPSBvcHRpb25zLm9jdGF2ZXM7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiB0aW1lIHRoZSBmcmVxdWVuY3kgZW52ZWxvcGUgdGFrZXMuIFxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5waXRjaERlY2F5ID0gb3B0aW9ucy5waXRjaERlY2F5O1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvci5jaGFpbih0aGlzLmVudmVsb3BlLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1lbWJyYW5lU3ludGgsIFRvbmUuSW5zdHJ1bWVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5NZW1icmFuZVN5bnRoLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdwaXRjaERlY2F5JzogMC4wNSxcblx0ICAgICAgICAnb2N0YXZlcyc6IDEwLFxuXHQgICAgICAgICdvc2NpbGxhdG9yJzogeyAndHlwZSc6ICdzaW5lJyB9LFxuXHQgICAgICAgICdlbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDAxLFxuXHQgICAgICAgICAgICAnZGVjYXknOiAwLjQsXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMC4wMSxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAxLjQsXG5cdCAgICAgICAgICAgICdhdHRhY2tDdXJ2ZSc6ICdleHBvbmVudGlhbCdcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIG5vdGUgYXQgdGhlIGdpdmVuIHRpbWUgd2l0aCB0aGUgZ2l2ZW4gdmVsb2NpdHkuIFxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7RnJlcXVlbmN5fSBub3RlICAgICB0aGUgbm90ZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddICAgICB0aGUgdGltZSwgaWYgbm90IGdpdmVuIGlzIG5vd1xuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IFt2ZWxvY2l0eT0xXSB2ZWxvY2l0eSBkZWZhdWx0cyB0byAxXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1lbWJyYW5lU3ludGh9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAga2ljay50cmlnZ2VyQXR0YWNrKDYwKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTWVtYnJhbmVTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uIChub3RlLCB0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBub3RlID0gdGhpcy50b0ZyZXF1ZW5jeShub3RlKTtcblx0ICAgICAgICB2YXIgbWF4Tm90ZSA9IG5vdGUgKiB0aGlzLm9jdGF2ZXM7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZShtYXhOb3RlLCB0aW1lKTtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5LmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUobm90ZSwgdGltZSArIHRoaXMudG9TZWNvbmRzKHRoaXMucGl0Y2hEZWNheSkpO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgbm90ZS5cblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIG5vdGUgd2lsbCByZWxlYXNlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1lbWJyYW5lU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWVtYnJhbmVTeW50aC5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NZW1icmFuZVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1lbWJyYW5lU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWVtYnJhbmVTeW50aDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEluaGFybW9uaWMgcmF0aW8gb2YgZnJlcXVlbmNpZXMgYmFzZWQgb24gdGhlIFJvbGFuZCBUUi04MDhcblx0XHQgKiAgVGFrZW4gZnJvbSBodHRwczovL2Njcm1hLnN0YW5mb3JkLmVkdS9wYXBlcnMvdHItODA4LWN5bWJhbC1waHlzaWNhbGx5LWluZm9ybWVkLWNpcmN1aXQtYmVuZGFibGUtZGlnaXRhbC1tb2RlbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0ICAgIHZhciBpbmhhcm1SYXRpb3MgPSBbXG5cdCAgICAgICAgMSxcblx0ICAgICAgICAxLjQ4Myxcblx0ICAgICAgICAxLjkzMixcblx0ICAgICAgICAyLjU0Nixcblx0ICAgICAgICAyLjYzLFxuXHQgICAgICAgIDMuODk3XG5cdCAgICBdO1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQSBoaWdobHkgaW5oYXJtb25pYyBhbmQgc3BlY3RyYWxseSBjb21wbGV4IHNvdXJjZSB3aXRoIGEgaGlnaHBhc3MgZmlsdGVyXG5cdFx0ICogICAgICAgICAgYW5kIGFtcGxpdHVkZSBlbnZlbG9wZSB3aGljaCBpcyBnb29kIGZvciBtYWtpbmcgbWV0YWxvcGhvbmUgc291bmRzLiBCYXNlZFxuXHRcdCAqICAgICAgICAgIG9uIEN5bWJhbFN5bnRoIGJ5IFtAcG9seXJoeXRobWF0aWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9wb2x5cmh5dGhtYXRpYykuXG5cdFx0ICogICAgICAgICAgSW5zcGlyYXRpb24gZnJvbSBbU291bmQgb24gU291bmRdKGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE2MDYxMDE0MzkyNC9odHRwczovL3d3dy5zb3VuZG9uc291bmQuY29tL3Nvcy9qdWwwMi9hcnRpY2xlcy9zeW50aHNlY3JldHMwNzAyLmFzcCkuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkluc3RydW1lbnR9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgYXZhaWxibGUgZm9yIHRoZSBzeW50aFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWUgZGVmYXVsdHMgYmVsb3dcblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0YWxTeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLk1ldGFsU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgb2YgdGhlIGN5bWJhbFxuXHRcdFx0ICogIEB0eXBlICB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYXJyYXkgb2YgRk1Pc2NpbGxhdG9yc1xuXHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3JzID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZyZXF1ZW5jeSBtdWx0aXBsaWVyc1xuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZnJlcU11bHRpcGxpZXJzID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtcGxpdHVkZSBmb3IgdGhlIGJvZHlcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZSA9IG5ldyBUb25lLkdhaW4oMCkuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgaGlnaHBhc3MgdGhlIG91dHB1dFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZpbHRlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faGlnaHBhc3MgPSBuZXcgVG9uZS5GaWx0ZXIoe1xuXHQgICAgICAgICAgICAndHlwZSc6ICdoaWdocGFzcycsXG5cdCAgICAgICAgICAgICdRJzogLTMuMDEwMjk5OTU2NjM5ODEyNVxuXHQgICAgICAgIH0pLmNvbm5lY3QodGhpcy5fYW1wbGl0dWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBudW1iZXIgb2Ygb2N0YXZlcyB0aGUgaGlnaHBhc3Ncblx0XHRcdCAqICBmaWx0ZXIgZnJlcXVlbmN5IHJhbXBzXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBTY2FsZSB0aGUgYm9keSBlbnZlbG9wZVxuXHRcdFx0ICogIGZvciB0aGUgYmFuZHBhc3Ncblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TY2FsZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmlsdGVyRnJlcVNjYWxlciA9IG5ldyBUb25lLlNjYWxlKG9wdGlvbnMucmVzb25hbmNlLCA3MDAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZW52ZWxvcGUgd2hpY2ggaXMgY29ubmVjdGVkIGJvdGggdG8gdGhlXG5cdFx0XHQgKiAgYW1wbGl0dWRlIGFuZCBoaWdocGFzcyBmaWx0ZXIncyBjdXRvZmYgZnJlcXVlbmN5XG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkVudmVsb3BlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG5ldyBUb25lLkVudmVsb3BlKHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IG9wdGlvbnMuZW52ZWxvcGUuYXR0YWNrLFxuXHQgICAgICAgICAgICAnYXR0YWNrQ3VydmUnOiAnbGluZWFyJyxcblx0ICAgICAgICAgICAgJ2RlY2F5Jzogb3B0aW9ucy5lbnZlbG9wZS5kZWNheSxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nOiAwLFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IG9wdGlvbnMuZW52ZWxvcGUucmVsZWFzZVxuXHQgICAgICAgIH0pLmNoYWluKHRoaXMuX2ZpbHRlckZyZXFTY2FsZXIsIHRoaXMuX2hpZ2hwYXNzLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS5jb25uZWN0KHRoaXMuX2FtcGxpdHVlLmdhaW4pO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5oYXJtUmF0aW9zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBvc2MgPSBuZXcgVG9uZS5GTU9zY2lsbGF0b3Ioe1xuXHQgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3F1YXJlJyxcblx0ICAgICAgICAgICAgICAgICdtb2R1bGF0aW9uVHlwZSc6ICdzcXVhcmUnLFxuXHQgICAgICAgICAgICAgICAgJ2hhcm1vbmljaXR5Jzogb3B0aW9ucy5oYXJtb25pY2l0eSxcblx0ICAgICAgICAgICAgICAgICdtb2R1bGF0aW9uSW5kZXgnOiBvcHRpb25zLm1vZHVsYXRpb25JbmRleFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgb3NjLmNvbm5lY3QodGhpcy5faGlnaHBhc3MpLnN0YXJ0KDApO1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yc1tpXSA9IG9zYztcblx0ICAgICAgICAgICAgdmFyIG11bHQgPSBuZXcgVG9uZS5NdWx0aXBseShpbmhhcm1SYXRpb3NbaV0pO1xuXHQgICAgICAgICAgICB0aGlzLl9mcmVxTXVsdGlwbGllcnNbaV0gPSBtdWx0O1xuXHQgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jaGFpbihtdWx0LCBvc2MuZnJlcXVlbmN5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9zZXQgdGhlIG9jdGF2ZXNcblx0ICAgICAgICB0aGlzLm9jdGF2ZXMgPSBvcHRpb25zLm9jdGF2ZXM7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NZXRhbFN5bnRoLCBUb25lLkluc3RydW1lbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGFsU3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDIwMCxcblx0ICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAwMSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMS40LFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IDAuMlxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ2hhcm1vbmljaXR5JzogNS4xLFxuXHQgICAgICAgICdtb2R1bGF0aW9uSW5kZXgnOiAzMixcblx0ICAgICAgICAncmVzb25hbmNlJzogNDAwMCxcblx0ICAgICAgICAnb2N0YXZlcyc6IDEuNVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBhdHRhY2suXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lICAgICAgV2hlbiB0aGUgYXR0YWNrIHNob3VsZCBiZSB0cmlnZ2VyZWQuXG5cdFx0ICogIEBwYXJhbSAge05vcm1hbFJhbmdlfSAgW3ZlbG9jaXR5PTFdICBUaGUgdmVsb2NpdHkgdGhhdCB0aGUgZW52ZWxvcGUgc2hvdWxkIGJlIHRyaWdnZXJlZCBhdC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTWV0YWxTeW50aH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0YWxTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uICh0aW1lLCB2ZWwpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmVsID0gVG9uZS5kZWZhdWx0QXJnKHZlbCwgMSk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIHJlbGVhc2Ugb2YgdGhlIGVudmVsb3BlLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdGltZSAgICAgIFdoZW4gdGhlIHJlbGVhc2Ugc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTWV0YWxTeW50aH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0YWxTeW50aC5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBhdHRhY2sgYW5kIHJlbGVhc2Ugb2YgdGhlIGVudmVsb3BlIGFmdGVyIHRoZSBnaXZlblxuXHRcdCAqICBkdXJhdGlvbi5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIGR1cmF0aW9uICBUaGUgZHVyYXRpb24gYmVmb3JlIHRyaWdnZXJpbmcgdGhlIHJlbGVhc2Vcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHRpbWUgICAgICBXaGVuIHRoZSBhdHRhY2sgc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHBhcmFtICB7Tm9ybWFsUmFuZ2V9ICBbdmVsb2NpdHk9MV0gIFRoZSB2ZWxvY2l0eSB0aGF0IHRoZSBlbnZlbG9wZSBzaG91bGQgYmUgdHJpZ2dlcmVkIGF0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5NZXRhbFN5bnRofSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NZXRhbFN5bnRoLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrUmVsZWFzZSA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgZHVyYXRpb24gPSB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbik7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLnRyaWdnZXJSZWxlYXNlKHRpbWUgKyBkdXJhdGlvbik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBtb2R1bGF0aW9uSW5kZXggb2YgdGhlIG9zY2lsbGF0b3JzIHdoaWNoIG1ha2UgdXAgdGhlIHNvdXJjZS5cblx0XHQgKiAgc2VlIFRvbmUuRk1Pc2NpbGxhdG9yLm1vZHVsYXRpb25JbmRleFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5NZXRhbFN5bnRoI1xuXHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogIEBuYW1lICBtb2R1bGF0aW9uSW5kZXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk1ldGFsU3ludGgucHJvdG90eXBlLCAnbW9kdWxhdGlvbkluZGV4Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvcnNbMF0ubW9kdWxhdGlvbkluZGV4LnZhbHVlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fb3NjaWxsYXRvcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3JzW2ldLm1vZHVsYXRpb25JbmRleC52YWx1ZSA9IHZhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBoYXJtb25pY2l0eSBvZiB0aGUgb3NjaWxsYXRvcnMgd2hpY2ggbWFrZSB1cCB0aGUgc291cmNlLlxuXHRcdCAqICBzZWUgVG9uZS5GTU9zY2lsbGF0b3IuaGFybW9uaWNpdHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTWV0YWxTeW50aCNcblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAbmFtZSAgaGFybW9uaWNpdHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk1ldGFsU3ludGgucHJvdG90eXBlLCAnaGFybW9uaWNpdHknLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yc1swXS5oYXJtb25pY2l0eS52YWx1ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29zY2lsbGF0b3JzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yc1tpXS5oYXJtb25pY2l0eS52YWx1ZSA9IHZhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBmcmVxdWVuY3kgb2YgdGhlIGhpZ2hwYXNzIGZpbHRlciBhdHRhY2hlZCB0byB0aGUgZW52ZWxvcGVcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTWV0YWxTeW50aCNcblx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHQgKiAgQG5hbWUgIHJlc29uYW5jZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTWV0YWxTeW50aC5wcm90b3R5cGUsICdyZXNvbmFuY2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJGcmVxU2NhbGVyLm1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9maWx0ZXJGcmVxU2NhbGVyLm1pbiA9IHZhbDtcblx0ICAgICAgICAgICAgdGhpcy5vY3RhdmVzID0gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbnVtYmVyIG9mIG9jdGF2ZXMgYWJvdmUgdGhlIFwicmVzb25hbmNlXCIgZnJlcXVlbmN5XG5cdFx0ICogIHRoYXQgdGhlIGZpbHRlciByYW1wcyBkdXJpbmcgdGhlIGF0dGFjay9kZWNheSBlbnZlbG9wZVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5NZXRhbFN5bnRoI1xuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbmFtZSAgb2N0YXZlc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTWV0YWxTeW50aC5wcm90b3R5cGUsICdvY3RhdmVzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9jdHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb2N0YXZlcyA9IG9jdHM7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbHRlckZyZXFTY2FsZXIubWF4ID0gdGhpcy5fZmlsdGVyRnJlcVNjYWxlci5taW4gKiBNYXRoLnBvdygyLCBvY3RzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NZXRhbFN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGFsU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9vc2NpbGxhdG9ycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yc1tpXS5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZyZXFNdWx0aXBsaWVyc1tpXS5kaXNwb3NlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3JzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mcmVxTXVsdGlwbGllcnMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyRnJlcVNjYWxlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyRnJlcVNjYWxlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYW1wbGl0dWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2FtcGxpdHVlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9oaWdocGFzcy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5faGlnaHBhc3MgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk1ldGFsU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBCdWZmZXJTb3VyY2UgcG9seWZpbGxcblx0XHQgKi9cblx0ICAgIGlmICh3aW5kb3cuQXVkaW9CdWZmZXJTb3VyY2VOb2RlICYmICFBdWRpb0J1ZmZlclNvdXJjZU5vZGUucHJvdG90eXBlLnN0YXJ0KSB7XG5cdCAgICAgICAgQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnByb3RvdHlwZS5zdGFydCA9IEF1ZGlvQnVmZmVyU291cmNlTm9kZS5wcm90b3R5cGUubm90ZUdyYWluT247XG5cdCAgICAgICAgQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnByb3RvdHlwZS5zdG9wID0gQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnByb3RvdHlwZS5ub3RlT2ZmO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBXcmFwcGVyIGFyb3VuZCB0aGUgbmF0aXZlIEJ1ZmZlclNvdXJjZU5vZGUuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtICB7QXVkaW9CdWZmZXJ8VG9uZS5CdWZmZXJ9ICBidWZmZXIgICBUaGUgYnVmZmVyIHRvIHBsYXlcblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBvbmxvYWQgIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgaXMgZG9uZSBwbGF5aW5nLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnYnVmZmVyJyxcblx0ICAgICAgICAgICAgJ29ubG9hZCdcblx0ICAgICAgICBdLCBUb25lLkJ1ZmZlclNvdXJjZSk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIHRoZVxuXHRcdFx0ICogIGJ1ZmZlciBzb3VyY2UgaXMgZG9uZSBwbGF5aW5nLlxuXHRcdFx0ICogIEB0eXBlICB7RnVuY3Rpb259XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm9uZW5kZWQgPSBvcHRpb25zLm9uZW5kZWQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHRpbWUgdGhhdCB0aGUgYnVmZmVyIHdhcyBzdGFydGVkLlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSAtMTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdGltZSB0aGF0IHRoZSBidWZmZXIgaXMgc2NoZWR1bGVkIHRvIHN0b3AuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N0b3BUaW1lID0gLTE7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGdhaW4gbm9kZSB3aGljaCBlbnZlbG9wZXMgdGhlIEJ1ZmZlclNvdXJjZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9nYWluTm9kZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBidWZmZXIgc291cmNlXG5cdFx0XHQgKiAgQHR5cGUgIHtBdWRpb0J1ZmZlclNvdXJjZU5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblx0ICAgICAgICB0aGlzLl9zb3VyY2UuY29ubmVjdCh0aGlzLl9nYWluTm9kZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgcHJpdmF0ZSBidWZmZXIgaW5zdGFuY2Vcblx0XHRcdCAqIEB0eXBlIHtUb25lLkJ1ZmZlcn1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgVG9uZS5CdWZmZXIob3B0aW9ucy5idWZmZXIsIG9wdGlvbnMub25sb2FkKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGxheWJhY2tSYXRlIG9mIHRoZSBidWZmZXJcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5wbGF5YmFja1JhdGUgPSBuZXcgVG9uZS5QYXJhbSh0aGlzLl9zb3VyY2UucGxheWJhY2tSYXRlLCBUb25lLlR5cGUuUG9zaXRpdmUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmYWRlSW4gdGltZSBvZiB0aGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mYWRlSW4gPSBvcHRpb25zLmZhZGVJbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmFkZU91dCB0aW1lIG9mIHRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZhZGVPdXQgPSBvcHRpb25zLmZhZGVPdXQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZhbHVlIHRoYXQgdGhlIGJ1ZmZlciByYW1wcyB0b1xuXHRcdFx0ICogIEB0eXBlIHtHYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9nYWluID0gMTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBvbmVuZGVkIHRpbWVvdXRcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb25lbmRlZFRpbWVvdXQgPSAtMTtcblx0ICAgICAgICB0aGlzLmxvb3AgPSBvcHRpb25zLmxvb3A7XG5cdCAgICAgICAgdGhpcy5sb29wU3RhcnQgPSBvcHRpb25zLmxvb3BTdGFydDtcblx0ICAgICAgICB0aGlzLmxvb3BFbmQgPSBvcHRpb25zLmxvb3BFbmQ7XG5cdCAgICAgICAgdGhpcy5wbGF5YmFja1JhdGUudmFsdWUgPSBvcHRpb25zLnBsYXliYWNrUmF0ZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkJ1ZmZlclNvdXJjZSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlclNvdXJjZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnb25lbmRlZCc6IFRvbmUubm9PcCxcblx0ICAgICAgICAnb25sb2FkJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdsb29wJzogZmFsc2UsXG5cdCAgICAgICAgJ2xvb3BTdGFydCc6IDAsXG5cdCAgICAgICAgJ2xvb3BFbmQnOiAwLFxuXHQgICAgICAgICdmYWRlSW4nOiAwLFxuXHQgICAgICAgICdmYWRlT3V0JzogMCxcblx0ICAgICAgICAncGxheWJhY2tSYXRlJzogMVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgc291cmNlLCBlaXRoZXIgXCJzdGFydGVkXCIgb3IgXCJzdG9wcGVkXCIuXG5cdFx0ICogIEB0eXBlIHtUb25lLlN0YXRlfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQnVmZmVyU291cmNlI1xuXHRcdCAqICBAbmFtZSBzdGF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXJ0VGltZSAhPT0gLTEgJiYgbm93ID49IHRoaXMuX3N0YXJ0VGltZSAmJiBub3cgPCB0aGlzLl9zdG9wVGltZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFRvbmUuU3RhdGUuU3RhcnRlZDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBUb25lLlN0YXRlLlN0b3BwZWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgYnVmZmVyXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFtzdGFydFRpbWU9bm93XSBXaGVuIHRoZSBwbGF5ZXIgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbb2Zmc2V0PTBdIFRoZSBvZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzYW1wbGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHN0YXJ0IGF0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gZHVyYXRpb24gSG93IGxvbmcgdGhlIHNhbXBsZSBzaG91bGQgcGxheS4gSWYgbm8gZHVyYXRpb25cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgZ2l2ZW4sIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgZnVsbCBsZW5ndGhcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIHNhbXBsZSAobWludXMgYW55IG9mZnNldClcblx0XHQgKiAgQHBhcmFtICB7R2Fpbn0gIFtnYWluPTFdICBUaGUgZ2FpbiB0byBwbGF5IHRoZSBidWZmZXIgYmFjayBhdC5cblx0XHQgKiAgQHBhcmFtICB7VGltZT19ICBmYWRlSW5UaW1lICBUaGUgb3B0aW9uYWwgZmFkZUluIHJhbXAgdGltZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuQnVmZmVyU291cmNlfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUsIG9mZnNldCwgZHVyYXRpb24sIGdhaW4sIGZhZGVJblRpbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5fc3RhcnRUaW1lICE9PSAtMSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbmUuQnVmZmVyU291cmNlIGNhbiBvbmx5IGJlIHN0YXJ0ZWQgb25jZS4nKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxvYWRlZCkge1xuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgICAgIC8vaWYgaXQncyBhIGxvb3AgdGhlIGRlZmF1bHQgb2Zmc2V0IGlzIHRoZSBsb29wc3RhcnQgcG9pbnRcblx0ICAgICAgICAgICAgaWYgKHRoaXMubG9vcCkge1xuXHQgICAgICAgICAgICAgICAgb2Zmc2V0ID0gVG9uZS5kZWZhdWx0QXJnKG9mZnNldCwgdGhpcy5sb29wU3RhcnQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy9vdGhlcndpc2UgdGhlIGRlZmF1bHQgb2Zmc2V0IGlzIDBcblx0ICAgICAgICAgICAgICAgIG9mZnNldCA9IFRvbmUuZGVmYXVsdEFyZyhvZmZzZXQsIDApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9mZnNldCA9IHRoaXMudG9TZWNvbmRzKG9mZnNldCk7XG5cdCAgICAgICAgICAgIC8vdGhlIHZhbHVlcyBpbiBzZWNvbmRzXG5cdCAgICAgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICAgICAgZ2FpbiA9IFRvbmUuZGVmYXVsdEFyZyhnYWluLCAxKTtcblx0ICAgICAgICAgICAgdGhpcy5fZ2FpbiA9IGdhaW47XG5cdCAgICAgICAgICAgIC8vdGhlIGZhZGVJbiB0aW1lXG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzVW5kZWYoZmFkZUluVGltZSkpIHtcblx0ICAgICAgICAgICAgICAgIGZhZGVJblRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aGlzLmZhZGVJbik7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmYWRlSW5UaW1lID0gdGhpcy50b1NlY29uZHMoZmFkZUluVGltZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGZhZGVJblRpbWUgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLl9nYWluLCB0aW1lICsgZmFkZUluVGltZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKGdhaW4sIHRpbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRpbWUgKyBmYWRlSW5UaW1lO1xuXHQgICAgICAgICAgICB2YXIgY29tcHV0ZWREdXIgPSBUb25lLmRlZmF1bHRBcmcoZHVyYXRpb24sIHRoaXMuYnVmZmVyLmR1cmF0aW9uIC0gb2Zmc2V0KTtcblx0ICAgICAgICAgICAgY29tcHV0ZWREdXIgPSB0aGlzLnRvU2Vjb25kcyhjb21wdXRlZER1cik7XG5cdCAgICAgICAgICAgIGNvbXB1dGVkRHVyID0gTWF0aC5tYXgoY29tcHV0ZWREdXIsIDApO1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMubG9vcCB8fCB0aGlzLmxvb3AgJiYgIVRvbmUuaXNVbmRlZihkdXJhdGlvbikpIHtcblx0ICAgICAgICAgICAgICAgIC8vY2xpcCB0aGUgZHVyYXRpb24gd2hlbiBub3QgbG9vcGluZ1xuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxvb3ApIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb21wdXRlZER1ciA9IE1hdGgubWluKGNvbXB1dGVkRHVyLCB0aGlzLmJ1ZmZlci5kdXJhdGlvbiAtIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGlzLnN0b3AodGltZSArIGNvbXB1dGVkRHVyICsgZmFkZUluVGltZSwgdGhpcy5mYWRlT3V0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL3N0YXJ0IHRoZSBidWZmZXIgc291cmNlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcblx0ICAgICAgICAgICAgICAgIC8vbW9kaWZ5IHRoZSBvZmZzZXQgaWYgaXQncyBncmVhdGVyIHRoYW4gdGhlIGxvb3AgdGltZVxuXHQgICAgICAgICAgICAgICAgdmFyIGxvb3BFbmQgPSB0aGlzLmxvb3BFbmQgfHwgdGhpcy5idWZmZXIuZHVyYXRpb247XG5cdCAgICAgICAgICAgICAgICB2YXIgbG9vcFN0YXJ0ID0gdGhpcy5sb29wU3RhcnQ7XG5cdCAgICAgICAgICAgICAgICB2YXIgbG9vcER1cmF0aW9uID0gbG9vcEVuZCAtIGxvb3BTdGFydDtcblx0ICAgICAgICAgICAgICAgIC8vbW92ZSB0aGUgb2Zmc2V0IGJhY2tcblx0ICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPiBsb29wRW5kKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCAtIGxvb3BTdGFydCkgJSBsb29wRHVyYXRpb24gKyBsb29wU3RhcnQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLmdldCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UubG9vcEVuZCA9IHRoaXMubG9vcEVuZCB8fCB0aGlzLmJ1ZmZlci5kdXJhdGlvbjtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLnN0YXJ0KHRpbWUsIG9mZnNldCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLkJ1ZmZlclNvdXJjZTogYnVmZmVyIGlzIGVpdGhlciBub3Qgc2V0IG9yIG5vdCBsb2FkZWQuJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBidWZmZXIuIE9wdGlvbmFsbHkgYWRkIGEgcmFtcCB0aW1lIHRvIGZhZGUgdGhlXG5cdFx0ICogIGJ1ZmZlciBvdXQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSAgdGltZSAgICAgICAgIFRoZSB0aW1lIHRoZSBidWZmZXIgc2hvdWxkIHN0b3AuXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSAgZmFkZU91dFRpbWUgIEhvdyBsb25nIHRoZSBnYWluIHNob3VsZCBmYWRlIG91dCBmb3Jcblx0XHQgKiAgQHJldHVybiAge1RvbmUuQnVmZmVyU291cmNlfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSwgZmFkZU91dFRpbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5idWZmZXIubG9hZGVkKSB7XG5cdCAgICAgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICAgICAgLy90aGUgZmFkZU91dCB0aW1lXG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzVW5kZWYoZmFkZU91dFRpbWUpKSB7XG5cdCAgICAgICAgICAgICAgICBmYWRlT3V0VGltZSA9IHRoaXMudG9TZWNvbmRzKHRoaXMuZmFkZU91dCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmYWRlT3V0VGltZSA9IHRoaXMudG9TZWNvbmRzKGZhZGVPdXRUaW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL29ubHkgc3RvcCBpZiB0aGUgbGFzdCBzdG9wIHdhcyBzY2hlZHVsZWQgbGF0ZXJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BUaW1lID09PSAtMSB8fCB0aGlzLl9zdG9wVGltZSA+IHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BUaW1lID0gdGltZTtcblx0ICAgICAgICAgICAgICAgIC8vY2FuY2VsIHRoZSBlbmQgY3VydmVcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2dhaW5Ob2RlLmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuc2FtcGxlVGltZSk7XG5cdCAgICAgICAgICAgICAgICB0aW1lID0gTWF0aC5tYXgodGhpcy5fc3RhcnRUaW1lLCB0aW1lKTtcblx0ICAgICAgICAgICAgICAgIC8vc2V0IGEgbmV3IG9uZVxuXHQgICAgICAgICAgICAgICAgaWYgKGZhZGVPdXRUaW1lID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEZhZGUgPSBNYXRoLm1heCh0aGlzLl9zdGFydFRpbWUsIHRpbWUgLSBmYWRlT3V0VGltZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh0aGlzLl9nYWluLCBzdGFydEZhZGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dhaW5Ob2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgdGltZSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgdGltZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBUb25lLmNvbnRleHQuY2xlYXJUaW1lb3V0KHRoaXMuX29uZW5kZWRUaW1lb3V0KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29uZW5kZWRUaW1lb3V0ID0gVG9uZS5jb250ZXh0LnNldFRpbWVvdXQodGhpcy5fb25lbmRlZC5iaW5kKHRoaXMpLCB0aGlzLl9zdG9wVGltZSAtIHRoaXMubm93KCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLkJ1ZmZlclNvdXJjZTogYnVmZmVyIGlzIGVpdGhlciBub3Qgc2V0IG9yIG5vdCBsb2FkZWQuJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBjYWxsYmFjayB3aGVuIHRoZSBidWZmZXIgaXMgZW5kZWQuXG5cdFx0ICogIEludm9rZXMgYG9uZW5kZWRgIGFuZCBkaXNwb3NlcyB0aGUgbm9kZS5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZS5fb25lbmRlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLm9uZW5kZWQodGhpcyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogSWYgbG9vcCBpcyB0cnVlLCB0aGUgbG9vcCB3aWxsIHN0YXJ0IGF0IHRoaXMgcG9zaXRpb24uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyU291cmNlI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGxvb3BTdGFydFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZSwgJ2xvb3BTdGFydCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5sb29wU3RhcnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wU3RhcnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLmxvb3BTdGFydCA9IHRoaXMudG9TZWNvbmRzKGxvb3BTdGFydCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBJZiBsb29wIGlzIHRydWUsIHRoZSBsb29wIHdpbGwgZW5kIGF0IHRoaXMgcG9zaXRpb24uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyU291cmNlI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGxvb3BFbmRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUsICdsb29wRW5kJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlLmxvb3BFbmQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wRW5kKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5sb29wRW5kID0gdGhpcy50b1NlY29uZHMobG9vcEVuZCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgYXVkaW8gYnVmZmVyIGJlbG9uZ2luZyB0byB0aGUgcGxheWVyLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlclNvdXJjZSNcblx0XHQgKiBAdHlwZSB7VG9uZS5CdWZmZXJ9XG5cdFx0ICogQG5hbWUgYnVmZmVyXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLCAnYnVmZmVyJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5zZXQoYnVmZmVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIHRoZSBidWZmZXIgc2hvdWxkIGxvb3Agb25jZSBpdCdzIG92ZXIuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyU291cmNlI1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBuYW1lIGxvb3Bcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUsICdsb29wJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlLmxvb3A7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5sb29wID0gbG9vcDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuQnVmZmVyU291cmNlfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLm9uZW5kZWQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fc291cmNlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9nYWluTm9kZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZ2Fpbk5vZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSAtMTtcblx0ICAgICAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IG51bGw7XG5cdCAgICAgICAgVG9uZS5jb250ZXh0LmNsZWFyVGltZW91dCh0aGlzLl9vbmVuZGVkVGltZW91dCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQnVmZmVyU291cmNlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuTm9pc2UgaXMgYSBub2lzZSBnZW5lcmF0b3IuIEl0IHVzZXMgbG9vcGVkIG5vaXNlIGJ1ZmZlcnMgdG8gc2F2ZSBvbiBwZXJmb3JtYW5jZS5cblx0XHQgKiAgICAgICAgICBUb25lLk5vaXNlIHN1cHBvcnRzIHRoZSBub2lzZSB0eXBlczogXCJwaW5rXCIsIFwid2hpdGVcIiwgYW5kIFwiYnJvd25cIi4gUmVhZCBtb3JlIGFib3V0XG5cdFx0ICogICAgICAgICAgY29sb3JzIG9mIG5vaXNlIG9uIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbG9yc19vZl9ub2lzZSkuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNvdXJjZX1cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHR5cGUgdGhlIG5vaXNlIHR5cGUgKHdoaXRlfHBpbmt8YnJvd24pXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9pbml0aWFsaXplIHRoZSBub2lzZSBhbmQgc3RhcnRcblx0XHQgKiB2YXIgbm9pc2UgPSBuZXcgVG9uZS5Ob2lzZShcInBpbmtcIikuc3RhcnQoKTtcblx0XHQgKiBcblx0XHQgKiAvL21ha2UgYW4gYXV0b2ZpbHRlciB0byBzaGFwZSB0aGUgbm9pc2Vcblx0XHQgKiB2YXIgYXV0b0ZpbHRlciA9IG5ldyBUb25lLkF1dG9GaWx0ZXIoe1xuXHRcdCAqIFx0XCJmcmVxdWVuY3lcIiA6IFwiOG1cIiwgXG5cdFx0ICogXHRcIm1pblwiIDogODAwLCBcblx0XHQgKiBcdFwibWF4XCIgOiAxNTAwMFxuXHRcdCAqIH0pLmNvbm5lY3QoVG9uZS5NYXN0ZXIpO1xuXHRcdCAqIFxuXHRcdCAqIC8vY29ubmVjdCB0aGUgbm9pc2Vcblx0XHQgKiBub2lzZS5jb25uZWN0KGF1dG9GaWx0ZXIpO1xuXHRcdCAqIC8vc3RhcnQgdGhlIGF1dG9maWx0ZXIgTEZPXG5cdFx0ICogYXV0b0ZpbHRlci5zdGFydCgpXG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsndHlwZSddLCBUb25lLk5vaXNlKTtcblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvQnVmZmVyU291cmNlTm9kZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGJ1ZmZlclxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvQnVmZmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGxheWJhY2sgcmF0ZSBvZiB0aGUgbm9pc2UuIEFmZmVjdHNcblx0XHRcdCAqICB0aGUgXCJmcmVxdWVuY3lcIiBvZiB0aGUgbm9pc2UuXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IG9wdGlvbnMucGxheWJhY2tSYXRlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTm9pc2UsIFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICpcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2UuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3R5cGUnOiAnd2hpdGUnLFxuXHQgICAgICAgICdwbGF5YmFja1JhdGUnOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIG5vaXNlLiBDYW4gYmUgXCJ3aGl0ZVwiLCBcImJyb3duXCIsIG9yIFwicGlua1wiLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Ob2lzZSNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIG5vaXNlLnR5cGUgPSBcIndoaXRlXCI7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Ob2lzZS5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgIT09IHR5cGUpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlIGluIF9ub2lzZUJ1ZmZlcnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgICAgICAgICAvL2lmIGl0J3MgcGxheWluZywgc3RvcCBhbmQgcmVzdGFydCBpdFxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3Aobm93KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQobm93KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RvbmUuTm9pc2U6IGludmFsaWQgdHlwZTogJyArIHR5cGUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHBsYXliYWNrIHJhdGUgb2YgdGhlIG5vaXNlLiBBZmZlY3RzXG5cdFx0ICogIHRoZSBcImZyZXF1ZW5jeVwiIG9mIHRoZSBub2lzZS5cblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAc2lnbmFsXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Ob2lzZS5wcm90b3R5cGUsICdwbGF5YmFja1JhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF5YmFja1JhdGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyYXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IHJhdGU7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSByYXRlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgaW50ZXJuYWwgc3RhcnQgbWV0aG9kXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSB0aW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHZhciBidWZmZXIgPSBfbm9pc2VCdWZmZXJzW3RoaXMuX3R5cGVdO1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZSA9IG5ldyBUb25lLkJ1ZmZlclNvdXJjZShidWZmZXIpLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZS5sb29wID0gdHJ1ZTtcblx0ICAgICAgICB0aGlzLl9zb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5fcGxheWJhY2tSYXRlO1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZS5zdGFydCh0aGlzLnRvU2Vjb25kcyh0aW1lKSwgTWF0aC5yYW5kb20oKSAqIChidWZmZXIuZHVyYXRpb24gLSAwLjAwMSkpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBpbnRlcm5hbCBzdG9wIG1ldGhvZFxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gdGltZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob2lzZS5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLnN0b3AodGhpcy50b1NlY29uZHModGltZSkpO1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk5vaXNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gVEhFIEJVRkZFUlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9Ob2lzZSBidWZmZXIgc3RhdHNcblx0ICAgIHZhciBidWZmZXJMZW5ndGggPSA0NDEwMCAqIDU7XG5cdCAgICB2YXIgY2hhbm5lbHMgPSAyO1xuXHQgICAgLyoqXG5cdFx0ICpcdFRoZSBub2lzZSBhcnJheXMuIEdlbmVyYXRlZCBvbiBpbml0aWFsaXphdGlvbi5cblx0XHQgKiAgYm9ycm93ZWQgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS96YWNoYXJ5ZGVudG9uL25vaXNlLmpzIFxuXHRcdCAqICAoYykgMjAxMyBaYWNoIERlbnRvbiAoTUlUKVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0ICAgIHZhciBfbm9pc2VBcnJheXMgPSB7XG5cdCAgICAgICAgJ3BpbmsnOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBidWZmZXIgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgY2hhbm5lbE51bSA9IDA7IGNoYW5uZWxOdW0gPCBjaGFubmVsczsgY2hhbm5lbE51bSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyTGVuZ3RoKTtcblx0ICAgICAgICAgICAgICAgIGJ1ZmZlcltjaGFubmVsTnVtXSA9IGNoYW5uZWw7XG5cdCAgICAgICAgICAgICAgICB2YXIgYjAsIGIxLCBiMiwgYjMsIGI0LCBiNSwgYjY7XG5cdCAgICAgICAgICAgICAgICBiMCA9IGIxID0gYjIgPSBiMyA9IGI0ID0gYjUgPSBiNiA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHdoaXRlID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIGIwID0gMC45OTg4NiAqIGIwICsgd2hpdGUgKiAwLjA1NTUxNzk7XG5cdCAgICAgICAgICAgICAgICAgICAgYjEgPSAwLjk5MzMyICogYjEgKyB3aGl0ZSAqIDAuMDc1MDc1OTtcblx0ICAgICAgICAgICAgICAgICAgICBiMiA9IDAuOTY5ICogYjIgKyB3aGl0ZSAqIDAuMTUzODUyO1xuXHQgICAgICAgICAgICAgICAgICAgIGIzID0gMC44NjY1ICogYjMgKyB3aGl0ZSAqIDAuMzEwNDg1Njtcblx0ICAgICAgICAgICAgICAgICAgICBiNCA9IDAuNTUgKiBiNCArIHdoaXRlICogMC41MzI5NTIyO1xuXHQgICAgICAgICAgICAgICAgICAgIGI1ID0gLTAuNzYxNiAqIGI1IC0gd2hpdGUgKiAwLjAxNjg5ODtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFubmVsW2ldID0gYjAgKyBiMSArIGIyICsgYjMgKyBiNCArIGI1ICsgYjYgKyB3aGl0ZSAqIDAuNTM2Mjtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFubmVsW2ldICo9IDAuMTE7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gKHJvdWdobHkpIGNvbXBlbnNhdGUgZm9yIGdhaW5cblx0ICAgICAgICAgICAgICAgICAgICBiNiA9IHdoaXRlICogMC4xMTU5MjY7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcblx0ICAgICAgICB9KCksXG5cdCAgICAgICAgJ2Jyb3duJzogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgYnVmZmVyID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGNoYW5uZWxOdW0gPSAwOyBjaGFubmVsTnVtIDwgY2hhbm5lbHM7IGNoYW5uZWxOdW0rKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlckxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICBidWZmZXJbY2hhbm5lbE51bV0gPSBjaGFubmVsO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxhc3RPdXQgPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB3aGl0ZSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFubmVsW2ldID0gKGxhc3RPdXQgKyAwLjAyICogd2hpdGUpIC8gMS4wMjtcblx0ICAgICAgICAgICAgICAgICAgICBsYXN0T3V0ID0gY2hhbm5lbFtpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFubmVsW2ldICo9IDMuNTsgICAgLy8gKHJvdWdobHkpIGNvbXBlbnNhdGUgZm9yIGdhaW5cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuXHQgICAgICAgIH0oKSxcblx0ICAgICAgICAnd2hpdGUnOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBidWZmZXIgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgY2hhbm5lbE51bSA9IDA7IGNoYW5uZWxOdW0gPCBjaGFubmVsczsgY2hhbm5lbE51bSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyTGVuZ3RoKTtcblx0ICAgICAgICAgICAgICAgIGJ1ZmZlcltjaGFubmVsTnVtXSA9IGNoYW5uZWw7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhbm5lbFtpXSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuXHQgICAgICAgIH0oKVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqXHRzdGF0aWMgbm9pc2UgYnVmZmVyc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlIHtUb25lLkJ1ZmZlcn1cblx0XHQgKi9cblx0ICAgIHZhciBfbm9pc2VCdWZmZXJzID0ge307XG5cdCAgICAvL2NyZWF0ZSB0aGUgVG9uZS5CdWZmZXJzXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVCdWZmZXJzKCkge1xuXHQgICAgICAgIGZvciAodmFyIHR5cGUgaW4gX25vaXNlQXJyYXlzKSB7XG5cdCAgICAgICAgICAgIF9ub2lzZUJ1ZmZlcnNbdHlwZV0gPSBuZXcgVG9uZS5CdWZmZXIoKS5mcm9tQXJyYXkoX25vaXNlQXJyYXlzW3R5cGVdKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvL2NyZWF0ZSB0aGUgbm9pc2UgYnVmZmVyc1xuXHQgICAgVG9uZS5nZXRDb250ZXh0KGNyZWF0ZUJ1ZmZlcnMpO1xuXHQgICAgVG9uZS5Db250ZXh0Lm9uKCdpbml0JywgY3JlYXRlQnVmZmVycyk7XG5cdCAgICByZXR1cm4gVG9uZS5Ob2lzZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLk5vaXNlU3ludGggaXMgY29tcG9zZWQgb2YgYSBub2lzZSBnZW5lcmF0b3IgKFRvbmUuTm9pc2UpLCBvbmUgZmlsdGVyIChUb25lLkZpbHRlciksIFxuXHRcdCAqICAgICAgICAgIGFuZCB0d28gZW52ZWxvcGVzIChUb25lLkVudmVsb3ApLiBPbmUgZW52ZWxvcGUgY29udHJvbHMgdGhlIGFtcGxpdHVkZVxuXHRcdCAqICAgICAgICAgIG9mIHRoZSBub2lzZSBhbmQgdGhlIG90aGVyIGlzIGNvbnRyb2xzIHRoZSBjdXRvZmYgZnJlcXVlbmN5IG9mIHRoZSBmaWx0ZXIuIFxuXHRcdCAqICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZHJhd2luZ3MvZC8xcnF6dVg5ckJsaFQ1ME1SdkQyVEttbDliblpoY1ptelhGMXJmX283dmRuRS9wdWI/dz05MTgmaD0yNDJcIj5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuSW5zdHJ1bWVudH1cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoZSBzeW50aCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiB2YXIgbm9pc2VTeW50aCA9IG5ldyBUb25lLk5vaXNlU3ludGgoKS50b01hc3RlcigpO1xuXHRcdCAqIG5vaXNlU3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2VTeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgLy9nZXQgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLk5vaXNlU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBub2lzZSBzb3VyY2UuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTm9pc2V9XG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIG5vaXNlU3ludGguc2V0KFwibm9pc2UudHlwZVwiLCBcImJyb3duXCIpO1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5ub2lzZSA9IG5ldyBUb25lLk5vaXNlKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtcGxpdHVkZSBlbnZlbG9wZS4gXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQW1wbGl0dWRlRW52ZWxvcGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbmV3IFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUob3B0aW9ucy5lbnZlbG9wZSk7XG5cdCAgICAgICAgLy9jb25uZWN0IHRoZSBub2lzZSB0byB0aGUgb3V0cHV0XG5cdCAgICAgICAgdGhpcy5ub2lzZS5jaGFpbih0aGlzLmVudmVsb3BlLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgLy9zdGFydCB0aGUgbm9pc2Vcblx0ICAgICAgICB0aGlzLm5vaXNlLnN0YXJ0KCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnbm9pc2UnLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Ob2lzZVN5bnRoLCBUb25lLkluc3RydW1lbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlU3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ25vaXNlJzogeyAndHlwZSc6ICd3aGl0ZScgfSxcblx0ICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAwNSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMC4xLFxuXHQgICAgICAgICAgICAnc3VzdGFpbic6IDBcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IHRoZSBhdHRhY2sgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVzLiBVbmxpa2Ugb3RoZXIgXG5cdFx0ICogIGluc3RydW1lbnRzLCBUb25lLk5vaXNlU3ludGggZG9lc24ndCBoYXZlIGEgbm90ZS4gXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgYXR0YWNrIHNob3VsZCBzdGFydFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZSAoMC0xKVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Ob2lzZVN5bnRofSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogbm9pc2VTeW50aC50cmlnZ2VyQXR0YWNrKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlU3ludGgucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICAvL3RoZSBlbnZlbG9wZXNcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgcmVsZWFzZSBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZXMuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgcmVsZWFzZSBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTm9pc2VTeW50aH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob2lzZVN5bnRoLnByb3RvdHlwZS50cmlnZ2VyUmVsZWFzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgYXR0YWNrIGFuZCB0aGVuIHRoZSByZWxlYXNlLiBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gZHVyYXRpb24gdGhlIGR1cmF0aW9uIG9mIHRoZSBub3RlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gICAgIHRoZSB0aW1lIG9mIHRoZSBhdHRhY2tcblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSBbdmVsb2NpdHk9MV0gdGhlIHZlbG9jaXR5XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk5vaXNlU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2VTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFja1JlbGVhc2UgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGR1cmF0aW9uID0gdGhpcy50b1NlY29uZHMoZHVyYXRpb24pO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyUmVsZWFzZSh0aW1lICsgZHVyYXRpb24pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk5vaXNlU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2VTeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdub2lzZScsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLm5vaXNlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm5vaXNlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Ob2lzZVN5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgS2FycGx1cy1TdHJpbmcgc3RyaW5nIHN5bnRoZXNpcy4gT2Z0ZW4gb3V0IG9mIHR1bmUuIFxuXHRcdCAqICAgICAgICAgV2lsbCBjaGFuZ2Ugd2hlbiB0aGUgQXVkaW9Xb3JrZXJOb2RlIGlzIGF2YWlsYWJsZSBhY3Jvc3Ncblx0XHQgKiAgICAgICAgIGJyb3dzZXJzLiBcblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5JbnN0cnVtZW50fVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHNlZSB0aGUgZGVmYXVsdHNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgcGx1Y2t5ID0gbmV3IFRvbmUuUGx1Y2tTeW50aCgpLnRvTWFzdGVyKCk7XG5cdFx0ICogcGx1Y2t5LnRyaWdnZXJBdHRhY2soXCJDNFwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGx1Y2tTeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLlBsdWNrU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk5vaXNlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ub2lzZSA9IG5ldyBUb25lLk5vaXNlKCdwaW5rJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBub2lzZSBhdCB0aGUgYXR0YWNrLiBcblx0XHRcdCAqICBOb21pbmFsIHJhbmdlIG9mIFswLjEsIDIwXVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmF0dGFja05vaXNlID0gb3B0aW9ucy5hdHRhY2tOb2lzZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgTEZDRlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxvd3Bhc3NDb21iRmlsdGVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZmNmID0gbmV3IFRvbmUuTG93cGFzc0NvbWJGaWx0ZXIoe1xuXHQgICAgICAgICAgICAncmVzb25hbmNlJzogb3B0aW9ucy5yZXNvbmFuY2UsXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnOiBvcHRpb25zLmRhbXBlbmluZ1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSByZXNvbmFuY2UgY29udHJvbC4gXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmVzb25hbmNlID0gdGhpcy5fbGZjZi5yZXNvbmFuY2U7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRhbXBlbmluZyBjb250cm9sLiBpLmUuIHRoZSBsb3dwYXNzIGZpbHRlciBmcmVxdWVuY3kgb2YgdGhlIGNvbWIgZmlsdGVyXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRhbXBlbmluZyA9IHRoaXMuX2xmY2YuZGFtcGVuaW5nO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLl9ub2lzZS5jb25uZWN0KHRoaXMuX2xmY2YpO1xuXHQgICAgICAgIHRoaXMuX2xmY2YuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAncmVzb25hbmNlJyxcblx0ICAgICAgICAgICAgJ2RhbXBlbmluZydcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBsdWNrU3ludGgsIFRvbmUuSW5zdHJ1bWVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuUGx1Y2tTeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnYXR0YWNrTm9pc2UnOiAxLFxuXHQgICAgICAgICdkYW1wZW5pbmcnOiA0MDAwLFxuXHQgICAgICAgICdyZXNvbmFuY2UnOiAwLjlcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgbm90ZS4gXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBub3RlIFRoZSBub3RlIHRvIHRyaWdnZXIuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBub3RlIHNob3VsZCBiZSB0cmlnZ2VyZWQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBsdWNrU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGx1Y2tTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uIChub3RlLCB0aW1lKSB7XG5cdCAgICAgICAgbm90ZSA9IHRoaXMudG9GcmVxdWVuY3kobm90ZSk7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHZhciBkZWxheUFtb3VudCA9IDEgLyBub3RlO1xuXHQgICAgICAgIHRoaXMuX2xmY2YuZGVsYXlUaW1lLnNldFZhbHVlQXRUaW1lKGRlbGF5QW1vdW50LCB0aW1lKTtcblx0ICAgICAgICB0aGlzLl9ub2lzZS5zdGFydCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9ub2lzZS5zdG9wKHRpbWUgKyBkZWxheUFtb3VudCAqIHRoaXMuYXR0YWNrTm9pc2UpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBsdWNrU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGx1Y2tTeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9ub2lzZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZjZi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbm9pc2UgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xmY2YgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZScsXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcgPSBudWxsO1xuXHQgICAgICAgIHRoaXMucmVzb25hbmNlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QbHVja1N5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuUG9seVN5bnRoIGhhbmRsZXMgdm9pY2UgY3JlYXRpb24gYW5kIGFsbG9jYXRpb24gZm9yIGFueVxuXHRcdCAqICAgICAgICAgIGluc3RydW1lbnRzIHBhc3NlZCBpbiBhcyB0aGUgc2Vjb25kIHBhcmFtdGVyLiBQb2x5U3ludGggaXMgXG5cdFx0ICogICAgICAgICAgbm90IGEgc3ludGhlc2l6ZXIgYnkgaXRzZWxmLCBpdCBtZXJlbHkgbWFuYWdlcyB2b2ljZXMgb2YgXG5cdFx0ICogICAgICAgICAgb25lIG9mIHRoZSBvdGhlciB0eXBlcyBvZiBzeW50aHMsIGFsbG93aW5nIGFueSBvZiB0aGUgXG5cdFx0ICogICAgICAgICAgbW9ub3Bob25pYyBzeW50aGVzaXplcnMgdG8gYmUgcG9seXBob25pYy4gXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkluc3RydW1lbnR9XG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gW3BvbHlwaG9ueT00XSBUaGUgbnVtYmVyIG9mIHZvaWNlcyB0byBjcmVhdGVcblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gW3ZvaWNlPVRvbmUuU3ludGhdIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgdm9pY2VzXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXMgVG9uZS5TeW50aCBieSBkZWZhdWx0LiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2EgcG9seXN5bnRoIGNvbXBvc2VkIG9mIDYgVm9pY2VzIG9mIFN5bnRoXG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFRvbmUuUG9seVN5bnRoKDYsIFRvbmUuU3ludGgpLnRvTWFzdGVyKCk7XG5cdFx0ICogLy9zZXQgdGhlIGF0dHJpYnV0ZXMgdXNpbmcgdGhlIHNldCBpbnRlcmZhY2Vcblx0XHQgKiBzeW50aC5zZXQoXCJkZXR1bmVcIiwgLTEyMDApO1xuXHRcdCAqIC8vcGxheSBhIGNob3JkXG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoW1wiQzRcIiwgXCJFNFwiLCBcIkE0XCJdLCBcIjRuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Qb2x5U3ludGggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAncG9seXBob255Jyxcblx0ICAgICAgICAgICAgJ3ZvaWNlJ1xuXHQgICAgICAgIF0sIFRvbmUuUG9seVN5bnRoKTtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuSW5zdHJ1bWVudC5kZWZhdWx0cyk7XG5cdCAgICAgICAgLy9tYXggcG9seXBob255XG5cdCAgICAgICAgb3B0aW9ucy5wb2x5cGhvbnkgPSBNYXRoLm1pbihUb25lLlBvbHlTeW50aC5NQVhfUE9MWVBIT05ZLCBvcHRpb25zLnBvbHlwaG9ueSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGFycmF5IG9mIHZvaWNlc1xuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9pY2VzID0gbmV3IEFycmF5KG9wdGlvbnMucG9seXBob255KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcXVldWUgb2Ygdm9pY2VzIHdpdGggZGF0YSBhYm91dCBsYXN0IHRyaWdnZXJcblx0XHRcdCAqICBhbmQgdGhlIHRyaWdnZXJlZCBub3RlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90cmlnZ2VycyA9IG5ldyBBcnJheShvcHRpb25zLnBvbHlwaG9ueSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBpbiBjZW50c1xuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmRldHVuZSwgVG9uZS5UeXBlLkNlbnRzKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgnZGV0dW5lJyk7XG5cdCAgICAgICAgLy9jcmVhdGUgdGhlIHZvaWNlc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5wb2x5cGhvbnk7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgdiA9IG5ldyBvcHRpb25zLnZvaWNlKGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcblx0ICAgICAgICAgICAgdGhpcy52b2ljZXNbaV0gPSB2O1xuXHQgICAgICAgICAgICB2LmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgICAgICBpZiAodi5oYXNPd25Qcm9wZXJ0eSgnZGV0dW5lJykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGV0dW5lLmNvbm5lY3Qodi5kZXR1bmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJzW2ldID0ge1xuXHQgICAgICAgICAgICAgICAgcmVsZWFzZTogLTEsXG5cdCAgICAgICAgICAgICAgICBub3RlOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgdm9pY2U6IHZcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Qb2x5U3ludGgsIFRvbmUuSW5zdHJ1bWVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHRzXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncG9seXBob255JzogNCxcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAndm9pY2UnOiBUb25lLlN5bnRoXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBub3RlXG5cdFx0ICogIEBwYXJhbSAge0ZyZXF1ZW5jeXxBcnJheX0gbm90ZXMgVGhlIG5vdGVzIHRvIHBsYXkuIEFjY2VwdHMgYSBzaW5nbGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGcmVxdWVuY3kgb3IgYW4gYXJyYXkgb2YgZnJlcXVlbmNpZXMuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gIFRoZSBzdGFydCB0aW1lIG9mIHRoZSBub3RlLlxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3ZlbG9jaXR5PTFdIFRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUG9seVN5bnRofSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy90cmlnZ2VyIGEgY2hvcmQgaW1tZWRpYXRlbHkgd2l0aCBhIHZlbG9jaXR5IG9mIDAuMlxuXHRcdCAqIHBvbHkudHJpZ2dlckF0dGFjayhbXCJBYjNcIiwgXCJDNFwiLCBcIkY1XCJdLCB1bmRlZmluZWQsIDAuMik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uIChub3RlcywgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobm90ZXMpKSB7XG5cdCAgICAgICAgICAgIG5vdGVzID0gW25vdGVzXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm90ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IG5vdGVzW2ldO1xuXHQgICAgICAgICAgICAvL3RyaWdnZXIgdGhlIG9sZGVzdCB2b2ljZVxuXHQgICAgICAgICAgICB2YXIgb2xkZXN0ID0gdGhpcy5fdHJpZ2dlcnNbMF07XG5cdCAgICAgICAgICAgIHZhciBvbGRlc3RJbmRleCA9IDA7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgdGhpcy5fdHJpZ2dlcnMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmlnZ2Vyc1tqXS5yZWxlYXNlIDwgb2xkZXN0LnJlbGVhc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvbGRlc3QgPSB0aGlzLl90cmlnZ2Vyc1tqXTtcblx0ICAgICAgICAgICAgICAgICAgICBvbGRlc3RJbmRleCA9IGo7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb2xkZXN0LnJlbGVhc2UgPSBJbmZpbml0eTtcblx0ICAgICAgICAgICAgb2xkZXN0Lm5vdGUgPSBKU09OLnN0cmluZ2lmeSh2YWwpO1xuXHQgICAgICAgICAgICBvbGRlc3Qudm9pY2UudHJpZ2dlckF0dGFjayh2YWwsIHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIGF0dGFjayBhbmQgcmVsZWFzZSBhZnRlciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtGcmVxdWVuY3l8QXJyYXl9IG5vdGVzIFRoZSBub3RlcyB0byBwbGF5LiBBY2NlcHRzIGEgc2luZ2xlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRnJlcXVlbmN5IG9yIGFuIGFycmF5IG9mIGZyZXF1ZW5jaWVzLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBkdXJhdGlvbiB0aGUgZHVyYXRpb24gb2YgdGhlIG5vdGVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSAgICAgaWYgbm8gdGltZSBpcyBnaXZlbiwgZGVmYXVsdHMgdG8gbm93XG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgYXR0YWNrICgwLTEpXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBvbHlTeW50aH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdHJpZ2dlciBhIGNob3JkIGZvciBhIGR1cmF0aW9uIG9mIGEgaGFsZiBub3RlIFxuXHRcdCAqIHBvbHkudHJpZ2dlckF0dGFja1JlbGVhc2UoW1wiRWIzXCIsIFwiRzRcIiwgXCJDNVwiXSwgXCIyblwiKTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2NhbiBwYXNzIGluIGFuIGFycmF5IG9mIGR1cmF0aW9ucyBhcyB3ZWxsXG5cdFx0ICogcG9seS50cmlnZ2VyQXR0YWNrUmVsZWFzZShbXCJFYjNcIiwgXCJHNFwiLCBcIkM1XCJdLCBbXCIyblwiLCBcIjRuXCIsIFwiNG5cIl0pO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Qb2x5U3ludGgucHJvdG90eXBlLnRyaWdnZXJBdHRhY2tSZWxlYXNlID0gZnVuY3Rpb24gKG5vdGVzLCBkdXJhdGlvbiwgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyQXR0YWNrKG5vdGVzLCB0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNBcnJheShkdXJhdGlvbikgJiYgVG9uZS5pc0FycmF5KG5vdGVzKSkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZCA9IGR1cmF0aW9uW01hdGgubWluKGksIGR1cmF0aW9uLmxlbmd0aCAtIDEpXTtcblx0ICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlclJlbGVhc2Uobm90ZXNbaV0sIHRpbWUgKyB0aGlzLnRvU2Vjb25kcyhkKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLnRyaWdnZXJSZWxlYXNlKG5vdGVzLCB0aW1lICsgdGhpcy50b1NlY29uZHMoZHVyYXRpb24pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIHJlbGVhc2Ugb2YgdGhlIG5vdGUuIFVubGlrZSBtb25vcGhvbmljIGluc3RydW1lbnRzLCBcblx0XHQgKiAgYSBub3RlIChvciBhcnJheSBvZiBub3RlcykgbmVlZHMgdG8gYmUgcGFzc2VkIGluIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cblx0XHQgKiAgQHBhcmFtICB7RnJlcXVlbmN5fEFycmF5fSBub3RlcyBUaGUgbm90ZXMgdG8gcGxheS4gQWNjZXB0cyBhIHNpbmdsZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZyZXF1ZW5jeSBvciBhbiBhcnJheSBvZiBmcmVxdWVuY2llcy5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSAgV2hlbiB0aGUgcmVsZWFzZSB3aWxsIGJlIHRyaWdnZXJlZC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBvbHlTeW50aH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHBvbHkudHJpZ2dlclJlbGVhc2UoW1wiQWIzXCIsIFwiQzRcIiwgXCJGNVwiXSwgXCIrMm5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAobm90ZXMsIHRpbWUpIHtcblx0ICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobm90ZXMpKSB7XG5cdCAgICAgICAgICAgIG5vdGVzID0gW25vdGVzXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm90ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgLy9nZXQgdGhlIHZvaWNlXG5cdCAgICAgICAgICAgIHZhciBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KG5vdGVzW2ldKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCB0aGlzLl90cmlnZ2Vycy5sZW5ndGg7IHYrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSB0aGlzLl90cmlnZ2Vyc1t2XTtcblx0ICAgICAgICAgICAgICAgIGlmIChkZXNjLm5vdGUgPT09IHN0cmluZ2lmaWVkICYmIGRlc2MucmVsZWFzZSA+IHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZXNjLnZvaWNlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlc2MucmVsZWFzZSA9IHRpbWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCBhIG1lbWJlci9hdHRyaWJ1dGUgb2YgdGhlIHZvaWNlcy4gXG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gcGFyYW1zXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gcmFtcFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUG9seVN5bnRofSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogcG9seS5zZXQoe1xuXHRcdCAqIFx0XCJmaWx0ZXJcIiA6IHtcblx0XHQgKiBcdFx0XCJ0eXBlXCIgOiBcImhpZ2hwYXNzXCJcblx0XHQgKiBcdH0sXG5cdFx0ICogXHRcImVudmVsb3BlXCIgOiB7XG5cdFx0ICogXHRcdFwiYXR0YWNrXCIgOiAwLjI1XG5cdFx0ICogXHR9XG5cdFx0ICogfSk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWUsIHJhbXBUaW1lKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZvaWNlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLnZvaWNlc1tpXS5zZXQocGFyYW1zLCB2YWx1ZSwgcmFtcFRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBzeW50aCdzIGF0dHJpYnV0ZXMuIEdpdmVuIG5vIGFyZ3VtZW50cyBnZXRcblx0XHQgKiAgd2lsbCByZXR1cm4gYWxsIGF2YWlsYWJsZSBvYmplY3QgcHJvcGVydGllcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZ1xuXHRcdCAqICB2YWx1ZXMuIFBhc3MgaW4gYSBzaW5nbGUgYXR0cmlidXRlIHRvIHJldHJpZXZlIG9yIGFuIGFycmF5XG5cdFx0ICogIG9mIGF0dHJpYnV0ZXMuIFRoZSBhdHRyaWJ1dGUgc3RyaW5ncyBjYW4gYWxzbyBpbmNsdWRlIGEgXCIuXCJcblx0XHQgKiAgdG8gYWNjZXNzIGRlZXBlciBwcm9wZXJ0aWVzLlxuXHRcdCAqICBAcGFyYW0ge0FycmF5PX0gcGFyYW1zIHRoZSBwYXJhbWV0ZXJzIHRvIGdldCwgb3RoZXJ3aXNlIHdpbGwgcmV0dXJuIFxuXHRcdCAqICBcdFx0XHRcdFx0ICAgYWxsIGF2YWlsYWJsZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudm9pY2VzWzBdLmdldChwYXJhbXMpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSByZWxlYXNlIHBvcnRpb24gb2YgYWxsIHRoZSBjdXJyZW50bHkgYWN0aXZlIHZvaWNlcy5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIG5vdGVzIHNob3VsZCBiZSByZWxlYXNlZC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5Qb2x5U3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoLnByb3RvdHlwZS5yZWxlYXNlQWxsID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90cmlnZ2Vycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgZGVzYyA9IHRoaXMuX3RyaWdnZXJzW2ldO1xuXHQgICAgICAgICAgICBpZiAoZGVzYy5yZWxlYXNlID4gdGltZSkge1xuXHQgICAgICAgICAgICAgICAgZGVzYy5yZWxlYXNlID0gdGltZTtcblx0ICAgICAgICAgICAgICAgIGRlc2Mudm9pY2UudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Qb2x5U3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52b2ljZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy52b2ljZXNbaV0uZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB0aGlzLnZvaWNlc1tpXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCdkZXR1bmUnKTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudm9pY2VzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl90cmlnZ2VycyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBtYXhpbXVtIG51bWJlciBvZiBub3RlcyB0aGF0IGNhbiBiZSBhbGxvY2F0ZWQgXG5cdFx0ICogIHRvIGEgcG9seXN5bnRoLiBcblx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoLk1BWF9QT0xZUEhPTlkgPSAyMDtcblx0ICAgIHJldHVybiBUb25lLlBvbHlTeW50aDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogQGNsYXNzIEF1dG9tYXRpY2FsbHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gYSBzZXQgb2YgcGl0Y2hlZCBzYW1wbGVzLiBQYXNzIGluIGFuIG9iamVjdCB3aGljaCBtYXBzIHRoZSBub3RlJ3MgcGl0Y2ggb3IgbWlkaSB2YWx1ZSB0byB0aGUgdXJsLCB0aGVuIHlvdSBjYW4gdHJpZ2dlciB0aGUgYXR0YWNrIGFuZCByZWxlYXNlIG9mIHRoYXQgbm90ZSBsaWtlIG90aGVyIGluc3RydW1lbnRzLiBCeSBhdXRvbWF0aWNhbGx5IHJlcGl0Y2hpbmcgdGhlIHNhbXBsZXMsIGl0IGlzIHBvc3NpYmxlIHRvIHBsYXkgcGl0Y2hlcyB3aGljaCB3ZXJlIG5vdCBleHBsaWNpdGx5IGluY2x1ZGVkIHdoaWNoIGNhbiBzYXZlIGxvYWRpbmcgdGltZS5cblx0XHQgKiAgICAgICAgRm9yIHNhbXBsZSBvciBidWZmZXIgcGxheWJhY2sgd2hlcmUgcmVwaXRjaGluZyBpcyBub3QgbmVjZXNzYXJ5LCB1c2UgW1RvbmUuUGxheWVyXShodHRwczovL3RvbmVqcy5naXRodWIuaW8vZG9jcy9QbGF5ZXIpLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBzYW1wbGVzIEFuIG9iamVjdCBvZiBzYW1wbGVzIG1hcHBpbmcgZWl0aGVyIE1pZGlcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICBOb3RlIE51bWJlcnMgb3IgU2NpZW50aWZpYyBQaXRjaCBOb3RhdGlvblxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSB1cmwgb2YgdGhhdCBzYW1wbGUuXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiB2YXIgc2FtcGxlciA9IG5ldyBUb25lLlNhbXBsZXIoe1xuXHRcdCAqIFx0XCJDM1wiIDogXCJwYXRoL3RvL0MzLm1wM1wiLFxuXHRcdCAqIFx0XCJEIzNcIiA6IFwicGF0aC90by9Ec2hhcnAzLm1wM1wiLFxuXHRcdCAqIFx0XCJGIzNcIiA6IFwicGF0aC90by9Gc2hhcnAzLm1wM1wiLFxuXHRcdCAqIFx0XCJBM1wiIDogXCJwYXRoL3RvL0EzLm1wM1wiLFxuXHRcdCAqIH0sIGZ1bmN0aW9uKCl7XG5cdFx0ICogXHQvL3NhbXBsZXIgd2lsbCByZXBpdGNoIHRoZSBjbG9zZXN0IHNhbXBsZVxuXHRcdCAqIFx0c2FtcGxlci50cmlnZ2VyQXR0YWNrKFwiRDNcIilcblx0XHQgKiB9KVxuXHRcdCAqIEBleHRlbmRzIHtUb25lLkluc3RydW1lbnR9XG5cdFx0ICovXG5cdCAgICBUb25lLlNhbXBsZXIgPSBmdW5jdGlvbiAodXJscykge1xuXHQgICAgICAgIC8vIHNoaWZ0IGFyZ3VtZW50cyBvdmVyIG9uZS4gVGhvc2UgYXJlIHRoZSByZW1haW5kZXIgb2YgdGhlIG9wdGlvbnNcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgYXJncy5zaGlmdCgpO1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmdzLCBbXG5cdCAgICAgICAgICAgICdvbmxvYWQnLFxuXHQgICAgICAgICAgICAnYmFzZVVybCdcblx0ICAgICAgICBdLCBUb25lLlNhbXBsZXIpO1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIHZhciB1cmxNYXAgPSB7fTtcblx0ICAgICAgICBmb3IgKHZhciBub3RlIGluIHVybHMpIHtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNOb3RlKG5vdGUpKSB7XG5cdCAgICAgICAgICAgICAgICAvL2NvbnZlcnQgdGhlIG5vdGUgbmFtZSB0byBNSURJXG5cdCAgICAgICAgICAgICAgICB2YXIgbWlkID0gVG9uZS5GcmVxdWVuY3kobm90ZSkudG9NaWRpKCk7XG5cdCAgICAgICAgICAgICAgICB1cmxNYXBbbWlkXSA9IHVybHNbbm90ZV07XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHBhcnNlRmxvYXQobm90ZSkpKSB7XG5cdCAgICAgICAgICAgICAgICAvL290aGVyd2lzZSBpZiBpdCdzIG51bWJlcnMgYXNzdW1lIGl0J3MgbWlkaVxuXHQgICAgICAgICAgICAgICAgdXJsTWFwW25vdGVdID0gdXJsc1tub3RlXTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5TYW1wbGVyOiB1cmwga2V5cyBtdXN0IGJlIHRoZSBub3RlXFwncyBwaXRjaCcpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIHN0b3JlZCBhbmQgbG9hZGVkIGJ1ZmZlcnNcblx0XHRcdCAqIEB0eXBlIHtUb25lLkJ1ZmZlcnN9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYnVmZmVycyA9IG5ldyBUb25lLkJ1ZmZlcnModXJsTWFwLCBvcHRpb25zLm9ubG9hZCwgb3B0aW9ucy5iYXNlVXJsKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBvYmplY3Qgb2YgYWxsIGN1cnJlbnRseSBwbGF5aW5nIEJ1ZmZlclNvdXJjZXNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlcyA9IHt9O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGVudmVsb3BlIGFwcGxpZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgc2FtcGxlLlxuXHRcdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmF0dGFjayA9IG9wdGlvbnMuYXR0YWNrO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGVudmVsb3BlIGFwcGxpZWQgdG8gdGhlIGVuZCBvZiB0aGUgZW52ZWxvcGUuXG5cdFx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmVsZWFzZSA9IG9wdGlvbnMucmVsZWFzZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlNhbXBsZXIsIFRvbmUuSW5zdHJ1bWVudCk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZGVmYXVsdHNcblx0XHQgKiBAY29uc3Rcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TYW1wbGVyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgIGF0dGFjazogMCxcblx0ICAgICAgICByZWxlYXNlOiAwLjEsXG5cdCAgICAgICAgb25sb2FkOiBUb25lLm5vT3AsXG5cdCAgICAgICAgYmFzZVVybDogJydcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIGluIHN0ZXBzIGJldHdlZW4gdGhlIGdpdmVuIG1pZGkgbm90ZSBhdCB0aGUgY2xvc2V0cyBzYW1wbGUuXG5cdFx0ICogQHBhcmFtICB7TWlkaX0gbWlkaVxuXHRcdCAqIEByZXR1cm4ge0ludGVydmFsfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlNhbXBsZXIucHJvdG90eXBlLl9maW5kQ2xvc2VzdCA9IGZ1bmN0aW9uIChtaWRpKSB7XG5cdCAgICAgICAgdmFyIE1BWF9JTlRFUlZBTCA9IDI0O1xuXHQgICAgICAgIHZhciBpbnRlcnZhbCA9IDA7XG5cdCAgICAgICAgd2hpbGUgKGludGVydmFsIDwgTUFYX0lOVEVSVkFMKSB7XG5cdCAgICAgICAgICAgIC8vIGNoZWNrIGFib3ZlIGFuZCBiZWxvd1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fYnVmZmVycy5oYXMobWlkaSArIGludGVydmFsKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC1pbnRlcnZhbDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9idWZmZXJzLmhhcyhtaWRpIC0gaW50ZXJ2YWwpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaW50ZXJ2YWwrKztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogQHBhcmFtICB7RnJlcXVlbmN5fSBub3RlICAgICBUaGUgbm90ZSB0byBwbGF5XG5cdFx0ICogQHBhcmFtICB7VGltZT19IHRpbWUgICAgIFdoZW4gdG8gcGxheSB0aGUgbm90ZVxuXHRcdCAqIEBwYXJhbSAge05vcm1hbFJhbmdlPX0gdmVsb2NpdHkgVGhlIHZlbG9jaXR5IHRvIHBsYXkgdGhlIHNhbXBsZSBiYWNrLlxuXHRcdCAqIEByZXR1cm4ge1RvbmUuU2FtcGxlcn0gICAgICAgICAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TYW1wbGVyLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrID0gZnVuY3Rpb24gKG5vdGUsIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdmFyIG1pZGkgPSBUb25lLkZyZXF1ZW5jeShub3RlKS50b01pZGkoKTtcblx0ICAgICAgICAvLyBmaW5kIHRoZSBjbG9zZXN0IG5vdGUgcGl0Y2hcblx0ICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IHRoaXMuX2ZpbmRDbG9zZXN0KG1pZGkpO1xuXHQgICAgICAgIGlmIChkaWZmZXJlbmNlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9zZXN0Tm90ZSA9IG1pZGkgLSBkaWZmZXJlbmNlO1xuXHQgICAgICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5fYnVmZmVycy5nZXQoY2xvc2VzdE5vdGUpO1xuXHQgICAgICAgICAgICAvLyBwbGF5IHRoYXQgbm90ZVxuXHQgICAgICAgICAgICB2YXIgc291cmNlID0gbmV3IFRvbmUuQnVmZmVyU291cmNlKHtcblx0ICAgICAgICAgICAgICAgICdidWZmZXInOiBidWZmZXIsXG5cdCAgICAgICAgICAgICAgICAncGxheWJhY2tSYXRlJzogVG9uZS5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8oZGlmZmVyZW5jZSksXG5cdCAgICAgICAgICAgICAgICAnZmFkZUluJzogdGhpcy5hdHRhY2ssXG5cdCAgICAgICAgICAgICAgICAnZmFkZU91dCc6IHRoaXMucmVsZWFzZVxuXHQgICAgICAgICAgICB9KS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICAgICAgc291cmNlLnN0YXJ0KHRpbWUsIDAsIGJ1ZmZlci5kdXJhdGlvbiwgdmVsb2NpdHkpO1xuXHQgICAgICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIGFjdGl2ZSBzb3VyY2VzXG5cdCAgICAgICAgICAgIGlmICghVG9uZS5pc0FycmF5KHRoaXMuX2FjdGl2ZVNvdXJjZXNbbWlkaV0pKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzW21pZGldID0gW107XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlc1ttaWRpXS5wdXNoKHtcblx0ICAgICAgICAgICAgICAgIG5vdGU6IG1pZGksXG5cdCAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogQHBhcmFtICB7RnJlcXVlbmN5fSBub3RlICAgICBUaGUgbm90ZSB0byByZWxlYXNlLlxuXHRcdCAqIEBwYXJhbSAge1RpbWU9fSB0aW1lICAgICBcdFdoZW4gdG8gcmVsZWFzZSB0aGUgbm90ZS5cblx0XHQgKiBAcmV0dXJuIHtUb25lLlNhbXBsZXJ9XHR0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNhbXBsZXIucHJvdG90eXBlLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKG5vdGUsIHRpbWUpIHtcblx0ICAgICAgICB2YXIgbWlkaSA9IFRvbmUuRnJlcXVlbmN5KG5vdGUpLnRvTWlkaSgpO1xuXHQgICAgICAgIC8vIGZpbmQgdGhlIG5vdGVcblx0ICAgICAgICBpZiAodGhpcy5fYWN0aXZlU291cmNlc1ttaWRpXSAmJiB0aGlzLl9hY3RpdmVTb3VyY2VzW21pZGldLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fYWN0aXZlU291cmNlc1ttaWRpXS5zaGlmdCgpLnNvdXJjZTtcblx0ICAgICAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgICAgICBzb3VyY2Uuc3RvcCh0aW1lICsgdGhpcy5yZWxlYXNlLCB0aGlzLnJlbGVhc2UpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBJbnZva2UgdGhlIGF0dGFjayBwaGFzZSwgdGhlbiBhZnRlciB0aGUgZHVyYXRpb24sIGludm9rZSB0aGUgcmVsZWFzZS5cblx0XHQgKiBAcGFyYW0gIHtGcmVxdWVuY3l9IG5vdGUgICAgIFRoZSBub3RlIHRvIHBsYXlcblx0XHQgKiBAcGFyYW0gIHtUaW1lfSBkdXJhdGlvbiBUaGUgdGltZSB0aGUgbm90ZSBzaG91bGQgYmUgaGVsZFxuXHRcdCAqIEBwYXJhbSAge1RpbWU9fSB0aW1lICAgICBXaGVuIHRvIHN0YXJ0IHRoZSBhdHRhY2tcblx0XHQgKiBAcGFyYW0gIHtOb3JtYWxSYW5nZX0gW3ZlbG9jaXR5PTFdIFRoZSB2ZWxvY2l0eSBvZiB0aGUgYXR0YWNrXG5cdFx0ICogQHJldHVybiB7VG9uZS5TYW1wbGVyfSAgICAgICAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNhbXBsZXIucHJvdG90eXBlLnRyaWdnZXJBdHRhY2tSZWxlYXNlID0gZnVuY3Rpb24gKG5vdGUsIGR1cmF0aW9uLCB0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBkdXJhdGlvbiA9IHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKTtcblx0ICAgICAgICB0aGlzLnRyaWdnZXJBdHRhY2sobm90ZSwgdGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlclJlbGVhc2Uobm90ZSwgdGltZSArIGR1cmF0aW9uKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWRkIGEgbm90ZSB0byB0aGUgc2FtcGxlci5cblx0XHQgKiAgQHBhcmFtICB7Tm90ZXxNaWRpfSAgIG5vdGUgICAgICBUaGUgYnVmZmVyJ3MgcGl0Y2guXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ3xUb25lLkJ1ZmZlcnxBdWRpb2J1ZmZlcn0gIHVybCAgRWl0aGVyIHRoZSB1cmwgb2YgdGhlIGJ1ZmVyLFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGEgYnVmZmVyIHdoaWNoIHdpbGwgYmUgYWRkZWRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbj19ICBjYWxsYmFjayAgVGhlIGNhbGxiYWNrIHRvIGludm9rZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgdXJsIGlzIGxvYWRlZC5cblx0XHQgKi9cblx0ICAgIFRvbmUuU2FtcGxlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5vdGUsIHVybCwgY2FsbGJhY2spIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc05vdGUobm90ZSkpIHtcblx0ICAgICAgICAgICAgLy9jb252ZXJ0IHRoZSBub3RlIG5hbWUgdG8gTUlESVxuXHQgICAgICAgICAgICB2YXIgbWlkID0gVG9uZS5GcmVxdWVuY3kobm90ZSkudG9NaWRpKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlcnMuYWRkKG1pZCwgdXJsLCBjYWxsYmFjayk7XG5cdCAgICAgICAgfSBlbHNlIGlmICghaXNOYU4ocGFyc2VGbG9hdChub3RlKSkpIHtcblx0ICAgICAgICAgICAgLy9vdGhlcndpc2UgaWYgaXQncyBudW1iZXJzIGFzc3VtZSBpdCdzIG1pZGlcblx0ICAgICAgICAgICAgdGhpcy5fYnVmZmVycy5hZGQobm90ZSwgdXJsLCBjYWxsYmFjayk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLlNhbXBsZXI6IG5vdGUgbXVzdCBiZSB0aGUgbm90ZVxcJ3MgcGl0Y2guIEluc3RlYWQgZ290ICcgKyBub3RlKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogSWYgdGhlIGJ1ZmZlcnMgYXJlIGxvYWRlZCBvciBub3Rcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5TYW1wbGVyI1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBuYW1lIGxvYWRlZFxuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2FtcGxlci5wcm90b3R5cGUsICdsb2FkZWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXJzLmxvYWRlZDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIENsZWFuIHVwXG5cdFx0ICogQHJldHVybiB7VG9uZS5TYW1wbGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNhbXBsZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fYnVmZmVycy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG5cdCAgICAgICAgZm9yICh2YXIgbWlkaSBpbiB0aGlzLl9hY3RpdmVTb3VyY2VzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXNbbWlkaV0uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TYW1wbGVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgTWFwcyBhIE5vcm1hbFJhbmdlIFswLCAxXSB0byBhbiBBdWRpb1JhbmdlIFstMSwgMV0uIFxuXHRcdCAqICAgICAgICAgU2VlIGFsc28gVG9uZS5BdWRpb1RvR2Fpbi4gXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGcyYSA9IG5ldyBUb25lLkdhaW5Ub0F1ZGlvKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkdhaW5Ub0F1ZGlvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtXYXZlU2hhcGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbm9ybSA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLldhdmVTaGFwZXIoZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHgpICogMiAtIDE7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5HYWluVG9BdWRpbywgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5HYWluVG9BdWRpb30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5HYWluVG9BdWRpby5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9ub3JtLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9ub3JtID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5HYWluVG9BdWRpbztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIE5vcm1hbGl6ZSB0YWtlcyBhbiBpbnB1dCBtaW4gYW5kIG1heCBhbmQgbWFwcyBpdCBsaW5lYXJseSB0byBOb3JtYWxSYW5nZSBbMCwxXVxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gaW5wdXRNaW4gdGhlIG1pbiBpbnB1dCB2YWx1ZVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gaW5wdXRNYXggdGhlIG1heCBpbnB1dCB2YWx1ZVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBub3JtID0gbmV3IFRvbmUuTm9ybWFsaXplKDIsIDQpO1xuXHRcdCAqIHZhciBzaWcgPSBuZXcgVG9uZS5TaWduYWwoMykuY29ubmVjdChub3JtKTtcblx0XHQgKiAvL291dHB1dCBvZiBub3JtIGlzIDAuNS4gXG5cdFx0ICovXG5cdCAgICBUb25lLk5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChpbnB1dE1pbiwgaW5wdXRNYXgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbWluIGlucHV0IHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faW5wdXRNaW4gPSBUb25lLmRlZmF1bHRBcmcoaW5wdXRNaW4sIDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBtYXggaW5wdXQgdmFsdWVcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9pbnB1dE1heCA9IFRvbmUuZGVmYXVsdEFyZyhpbnB1dE1heCwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgc3VidHJhY3QgdGhlIG1pbiBmcm9tIHRoZSBpbnB1dFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkFkZH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3ViID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLkFkZCgwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBkaXZpZGUgYnkgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgaW5wdXQgYW5kIG91dHB1dFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk11bHRpcGx5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kaXYgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLk11bHRpcGx5KDEpO1xuXHQgICAgICAgIHRoaXMuX3N1Yi5jb25uZWN0KHRoaXMuX2Rpdik7XG5cdCAgICAgICAgdGhpcy5fc2V0UmFuZ2UoKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk5vcm1hbGl6ZSwgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBtaW5pbXVtIHZhbHVlIHRoZSBpbnB1dCBzaWduYWwgd2lsbCByZWFjaC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Ob3JtYWxpemUjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtaW5cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk5vcm1hbGl6ZS5wcm90b3R5cGUsICdtaW4nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dE1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1pbikge1xuXHQgICAgICAgICAgICB0aGlzLl9pbnB1dE1pbiA9IG1pbjtcblx0ICAgICAgICAgICAgdGhpcy5fc2V0UmFuZ2UoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIHZhbHVlIHRoZSBpbnB1dCBzaWduYWwgd2lsbCByZWFjaC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Ob3JtYWxpemUjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtYXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk5vcm1hbGl6ZS5wcm90b3R5cGUsICdtYXgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dE1heDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1heCkge1xuXHQgICAgICAgICAgICB0aGlzLl9pbnB1dE1heCA9IG1heDtcblx0ICAgICAgICAgICAgdGhpcy5fc2V0UmFuZ2UoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBzZXQgdGhlIHZhbHVlc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob3JtYWxpemUucHJvdG90eXBlLl9zZXRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9zdWIudmFsdWUgPSAtdGhpcy5faW5wdXRNaW47XG5cdCAgICAgICAgdGhpcy5fZGl2LnZhbHVlID0gMSAvICh0aGlzLl9pbnB1dE1heCAtIHRoaXMuX2lucHV0TWluKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTm9ybWFsaXplfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk5vcm1hbGl6ZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zdWIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3N1YiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZGl2LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kaXYgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk5vcm1hbGl6ZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogQGNsYXNzIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwgZXh0ZW5kcyBUb25lLlRpbWVsaW5lU2lnbmFsLCBidXQgYWRkcyB0aGUgYWJpbGl0eSB0byBzeW5jaHJvbml6ZSB0aGUgc2lnbmFsIHRvIHRoZSBzaWduYWwgdG8gdGhlIFRvbmUuVHJhbnNwb3J0XG5cdFx0ICogQGV4dGVuZHMge1RvbmUuVGltZWxpbmVTaWduYWx9XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuVGltZWxpbmVTaWduYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSByZWFsIHNpZ25hbCBvdXRwdXRcblx0XHRcdCAqIEB0eXBlIHtUb25lLlNpZ25hbH1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMuX291dHB1dFNpZyA9IG5ldyBUb25lLlNpZ25hbCh0aGlzLl9pbml0aWFsKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIEtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgdmFsdWUuIChzbWFsbCBvcHRpbWl6YXRpb24pXG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xhc3RWYWwgPSB0aGlzLnZhbHVlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGV2ZW50IGlkIG9mIHRoZSB0aWNrIHVwZGF0ZSBsb29wXG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N5bmNlZCA9IFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlUmVwZWF0KHRoaXMuX29uVGljay5iaW5kKHRoaXMpLCAnMWknKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIEEgYm91bmQgdmVyc2lvbiBvZiB0aGUgYW5jaG9yIHZhbHVlIG1ldGhvZHNcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9iaW5kQW5jaG9yVmFsdWUgPSB0aGlzLl9hbmNob3JWYWx1ZS5iaW5kKHRoaXMpO1xuXHQgICAgICAgIFRvbmUuVHJhbnNwb3J0Lm9uKCdzdGFydCBzdG9wIHBhdXNlJywgdGhpcy5fYmluZEFuY2hvclZhbHVlKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMubWVtb3J5ID0gSW5maW5pdHk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbCwgVG9uZS5UaW1lbGluZVNpZ25hbCk7XG5cdCAgICAvKipcblx0XHQgKiBDYWxsYmFjayB3aGljaCBpcyBpbnZva2VkIGV2ZXJ5IHRpY2suXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVcblx0XHQgKiBAcmV0dXJuIHtUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsfSAgICAgIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9vblRpY2sgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHZhciB2YWwgPSB0aGlzLmdldFZhbHVlQXRUaW1lKFRvbmUuVHJhbnNwb3J0LnNlY29uZHMpO1xuXHQgICAgICAgIGlmICh0aGlzLl9sYXN0VmFsICE9PSB2YWwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGFzdFZhbCA9IHZhbDtcblx0ICAgICAgICAgICAgLy9hcHByb3hpbWF0ZSByYW1wIGN1cnZlcyB3aXRoIGxpbmVhciByYW1wc1xuXHQgICAgICAgICAgICB0aGlzLl9vdXRwdXRTaWcubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsLCB0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogQW5jaG9yIHRoZSB2YWx1ZSBhdCB0aGUgc3RhcnQgYW5kIHN0b3Agb2YgdGhlIFRyYW5zcG9ydFxuXHRcdCAqIEBwYXJhbSAge051bWJlcn0gdGltZSBUaGUgdGltZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBAcmV0dXJuIHtUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsfSAgICAgIHRoaXNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuX2FuY2hvclZhbHVlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB2YXIgdmFsID0gdGhpcy5nZXRWYWx1ZUF0VGltZShUb25lLlRyYW5zcG9ydC50aWNrcyk7XG5cdCAgICAgICAgdGhpcy5fbGFzdFZhbCA9IHZhbDtcblx0ICAgICAgICB0aGlzLl9vdXRwdXRTaWcuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX291dHB1dFNpZy5zZXRWYWx1ZUF0VGltZSh2YWwsIHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgdGhlIHNjaGVkdWxlZCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZS4gVGhpcyB3aWxsXG5cdFx0ICogIHJldHVybiB0aGUgdW5jb252ZXJ0ZWQgKHJhdykgdmFsdWUuXG5cdFx0ICogIEBwYXJhbSAge1RyYW5zcG9ydFRpbWV9ICB0aW1lICBUaGUgdGltZSBpbiBzZWNvbmRzLlxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgVGhlIHNjaGVkdWxlZCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1RpY2tzKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5nZXRWYWx1ZUF0VGltZS5jYWxsKHRoaXMsIHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFNldCB0aGUgb3V0cHV0IG9mIHRoZSBzaWduYWwgYXQgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGFuZ2UgdG8gYXQgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiBAcGFyYW0gIHtUcmFuc3BvcnRUaW1lfSB0aW1lICBUaGUgdGltZSB0byBjaGFuZ2UgdGhlIHNpZ25hbFxuXHRcdCAqIEByZXR1cm4ge1RvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWx9ICAgICAgIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCB0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRWYWx1ZUF0VGltZS5jYWxsKHRoaXMsIHZhbHVlLCB0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBMaW5lYXIgcmFtcCB0byB0aGUgZ2l2ZW4gdmFsdWUgZnJvbSB0aGUgcHJldmlvdXMgc2NoZWR1bGVkIHBvaW50IHRvIHRoZSBnaXZlbiB2YWx1ZVxuXHRcdCAqIEBwYXJhbSAge051bWJlcn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoYW5nZSB0byBhdCB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqIEBwYXJhbSAge1RyYW5zcG9ydFRpbWV9IHRpbWUgIFRoZSB0aW1lIHRvIGNoYW5nZSB0aGUgc2lnbmFsXG5cdFx0ICogQHJldHVybiB7VG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbH0gICAgICAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbC5wcm90b3R5cGUubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWUsIHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1RpY2tzKHRpbWUpO1xuXHQgICAgICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lLmNhbGwodGhpcywgdmFsdWUsIHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEV4cG9uZW50aWFsIHJhbXAgdG8gdGhlIGdpdmVuIHZhbHVlIGZyb20gdGhlIHByZXZpb3VzIHNjaGVkdWxlZCBwb2ludCB0byB0aGUgZ2l2ZW4gdmFsdWVcblx0XHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGFuZ2UgdG8gYXQgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiBAcGFyYW0gIHtUcmFuc3BvcnRUaW1lfSB0aW1lICBUaGUgdGltZSB0byBjaGFuZ2UgdGhlIHNpZ25hbFxuXHRcdCAqIEByZXR1cm4ge1RvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWx9ICAgICAgIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwucHJvdG90eXBlLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWUsIHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1RpY2tzKHRpbWUpO1xuXHQgICAgICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUuY2FsbCh0aGlzLCB2YWx1ZSwgdGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IGV4cG9uZW50aWFsbHkgYXBwcm9hY2hpbmcgdGhlIHRhcmdldCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZSB3aXRoXG5cdFx0ICogIGEgcmF0ZSBoYXZpbmcgdGhlIGdpdmVuIHRpbWUgY29uc3RhbnQuXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHRcdCAqICBAcGFyYW0ge1RyYW5zcG9ydFRpbWV9IHN0YXJ0VGltZVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdGltZUNvbnN0YW50XG5cdFx0ICogQHJldHVybiB7VG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbH0gICAgICAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuc2V0VGFyZ2V0QXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydFRpbWUsIHRpbWVDb25zdGFudCkge1xuXHQgICAgICAgIHN0YXJ0VGltZSA9IHRoaXMudG9UaWNrcyhzdGFydFRpbWUpO1xuXHQgICAgICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFRhcmdldEF0VGltZS5jYWxsKHRoaXMsIHZhbHVlLCBzdGFydFRpbWUsIHRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbmNlbHMgYWxsIHNjaGVkdWxlZCBwYXJhbWV0ZXIgY2hhbmdlcyB3aXRoIHRpbWVzIGdyZWF0ZXIgdGhhbiBvclxuXHRcdCAqICBlcXVhbCB0byBzdGFydFRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1RyYW5zcG9ydFRpbWV9IHN0YXJ0VGltZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzID0gZnVuY3Rpb24gKHN0YXJ0VGltZSkge1xuXHQgICAgICAgIHN0YXJ0VGltZSA9IHRoaXMudG9UaWNrcyhzdGFydFRpbWUpO1xuXHQgICAgICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcy5jYWxsKHRoaXMsIHN0YXJ0VGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCBhbiBhcnJheSBvZiBhcmJpdHJhcnkgdmFsdWVzIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiB0aW1lIGZvciB0aGUgZ2l2ZW4gZHVyYXRpb24uXG5cdFx0ICogIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB2YWx1ZXNcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydFRpbWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBkdXJhdGlvblxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbc2NhbGluZz0xXSBJZiB0aGUgdmFsdWVzIGluIHRoZSBjdXJ2ZSBzaG91bGQgYmUgc2NhbGVkIGJ5IHNvbWUgdmFsdWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFZhbHVlQ3VydmVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWVzLCBzdGFydFRpbWUsIGR1cmF0aW9uLCBzY2FsaW5nKSB7XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1RpY2tzKHN0YXJ0VGltZSk7XG5cdCAgICAgICAgZHVyYXRpb24gPSB0aGlzLnRvVGlja3MoZHVyYXRpb24pO1xuXHQgICAgICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFZhbHVlQ3VydmVBdFRpbWUuY2FsbCh0aGlzLCB2YWx1ZXMsIHN0YXJ0VGltZSwgZHVyYXRpb24sIHNjYWxpbmcpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIERpc3Bvc2UgYW5kIGRpc2Nvbm5lY3Rcblx0XHQgKiBAcmV0dXJuIHtUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuVHJhbnNwb3J0LmNsZWFyKHRoaXMuX3N5bmNlZCk7XG5cdCAgICAgICAgVG9uZS5UcmFuc3BvcnQub2ZmKCdzdGFydCBzdG9wIHBhdXNlJywgdGhpcy5fc3luY2VkQ2FsbGJhY2spO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cy5jYW5jZWwoMCk7XG5cdCAgICAgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX291dHB1dFNpZy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fb3V0cHV0U2lnID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLk11bHRpUGxheWVyIGlzIHdlbGwgc3VpdGVkIGZvciBvbmUtc2hvdHMsIG11bHRpLXNhbXBsZWQgaW5zdHJ1bWVudHNcblx0XHQgKiAgICAgICAgIG9yIGFueSB0aW1lIHlvdSBuZWVkIHRvIHBsYXkgYSBidW5jaCBvZiBhdWRpbyBidWZmZXJzLiBcblx0XHQgKlxuXHRcdCAqICBAZGVwcmVjYXRlZCBVc2UgW1RvbmUuUGxheWVyc10oUGxheWVycykgaW5zdGVhZC5cblx0XHQgKiAgQHBhcmFtICB7T2JqZWN0fEFycmF5fFRvbmUuQnVmZmVyc30gIGJ1ZmZlcnMgIFRoZSBidWZmZXJzIHdoaWNoIGFyZSBhdmFpbGFibGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBNdWx0aVBsYXllclxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBvbmxvYWQgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFsbCBvZiB0aGUgYnVmZmVycyBhcmUgbG9hZGVkLlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbXVsdGlQbGF5ZXIgPSBuZXcgTXVsdGlQbGF5ZXIoe1xuXHRcdCAqIFx0XCJraWNrXCIgOiBcInBhdGgvdG8va2ljay5tcDNcIixcblx0XHQgKiBcdFwic25hcmVcIiA6IFwicGF0aC90by9zbmFyZS5tcDNcIixcblx0XHQgKiB9LCBmdW5jdGlvbigpe1xuXHRcdCAqIFx0bXVsdGlQbGF5ZXIuc3RhcnQoXCJraWNrXCIpO1xuXHRcdCAqIH0pO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vY2FuIGFsc28gc3RvcmUgdGhlIHZhbHVlcyBpbiBhbiBhcnJheVxuXHRcdCAqIHZhciBtdWx0aVBsYXllciA9IG5ldyBNdWx0aVBsYXllcihbXCJwYXRoL3RvL2tpY2subXAzXCIsIFwicGF0aC90by9zbmFyZS5tcDNcIl0sIFxuXHRcdCAqIGZ1bmN0aW9uKCl7XG5cdFx0ICogXHQvL2lmIGFuIGFycmF5IGlzIHBhc3NlZCBpbiwgdGhlIHNhbXBsZXMgYXJlIHJlZmVyZW5jZWQgdG8gYnkgaW5kZXhcblx0XHQgKiBcdG11bHRpUGxheWVyLnN0YXJ0KDEpO1xuXHRcdCAqIH0pO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aVBsYXllciA9IGZ1bmN0aW9uICh1cmxzKSB7XG5cdCAgICAgICAgY29uc29sZS53YXJuKCdUb25lLk11bHRpUGxheWVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBUb25lLlBsYXllcnMgaW5zdGVhZC4nKTtcblx0ICAgICAgICAvL3JlbW92ZSB0aGUgdXJscyBmcm9tIHRoZSBvcHRpb25zXG5cdCAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgIVRvbmUuaXNVbmRlZihhcmd1bWVudHNbMF0pICYmICFhcmd1bWVudHNbMF0uaGFzT3duUHJvcGVydHkoJ3VybHMnKSkge1xuXHQgICAgICAgICAgICB1cmxzID0geyAndXJscyc6IHVybHMgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndXJscycsXG5cdCAgICAgICAgICAgICdvbmxvYWQnXG5cdCAgICAgICAgXSwgVG9uZS5NdWx0aVBsYXllcik7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICBpZiAob3B0aW9ucy51cmxzIGluc3RhbmNlb2YgVG9uZS5CdWZmZXJzKSB7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgQWxsIHRoZSBidWZmZXJzIGJlbG9uZ2luZyB0byB0aGUgcGxheWVyLlxuXHRcdFx0XHQgKiAgQHR5cGUgIHtUb25lLkJ1ZmZlcnN9XG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBvcHRpb25zLnVybHM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5idWZmZXJzID0gbmV3IFRvbmUuQnVmZmVycyhvcHRpb25zLnVybHMsIG9wdGlvbnMub25sb2FkKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnRseSBwbGF5aW5nIHNvdXJjZXMuXG5cdFx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXMgPSB7fTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmFkZSBpbiBlbnZlbG9wZSB3aGljaCBpcyBhcHBsaWVkXG5cdFx0XHQgKiAgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgQnVmZmVyU291cmNlXG5cdFx0XHQgKiAgQHR5cGUgIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mYWRlSW4gPSBvcHRpb25zLmZhZGVJbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmFkZSBvdXQgZW52ZWxvcGUgd2hpY2ggaXMgYXBwbGllZFxuXHRcdFx0ICogIHRvIHRoZSBlbmQgb2YgdGhlIEJ1ZmZlclNvdXJjZVxuXHRcdFx0ICogIEB0eXBlICB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmFkZU91dCA9IG9wdGlvbnMuZmFkZU91dDtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk11bHRpUGxheWVyLCBUb25lLlNvdXJjZSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aVBsYXllci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnb25sb2FkJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdmYWRlSW4nOiAwLFxuXHQgICAgICAgICdmYWRlT3V0JzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIE1ha2UgdGhlIHNvdXJjZSBmcm9tIHRoZSBidWZmZXJuYW1lXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBidWZmZXJOYW1lXG5cdFx0ICogQHJldHVybiB7VG9uZS5CdWZmZXJTb3VyY2V9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGlQbGF5ZXIucHJvdG90eXBlLl9tYWtlU291cmNlID0gZnVuY3Rpb24gKGJ1ZmZlck5hbWUpIHtcblx0ICAgICAgICB2YXIgYnVmZmVyO1xuXHQgICAgICAgIGlmIChUb25lLmlzU3RyaW5nKGJ1ZmZlck5hbWUpIHx8IFRvbmUuaXNOdW1iZXIoYnVmZmVyTmFtZSkpIHtcblx0ICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5idWZmZXJzLmdldChidWZmZXJOYW1lKS5nZXQoKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlck5hbWUgaW5zdGFuY2VvZiBUb25lLkJ1ZmZlcikge1xuXHQgICAgICAgICAgICBidWZmZXIgPSBidWZmZXJOYW1lLmdldCgpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyTmFtZSBpbnN0YW5jZW9mIEF1ZGlvQnVmZmVyKSB7XG5cdCAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlck5hbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzb3VyY2UgPSBuZXcgVG9uZS5CdWZmZXJTb3VyY2UoYnVmZmVyKS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZVNvdXJjZXMuaGFzT3duUHJvcGVydHkoYnVmZmVyTmFtZSkpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlc1tidWZmZXJOYW1lXSA9IFtdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzW2J1ZmZlck5hbWVdLnB1c2goc291cmNlKTtcblx0ICAgICAgICByZXR1cm4gc291cmNlO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCBhIGJ1ZmZlciBieSBuYW1lLiBUaGUgYHN0YXJ0YCBtZXRob2QgYWxsb3dzIGEgbnVtYmVyIG9mIG9wdGlvbnNcblx0XHQgKiAgdG8gYmUgcGFzc2VkIGluIHN1Y2ggYXMgb2Zmc2V0LCBpbnRlcnZhbCwgYW5kIGdhaW4uIFRoaXMgaXMgZ29vZCBmb3IgbXVsdGktc2FtcGxlZCBcblx0XHQgKiAgaW5zdHJ1bWVudHMgYW5kIHNvdW5kIHNwcml0ZXMgd2hlcmUgc2FtcGxlcyBhcmUgcmVwaXRjaGVkIHBsYXllZCBiYWNrIGF0IGRpZmZlcmVudCB2ZWxvY2l0aWVzLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBidWZmZXJOYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBidWZmZXIgdG8gc3RhcnQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lICAgICAgV2hlbiB0byBzdGFydCB0aGUgYnVmZmVyLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgW29mZnNldD0wXSAgICBUaGUgb2Zmc2V0IGludG8gdGhlIGJ1ZmZlciB0byBwbGF5IGZyb20uXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSAgZHVyYXRpb24gICBIb3cgbG9uZyB0byBwbGF5IHRoZSBidWZmZXIgZm9yLlxuXHRcdCAqICBAcGFyYW0gIHtJbnRlcnZhbH0gIFtwaXRjaD0wXSAgVGhlIGludGVydmFsIHRvIHJlcGl0Y2ggdGhlIGJ1ZmZlci5cblx0XHQgKiAgQHBhcmFtICB7R2Fpbn0gIFtnYWluPTFdICAgICAgVGhlIGdhaW4gdG8gcGxheSB0aGUgc2FtcGxlIGF0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5NdWx0aVBsYXllcn0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGlQbGF5ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGJ1ZmZlck5hbWUsIHRpbWUsIG9mZnNldCwgZHVyYXRpb24sIHBpdGNoLCBnYWluKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9tYWtlU291cmNlKGJ1ZmZlck5hbWUpO1xuXHQgICAgICAgIHNvdXJjZS5zdGFydCh0aW1lLCBvZmZzZXQsIGR1cmF0aW9uLCBUb25lLmRlZmF1bHRBcmcoZ2FpbiwgMSksIHRoaXMuZmFkZUluKTtcblx0ICAgICAgICBpZiAoZHVyYXRpb24pIHtcblx0ICAgICAgICAgICAgc291cmNlLnN0b3AodGltZSArIHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKSwgdGhpcy5mYWRlT3V0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcGl0Y2ggPSBUb25lLmRlZmF1bHRBcmcocGl0Y2gsIDApO1xuXHQgICAgICAgIHNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSBUb25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbyhwaXRjaCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IGEgbG9vcGluZyBidWZmZXIgYnkgbmFtZS4gU2ltaWxhciB0byBgc3RhcnRgLCBidXQgdGhlIGJ1ZmZlclxuXHRcdCAqICBpcyBsb29wZWQgaW5zdGVhZCBvZiBwbGF5ZWQgc3RyYWlnaHQgdGhyb3VnaC4gQ2FuIHN0aWxsIGJlIHN0b3BwZWQgd2l0aCBgc3RvcGAuIFxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBidWZmZXJOYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBidWZmZXIgdG8gc3RhcnQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lICAgICAgV2hlbiB0byBzdGFydCB0aGUgYnVmZmVyLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgW29mZnNldD0wXSAgICBUaGUgb2Zmc2V0IGludG8gdGhlIGJ1ZmZlciB0byBwbGF5IGZyb20uXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSAgbG9vcFN0YXJ0ICAgVGhlIHN0YXJ0IG9mIHRoZSBsb29wLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIGxvb3BFbmRcdFRoZSBlbmQgb2YgdGhlIGxvb3AuXG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsfSAgW3BpdGNoPTBdICBUaGUgaW50ZXJ2YWwgdG8gcmVwaXRjaCB0aGUgYnVmZmVyLlxuXHRcdCAqICBAcGFyYW0gIHtHYWlufSAgW2dhaW49MV0gICAgICBUaGUgZ2FpbiB0byBwbGF5IHRoZSBzYW1wbGUgYXQuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLk11bHRpUGxheWVyfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aVBsYXllci5wcm90b3R5cGUuc3RhcnRMb29wID0gZnVuY3Rpb24gKGJ1ZmZlck5hbWUsIHRpbWUsIG9mZnNldCwgbG9vcFN0YXJ0LCBsb29wRW5kLCBwaXRjaCwgZ2Fpbikge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fbWFrZVNvdXJjZShidWZmZXJOYW1lKTtcblx0ICAgICAgICBzb3VyY2UubG9vcCA9IHRydWU7XG5cdCAgICAgICAgc291cmNlLmxvb3BTdGFydCA9IHRoaXMudG9TZWNvbmRzKFRvbmUuZGVmYXVsdEFyZyhsb29wU3RhcnQsIDApKTtcblx0ICAgICAgICBzb3VyY2UubG9vcEVuZCA9IHRoaXMudG9TZWNvbmRzKFRvbmUuZGVmYXVsdEFyZyhsb29wRW5kLCAwKSk7XG5cdCAgICAgICAgc291cmNlLnN0YXJ0KHRpbWUsIG9mZnNldCwgdW5kZWZpbmVkLCBUb25lLmRlZmF1bHRBcmcoZ2FpbiwgMSksIHRoaXMuZmFkZUluKTtcblx0ICAgICAgICBwaXRjaCA9IFRvbmUuZGVmYXVsdEFyZyhwaXRjaCwgMCk7XG5cdCAgICAgICAgc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IFRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKHBpdGNoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCB0aGUgZmlyc3QgcGxheWVkIGluc3RhbmNlIG9mIHRoZSBidWZmZXIgbmFtZS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgYnVmZmVyTmFtZSAgVGhlIGJ1ZmZlciB0byBzdG9wLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIHRpbWUgICAgV2hlbiB0byBzdG9wIHRoZSBidWZmZXJcblx0XHQgKiAgQHJldHVybiAge1RvbmUuTXVsdGlQbGF5ZXJ9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpUGxheWVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKGJ1ZmZlck5hbWUsIHRpbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5fYWN0aXZlU291cmNlc1tidWZmZXJOYW1lXSAmJiB0aGlzLl9hY3RpdmVTb3VyY2VzW2J1ZmZlck5hbWVdLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXNbYnVmZmVyTmFtZV0uc2hpZnQoKS5zdG9wKHRpbWUsIHRoaXMuZmFkZU91dCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLk11bHRpUGxheWVyOiBjYW5ub3Qgc3RvcCBhIGJ1ZmZlciB0aGF0IGhhc25cXCd0IGJlZW4gc3RhcnRlZCBvciBpcyBhbHJlYWR5IHN0b3BwZWQnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0b3AgYWxsIGN1cnJlbnRseSBwbGF5aW5nIGJ1ZmZlcnMgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSAgdGltZSAgV2hlbiB0byBzdG9wIHRoZSBidWZmZXJzLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5NdWx0aVBsYXllcn0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGlQbGF5ZXIucHJvdG90eXBlLnN0b3BBbGwgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBmb3IgKHZhciBidWZmZXJOYW1lIGluIHRoaXMuX2FjdGl2ZVNvdXJjZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9hY3RpdmVTb3VyY2VzW2J1ZmZlck5hbWVdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHNvdXJjZXNbaV0uc3RvcCh0aW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWRkIGFub3RoZXIgYnVmZmVyIHRvIHRoZSBhdmFpbGFibGUgYnVmZmVycy5cblx0XHQgKiAgQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgdG8gdGhhdCB0aGUgYnVmZmVyIGlzIHJlZmVyZWRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgdG8gaW4gc3RhcnQvc3RvcCBtZXRob2RzLiBcblx0XHQgKiAgQHBhcmFtIHtTdHJpbmd8VG9uZS5CdWZmZXJ9IHVybCBUaGUgdXJsIG9mIHRoZSBidWZmZXIgdG8gbG9hZFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIHRoZSBidWZmZXIuXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgYWZ0ZXIgdGhlIGJ1ZmZlciBpcyBsb2FkZWQuXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpUGxheWVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobmFtZSwgdXJsLCBjYWxsYmFjaykge1xuXHQgICAgICAgIHRoaXMuYnVmZmVycy5hZGQobmFtZSwgdXJsLCBjYWxsYmFjayk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBzb3VyY2UuIFwic3RhcnRlZFwiXG5cdFx0ICogIGlmIHRoZXJlIGFyZSBhbnkgYnVmZmVycyBwbGF5aW5nLiBcInN0b3BwZWRcIiBvdGhlcndpc2UuXG5cdFx0ICogIEB0eXBlIHtUb25lLlN0YXRlfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTXVsdGlQbGF5ZXIjXG5cdFx0ICogIEBuYW1lIHN0YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5NdWx0aVBsYXllci5wcm90b3R5cGUsICdzdGF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVNvdXJjZXMubGVuZ3RoID4gMCA/IFRvbmUuU3RhdGUuU3RhcnRlZCA6IFRvbmUuU3RhdGUuU3RvcHBlZDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIE11dGUgdGhlIG91dHB1dC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTXVsdGlQbGF5ZXIjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9tdXRlIHRoZSBvdXRwdXRcblx0XHQgKiBzb3VyY2UubXV0ZSA9IHRydWU7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5NdWx0aVBsYXllci5wcm90b3R5cGUsICdtdXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdm9sdW1lLm11dGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtdXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3ZvbHVtZS5tdXRlID0gbXV0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTXVsdGlQbGF5ZXJ9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpUGxheWVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgZm9yICh2YXIgYnVmZmVyTmFtZSBpbiB0aGlzLl9hY3RpdmVTb3VyY2VzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXNbYnVmZmVyTmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICBzb3VyY2UuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5idWZmZXJzLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk11bHRpUGxheWVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiBAY2xhc3MgVG9uZS5HcmFpblBsYXllciBpbXBsZW1lbnRzIFtncmFudWxhciBzeW50aGVzaXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYW51bGFyX3N5bnRoZXNpcykuXG5cdFx0ICogICAgICAgIEdyYW51bGFyIFN5bnRoZXNpcyBlbmFibGVzIHlvdSB0byBhZGp1c3QgcGl0Y2ggYW5kIHBsYXliYWNrIHJhdGUgaW5kZXBlbmRlbnRseS4gVGhlIGdyYWluU2l6ZSBpcyB0aGVcblx0XHQgKiAgICAgICAgYW1vdW50IG9mIHRpbWUgZWFjaCBzbWFsbCBjaHVuayBvZiBhdWRpbyBpcyBwbGF5ZWQgZm9yIGFuZCB0aGUgb3ZlcmxhcCBpcyB0aGVcblx0XHQgKiAgICAgICAgYW1vdW50IG9mIGNyb3NzZmFkaW5nIHRyYW5zaXRpb24gdGltZSBiZXR3ZWVuIHN1Y2Nlc3NpdmUgZ3JhaW5zLlxuXHRcdCAqIEBleHRlbmRzIHtUb25lLlNvdXJjZX1cblx0XHQgKiBAcGFyYW0ge1N0cmluZ3xUb25lLkJ1ZmZlcn0gdXJsXHRUaGUgdXJsIHRvIGxvYWQsIG9yIHRoZSBUb25lLkJ1ZmZlciB0byBwbGF5LlxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIHRoZSB1cmwgaXMgbG9hZGVkLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmFpblBsYXllciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd1cmwnLFxuXHQgICAgICAgICAgICAnb25sb2FkJ1xuXHQgICAgICAgIF0sIFRvbmUuR3JhaW5QbGF5ZXIpO1xuXHQgICAgICAgIFRvbmUuU291cmNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGF1ZGlvIGJ1ZmZlciBiZWxvbmdpbmcgdG8gdGhlIHBsYXllci5cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuQnVmZmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVG9uZS5CdWZmZXIob3B0aW9ucy51cmwsIG9wdGlvbnMub25sb2FkKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBDcmVhdGUgYSByZXBlYXRpbmcgdGljayB0byBzY2hlZHVsZVxuXHRcdFx0ICogIHRoZSBncmFpbnMuXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkNsb2NrfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jbG9jayA9IG5ldyBUb25lLkNsb2NrKHRoaXMuX3RpY2suYmluZCh0aGlzKSwgb3B0aW9ucy5ncmFpblNpemUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wU3RhcnQgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wRW5kID0gMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIEFsbCBvZiB0aGUgY3VycmVudGx5IHBsYXlpbmcgQnVmZmVyU291cmNlc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXMgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGxheWJhY2tSYXRlID0gb3B0aW9ucy5wbGF5YmFja1JhdGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2dyYWluU2l6ZSA9IG9wdGlvbnMuZ3JhaW5TaXplO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX292ZXJsYXAgPSBvcHRpb25zLm92ZXJsYXA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQWRqdXN0IHRoZSBwaXRjaCBpbmRlcGVuZGVudGx5IG9mIHRoZSBwbGF5YmFja1JhdGUuXG5cdFx0XHQgKiAgQHR5cGUgIHtDZW50c31cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gb3B0aW9ucy5kZXR1bmU7XG5cdCAgICAgICAgLy9zZXR1cFxuXHQgICAgICAgIHRoaXMub3ZlcmxhcCA9IG9wdGlvbnMub3ZlcmxhcDtcblx0ICAgICAgICB0aGlzLmxvb3AgPSBvcHRpb25zLmxvb3A7XG5cdCAgICAgICAgdGhpcy5wbGF5YmFja1JhdGUgPSBvcHRpb25zLnBsYXliYWNrUmF0ZTtcblx0ICAgICAgICB0aGlzLmdyYWluU2l6ZSA9IG9wdGlvbnMuZ3JhaW5TaXplO1xuXHQgICAgICAgIHRoaXMubG9vcFN0YXJ0ID0gb3B0aW9ucy5sb29wU3RhcnQ7XG5cdCAgICAgICAgdGhpcy5sb29wRW5kID0gb3B0aW9ucy5sb29wRW5kO1xuXHQgICAgICAgIHRoaXMucmV2ZXJzZSA9IG9wdGlvbnMucmV2ZXJzZTtcblx0ICAgICAgICB0aGlzLl9jbG9jay5vbignc3RvcCcsIHRoaXMuX29uc3RvcC5iaW5kKHRoaXMpKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkdyYWluUGxheWVyLCBUb25lLlNvdXJjZSk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmFpblBsYXllci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnb25sb2FkJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdvdmVybGFwJzogMC4xLFxuXHQgICAgICAgICdncmFpblNpemUnOiAwLjIsXG5cdCAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IDEsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ2xvb3AnOiBmYWxzZSxcblx0ICAgICAgICAnbG9vcFN0YXJ0JzogMCxcblx0ICAgICAgICAnbG9vcEVuZCc6IDAsXG5cdCAgICAgICAgJ3JldmVyc2UnOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBQbGF5IHRoZSBidWZmZXIgYXQgdGhlIGdpdmVuIHN0YXJ0VGltZS4gT3B0aW9uYWxseSBhZGQgYW4gb2Zmc2V0XG5cdFx0ICogIGFuZC9vciBkdXJhdGlvbiB3aGljaCB3aWxsIHBsYXkgdGhlIGJ1ZmZlciBmcm9tIGEgcG9zaXRpb25cblx0XHQgKiAgd2l0aGluIHRoZSBidWZmZXIgZm9yIHRoZSBnaXZlbiBkdXJhdGlvbi5cblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbc3RhcnRUaW1lPW5vd10gV2hlbiB0aGUgcGxheWVyIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW29mZnNldD0wXSBUaGUgb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc2FtcGxlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBzdGFydCBhdC5cblx0XHQgKiAgQHBhcmFtICB7VGltZT19IGR1cmF0aW9uIEhvdyBsb25nIHRoZSBzYW1wbGUgc2hvdWxkIHBsYXkuIElmIG5vIGR1cmF0aW9uXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGdpdmVuLCBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIGZ1bGwgbGVuZ3RoXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSBzYW1wbGUgKG1pbnVzIGFueSBvZmZzZXQpXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkdyYWluUGxheWVyfSB0aGlzXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkdyYWluUGxheWVyI1xuXHRcdCAqICBAbWV0aG9kIHN0YXJ0XG5cdFx0ICogIEBuYW1lIHN0YXJ0XG5cdFx0ICovXG5cdCAgICAvKipcblx0XHQgKiAgSW50ZXJuYWwgc3RhcnQgbWV0aG9kXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gdGltZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IG9mZnNldFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHRpbWUsIG9mZnNldCwgZHVyYXRpb24pIHtcblx0ICAgICAgICBvZmZzZXQgPSBUb25lLmRlZmF1bHRBcmcob2Zmc2V0LCAwKTtcblx0ICAgICAgICBvZmZzZXQgPSB0aGlzLnRvU2Vjb25kcyhvZmZzZXQpO1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG5cdCAgICAgICAgdGhpcy5fY2xvY2suc3RhcnQodGltZSk7XG5cdCAgICAgICAgaWYgKGR1cmF0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc3RvcCh0aW1lICsgdGhpcy50b1NlY29uZHMoZHVyYXRpb24pKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEludGVybmFsIHN0YXJ0IG1ldGhvZFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHRpbWVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuR3JhaW5QbGF5ZXIucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9jbG9jay5zdG9wKHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEludm9rZWQgd2hlbiB0aGUgY2xvY2sgaXMgc3RvcHBlZFxuXHRcdCAqIEBwYXJhbSAge051bWJlcn0gdGltZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZS5fb25zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICAvL3N0b3AgdGhlIHBsYXllcnNcblx0ICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuXHQgICAgICAgICAgICBzb3VyY2Uuc3RvcCh0aW1lLCAwKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSW52b2tlZCBvbiBlYWNoIGNsb2NrIHRpY2suIHNjaGVkdWxlZCBhIG5ld1xuXHRcdCAqICBncmFpbiBhdCB0aGlzIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdmFyIGZhZGVJbiA9IHRoaXMuX29mZnNldCA8IHRoaXMuX292ZXJsYXAgPyAwIDogdGhpcy5fb3ZlcmxhcDtcblx0ICAgICAgICB2YXIgc291cmNlID0gbmV3IFRvbmUuQnVmZmVyU291cmNlKHtcblx0ICAgICAgICAgICAgJ2J1ZmZlcic6IHRoaXMuYnVmZmVyLFxuXHQgICAgICAgICAgICAnZmFkZUluJzogZmFkZUluLFxuXHQgICAgICAgICAgICAnZmFkZU91dCc6IHRoaXMuX292ZXJsYXAsXG5cdCAgICAgICAgICAgICdsb29wJzogdGhpcy5sb29wLFxuXHQgICAgICAgICAgICAnbG9vcFN0YXJ0JzogdGhpcy5fbG9vcFN0YXJ0LFxuXHQgICAgICAgICAgICAnbG9vcEVuZCc6IHRoaXMuX2xvb3BFbmQsXG5cdCAgICAgICAgICAgICdwbGF5YmFja1JhdGUnOiBUb25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbyh0aGlzLmRldHVuZSAvIDEwMClcblx0ICAgICAgICB9KS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICBzb3VyY2Uuc3RhcnQodGltZSwgdGhpcy5fb2Zmc2V0KTtcblx0ICAgICAgICB0aGlzLl9vZmZzZXQgKz0gdGhpcy5ncmFpblNpemU7XG5cdCAgICAgICAgc291cmNlLnN0b3AodGltZSArIHRoaXMuZ3JhaW5TaXplKTtcblx0ICAgICAgICAvL2FkZCBpdCB0byB0aGUgYWN0aXZlIHNvdXJjZXNcblx0ICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzLnB1c2goc291cmNlKTtcblx0ICAgICAgICAvL3JlbW92ZSBpdCB3aGVuIGl0J3MgZG9uZVxuXHQgICAgICAgIHNvdXJjZS5vbmVuZGVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9hY3RpdmVTb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblx0ICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBKdW1wIHRvIGEgc3BlY2lmaWMgdGltZSBhbmQgcGxheSBpdC5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIG9mZnNldCAgVGhlIG9mZnNldCB0byBqdW1wIHRvLlxuXHRcdCAqICBAcGFyYW0ge1RpbWU9fSB0aW1lIFdoZW4gdG8gbWFrZSB0aGUganVtcC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuR3JhaW5QbGF5ZXJ9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24gKG9mZnNldCwgdGltZSkge1xuXHQgICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMudG9TZWNvbmRzKG9mZnNldCk7XG5cdCAgICAgICAgdGhpcy5fdGljayh0aGlzLnRvU2Vjb25kcyh0aW1lKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBsYXliYWNrIHJhdGUgb2YgdGhlIHNhbXBsZVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkdyYWluUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiBAbmFtZSBwbGF5YmFja1JhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZSwgJ3BsYXliYWNrUmF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXliYWNrUmF0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGxheWJhY2tSYXRlID0gcmF0ZTtcblx0ICAgICAgICAgICAgdGhpcy5ncmFpblNpemUgPSB0aGlzLl9ncmFpblNpemU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbG9vcCBzdGFydCB0aW1lLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkdyYWluUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGxvb3BTdGFydFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuR3JhaW5QbGF5ZXIucHJvdG90eXBlLCAnbG9vcFN0YXJ0Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9vcFN0YXJ0O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wU3RhcnQgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBsb29wIGVuZCB0aW1lLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkdyYWluUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGxvb3BFbmRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZSwgJ2xvb3BFbmQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29wRW5kO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZGlyZWN0aW9uIHRoZSBidWZmZXIgc2hvdWxkIHBsYXkgaW5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5HcmFpblBsYXllciNcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbmFtZSByZXZlcnNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUsICdyZXZlcnNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIucmV2ZXJzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJldikge1xuXHQgICAgICAgICAgICB0aGlzLmJ1ZmZlci5yZXZlcnNlID0gcmV2O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHNpemUgb2YgZWFjaCBjaHVuayBvZiBhdWRpbyB0aGF0IHRoZVxuXHRcdCAqIGJ1ZmZlciBpcyBjaG9wcGVkIGludG8gYW5kIHBsYXllZCBiYWNrIGF0LlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkdyYWluUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGdyYWluU2l6ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuR3JhaW5QbGF5ZXIucHJvdG90eXBlLCAnZ3JhaW5TaXplJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ3JhaW5TaXplO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2l6ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9ncmFpblNpemUgPSB0aGlzLnRvU2Vjb25kcyhzaXplKTtcblx0ICAgICAgICAgICAgdGhpcy5fY2xvY2suZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5fcGxheWJhY2tSYXRlIC8gdGhpcy5fZ3JhaW5TaXplO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhpcyBpcyB0aGUgZHVyYXRpb24gb2YgdGhlIGNyb3NzLWZhZGUgYmV0d2VlblxuXHRcdCAqIHN1Y2Vzc2l2ZSBncmFpbnMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuR3JhaW5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgb3ZlcmxhcFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuR3JhaW5QbGF5ZXIucHJvdG90eXBlLCAnb3ZlcmxhcCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXA7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX292ZXJsYXAgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIENsZWFuIHVwXG5cdFx0ICogQHJldHVybiB7VG9uZS5HcmFpblBsYXllcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuYnVmZmVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fY2xvY2suZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuXHQgICAgICAgICAgICBzb3VyY2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkdyYWluUGxheWVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuUGxheWVyIGlzIGFuIGF1ZGlvIGZpbGUgcGxheWVyIHdpdGggc3RhcnQsIGxvb3AsIGFuZCBzdG9wIGZ1bmN0aW9ucy5cblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Tb3VyY2V9IFxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ3xBdWRpb0J1ZmZlcn0gdXJsIEVpdGhlciB0aGUgQXVkaW9CdWZmZXIgb3IgdGhlIHVybCBmcm9tXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggdG8gbG9hZCB0aGUgQXVkaW9CdWZmZXJcblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbj19IG9ubG9hZCBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGJ1ZmZlciBpcyBsb2FkZWQuIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlY29tbWVuZGVkIHRvIHVzZSBUb25lLkJ1ZmZlci5vbignbG9hZCcpIGluc3RlYWQuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHBsYXllciA9IG5ldyBUb25lLlBsYXllcihcIi4vcGF0aC90by9zYW1wbGUubXAzXCIpLnRvTWFzdGVyKCk7XG5cdFx0ICogLy9wbGF5IGFzIHNvb24gYXMgdGhlIGJ1ZmZlciBpcyBsb2FkZWRcblx0XHQgKiBwbGF5ZXIuYXV0b3N0YXJ0ID0gdHJ1ZTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVyID0gZnVuY3Rpb24gKHVybCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zO1xuXHQgICAgICAgIGlmICh1cmwgaW5zdGFuY2VvZiBUb25lLkJ1ZmZlcikge1xuXHQgICAgICAgICAgICB1cmwgPSB1cmwuZ2V0KCk7XG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSBUb25lLlBsYXllci5kZWZhdWx0cztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgICAgICd1cmwnLFxuXHQgICAgICAgICAgICAgICAgJ29ubG9hZCdcblx0ICAgICAgICAgICAgXSwgVG9uZS5QbGF5ZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvQnVmZmVyU291cmNlTm9kZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSWYgdGhlIGZpbGUgc2hvdWxkIHBsYXkgYXMgc29vblxuXHRcdFx0ICogIGFzIHRoZSBidWZmZXIgaXMgbG9hZGVkLiBcblx0XHRcdCAqICBAdHlwZSB7Ym9vbGVhbn1cblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogLy93aWxsIHBsYXkgYXMgc29vbiBhcyBpdCdzIGxvYWRlZFxuXHRcdFx0ICogdmFyIHBsYXllciA9IG5ldyBUb25lLlBsYXllcih7XG5cdFx0XHQgKiBcdFwidXJsXCIgOiBcIi4vcGF0aC90by9zYW1wbGUubXAzXCIsXG5cdFx0XHQgKiBcdFwiYXV0b3N0YXJ0XCIgOiB0cnVlLFxuXHRcdFx0ICogfSkudG9NYXN0ZXIoKTtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuYXV0b3N0YXJ0ID0gb3B0aW9ucy5hdXRvc3RhcnQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGJ1ZmZlclxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQnVmZmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYnVmZmVyID0gbmV3IFRvbmUuQnVmZmVyKHtcblx0ICAgICAgICAgICAgJ3VybCc6IG9wdGlvbnMudXJsLFxuXHQgICAgICAgICAgICAnb25sb2FkJzogdGhpcy5fb25sb2FkLmJpbmQodGhpcywgb3B0aW9ucy5vbmxvYWQpLFxuXHQgICAgICAgICAgICAncmV2ZXJzZSc6IG9wdGlvbnMucmV2ZXJzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGlmICh1cmwgaW5zdGFuY2VvZiBBdWRpb0J1ZmZlcikge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXIuc2V0KHVybCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGlmIHRoZSBidWZmZXIgc2hvdWxkIGxvb3Agb25jZSBpdCdzIG92ZXJcblx0XHRcdCAqICBAdHlwZSB7Ym9vbGVhbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbG9vcCA9IG9wdGlvbnMubG9vcDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBpZiAnbG9vcCcgaXMgdHJ1ZSwgdGhlIGxvb3Agd2lsbCBzdGFydCBhdCB0aGlzIHBvc2l0aW9uXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3BTdGFydCA9IG9wdGlvbnMubG9vcFN0YXJ0O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGlmICdsb29wJyBpcyB0cnVlLCB0aGUgbG9vcCB3aWxsIGVuZCBhdCB0aGlzIHBvc2l0aW9uXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3BFbmQgPSBvcHRpb25zLmxvb3BFbmQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHBsYXliYWNrIHJhdGVcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSBvcHRpb25zLnBsYXliYWNrUmF0ZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBFbmFibGluZyByZXRyaWdnZXIgd2lsbCBhbGxvdyBhIHBsYXllciB0byBiZSByZXN0YXJ0ZWRcblx0XHRcdCAqICBiZWZvcmUgdGhlIHRoZSBwcmV2aW91cyAnc3RhcnQnIGlzIGRvbmUgcGxheWluZy4gT3RoZXJ3aXNlLCBcblx0XHRcdCAqICBzdWNjZXNzaXZlIGNhbGxzIHRvIFRvbmUuUGxheWVyLnN0YXJ0IHdpbGwgb25seSBzdGFydFxuXHRcdFx0ICogIHRoZSBzYW1wbGUgaWYgaXQgaGFkIHBsYXllZCBhbGwgdGhlIHdheSB0aHJvdWdoLiBcblx0XHRcdCAqICBAdHlwZSB7Ym9vbGVhbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmV0cmlnZ2VyID0gb3B0aW9ucy5yZXRyaWdnZXI7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZhZGVJbiB0aW1lIG9mIHRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZhZGVJbiA9IG9wdGlvbnMuZmFkZUluO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmYWRlT3V0IHRpbWUgb2YgdGhlIGFtcGxpdHVkZSBlbnZlbG9wZS5cblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmFkZU91dCA9IG9wdGlvbnMuZmFkZU91dDtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBsYXllciwgVG9uZS5Tb3VyY2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdvbmxvYWQnOiBUb25lLm5vT3AsXG5cdCAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IDEsXG5cdCAgICAgICAgJ2xvb3AnOiBmYWxzZSxcblx0ICAgICAgICAnYXV0b3N0YXJ0JzogZmFsc2UsXG5cdCAgICAgICAgJ2xvb3BTdGFydCc6IDAsXG5cdCAgICAgICAgJ2xvb3BFbmQnOiAwLFxuXHQgICAgICAgICdyZXRyaWdnZXInOiBmYWxzZSxcblx0ICAgICAgICAncmV2ZXJzZSc6IGZhbHNlLFxuXHQgICAgICAgICdmYWRlSW4nOiAwLFxuXHQgICAgICAgICdmYWRlT3V0JzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBMb2FkIHRoZSBhdWRpbyBmaWxlIGFzIGFuIGF1ZGlvIGJ1ZmZlci5cblx0XHQgKiAgRGVjb2RlcyB0aGUgYXVkaW8gYXN5bmNocm9ub3VzbHkgYW5kIGludm9rZXNcblx0XHQgKiAgdGhlIGNhbGxiYWNrIG9uY2UgdGhlIGF1ZGlvIGJ1ZmZlciBsb2Fkcy4gXG5cdFx0ICogIE5vdGU6IHRoaXMgZG9lcyBub3QgbmVlZCB0byBiZSBjYWxsZWQgaWYgYSB1cmxcblx0XHQgKiAgd2FzIHBhc3NlZCBpbiB0byB0aGUgY29uc3RydWN0b3IuIE9ubHkgdXNlIHRoaXNcblx0XHQgKiAgaWYgeW91IHdhbnQgdG8gbWFudWFsbHkgbG9hZCBhIG5ldyB1cmwuIFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHVybCBvZiB0aGUgYnVmZmVyIHRvIGxvYWQuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICBGaWxldHlwZSBzdXBwb3J0IGRlcGVuZHMgb24gdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICBicm93c2VyLlxuXHRcdCAqICBAcGFyYW0gIHtmdW5jdGlvbj19IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugb25jZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzYW1wbGUgaXMgbG9hZGVkLlxuXHRcdCAqICBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2spIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmxvYWQodXJsLCB0aGlzLl9vbmxvYWQuYmluZCh0aGlzLCBjYWxsYmFjaykpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEludGVybmFsIGNhbGxiYWNrIHdoZW4gdGhlIGJ1ZmZlciBpcyBsb2FkZWQuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVyLnByb3RvdHlwZS5fb25sb2FkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgY2FsbGJhY2sgPSBUb25lLmRlZmF1bHRBcmcoY2FsbGJhY2ssIFRvbmUubm9PcCk7XG5cdCAgICAgICAgY2FsbGJhY2sodGhpcyk7XG5cdCAgICAgICAgaWYgKHRoaXMuYXV0b3N0YXJ0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFBsYXkgdGhlIGJ1ZmZlciBhdCB0aGUgZ2l2ZW4gc3RhcnRUaW1lLiBPcHRpb25hbGx5IGFkZCBhbiBvZmZzZXRcblx0XHQgKiAgYW5kL29yIGR1cmF0aW9uIHdoaWNoIHdpbGwgcGxheSB0aGUgYnVmZmVyIGZyb20gYSBwb3NpdGlvblxuXHRcdCAqICB3aXRoaW4gdGhlIGJ1ZmZlciBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLiBcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFtzdGFydFRpbWU9bm93XSBXaGVuIHRoZSBwbGF5ZXIgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbb2Zmc2V0PTBdIFRoZSBvZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzYW1wbGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHN0YXJ0IGF0LiBcblx0XHQgKiAgQHBhcmFtICB7VGltZT19IGR1cmF0aW9uIEhvdyBsb25nIHRoZSBzYW1wbGUgc2hvdWxkIHBsYXkuIElmIG5vIGR1cmF0aW9uXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGdpdmVuLCBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIGZ1bGwgbGVuZ3RoIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgc2FtcGxlIChtaW51cyBhbnkgb2Zmc2V0KVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QbGF5ZXJ9IHRoaXNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGxheWVyI1xuXHRcdCAqICBAbWV0aG9kIHN0YXJ0XG5cdFx0ICogIEBuYW1lIHN0YXJ0XG5cdFx0ICovXG5cdCAgICAvKipcblx0XHQgKiAgSW50ZXJuYWwgc3RhcnQgbWV0aG9kXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHN0YXJ0VGltZSwgb2Zmc2V0LCBkdXJhdGlvbikge1xuXHQgICAgICAgIC8vaWYgaXQncyBhIGxvb3AgdGhlIGRlZmF1bHQgb2Zmc2V0IGlzIHRoZSBsb29wc3RhcnQgcG9pbnRcblx0ICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuXHQgICAgICAgICAgICBvZmZzZXQgPSBUb25lLmRlZmF1bHRBcmcob2Zmc2V0LCB0aGlzLl9sb29wU3RhcnQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vb3RoZXJ3aXNlIHRoZSBkZWZhdWx0IG9mZnNldCBpcyAwXG5cdCAgICAgICAgICAgIG9mZnNldCA9IFRvbmUuZGVmYXVsdEFyZyhvZmZzZXQsIDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2NvbXB1dGUgdGhlIHZhbHVlcyBpbiBzZWNvbmRzXG5cdCAgICAgICAgb2Zmc2V0ID0gdGhpcy50b1NlY29uZHMob2Zmc2V0KTtcblx0ICAgICAgICBkdXJhdGlvbiA9IFRvbmUuZGVmYXVsdEFyZyhkdXJhdGlvbiwgTWF0aC5tYXgodGhpcy5fYnVmZmVyLmR1cmF0aW9uIC0gb2Zmc2V0LCAwKSk7XG5cdCAgICAgICAgZHVyYXRpb24gPSB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbik7XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICAvLyAvL21ha2UgdGhlIHNvdXJjZVxuXHQgICAgICAgIHRoaXMuX3NvdXJjZSA9IG5ldyBUb25lLkJ1ZmZlclNvdXJjZSh7XG5cdCAgICAgICAgICAgICdidWZmZXInOiB0aGlzLl9idWZmZXIsXG5cdCAgICAgICAgICAgICdsb29wJzogdGhpcy5fbG9vcCxcblx0ICAgICAgICAgICAgJ2xvb3BTdGFydCc6IHRoaXMuX2xvb3BTdGFydCxcblx0ICAgICAgICAgICAgJ2xvb3BFbmQnOiB0aGlzLl9sb29wRW5kLFxuXHQgICAgICAgICAgICAncGxheWJhY2tSYXRlJzogdGhpcy5fcGxheWJhY2tSYXRlLFxuXHQgICAgICAgICAgICAnZmFkZUluJzogdGhpcy5mYWRlSW4sXG5cdCAgICAgICAgICAgICdmYWRlT3V0JzogdGhpcy5mYWRlT3V0XG5cdCAgICAgICAgfSkuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgLy9zZXQgdGhlIGxvb3BpbmcgcHJvcGVydGllc1xuXHQgICAgICAgIGlmICghdGhpcy5fbG9vcCAmJiAhdGhpcy5fc3luY2VkKSB7XG5cdCAgICAgICAgICAgIC8vaWYgaXQncyBub3QgbG9vcGluZywgc2V0IHRoZSBzdGF0ZSBjaGFuZ2UgYXQgdGhlIGVuZCBvZiB0aGUgc2FtcGxlXG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuU3RvcHBlZCwgc3RhcnRUaW1lICsgZHVyYXRpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL3N0YXJ0IGl0XG5cdCAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLnN0YXJ0KHN0YXJ0VGltZSwgb2Zmc2V0KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2Uuc3RhcnQoc3RhcnRUaW1lLCBvZmZzZXQsIGR1cmF0aW9uKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0b3AgcGxheWJhY2suXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd11cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGxheWVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLnN0b3AodGhpcy50b1NlY29uZHModGltZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2VlayB0byBhIHNwZWNpZmljIHRpbWUgaW4gdGhlIHBsYXllcidzIGJ1ZmZlci4gSWYgdGhlIFxuXHRcdCAqICBzb3VyY2UgaXMgbm8gbG9uZ2VyIHBsYXlpbmcgYXQgdGhhdCB0aW1lLCBpdCB3aWxsIHN0b3AuXG5cdFx0ICogIElmIHlvdSBzZWVrIHRvIGEgdGltZSB0aGF0IFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IG9mZnNldCBUaGUgdGltZSB0byBzZWVrIHRvLlxuXHRcdCAqICBAcGFyYW0ge1RpbWU9fSB0aW1lIFRoZSB0aW1lIGZvciB0aGUgc2VlayBldmVudCB0byBvY2N1ci5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5QbGF5ZXJ9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBzb3VyY2Uuc3RhcnQoMC4yKTtcblx0XHQgKiBzb3VyY2Uuc3RvcCgwLjQpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXIucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbiAob2Zmc2V0LCB0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgIG9mZnNldCA9IHRoaXMudG9TZWNvbmRzKG9mZnNldCk7XG5cdCAgICAgICAgICAgIC8vIGlmIGl0J3MgY3VycmVudGx5IHBsYXlpbmcsIHN0b3AgaXRcblx0ICAgICAgICAgICAgdGhpcy5fc3RvcCh0aW1lKTtcblx0ICAgICAgICAgICAgLy9yZXN0YXJ0IGl0IGF0IHRoZSBnaXZlbiB0aW1lXG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXJ0KHRpbWUsIG9mZnNldCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgdGhlIGxvb3Agc3RhcnQgYW5kIGVuZC4gV2lsbCBvbmx5IGxvb3AgaWYgbG9vcCBpcyBcblx0XHQgKiAgc2V0IHRvIHRydWUuIFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGxvb3BTdGFydCBUaGUgbG9vcCBlbmQgdGltZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGxvb3BFbmQgVGhlIGxvb3AgZW5kIHRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGxheWVyfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9sb29wIDAuMSBzZWNvbmRzIG9mIHRoZSBmaWxlLiBcblx0XHQgKiBwbGF5ZXIuc2V0TG9vcFBvaW50cygwLjIsIDAuMyk7XG5cdFx0ICogcGxheWVyLmxvb3AgPSB0cnVlO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXIucHJvdG90eXBlLnNldExvb3BQb2ludHMgPSBmdW5jdGlvbiAobG9vcFN0YXJ0LCBsb29wRW5kKSB7XG5cdCAgICAgICAgdGhpcy5sb29wU3RhcnQgPSBsb29wU3RhcnQ7XG5cdCAgICAgICAgdGhpcy5sb29wRW5kID0gbG9vcEVuZDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBJZiBsb29wIGlzIHRydWUsIHRoZSBsb29wIHdpbGwgc3RhcnQgYXQgdGhpcyBwb3NpdGlvbi4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGxvb3BTdGFydFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGxheWVyLnByb3RvdHlwZSwgJ2xvb3BTdGFydCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3BTdGFydDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxvb3BTdGFydCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wU3RhcnQgPSBsb29wU3RhcnQ7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5sb29wU3RhcnQgPSB0aGlzLnRvU2Vjb25kcyhsb29wU3RhcnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBJZiBsb29wIGlzIHRydWUsIHRoZSBsb29wIHdpbGwgZW5kIGF0IHRoaXMgcG9zaXRpb24uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGxvb3BFbmRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBsYXllci5wcm90b3R5cGUsICdsb29wRW5kJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9vcEVuZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxvb3BFbmQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcEVuZCA9IGxvb3BFbmQ7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5sb29wRW5kID0gdGhpcy50b1NlY29uZHMobG9vcEVuZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBhdWRpbyBidWZmZXIgYmVsb25naW5nIHRvIHRoZSBwbGF5ZXIuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBsYXllciNcblx0XHQgKiBAdHlwZSB7VG9uZS5CdWZmZXJ9XG5cdFx0ICogQG5hbWUgYnVmZmVyXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXIucHJvdG90eXBlLCAnYnVmZmVyJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5zZXQoYnVmZmVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIHRoZSBidWZmZXIgc2hvdWxkIGxvb3Agb25jZSBpdCdzIG92ZXIuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBsYXllciNcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbmFtZSBsb29wXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXIucHJvdG90eXBlLCAnbG9vcCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3A7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3AgPSBsb29wO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UubG9vcCA9IGxvb3A7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwbGF5YmFjayBzcGVlZC4gMSBpcyBub3JtYWwgc3BlZWQuIFRoaXMgaXMgbm90IGEgc2lnbmFsIGJlY2F1c2Vcblx0XHQgKiBTYWZhcmkgYW5kIGlPUyBjdXJyZW50bHkgZG9uJ3Qgc3VwcG9ydCBwbGF5YmFja1JhdGUgYXMgYSBzaWduYWwuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgcGxheWJhY2tSYXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXIucHJvdG90eXBlLCAncGxheWJhY2tSYXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSByYXRlO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gcmF0ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGRpcmVjdGlvbiB0aGUgYnVmZmVyIHNob3VsZCBwbGF5IGluXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBuYW1lIHJldmVyc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBsYXllci5wcm90b3R5cGUsICdyZXZlcnNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLnJldmVyc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyZXYpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYnVmZmVyLnJldmVyc2UgPSByZXY7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBJZiBhbGwgdGhlIGJ1ZmZlciBpcyBsb2FkZWRcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbG9hZGVkXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXIucHJvdG90eXBlLCAnbG9hZGVkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmxvYWRlZDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBEaXNwb3NlIGFuZCBkaXNjb25uZWN0LlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlBsYXllcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICBpZiAodGhpcy5fc291cmNlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2J1ZmZlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QbGF5ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5QbGF5ZXJzIGNvbWJpbmVzIG11bHRpcGxlIFtUb25lLlBsYXllcl0oUGxheWVyKSBvYmplY3RzLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSB1cmxzIEFuIG9iamVjdCBtYXBwaW5nIGEgbmFtZSB0byBhIHVybC5cblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbj19IG9ubG9hZCBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGJ1ZmZlciBpcyBsb2FkZWQuXG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllcnMgPSBmdW5jdGlvbiAodXJscykge1xuXHQgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0ICAgICAgICBhcmdzLnNoaWZ0KCk7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3MsIFsnb25sb2FkJ10sIFRvbmUuUGxheWVycyk7XG5cdCAgICAgICAgVG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvdXRwdXQgdm9sdW1lIG5vZGVcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuVm9sdW1lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlZvbHVtZShvcHRpb25zLnZvbHVtZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgdm9sdW1lIG9mIHRoZSBvdXRwdXQgaW4gZGVjaWJlbHMuXG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogc291cmNlLnZvbHVtZS52YWx1ZSA9IC02O1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSB0aGlzLl92b2x1bWUudm9sdW1lO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCd2b2x1bWUnKTtcblx0ICAgICAgICAvL21ha2UgdGhlIG91dHB1dCBleHBsaWNpdGx5IHN0ZXJlb1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZS5vdXRwdXQub3V0cHV0LmNoYW5uZWxDb3VudCA9IDI7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lLm91dHB1dC5vdXRwdXQuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG5cdCAgICAgICAgLy9tdXRlIGluaXRpYWxseVxuXHQgICAgICAgIHRoaXMubXV0ZSA9IG9wdGlvbnMubXV0ZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBjb250YWluZXIgb2YgYWxsIG9mIHRoZSBwbGF5ZXJzXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BsYXllcnMgPSB7fTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBsb2FkaW5nIGNvdW50XG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvYWRpbmdDb3VudCA9IDA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBwcml2YXRlIGhvbGRlciBvZiB0aGUgZmFkZUluIHRpbWVcblx0XHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZhZGVJbiA9IG9wdGlvbnMuZmFkZUluO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogcHJpdmF0ZSBob2xkZXIgb2YgdGhlIGZhZGVPdXQgdGltZVxuXHRcdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmFkZU91dCA9IG9wdGlvbnMuZmFkZU91dDtcblx0ICAgICAgICAvL2FkZCBhbGwgb2YgdGhlIHBsYXllcnNcblx0ICAgICAgICBmb3IgKHZhciBuYW1lIGluIHVybHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9hZGluZ0NvdW50Kys7XG5cdCAgICAgICAgICAgIHRoaXMuYWRkKG5hbWUsIHVybHNbbmFtZV0sIHRoaXMuX2J1ZmZlckxvYWRlZC5iaW5kKHRoaXMsIG9wdGlvbnMub25sb2FkKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGxheWVycywgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVycy5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlLFxuXHQgICAgICAgICdvbmxvYWQnOiBUb25lLm5vT3AsXG5cdCAgICAgICAgJ2ZhZGVJbic6IDAsXG5cdCAgICAgICAgJ2ZhZGVPdXQnOiAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEEgYnVmZmVyIHdhcyBsb2FkZWQuIGRlY3JlbWVudCB0aGUgY291bnRlci5cblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFja1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXJzLnByb3RvdHlwZS5fYnVmZmVyTG9hZGVkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgdGhpcy5fbG9hZGluZ0NvdW50LS07XG5cdCAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmdDb3VudCA9PT0gMCAmJiBjYWxsYmFjaykge1xuXHQgICAgICAgICAgICBjYWxsYmFjayh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogTXV0ZSB0aGUgb3V0cHV0LlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlNvdXJjZSNcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbmFtZSBtdXRlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvL211dGUgdGhlIG91dHB1dFxuXHRcdCAqIHNvdXJjZS5tdXRlID0gdHJ1ZTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBsYXllcnMucHJvdG90eXBlLCAnbXV0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZS5tdXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobXV0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl92b2x1bWUubXV0ZSA9IG11dGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZmFkZUluIHRpbWUgb2YgdGhlIGFtcGxpdHVkZSBlbnZlbG9wZS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Tb3VyY2UjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgZmFkZUluXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXJzLnByb3RvdHlwZSwgJ2ZhZGVJbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhZGVJbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGZhZGVJbikge1xuXHQgICAgICAgICAgICB0aGlzLl9mYWRlSW4gPSBmYWRlSW47XG5cdCAgICAgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuXHQgICAgICAgICAgICAgICAgcGxheWVyLmZhZGVJbiA9IGZhZGVJbjtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZmFkZU91dCB0aW1lIG9mIHRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU291cmNlI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGZhZGVPdXRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBsYXllcnMucHJvdG90eXBlLCAnZmFkZU91dCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhZGVPdXQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChmYWRlT3V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZhZGVPdXQgPSBmYWRlT3V0O1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcblx0ICAgICAgICAgICAgICAgIHBsYXllci5mYWRlT3V0ID0gZmFkZU91dDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgc3RhdGUgb2YgdGhlIHBsYXllcnMgb2JqZWN0LiBSZXR1cm5zIFwic3RhcnRlZFwiIGlmIGFueSBvZiB0aGUgcGxheWVycyBhcmUgcGxheWluZy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QbGF5ZXJzI1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQG5hbWUgc3RhdGVcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBsYXllcnMucHJvdG90eXBlLCAnc3RhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwbGF5aW5nID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuXHQgICAgICAgICAgICAgICAgcGxheWluZyA9IHBsYXlpbmcgfHwgcGxheWVyLnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQ7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gcGxheWluZyA/IFRvbmUuU3RhdGUuU3RhcnRlZCA6IFRvbmUuU3RhdGUuU3RvcHBlZDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcnVlIGlmIHRoZSBidWZmZXJzIG9iamVjdCBoYXMgYSBidWZmZXIgYnkgdGhhdCBuYW1lLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd8TnVtYmVyfSAgbmFtZSAgVGhlIGtleSBvciBpbmRleCBvZiB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5cblx0XHQgKiAgQHJldHVybiAge0Jvb2xlYW59XG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXllcnMuaGFzT3duUHJvcGVydHkobmFtZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCBhIHBsYXllciBieSBuYW1lLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICBUaGUgcGxheWVycyBuYW1lIGFzIGRlZmluZWQgaW5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGNvbnN0cnVjdG9yIG9iamVjdCBvciBgYWRkYCBtZXRob2QuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlBsYXllcn1cblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5oYXMobmFtZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXllcnNbbmFtZV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLlBsYXllcnM6IG5vIHBsYXllciBuYW1lZCAnICsgbmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEl0ZXJhdGUgb3ZlciBhbGwgb2YgdGhlIHBsYXllcnNcblx0XHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0XHQgKiBAcmV0dXJuIHtUb25lLlBsYXllcnN9ICAgICAgICAgICAgdGhpc1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllcnMucHJvdG90eXBlLl9mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgZm9yICh2YXIgcGxheWVyTmFtZSBpbiB0aGlzLl9wbGF5ZXJzKSB7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuX3BsYXllcnNbcGxheWVyTmFtZV0sIHBsYXllck5hbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBJZiBhbGwgdGhlIGJ1ZmZlcnMgYXJlIGxvYWRlZCBvciBub3Rcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QbGF5ZXJzI1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBuYW1lIGxvYWRlZFxuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGxheWVycy5wcm90b3R5cGUsICdsb2FkZWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBpc0xvYWRlZCA9IHRydWU7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuXHQgICAgICAgICAgICAgICAgaXNMb2FkZWQgPSBpc0xvYWRlZCAmJiBwbGF5ZXIubG9hZGVkO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGlzTG9hZGVkO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZCBhIHBsYXllciBieSBuYW1lIGFuZCB1cmwgdG8gdGhlIFBsYXllcnNcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgICBuYW1lICAgICAgQSB1bmlxdWUgbmFtZSB0byBnaXZlIHRoZSBwbGF5ZXJcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfFRvbmUuQnVmZmVyfEF1ZGlvYnVmZmVyfSAgdXJsICBFaXRoZXIgdGhlIHVybCBvZiB0aGUgYnVmZXIsXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgYSBidWZmZXIgd2hpY2ggd2lsbCBiZSBhZGRlZFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGdpdmVuIG5hbWUuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9uPX0gIGNhbGxiYWNrICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIHRoZSB1cmwgaXMgbG9hZGVkLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXJzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobmFtZSwgdXJsLCBjYWxsYmFjaykge1xuXHQgICAgICAgIHRoaXMuX3BsYXllcnNbbmFtZV0gPSBuZXcgVG9uZS5QbGF5ZXIodXJsLCBjYWxsYmFjaykuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcGxheWVyc1tuYW1lXS5mYWRlSW4gPSB0aGlzLl9mYWRlSW47XG5cdCAgICAgICAgdGhpcy5fcGxheWVyc1tuYW1lXS5mYWRlT3V0ID0gdGhpcy5fZmFkZU91dDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTdG9wIGFsbCBvZiB0aGUgcGxheWVycyBhdCB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqIEBwYXJhbSB7VGltZX0gdGltZSBUaGUgdGltZSB0byBzdG9wIGFsbCBvZiB0aGUgcGxheWVycy5cblx0XHQgKiBAcmV0dXJuIHtUb25lLlBsYXllcnN9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVycy5wcm90b3R5cGUuc3RvcEFsbCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG5cdCAgICAgICAgICAgIHBsYXllci5zdG9wKHRpbWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBEaXNwb3NlIGFuZCBkaXNjb25uZWN0LlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlBsYXllcnN9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVycy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgndm9sdW1lJyk7XG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMub3V0cHV0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcblx0ICAgICAgICAgICAgcGxheWVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9wbGF5ZXJzID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QbGF5ZXJzO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuVXNlck1lZGlhIHVzZXMgTWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSB0byBvcGVuIHVwXG5cdFx0ICogICAgICAgICAgYW5kIGV4dGVybmFsIG1pY3JvcGhvbmUgb3IgYXVkaW8gaW5wdXQuIENoZWNrXG5cdFx0ICogICAgICAgICAgW01lZGlhRGV2aWNlcyBBUEkgU3VwcG9ydF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhRGV2aWNlcy9nZXRVc2VyTWVkaWEpXG5cdFx0ICogICAgICAgICAgdG8gc2VlIHdoaWNoIGJyb3dzZXJzIGFyZSBzdXBwb3J0ZWQuIEFjY2VzcyB0byBhbiBleHRlcm5hbCBpbnB1dFxuXHRcdCAqICAgICAgICAgIGlzIGxpbWl0ZWQgdG8gc2VjdXJlIChIVFRQUykgY29ubmVjdGlvbnMuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtEZWNpYmVscz19IHZvbHVtZSBUaGUgbGV2ZWwgb2YgdGhlIGlucHV0XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9saXN0IHRoZSBpbnB1dHMgYW5kIG9wZW4gdGhlIHRoaXJkIG9uZVxuXHRcdCAqIHZhciBtb3R1ID0gbmV3IFRvbmUuVXNlck1lZGlhKCk7XG5cdFx0ICpcblx0XHQgKiAvL29wZW5pbmcgdGhlIGlucHV0IGFza3MgdGhlIHVzZXIgdG8gYWN0aXZhdGUgdGhlaXIgbWljXG5cdFx0ICogbW90dS5vcGVuKCkudGhlbihmdW5jdGlvbigpe1xuXHRcdCAqIFx0Ly9vcGVuaW5nIGlzIGFjdGl2YXRlcyB0aGUgbWljcm9waG9uZVxuXHRcdCAqIFx0Ly9zdGFydGluZyBsZXRzIGF1ZGlvIHRocm91Z2hcblx0XHQgKiBcdG1vdHUuc3RhcnQoMTApO1xuXHRcdCAqIH0pO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Vc2VyTWVkaWEgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWyd2b2x1bWUnXSwgVG9uZS5Vc2VyTWVkaWEpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIE1lZGlhU3RyZWFtTm9kZVxuXHRcdFx0ICogIEB0eXBlIHtNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW0gPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtZWRpYSBzdHJlYW0gY3JlYXRlZCBieSBnZXRVc2VyTWVkaWEuXG5cdFx0XHQgKiAgQHR5cGUge0xvY2FsTWVkaWFTdHJlYW19XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N0cmVhbSA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG9wZW4gZGV2aWNlXG5cdFx0XHQgKiAgQHR5cGUgIHtNZWRpYURldmljZUluZm99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RldmljZSA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG91dHB1dCB2b2x1bWUgbm9kZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Wb2x1bWV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuVm9sdW1lKG9wdGlvbnMudm9sdW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSB2b2x1bWUgb2YgdGhlIG91dHB1dCBpbiBkZWNpYmVscy5cblx0XHRcdCAqIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBpbnB1dC52b2x1bWUudmFsdWUgPSAtNjtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gdGhpcy5fdm9sdW1lLnZvbHVtZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgndm9sdW1lJyk7XG5cdCAgICAgICAgdGhpcy5tdXRlID0gb3B0aW9ucy5tdXRlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVXNlck1lZGlhLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuVXNlck1lZGlhLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd2b2x1bWUnOiAwLFxuXHQgICAgICAgICdtdXRlJzogZmFsc2Vcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgT3BlbiB0aGUgbWVkaWEgc3RyZWFtLiBJZiBhIHN0cmluZyBpcyBwYXNzZWQgaW4sIGl0IGlzIGFzc3VtZWRcblx0XHQgKiAgdG8gYmUgdGhlIGxhYmVsIG9yIGlkIG9mIHRoZSBzdHJlYW0sIGlmIGEgbnVtYmVyIGlzIHBhc3NlZCBpbixcblx0XHQgKiAgaXQgaXMgdGhlIGlucHV0IG51bWJlciBvZiB0aGUgc3RyZWFtLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd8TnVtYmVyfSBbbGFiZWxPcklkPVwiZGVmYXVsdFwiXSBUaGUgbGFiZWwgb3IgaWQgb2YgdGhlIGF1ZGlvIGlucHV0IG1lZGlhIGRldmljZS5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdpdGggbm8gYXJndW1lbnQsIHRoZSBkZWZhdWx0IHN0cmVhbSBpcyBvcGVuZWQuXG5cdFx0ICogIEByZXR1cm4ge1Byb21pc2V9IFRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdoZW4gdGhlIHN0cmVhbSBpcyBvcGVuLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAobGFiZWxPcklkKSB7XG5cdCAgICAgICAgbGFiZWxPcklkID0gVG9uZS5kZWZhdWx0QXJnKGxhYmVsT3JJZCwgJ2RlZmF1bHQnKTtcblx0ICAgICAgICByZXR1cm4gVG9uZS5Vc2VyTWVkaWEuZW51bWVyYXRlRGV2aWNlcygpLnRoZW4oZnVuY3Rpb24gKGRldmljZXMpIHtcblx0ICAgICAgICAgICAgdmFyIGRldmljZTtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNOdW1iZXIobGFiZWxPcklkKSkge1xuXHQgICAgICAgICAgICAgICAgZGV2aWNlID0gZGV2aWNlc1tsYWJlbE9ySWRdO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZGV2aWNlID0gZGV2aWNlcy5maW5kKGZ1bmN0aW9uIChkZXZpY2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlLmxhYmVsID09PSBsYWJlbE9ySWQgfHwgZGV2aWNlLmRldmljZUlkID09PSBsYWJlbE9ySWQ7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIC8vZGlkbid0IGZpbmQgYSBtYXRjaGluZyBkZXZpY2Vcblx0ICAgICAgICAgICAgICAgIGlmICghZGV2aWNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLlVzZXJNZWRpYTogbm8gbWF0Y2hpbmcgZGV2aWNlOiAnICsgbGFiZWxPcklkKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9kZXZpY2UgPSBkZXZpY2U7XG5cdCAgICAgICAgICAgIC8vZG8gZ2V0VXNlck1lZGlhXG5cdCAgICAgICAgICAgIHZhciBjb25zdHJhaW50cyA9IHtcblx0ICAgICAgICAgICAgICAgIGF1ZGlvOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgJ2RldmljZUlkJzogZGV2aWNlLmRldmljZUlkLFxuXHQgICAgICAgICAgICAgICAgICAgICdlY2hvQ2FuY2VsbGF0aW9uJzogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgJ3NhbXBsZVJhdGUnOiB0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpLnRoZW4oZnVuY3Rpb24gKHN0cmVhbSkge1xuXHQgICAgICAgICAgICAgICAgLy9zdGFydCBhIG5ldyBzb3VyY2Ugb25seSBpZiB0aGUgcHJldmlvdXMgb25lIGlzIGNsb3NlZFxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdHJlYW0pIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG5cdCAgICAgICAgICAgICAgICAgICAgLy9XcmFwIGEgTWVkaWFTdHJlYW1Tb3VyY2VOb2RlIGFyb3VuZCB0aGUgbGl2ZSBpbnB1dCBzdHJlYW0uXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW0gPSB0aGlzLmNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcblx0ICAgICAgICAgICAgICAgICAgICAvL0Nvbm5lY3QgdGhlIE1lZGlhU3RyZWFtU291cmNlTm9kZSB0byBhIGdhdGUgZ2FpbiBub2RlXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW0uY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbG9zZSB0aGUgbWVkaWEgc3RyZWFtXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuVXNlck1lZGlhfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlVzZXJNZWRpYS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3N0cmVhbSkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuXHQgICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RyZWFtID0gbnVsbDtcblx0ICAgICAgICAgICAgLy9yZW1vdmUgdGhlIG9sZCBtZWRpYSBzdHJlYW1cblx0ICAgICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW0uZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2RldmljZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdpdGggdGhlIGxpc3Qgb2YgYXVkaW8gaW5wdXQgZGV2aWNlcyBhdmFpbGFibGUuXG5cdFx0ICogIEByZXR1cm4ge1Byb21pc2V9IFRoZSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgZGV2aWNlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5Vc2VyTWVkaWEuZW51bWVyYXRlRGV2aWNlcygpLnRoZW4oZnVuY3Rpb24oZGV2aWNlcyl7XG5cdFx0ICogXHRjb25zb2xlLmxvZyhkZXZpY2VzKVxuXHRcdCAqIH0pXG5cdFx0ICovXG5cdCAgICBUb25lLlVzZXJNZWRpYS5lbnVtZXJhdGVEZXZpY2VzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGZ1bmN0aW9uIChkZXZpY2VzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBkZXZpY2VzLmZpbHRlcihmdW5jdGlvbiAoZGV2aWNlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlLmtpbmQgPT09ICdhdWRpb2lucHV0Jztcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBzb3VyY2UsIFwic3RhcnRlZFwiIHdoZW4gdGhlIG1pY3JvcGhvbmUgaXMgb3BlblxuXHRcdCAqICBhbmQgXCJzdG9wcGVkXCIgd2hlbiB0aGUgbWljIGlzIGNsb3NlZC5cblx0XHQgKiAgQHR5cGUge1RvbmUuU3RhdGV9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Vc2VyTWVkaWEjXG5cdFx0ICogIEBuYW1lIHN0YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLCAnc3RhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJlYW0gJiYgdGhpcy5fc3RyZWFtLmFjdGl2ZSA/IFRvbmUuU3RhdGUuU3RhcnRlZCA6IFRvbmUuU3RhdGUuU3RvcHBlZDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFx0UmV0dXJucyBhbiBpZGVudGlmaWVyIGZvciB0aGUgcmVwcmVzZW50ZWQgZGV2aWNlIHRoYXQgaXNcblx0XHQgKiBcdHBlcnNpc3RlZCBhY3Jvc3Mgc2Vzc2lvbnMuIEl0IGlzIHVuLWd1ZXNzYWJsZSBieSBvdGhlciBhcHBsaWNhdGlvbnMgYW5kXG5cdFx0ICogXHR1bmlxdWUgdG8gdGhlIG9yaWdpbiBvZiB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbi4gSXQgaXMgcmVzZXQgd2hlbiB0aGVcblx0XHQgKiBcdHVzZXIgY2xlYXJzIGNvb2tpZXMgKGZvciBQcml2YXRlIEJyb3dzaW5nLCBhIGRpZmZlcmVudCBpZGVudGlmaWVyIGlzXG5cdFx0ICogXHR1c2VkIHRoYXQgaXMgbm90IHBlcnNpc3RlZCBhY3Jvc3Mgc2Vzc2lvbnMpLiBSZXR1cm5zIHVuZGVmaW5lZCB3aGVuIHRoZVxuXHRcdCAqIFx0ZGV2aWNlIGlzIG5vdCBvcGVuLlxuXHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVXNlck1lZGlhI1xuXHRcdCAqICBAbmFtZSBkZXZpY2VJZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVXNlck1lZGlhLnByb3RvdHlwZSwgJ2RldmljZUlkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZGV2aWNlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGV2aWNlLmRldmljZUlkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBcdFJldHVybnMgYSBncm91cCBpZGVudGlmaWVyLiBUd28gZGV2aWNlcyBoYXZlIHRoZVxuXHRcdCAqIFx0c2FtZSBncm91cCBpZGVudGlmaWVyIGlmIHRoZXkgYmVsb25nIHRvIHRoZSBzYW1lIHBoeXNpY2FsIGRldmljZS5cblx0XHQgKiBcdFJldHVybnMgdW5kZWZpbmVkIHdoZW4gdGhlIGRldmljZSBpcyBub3Qgb3Blbi5cblx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlVzZXJNZWRpYSNcblx0XHQgKiAgQG5hbWUgZ3JvdXBJZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVXNlck1lZGlhLnByb3RvdHlwZSwgJ2dyb3VwSWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9kZXZpY2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXZpY2UuZ3JvdXBJZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogXHRSZXR1cm5zIGEgbGFiZWwgZGVzY3JpYmluZyB0aGlzIGRldmljZSAoZm9yIGV4YW1wbGUgXCJCdWlsdC1pbiBNaWNyb3Bob25lXCIpLlxuXHRcdCAqIFx0UmV0dXJucyB1bmRlZmluZWQgd2hlbiB0aGUgZGV2aWNlIGlzIG5vdCBvcGVuIG9yIGxhYmVsIGlzIG5vdCBhdmFpbGFibGVcblx0XHQgKiBcdGJlY2F1c2Ugb2YgcGVybWlzc2lvbnMuXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Vc2VyTWVkaWEjXG5cdFx0ICogIEBuYW1lIGdyb3VwSWRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlVzZXJNZWRpYS5wcm90b3R5cGUsICdsYWJlbCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2RldmljZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RldmljZS5sYWJlbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogTXV0ZSB0aGUgb3V0cHV0LlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlVzZXJNZWRpYSNcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbmFtZSBtdXRlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvL211dGUgdGhlIG91dHB1dFxuXHRcdCAqIHVzZXJNZWRpYS5tdXRlID0gdHJ1ZTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlVzZXJNZWRpYS5wcm90b3R5cGUsICdtdXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdm9sdW1lLm11dGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtdXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3ZvbHVtZS5tdXRlID0gbXV0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIENsZWFuIHVwLlxuXHRcdCAqIEByZXR1cm4ge1RvbmUuVXNlck1lZGlhfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlVzZXJNZWRpYS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY2xvc2UoKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgndm9sdW1lJyk7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSWYgZ2V0VXNlck1lZGlhIGlzIHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci5cblx0XHQgKiAgQHR5cGUgIHtCb29sZWFufVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Vc2VyTWVkaWEjXG5cdFx0ICogIEBuYW1lIHN1cHBvcnRlZFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVXNlck1lZGlhLCAnc3VwcG9ydGVkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gIVRvbmUuaXNVbmRlZihuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSAmJiBUb25lLmlzRnVuY3Rpb24obmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIFRvbmUuVXNlck1lZGlhO1xuXHR9KTtcblx0XG5cdHJldHVybiBUb25lO1xufSkpOyIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtOREFycmF5fSBmcm9tICcuL21hdGgvbmRhcnJheSc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrcG9pbnRWYXJpYWJsZSB7XG4gIGZpbGVuYW1lOiBzdHJpbmc7XG4gIHNoYXBlOiBudW1iZXJbXTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCB0eXBlIENoZWNrcG9pbnRNYW5pZmVzdCA9IHtcbiAgW3Zhck5hbWU6IHN0cmluZ106IENoZWNrcG9pbnRWYXJpYWJsZVxufTtcblxuY29uc3QgTUFOSUZFU1RfRklMRSA9ICdtYW5pZmVzdC5qc29uJztcblxuZXhwb3J0IGNsYXNzIENoZWNrcG9pbnRMb2FkZXIge1xuICBwcml2YXRlIGNoZWNrcG9pbnRNYW5pZmVzdDogQ2hlY2twb2ludE1hbmlmZXN0O1xuICBwcml2YXRlIHZhcmlhYmxlczoge1t2YXJOYW1lOiBzdHJpbmddOiBOREFycmF5fTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHVybFBhdGg6IHN0cmluZykge1xuICAgIGlmICh0aGlzLnVybFBhdGguY2hhckF0KHRoaXMudXJsUGF0aC5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICB0aGlzLnVybFBhdGggKz0gJy8nO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbG9hZE1hbmlmZXN0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCB0aGlzLnVybFBhdGggKyBNQU5JRkVTVF9GSUxFKTtcblxuICAgICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5jaGVja3BvaW50TWFuaWZlc3QgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYCR7TUFOSUZFU1RfRklMRX0gbm90IGZvdW5kIGF0ICR7dGhpcy51cmxQYXRofS4gYCArIGVycm9yKTtcbiAgICAgIH07XG4gICAgICB4aHIuc2VuZCgpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q2hlY2twb2ludE1hbmlmZXN0KCk6IFByb21pc2U8Q2hlY2twb2ludE1hbmlmZXN0PiB7XG4gICAgaWYgKHRoaXMuY2hlY2twb2ludE1hbmlmZXN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxDaGVja3BvaW50TWFuaWZlc3Q+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5sb2FkTWFuaWZlc3QoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKHRoaXMuY2hlY2twb2ludE1hbmlmZXN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPENoZWNrcG9pbnRNYW5pZmVzdD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVzb2x2ZSh0aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRBbGxWYXJpYWJsZXMoKTogUHJvbWlzZTx7W3Zhck5hbWU6IHN0cmluZ106IE5EQXJyYXl9PiB7XG4gICAgaWYgKHRoaXMudmFyaWFibGVzICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx7W3Zhck5hbWU6IHN0cmluZ106IE5EQXJyYXl9PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlc29sdmUodGhpcy52YXJpYWJsZXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHtbdmFyTmFtZTogc3RyaW5nXTogTkRBcnJheX0+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuZ2V0Q2hlY2twb2ludE1hbmlmZXN0KCkudGhlbihcbiAgICAgICAgICAoY2hlY2twb2ludERlZmluaXRpb246IENoZWNrcG9pbnRNYW5pZmVzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVOYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuY2hlY2twb2ludE1hbmlmZXN0KTtcblxuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVQcm9taXNlczogQXJyYXk8UHJvbWlzZTxOREFycmF5Pj4gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFyaWFibGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXJpYWJsZVByb21pc2VzLnB1c2godGhpcy5nZXRWYXJpYWJsZSh2YXJpYWJsZU5hbWVzW2ldKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFByb21pc2UuYWxsKHZhcmlhYmxlUHJvbWlzZXMpLnRoZW4odmFyaWFibGVzID0+IHtcbiAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YXJpYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1t2YXJpYWJsZU5hbWVzW2ldXSA9IHZhcmlhYmxlc1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHRoaXMudmFyaWFibGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0VmFyaWFibGUodmFyTmFtZTogc3RyaW5nKTogUHJvbWlzZTxOREFycmF5PiB7XG4gICAgaWYgKCEodmFyTmFtZSBpbiB0aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGxvYWQgbm9uLWV4aXN0YW50IHZhcmlhYmxlICcgKyB2YXJOYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YXJpYWJsZVJlcXVlc3RQcm9taXNlTWV0aG9kID1cbiAgICAgICAgKHJlc29sdmU6IChuZGFycmF5OiBOREFycmF5KSA9PiB2b2lkLCByZWplY3Q6ICgpID0+IHZvaWQpID0+IHtcbiAgICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICBjb25zdCBmbmFtZSA9IHRoaXMuY2hlY2twb2ludE1hbmlmZXN0W3Zhck5hbWVdLmZpbGVuYW1lO1xuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB0aGlzLnVybFBhdGggKyBmbmFtZSk7XG5cbiAgICAgICAgICB4aHIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgY29uc3QgbmRhcnJheSA9XG4gICAgICAgICAgICAgICAgTkRBcnJheS5tYWtlKHRoaXMuY2hlY2twb2ludE1hbmlmZXN0W3Zhck5hbWVdLnNoYXBlLCB7dmFsdWVzfSk7XG4gICAgICAgICAgICByZXNvbHZlKG5kYXJyYXkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgeGhyLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnQ291bGQgbm90IGZldGNoIHZhcmlhYmxlICcgKyB2YXJOYW1lICsgJzogJyArIGVycm9yKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgIH07XG5cbiAgICBpZiAodGhpcy5jaGVja3BvaW50TWFuaWZlc3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPE5EQXJyYXk+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5sb2FkTWFuaWZlc3QoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBuZXcgUHJvbWlzZTxOREFycmF5Pih2YXJpYWJsZVJlcXVlc3RQcm9taXNlTWV0aG9kKS50aGVuKHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2U8TkRBcnJheT4odmFyaWFibGVSZXF1ZXN0UHJvbWlzZU1ldGhvZCk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtOREFycmF5fSBmcm9tICcuL21hdGgvbmRhcnJheSc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IFNUQVRTX1NBTVBMRV9QRVJDRU5UQUdFID0gMC4xO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFTdGF0cyB7XG4gIGV4YW1wbGVDb3VudDogbnVtYmVyO1xuICBpbnB1dE1pbjogbnVtYmVyO1xuICBpbnB1dE1heDogbnVtYmVyO1xuICBzaGFwZTogbnVtYmVyW107XG59XG5cbmludGVyZmFjZSBOb3JtYWxpemF0aW9uSW5mbyB7XG4gIGlzTm9ybWFsaXplZDogYm9vbGVhbjtcbiAgLy8gQm91bmRzIG9mIHRoZSBub3JtYWxpemF0aW9uIGlmIG5vcm1hbGl6ZWQuXG4gIGxvd2VyQm91bmQ/OiBudW1iZXI7XG4gIHVwcGVyQm91bmQ/OiBudW1iZXI7XG4gIC8vIE1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzIGZvciBlYWNoIGRpbWVuc2lvbiBvZiB0aGUgb3JpZ2luYWwgZGF0YS4gVGhlc2VcbiAgLy8gYXJlIHRoZSBzYW1lIHNpemUgYXMgYW4gaW5wdXQgZXhhbXBsZS4gVGhlc2UgYXJlIGNvbXB1dGVkIGxhemlseSwgb25seSBpZlxuICAvLyBub3JtYWxpemF0aW9uIGlzIHJlcXVlc3RlZC4gSWYgdGhlIGRhdGEgaXMgdW4tbm9ybWFsaXplZCwgdGhlc2UgYXJlIGtlcHRcbiAgLy8gYXJvdW5kIHNvIHRoZXkgZG9uJ3QgaGF2ZSB0byBiZSByZWNvbXB1dGVkLlxuICBtaW5WYWx1ZXM6IEZsb2F0MzJBcnJheTtcbiAgbWF4VmFsdWVzOiBGbG9hdDMyQXJyYXk7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbk1lbW9yeURhdGFzZXQge1xuICBwcm90ZWN0ZWQgZGF0YXNldDogTkRBcnJheVtdW118bnVsbDtcblxuICAvLyBDb250YWlucyBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgZm9yIHJlY29uc3RydWN0aW9uIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIC8vIGFmdGVyIG5vcm1hbGl6YXRpb24uXG4gIHByaXZhdGUgbm9ybWFsaXphdGlvbkluZm86IHtbZGF0YUluZGV4OiBudW1iZXJdOiBOb3JtYWxpemF0aW9uSW5mb307XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGRhdGFTaGFwZXM6IG51bWJlcltdW10pIHtcbiAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvID0ge307XG4gIH1cblxuICBnZXREYXRhU2hhcGUoZGF0YUluZGV4OiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVNoYXBlc1tkYXRhSW5kZXhdO1xuICB9XG5cbiAgYWJzdHJhY3QgZmV0Y2hEYXRhKCk6IFByb21pc2U8dm9pZD47XG5cbiAgZ2V0RGF0YSgpOiBOREFycmF5W11bXXxudWxsIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhc2V0O1xuICB9XG5cbiAgZ2V0U3RhdHMoKTogRGF0YVN0YXRzW10ge1xuICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGlzIG51bGwuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YXNldC5tYXAoZCA9PiB0aGlzLmdldFN0YXRzRm9yRGF0YShkKSk7XG4gIH1cblxuICAvLyBDb21wdXRlcyBzdGF0cyBhY3Jvc3MgYSBzYW1wbGVkIHBvcnRpb24gb2YgdGhlIGRhdGEuXG4gIHByaXZhdGUgZ2V0U3RhdHNGb3JEYXRhKGRhdGE6IE5EQXJyYXlbXSk6IERhdGFTdGF0cyB7XG4gICAgbGV0IGlucHV0TWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBpbnB1dE1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICAgIGxldCBleGFtcGxlSW5kaWNlcyA9IGRhdGEubWFwKChleGFtcGxlLCBpKSA9PiBpKTtcbiAgICB1dGlsLnNodWZmbGUoZXhhbXBsZUluZGljZXMpO1xuICAgIGV4YW1wbGVJbmRpY2VzID1cbiAgICAgICAgZXhhbXBsZUluZGljZXMuc2xpY2UoZXhhbXBsZUluZGljZXMubGVuZ3RoICogU1RBVFNfU0FNUExFX1BFUkNFTlRBR0UpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGFtcGxlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5wdXRWYWx1ZXMgPSBkYXRhW2V4YW1wbGVJbmRpY2VzW2ldXS5nZXRWYWx1ZXMoKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5wdXRWYWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaW5wdXRNaW4gPSBNYXRoLm1pbihpbnB1dE1pbiwgaW5wdXRWYWx1ZXNbal0pO1xuICAgICAgICBpbnB1dE1heCA9IE1hdGgubWF4KGlucHV0TWF4LCBpbnB1dFZhbHVlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0TWluLFxuICAgICAgaW5wdXRNYXgsXG4gICAgICBleGFtcGxlQ291bnQ6IGRhdGEubGVuZ3RoLFxuICAgICAgc2hhcGU6IGRhdGFbMF0uc2hhcGUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gZXhhbXBsZXMgTkRBcnJheXMgdG8gYmUgbm9ybWFsaXplZC5cbiAgICogQHBhcmFtIGN1ckxvd2VyQm91bmRzIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG1pbmltdW0gdmFsdWUgZm9yIGVhY2hcbiAgICogZGltZW5zaW9uIG9yIGEgZml4ZWQgbWluaW11bSB2YWx1ZS5cbiAgICogQHBhcmFtIGN1clVwcGVyQm91bmRzIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG1heGltdW0gdmFsdWUgZm9yIGVhY2hcbiAgICogZGltZW5zaW9uIG9yIGEgZml4ZWQgbWF4aW11bSB2YWx1ZS5cbiAgICogQHBhcmFtIG5ld0xvd2VyQm91bmRzIEFuIGFycmF5IGNvbnRhaW5pbmcgbmV3IG1pbmltdW0gdmFsdWVzIGZvciBlYWNoXG4gICAqIGRpbWVuc2lvbiwgb3IgYSBmaXhlZCBtaW51bXVtIHZhbHVlIHRvIG5vcm1hbGl6ZSB0aGUgZGF0YSB0by5cbiAgICogQHBhcmFtIG5ld1VwcGVyQm91bmRzIEFuIGFycmF5IGNvbnRhaW5pbmcgbmV3IG1heGltdW0gdmFsdWVzIGZvciBlYWNoXG4gICAqIGRpbWVuc2lvbiwgb3IgYSBmaXhlZCBtYXhpbXVtIHZhbHVlIHRvIG5vcm1hbGl6ZSB0aGUgZGF0YSB0by5cbiAgICovXG4gIHByaXZhdGUgbm9ybWFsaXplRXhhbXBsZXNUb1JhbmdlKFxuICAgICAgZXhhbXBsZXM6IE5EQXJyYXlbXSwgY3VyTG93ZXJCb3VuZHM6IEZsb2F0MzJBcnJheXxudW1iZXIsXG4gICAgICBjdXJVcHBlckJvdW5kczogRmxvYXQzMkFycmF5fG51bWJlciwgbmV3TG93ZXJCb3VuZHM6IEZsb2F0MzJBcnJheXxudW1iZXIsXG4gICAgICBuZXdVcHBlckJvdW5kczogRmxvYXQzMkFycmF5fG51bWJlcik6IE5EQXJyYXlbXSB7XG4gICAgY29uc3QgY3VyQm91bmRzSXNQZXJEaW1lbnNpb24gPVxuICAgICAgICAoY3VyVXBwZXJCb3VuZHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgJiZcbiAgICAgICAgIGN1ckxvd2VyQm91bmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KTtcbiAgICBjb25zdCBuZXdCb3VuZHNJc1BlckRpbWVuc2lvbiA9XG4gICAgICAgIChuZXdMb3dlckJvdW5kcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSAmJlxuICAgICAgICAgbmV3VXBwZXJCb3VuZHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpO1xuXG4gICAgY29uc3QgaW5wdXRTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKGV4YW1wbGVzWzBdLnNoYXBlKTtcbiAgICBjb25zdCBuZXdFeGFtcGxlczogTkRBcnJheVtdID0gW107XG5cbiAgICBleGFtcGxlcy5mb3JFYWNoKGV4YW1wbGUgPT4ge1xuICAgICAgY29uc3QgaW5wdXRWYWx1ZXMgPSBleGFtcGxlLmdldFZhbHVlcygpO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoaW5wdXRTaXplKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5wdXRTaXplOyBqKyspIHtcbiAgICAgICAgY29uc3QgY3VyTG93ZXJCb3VuZCA9IGN1ckJvdW5kc0lzUGVyRGltZW5zaW9uID9cbiAgICAgICAgICAgIChjdXJMb3dlckJvdW5kcyBhcyBGbG9hdDMyQXJyYXkpW2pdIDpcbiAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzIGFzIG51bWJlcjtcbiAgICAgICAgY29uc3QgY3VyVXBwZXJCb3VuZCA9IGN1ckJvdW5kc0lzUGVyRGltZW5zaW9uID9cbiAgICAgICAgICAgIChjdXJVcHBlckJvdW5kcyBhcyBGbG9hdDMyQXJyYXkpW2pdIDpcbiAgICAgICAgICAgIGN1clVwcGVyQm91bmRzIGFzIG51bWJlcjtcbiAgICAgICAgY29uc3QgY3VyUmFuZ2UgPSBjdXJVcHBlckJvdW5kIC0gY3VyTG93ZXJCb3VuZDtcblxuICAgICAgICBjb25zdCBuZXdMb3dlckJvdW5kID0gbmV3Qm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgKG5ld0xvd2VyQm91bmRzIGFzIEZsb2F0MzJBcnJheSlbal0gOlxuICAgICAgICAgICAgbmV3TG93ZXJCb3VuZHMgYXMgbnVtYmVyO1xuICAgICAgICBjb25zdCBuZXdVcHBlckJvdW5kID0gbmV3Qm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgKG5ld1VwcGVyQm91bmRzIGFzIEZsb2F0MzJBcnJheSlbal0gOlxuICAgICAgICAgICAgbmV3VXBwZXJCb3VuZHMgYXMgbnVtYmVyO1xuICAgICAgICBjb25zdCBuZXdSYW5nZSA9IG5ld1VwcGVyQm91bmQgLSBuZXdMb3dlckJvdW5kO1xuXG4gICAgICAgIGlmIChjdXJSYW5nZSA9PT0gMCkge1xuICAgICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbal0gPSBuZXdMb3dlckJvdW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbal0gPSBuZXdMb3dlckJvdW5kICtcbiAgICAgICAgICAgICAgbmV3UmFuZ2UgKiAoaW5wdXRWYWx1ZXNbal0gLSBjdXJMb3dlckJvdW5kKSAvIGN1clJhbmdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXdFeGFtcGxlcy5wdXNoKE5EQXJyYXkubWFrZShleGFtcGxlLnNoYXBlLCB7dmFsdWVzOiBub3JtYWxpemVkVmFsdWVzfSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXdFeGFtcGxlcztcbiAgfVxuXG4gIHByaXZhdGUgY29tcHV0ZUJvdW5kcyhkYXRhSW5kZXg6IG51bWJlcikge1xuICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGlzIG51bGwuJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLmRhdGFzZXRbZGF0YUluZGV4XVswXS5zaGFwZSk7XG5cbiAgICAvLyBDb21wdXRlIG1pbiBhbmQgbWF4IHZhbHVlcyBmb3IgZXZlcnkgZGltZW5zaW9uLlxuICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XSA9IHtcbiAgICAgIGlzTm9ybWFsaXplZDogZmFsc2UsXG4gICAgICBtaW5WYWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSksXG4gICAgICBtYXhWYWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSlcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5taW5WYWx1ZXNbaV0gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzW2ldID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdLmZvckVhY2goZXhhbXBsZSA9PiB7XG4gICAgICBjb25zdCBpbnB1dFZhbHVlcyA9IGV4YW1wbGUuZ2V0VmFsdWVzKCk7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IHNpemU7IGsrKykge1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzW2tdID0gTWF0aC5taW4oXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzW2tdLCBpbnB1dFZhbHVlc1trXSk7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5tYXhWYWx1ZXNba10gPSBNYXRoLm1heChcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5tYXhWYWx1ZXNba10sIGlucHV0VmFsdWVzW2tdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG5vcm1hbGl6ZVdpdGhpbkJvdW5kcyhcbiAgICAgIGRhdGFJbmRleDogbnVtYmVyLCBsb3dlckJvdW5kOiBudW1iZXIsIHVwcGVyQm91bmQ6IG51bWJlcikge1xuICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGlzIG51bGwuJyk7XG4gICAgfVxuICAgIGlmIChkYXRhSW5kZXggPj0gdGhpcy5kYXRhc2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhSW5kZXggb3V0IG9mIGJvdW5kcy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdID09IG51bGwpIHtcbiAgICAgIHRoaXMuY29tcHV0ZUJvdW5kcyhkYXRhSW5kZXgpO1xuICAgIH1cblxuICAgIC8vIGN1ckxvd2VyL1VwcGVyQm91bmRzIG9mIHRoZSBjdXJyZW50IGRhdGEgc2V0IGNhbiBlaXRoZXIgYmUgZml4ZWQgbnVtYmVyc1xuICAgIC8vIGlmIHRoZSBkYXRhIGhhcyBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZCwgb3IgY3VyTG93ZXIvVXBwZXIgZm9yIGVhY2hcbiAgICAvLyBkaW1lbnNpb24gaWYgaXQgaGFzbid0IGJlZW4gbm9ybWFsaXplZCB5ZXQuXG4gICAgbGV0IGN1ckxvd2VyQm91bmRzOiBGbG9hdDMyQXJyYXl8bnVtYmVyO1xuICAgIGxldCBjdXJVcHBlckJvdW5kczogRmxvYXQzMkFycmF5fG51bWJlcjtcblxuICAgIGlmICh0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0uaXNOb3JtYWxpemVkKSB7XG4gICAgICBjdXJMb3dlckJvdW5kcyA9IHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5sb3dlckJvdW5kITtcbiAgICAgIGN1clVwcGVyQm91bmRzID0gdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLnVwcGVyQm91bmQhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJMb3dlckJvdW5kcyA9IHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5taW5WYWx1ZXM7XG4gICAgICBjdXJVcHBlckJvdW5kcyA9IHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5tYXhWYWx1ZXM7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhc2V0W2RhdGFJbmRleF0gPSB0aGlzLm5vcm1hbGl6ZUV4YW1wbGVzVG9SYW5nZShcbiAgICAgICAgdGhpcy5kYXRhc2V0W2RhdGFJbmRleF0sIGN1ckxvd2VyQm91bmRzLCBjdXJVcHBlckJvdW5kcywgbG93ZXJCb3VuZCxcbiAgICAgICAgdXBwZXJCb3VuZCk7XG4gICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmlzTm9ybWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmxvd2VyQm91bmQgPSBsb3dlckJvdW5kO1xuICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS51cHBlckJvdW5kID0gdXBwZXJCb3VuZDtcbiAgfVxuXG4gIHByaXZhdGUgaXNOb3JtYWxpemVkKGRhdGFJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsaXphdGlvbkluZm8gIT0gbnVsbCAmJlxuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0uaXNOb3JtYWxpemVkO1xuICB9XG5cbiAgcmVtb3ZlTm9ybWFsaXphdGlvbihkYXRhSW5kZXg6IG51bWJlcikge1xuICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFpbmluZyBvciB0ZXN0IGRhdGEgaXMgbnVsbC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNOb3JtYWxpemVkKGRhdGFJbmRleCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFzZXRbZGF0YUluZGV4XSA9IHRoaXMubm9ybWFsaXplRXhhbXBsZXNUb1JhbmdlKFxuICAgICAgICB0aGlzLmRhdGFzZXRbZGF0YUluZGV4XSwgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmxvd2VyQm91bmQhLFxuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0udXBwZXJCb3VuZCEsXG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5taW5WYWx1ZXMsXG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5tYXhWYWx1ZXMpO1xuICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5pc05vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHVubm9ybWFsaXplRXhhbXBsZXMoZXhhbXBsZXM6IE5EQXJyYXlbXSwgZGF0YUluZGV4OiBudW1iZXIpOiBOREFycmF5W10ge1xuICAgIGlmICghdGhpcy5pc05vcm1hbGl6ZWQoZGF0YUluZGV4KSkge1xuICAgICAgcmV0dXJuIGV4YW1wbGVzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZUV4YW1wbGVzVG9SYW5nZShcbiAgICAgICAgZXhhbXBsZXMsIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5sb3dlckJvdW5kISxcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLnVwcGVyQm91bmQhLFxuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzLFxuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuZGF0YXNldCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGFzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5kYXRhc2V0W2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRoaXMuZGF0YXNldFtpXVtqXS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGF0YXNldCA9IFtdO1xuICB9XG59XG5cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtHcmFwaExheWVyc30gZnJvbSAnLi9ncmFwaF9sYXllcnMnO1xuaW1wb3J0ICogYXMgY29uY2F0M2RfdXRpbCBmcm9tICcuL21hdGgvY29uY2F0M2RfdXRpbCc7XG5pbXBvcnQgKiBhcyBjb252X3V0aWwgZnJvbSAnLi9tYXRoL2NvbnZfdXRpbCc7XG5pbXBvcnQge05EQXJyYXksIFNjYWxhcn0gZnJvbSAnLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEdyYXBoIGlzIHRoZSBwcmltYXJ5IGNvbnRhaW5lciBzdHJ1Y3R1cmUgZm9yIGRlZXBsZWFybi5qcyBvcGVyYXRpb25zLiBHcmFwaFxuICogaG9sZHMgdGhlIHRvcG9sb2d5IG9mIG9wZXJhdGlvbiBub2RlcyBhbmQgdGhlIGNvbm5lY3Rpdml0eSBiZXR3ZWVuIHRoZW0uXG4gKi9cbmV4cG9ydCBjbGFzcyBHcmFwaCB7XG4gIGxheWVyczogR3JhcGhMYXllcnM7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5sYXllcnMgPSBuZXcgR3JhcGhMYXllcnModGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5hbWVkIHZhcmlhYmxlLiBWYXJpYWJsZXMgYXJlIHRlbnNvcnMgdGhhdCBtYWludGFpbiBzdGF0ZSBhY3Jvc3NcbiAgICogc2Vzc2lvbiBjYWxscyBhbmQgd2hvc2UgdmFsdWVzIGFyZSBhZGp1c3RlZCBkdXJpbmcgYmFja3Byb3BhZ2F0aW9uXG4gICAqIHRyYWluaW5nLlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGlzIHZhcmlhYmxlLlxuICAgKiBAcGFyYW0gZGF0YSBUaGUgTkRBcnJheSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIHZhcmlhYmxlIHRlbnNvci5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyB0aGUgdmFyaWFibGUuXG4gICAqL1xuICB2YXJpYWJsZShuYW1lOiBzdHJpbmcsIGRhdGE6IE5EQXJyYXkpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFZhcmlhYmxlTm9kZSh0aGlzLCBuYW1lLCBkYXRhKSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBhIHBsYWNlaG9sZGVyIGZvciBhIHRlbnNvciB0aGF0IHdpbGwgYmUgYWx3YXlzIGZlZC4gUGxhY2Vob2xkZXJzXG4gICAqIGFyZSBpbnB1dCB0ZW5zb3JzIHdob3NlIHZhbHVlcyBhcmUgcHJvdmlkZWQgYnkgdGhlIGNsaWVudCB2aWEgZmVlZFxuICAgKiBkaWN0aW9uYXJpZXMuIFBsYWNlaG9sZGVycyBhcmUgbm90IHVwZGF0ZWQgYXMgcGFydCBvZiB0cmFpbmluZzsgdGhleSBhcmVcbiAgICogb25seSB1c2VkIGFzIGltbXV0YWJsZSBpbnB1dC5cbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhpcyBwbGFjZWhvbGRlci5cbiAgICogQHBhcmFtIHNoYXBlIFRoZSBzaGFwZSBvZiB0aGUgcGxhY2Vob2xkZXIgdGVuc29yLlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIHRoZSBwbGFjZWhvbGRlci5cbiAgICovXG4gIHBsYWNlaG9sZGVyKG5hbWU6IHN0cmluZywgc2hhcGU6IG51bWJlcltdKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBQbGFjZWhvbGRlck5vZGUodGhpcywgbmFtZSwgc2hhcGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdGFudCB2YWx1ZSB0aGF0IHBlcnNpc3RzIGFjcm9zcyBzZXNzaW9uIGNhbGxzLlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybi5cbiAgICogQHJldHVybiBBIG5vZGUgb3V0cHV0aW5nIHRoZSBjb25zdGFudCB2YWx1ZS5cbiAgICovXG4gIGNvbnN0YW50KHZhbHVlOiBBcnJheURhdGEpOiBUZW5zb3Ige1xuICAgIGxldCBmaW5hbFZhbHVlOiBOREFycmF5O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBmaW5hbFZhbHVlID0gU2NhbGFyLm5ldyh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcbiAgICAgIGZpbmFsVmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGNvbnN0IHZhbHMgPSBuZXcgRmxvYXQzMkFycmF5KHV0aWwuZmxhdHRlbih2YWx1ZSkpO1xuICAgICAgZmluYWxWYWx1ZSA9IE5EQXJyYXkubWFrZSh1dGlsLmluZmVyU2hhcGUodmFsdWUpLCB7dmFsdWVzOiB2YWxzfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCBjb25zdGFudCB0eXBlLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBDb25zdGFudE5vZGUodGhpcywgZmluYWxWYWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2hhcGUgdGhlIGlucHV0IHRlbnNvci5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IHRlbnNvciB0byBiZSByZXNoYXBlZC5cbiAgICogQHBhcmFtIHNoYXBlIFRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IHRlbnNvci5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyB0aGUgcmVzaGFwZSBvcGVyYXRpb24uXG4gICAqL1xuICByZXNoYXBlKHg6IFRlbnNvciwgc2hhcGU6IG51bWJlcltdKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KFxuICAgICAgICBuZXcgUmVzaGFwZU5vZGUodGhpcywgJ1Jlc2hhcGUnLCB4LCBzaGFwZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGEgZnVzZWQgbGluZWFyIGNvbWJpbmF0aW9uIG9mIHR3byB0ZW5zb3JzLlxuICAgKiBAcGFyYW0geDEgVGhlIGZpcnN0IGlucHV0IHRlbnNvci5cbiAgICogQHBhcmFtIHgyIFRoZSBzZWNvbmQgaW5wdXQgdGVuc29yLiBTYW1lIHNoYXBlIGFzIHQxLlxuICAgKiBAcGFyYW0gYzEgQ29lZmZpY2llbnQgb2YgdDEuIE11c3QgYmUgc2l6ZSAxLlxuICAgKiBAcGFyYW0gYzIgQ29lZmZpY2llbnQgb2YgdDIuIE11c3QgYmUgc2l6ZSAxLlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIGMxKnQxK2MyKnQyLlxuICAgKi9cbiAgZnVzZWRMaW5lYXJDb21iaW5hdGlvbih4MTogVGVuc29yLCB4MjogVGVuc29yLCBjMTogVGVuc29yLCBjMjogVGVuc29yKTpcbiAgICAgIFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChcbiAgICAgICAgbmV3IEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlKHRoaXMsIHgxLCB4MiwgYzEsIGMyKSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBZGRzIHR3byB0ZW5zb3JzIChlbGVtZW50d2lzZSkuIEJyb2FkY2FzdHMgaWYgb25lIG9mIHRoZSB0ZW5zb3JzIGlzIHNjYWxhci5cbiAgICogQHBhcmFtIHgxIFRoZSBmaXJzdCBpbnB1dCB0ZW5zb3IuXG4gICAqIEBwYXJhbSB4MiBUaGUgc2Vjb25kIGlucHV0IHRlbnNvci5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyB0MSt0Mi5cbiAgICovXG4gIGFkZCh4MTogVGVuc29yLCB4MjogVGVuc29yKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBBZGROb2RlKHRoaXMsIHgxLCB4MikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnRyYWN0cyB0d28gdGVuc29ycyAoZWxlbWVudHdpc2UpLiBCcm9hZGNhc3RzIGlmIG9uZSBvZiB0aGUgdGVuc29ycyBpc1xuICAgKiBzY2FsYXIuXG4gICAqIEBwYXJhbSB4MSBUaGUgZmlyc3QgaW5wdXQgdGVuc29yLlxuICAgKiBAcGFyYW0geDIgVGhlIHNlY29uZCBpbnB1dCB0ZW5zb3IuXG4gICAqIEByZXR1cm4gVGhlIHRlbnNvciByZXByZXNlbnRpbmcgdDEtdDIuXG4gICAqL1xuICBzdWJ0cmFjdCh4MTogVGVuc29yLCB4MjogVGVuc29yKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBTdWJ0cmFjdE5vZGUodGhpcywgeDEsIHgyKSk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgdHdvIHRlbnNvcnMgKGVsZW1lbnR3aXNlKS4gQnJvYWRjYXN0cyBpZiBvbmUgb2YgdGhlIHRlbnNvcnMgaXNcbiAgICogc2NhbGFyLlxuICAgKiBAcGFyYW0geDEgVGhlIGZpcnN0IGlucHV0IHRlbnNvci5cbiAgICogQHBhcmFtIHgyIFRoZSBzZWNvbmQgaW5wdXQgdGVuc29yLlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIHQxKnQyLlxuICAgKi9cbiAgbXVsdGlwbHkoeDE6IFRlbnNvciwgeDI6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgTXVsdGlwbHlOb2RlKHRoaXMsIHgxLCB4MikpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpdmlkZSB0d28gdGVuc29ycyAoZWxlbWVudHdpc2UpLiBCcm9hZGNhc3RzIGlmIG9uZSBvZiB0aGUgdGVuc29ycyBpc1xuICAgKiBzY2FsYXIuXG4gICAqIEBwYXJhbSB4MSBUaGUgZmlyc3QgaW5wdXQgdGVuc29yLlxuICAgKiBAcGFyYW0geDIgVGhlIHNlY29uZCBpbnB1dCB0ZW5zb3IuXG4gICAqIEByZXR1cm4gVGhlIHRlbnNvciByZXByZXNlbnRpbmcgdDEgLyB0Mi5cbiAgICovXG4gIGRpdmlkZSh4MTogVGVuc29yLCB4MjogVGVuc29yKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBEaXZpZGVOb2RlKHRoaXMsIHgxLCB4MikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdW0gb2YgZWxlbWVudHMgaW4gdGhlIHRlbnNvci5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IHRlbnNvci5cbiAgICovXG4gIHJlZHVjZVN1bSh4OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFJlZHVjZVN1bU5vZGUodGhpcywgeCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmNhdHMgdHdvIDNEIHRlbnNvcnMgYWxvbmcgYSBnaXZlbiBheGlzLlxuICAgKiBAcGFyYW0geDEgVGhlIGZpcnN0IGlucHV0IHRlbnNvci5cbiAgICogQHBhcmFtIHgyIFRoZSBzZWNvbmQgaW5wdXQgdGVuc29yLlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIGNvbmNhdCBvZiB0d28gdGVuc29ycyBhbG9uZyBheGlzLlxuICAgKi9cbiAgY29uY2F0M2QoeDE6IFRlbnNvciwgeDI6IFRlbnNvciwgYXhpczogbnVtYmVyKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBDb25jYXQzRE5vZGUodGhpcywgeDEsIHgyLCBheGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdHdvIG1hdHJpY2VzLlxuICAgKiBAcGFyYW0geDEgVGhlIGZpcnN0IGlucHV0IHRlbnNvci5cbiAgICogQHBhcmFtIHgyIFRoZSBzZWNvbmQgaW5wdXQgdGVuc29yLlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIHRoZSBkb3QgcHJvZHVjdCBvZiB4MSBhbmQgeDIuXG4gICAqL1xuICBtYXRtdWwoeDE6IFRlbnNvciwgeDI6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgTWF0TXVsTm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBhIDJEIGNvbnZvbHV0aW9uLlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgdGVuc29yIHRvIHRoZSBjb252b2x1dGlvbiBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSB3IFRoZSB3ZWlnaHQgdGVuc29yIHVzZWQgYnkgdGhlIGNvbnZvbHV0aW9uIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIGIgVGhlIGJpYXMgdGVuc29yIHVzZWQgYnkgdGhlIGNvbnZvbHV0aW9uIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIGZpZWxkU2l6ZSBUaGUgc2l6ZSBvZiB0aGUgY29udm9sdXRpb25hbCBrZXJuZWwuXG4gICAqIEBwYXJhbSBvdXRwdXREZXB0aCBUaGUgb3V0cHV0IGRlcHRoIG9mIHRoZSBjb252b2x1dGlvbiBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBzdHJpZGUgVGhlIHN0cmlkZSBvZiB0aGUgY29udm9sdXRpb24gb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gemVyb1BhZCBUaGUgYW1vdW50IG9mIHplcm8gcGFkZGluZyBvbiBhbGwgc2lkZXMgb2YgdGhlIGlucHV0IHRlbnNvci5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyB0aGUgY29udm9sdXRpb24gb3BlcmF0aW9uLlxuICAgKi9cbiAgY29udjJkKFxuICAgICAgeDogVGVuc29yLCB3OiBUZW5zb3IsIGI6IFRlbnNvciwgZmllbGRTaXplOiBudW1iZXIsIG91dHB1dERlcHRoOiBudW1iZXIsXG4gICAgICBzdHJpZGUgPSAxLCB6ZXJvUGFkPzogbnVtYmVyKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBDb252b2x1dGlvbjJETm9kZShcbiAgICAgICAgdGhpcywgeCwgdywgYiwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgYSAyRCBtYXggcG9vbCBvZiB4LlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgdGVuc29yIHRvIHRoZSBtYXggcG9vbCBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBmaWVsZFNpemUgVGhlIHNpemUgb2YgdGhlIGNvbnZvbHV0aW9uYWwga2VybmVsLlxuICAgKiBAcGFyYW0gc3RyaWRlIFRoZSBzdHJpZGUgb2YgdGhlIGNvbnZvbHV0aW9uIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIHplcm9QYWQgVGhlIGFtb3VudCBvZiB6ZXJvIHBhZGRpbmcgb24gYWxsIHNpZGVzIG9mIHRoZSBpbnB1dCB0ZW5zb3IuXG4gICAqIEByZXR1cm4gVGhlIHRlbnNvciByZXByZXNlbnRpbmcgdGhlIG1heCBwb29sIG9wZXJhdGlvbi5cbiAgICovXG4gIG1heFBvb2woeDogVGVuc29yLCBmaWVsZFNpemU6IG51bWJlciwgc3RyaWRlID0gMSwgemVyb1BhZD86IG51bWJlcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChcbiAgICAgICAgbmV3IE1heFBvb2xOb2RlKHRoaXMsIHgsIGZpZWxkU2l6ZSwgc3RyaWRlLCB6ZXJvUGFkKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgZXhwb25lbnRpYWwgb2YgeCBlbGVtZW50LXdpc2UuXG4gICAqIEBwYXJhbSB4IFRoZSBpbnB1dCB0ZW5zb3IgdG8gdGhlIGV4cC5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyB0aGUgZSBeIHggb3BlcmF0aW9uLlxuICAgKi9cbiAgZXhwKHg6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgRXhwTm9kZSh0aGlzLCB4KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgbG9nIG9mIHggZWxlbWVudC13aXNlLlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgdGVuc29yIHRvIHRoZSBsb2cuXG4gICAqIEByZXR1cm4gVGhlIHRlbnNvciByZXByZXNlbnRpbmcgdGhlIGxuKHgpIG9wZXJhdGlvbi5cbiAgICovXG4gIGxvZyh4OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IExvZ05vZGUodGhpcywgeCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIFJlTFUgb2YgeCBlbGVtZW50LXdpc2UuXG4gICAqIEBwYXJhbSB4IFRoZSBpbnB1dCB0ZW5zb3IgdG8gdGhlIFJlTFUuXG4gICAqIEByZXR1cm4gVGhlIHRlbnNvciByZXByZXNlbnRpbmcgdGhlIFJlTFUgb3BlcmF0aW9uLlxuICAgKi9cbiAgcmVsdSh4OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFJlTFVOb2RlKHRoaXMsIHgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBUYW5IIG9mIHggZWxlbWVudC13aXNlLlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgdGVuc29yIHRvIHRoZSBUYW5ILlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIHRoZSBUYW5IIG9wZXJhdGlvbi5cbiAgICovXG4gIHRhbmgoeDogVGVuc29yKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBUYW5ITm9kZSh0aGlzLCB4KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgU2lnbW9pZCBvZiB4IGVsZW1lbnQtd2lzZS5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IHRlbnNvciB0byB0aGUgc2lnbW9pZC5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyB0aGUgc2lnbW9pZCBvcGVyYXRpb24uXG4gICAqL1xuICBzaWdtb2lkKHg6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU2lnbW9pZE5vZGUodGhpcywgeCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHNxdWFyZSBvZiB4IGVsZW1lbnQtd2lzZS5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IHRlbnNvciB0byB0aGUgc3F1YXJlLlxuICAgKi9cbiAgc3F1YXJlKHg6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU3F1YXJlTm9kZSh0aGlzLCB4KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgc29mdG1heCBwcm9iYWJpbGl0aWVzIGZyb20gbG9naXRzLlxuICAgKlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgbG9naXRzLlxuICAgKiBAcmV0dXJuIFRoZSBzb2Z0bWF4IHByb2JhYmlsaXRpZXMuXG4gICAqL1xuICBzb2Z0bWF4KHg6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU29mdG1heE5vZGUodGhpcywgeCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzb2Z0bWF4IGNyb3NzLWVudHJvcHkgY29zdCBvcGVyYXRpb24gaW4gdGhlIGdyYXBoLlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgdGVuc29yIHRvIGNsYXNzaWZ5LlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIHRoZSBzb2Z0bWF4IGNyb3NzLWVudHJvcHkgY29zdCBvcGVyYXRpb24uXG4gICAqL1xuICBzb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCh4OiBUZW5zb3IsIHRhcmdldDogVGVuc29yKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KFxuICAgICAgICBuZXcgU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlKHRoaXMsIHgsIHRhcmdldCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtZWFuLXNxdWFyZWQgY29zdCBvcGVyYXRpb24gaW4gdGhlIGdyYXBoLlxuICAgKiBAcGFyYW0gbGFiZWwgVGhlIGxhYmVsIHRlbnNvci5cbiAgICogQHBhcmFtIHByZWRpY3Rpb24gVGhlIHByZWRpY3Rpb24gdGVuc29yLlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIHRoZSBtZWFuLXNxdWFyZWQgY29zdCBvcGVyYXRpb24uXG4gICAqL1xuICBtZWFuU3F1YXJlZENvc3QobGFiZWw6IFRlbnNvciwgcHJlZGljdGlvbjogVGVuc29yKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChcbiAgICAgICAgbmV3IE1lYW5TcXVhcmVkQ29zdE5vZGUodGhpcywgbGFiZWwsIHByZWRpY3Rpb24pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmbGF0dGVuZWQgaW5kZXggb2YgdGhlIG1heGltdW0gZW50cnkgaW4gdGhlIHRlbnNvci5cbiAgICogQHBhcmFtIHggVGhlIHRlbnNvciB3aXRoIHRoZSB2YWx1ZS5cbiAgICogQHJldHVybiBBIFNjYWxhciB0ZW5zb3Igd2l0aCB0aGUgaW5kZXggb2YgdGhlIG1heGltdW0gZW50cnkuXG4gICAqL1xuICBhcmdtYXgoeDogVGVuc29yKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBBcmdNYXhOb2RlKHRoaXMsIHgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFyZ21heCBlcXVhbHMgb3BlcmF0aW9uIGluIHRoZSBncmFwaC5cbiAgICogQHBhcmFtIHgxIEZpcnN0IGlucHV0IHRlbnNvciB0byBjaGVjayBhZ2FpbnN0LlxuICAgKiBAcGFyYW0geDIgU2Vjb25kIGlucHV0IHRlbnNvciB0byBjaGVjayBhZ2FpbnN0LlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIHRoZSBhcmdtYXggZXF1YWxzIG9wZXJhdGlvbi5cbiAgICovXG4gIGFyZ21heEVxdWFscyh4MTogVGVuc29yLCB4MjogVGVuc29yKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBBcmdNYXhFcXVhbHNOb2RlKHRoaXMsIHgxLCB4MikpO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5vZGU6IE5vZGUpOiBUZW5zb3Ige1xuICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcbiAgICBub2RlLnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIG5vZGUub3V0cHV0O1xuICB9XG5cbiAgZ2V0Tm9kZXMoKTogTm9kZVtdIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgfVxuXG4gIHByaXZhdGUgbm9kZXM6IE5vZGVbXSA9IFtdO1xufVxuXG4vKipcbiAqIFRlbnNvciByZXByZXNlbnRzIHRoZSBvdXRwdXQgb2YgYW4gb3BlcmF0aW9uIG5vZGUgaW4gdGhlIGdyYXBoLlxuICogVGVuc29ycyBoYXZlIG5vIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZW0sIGJ1dCBtYWludGFpbiBhIHNoYXBlIGFycmF5XG4gKiB0byBkZXRlcm1pbmUgb3BlcmF0aW9uIGNvbXBhdGliaWxpdHkuIEFsbCBncmFwaCBtZXRob2RzIHRoYXQgY3JlYXRlIGdyYXBoXG4gKiBvcGVyYXRpb25zIHJldHVybiBUZW5zb3Igb2JqZWN0cywgd2hpY2ggY2FuIGJlIHRob3VnaHQgb2YgYXMgJ2hhbmRsZXMnIHRvXG4gKiBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgVGVuc29yIHtcbiAgbm9kZTogTm9kZTtcbiAgaWQ6IG51bWJlcjtcbiAgLyoqXG4gICAqIEBwYXJhbSBzaGFwZSBUaGUgc2hhcGUgb2YgdGhpcyB0ZW5zb3IsIGluIGRpbWVuc2lvbiBzaXplcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzaGFwZTogbnVtYmVyW10pIHtcbiAgICB0aGlzLmlkID0gVGVuc29yLm5leHRJRCsrO1xuICB9XG4gIHByaXZhdGUgc3RhdGljIG5leHRJRCA9IDA7XG59XG5cbi8qKlxuICogTm9kZSBpcyB0aGUgY29uY3JldGUgYmFzZSBjbGFzcyBmb3IgYWxsIG9wZXJhdGlvbnMgaW4gdGhlIGdyYXBoLlxuICogVXNlcnMgZ2VuZXJhbGx5IGRvbid0IG5lZWQgdG8gaW50ZXJhY3QgZGlyZWN0bHkgd2l0aCBOb2RlIGluc3RhbmNlcywgYnV0IHRoZXlcbiAqIGFyZSBwcm92aWRlZCBmb3IgaW5mb3JtYXRpb25hbCBhbmQgaW50cm9zcGVjdGlvbiBwdXJwb3Nlcy5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBOb2RlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBncmFwaCBUaGUgZ3JhcGggY29udGFpbmluZyB0aGlzIG5vZGVcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhpcyBub2RlXG4gICAqIEBwYXJhbSBpbnB1dHMgQSBkaWN0aW9uYXJ5IG9mIG5hbWVkIFRlbnNvcnMgdGhhdCBjb21wcmlzZSB0aGlzIG5vZGUnc1xuICAgKiBpbnB1dHMuXG4gICAqIEBwYXJhbSBvdXRwdXQgVGhpcyBub2RlJ3Mgb3V0cHV0IFRlbnNvclxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgZ3JhcGg6IEdyYXBoLCBwdWJsaWMgbmFtZTogc3RyaW5nLFxuICAgICAgcHVibGljIGlucHV0czoge1tuYW1lOiBzdHJpbmddOiBUZW5zb3J9LCBwdWJsaWMgb3V0cHV0OiBUZW5zb3IpIHtcbiAgICB0aGlzLmlkID0gTm9kZS5uZXh0SUQrKztcbiAgICBvdXRwdXQubm9kZSA9IHRoaXM7XG4gIH1cbiAgYWJzdHJhY3QgdmFsaWRhdGUoKTogdm9pZDtcbiAgaWQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBzdGF0aWMgbmV4dElEID0gMDtcbn1cblxuLyoqXG4gKiBWYXJpYWJsZU5vZGUgcmVwcmVzZW50cyBhIHZhcmlhYmxlLCBhIHVzZXItcHJvdmlkZWQgTkRBcnJheSB0aGF0J3NcbiAqIGFkanVzdGVkIGR1cmluZyBiYWNrcHJvcGFnYXRpb24gdHJhaW5pbmcuXG4gKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgVmFyaWFibGVOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgbmFtZTogc3RyaW5nLCBwdWJsaWMgZGF0YTogTkRBcnJheSkge1xuICAgIHN1cGVyKGdyYXBoLCBuYW1lLCB7fSwgbmV3IFRlbnNvcihkYXRhLnNoYXBlKSk7XG4gIH1cbiAgdmFsaWRhdGUoKSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHRoaXMuZGF0YSAhPSBudWxsLFxuICAgICAgICAnRXJyb3IgYWRkaW5nIHZhcmlhYmxlIG9wOiBEYXRhIGZvciB2YXJpYWJsZSBcXCcnICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICdcXCcgaXMgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFBsYWNlaG9sZGVyTm9kZSByZXByZXNlbnRzIGEgcGxhY2Vob2xkZXIsIGEgdXNlci1wcm92aWRlZCBOREFycmF5XG4gKiB0aGF0J3MgdXNlZCBhcyBpbW11dGFibGUgaW5wdXQgZHVyaW5nIGluZmVyZW5jZSBhbmQgdHJhaW5pbmcuXG4gKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgUGxhY2Vob2xkZXJOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgbmFtZTogc3RyaW5nLCBzaGFwZTogbnVtYmVyW10pIHtcbiAgICBzdXBlcihncmFwaCwgbmFtZSwge30sIG5ldyBUZW5zb3Ioc2hhcGUpKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHt9XG59XG5cbi8qKlxuICogQ29uc3RhbnROb2RlIHJlcHJlc2VudHMgYSBjb25zdGFudCB2YWx1ZSBpbiB0aGUgZ3JhcGguXG4gKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQ29uc3RhbnROb2RlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgcHVibGljIGRhdGE6IE5EQXJyYXkpIHtcbiAgICBzdXBlcihncmFwaCwgJ0NvbnN0YW50Jywge30sIG5ldyBUZW5zb3IoZGF0YS5zaGFwZSkpO1xuICB9XG4gIHZhbGlkYXRlKCkge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB0aGlzLmRhdGEgIT0gbnVsbCxcbiAgICAgICAgJ0Vycm9yIGFkZGluZyBjb25zdGFudDogZGF0YSBmb3IgcGxhY2Vob2xkZXIgXFwnJyArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAnXFwnIGlzIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNoYXBlTm9kZSByZXByZXNlbnRzIGEgcmVzaGFwZSBvcGVyYXRpb24gaW4gdGhlIGdyYXBoLlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlc2hhcGVOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBYID0gJ3gnO1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIGdyYXBoOiBHcmFwaCwgcHVibGljIG5hbWU6IHN0cmluZywgcHJpdmF0ZSB4OiBUZW5zb3IsXG4gICAgICBwcml2YXRlIHNoYXBlOiBudW1iZXJbXSkge1xuICAgIHN1cGVyKGdyYXBoLCBuYW1lLCB7eH0sIG5ldyBUZW5zb3Ioc2hhcGUpKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHtcbiAgICBjb25zdCB4U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnguc2hhcGUpO1xuICAgIGNvbnN0IHNoYXBlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnNoYXBlKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgeFNpemUgPT09IHNoYXBlU2l6ZSxcbiAgICAgICAgJ0Vycm9yIG1ha2luZyByZXNoYXBlIG9wZXJhdGlvbjogaW5wdXQgVGVuc29yIHRvIHJlc2hhcGUgXFwnJyArXG4gICAgICAgICAgICB0aGlzLm5hbWUgKyAnXFwnIG9mIHNoYXBlICgnICsgdGhpcy54LnNoYXBlICtcbiAgICAgICAgICAgICcpIGRvZXMgbm90IG1hdGNoIHNpemUgb2YgcmVxdWVzdGVkIHNoYXBlICcgKyB0aGlzLnNoYXBlICsgJy4nKTtcbiAgfVxufVxuXG4vKipcbiAqIExpbmVhckNvbWJpbmF0aW9uTm9kZSByZXByZXNlbnRzIGEgbGluZWFyIGNvbWJpbmF0aW9uIG9mIHR3byB0ZW5zb3JzLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFQxID0gJ3QxJztcbiAgc3RhdGljIHJlYWRvbmx5IFQyID0gJ3QyJztcbiAgc3RhdGljIHJlYWRvbmx5IEMxID0gJ2MxJztcbiAgc3RhdGljIHJlYWRvbmx5IEMyID0gJ2MyJztcbiAgY29uc3RydWN0b3IoXG4gICAgICBncmFwaDogR3JhcGgsIHByaXZhdGUgdDE6IFRlbnNvciwgcHJpdmF0ZSB0MjogVGVuc29yLCBwcml2YXRlIGMxOiBUZW5zb3IsXG4gICAgICBwcml2YXRlIGMyOiBUZW5zb3IpIHtcbiAgICBzdXBlcihncmFwaCwgJ0xpbmVhciBDb21iaW5hdGlvbicsIHt0MSwgdDIsIGMxLCBjMn0sIG5ldyBUZW5zb3IodDEuc2hhcGUpKTtcbiAgfVxuXG4gIHZhbGlkYXRlKCkge1xuICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2godGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSk7XG4gICAgaWYgKCF1dGlsLmlzU2NhbGFyU2hhcGUodGhpcy5jMS5zaGFwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRXJyb3IgYWRkaW5nIGZ1c2VkTGluZWFyQ29tYmluYXRpb246IGMxIGlzIG5vdCBhIHNjYWxhciwgZ290ICcgK1xuICAgICAgICAgICdzaGFwZTogJyArIHRoaXMuYzEuc2hhcGUpO1xuICAgIH1cbiAgICBpZiAoIXV0aWwuaXNTY2FsYXJTaGFwZSh0aGlzLmMyLnNoYXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdFcnJvciBhZGRpbmcgZnVzZWRMaW5lYXJDb21iaW5hdGlvbjogYzIgaXMgbm90IGEgc2NhbGFyLCBnb3QgJyArXG4gICAgICAgICAgJ3NoYXBlOiAnICsgdGhpcy5jMi5zaGFwZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQWRkTm9kZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkgVDEgPSAndDEnO1xuICBzdGF0aWMgcmVhZG9ubHkgVDIgPSAndDInO1xuXG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgcHJpdmF0ZSB0MTogVGVuc29yLCBwcml2YXRlIHQyOiBUZW5zb3IpIHtcbiAgICBzdXBlcihcbiAgICAgICAgZ3JhcGgsICdBZGQnLCB7dDEsIHQyfSxcbiAgICAgICAgbmV3IFRlbnNvcih1dGlsLnNpemVGcm9tU2hhcGUodDEuc2hhcGUpID09PSAxID8gdDIuc2hhcGUgOiB0MS5zaGFwZSkpO1xuICB9XG5cbiAgdmFsaWRhdGUoKSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQxLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDIuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMudDEuc2hhcGUsIHRoaXMudDIuc2hhcGUpLFxuICAgICAgICAnRXJyb3IgYWRkaW5nIGFkZCBvcGVyYXRpb24gb3A6IG9uZSBvZiBpbnB1dHMgbXVzdCBiZSBzY2FsYXIgb3IgdGhlICcgK1xuICAgICAgICAgICAgJ3NoYXBlcyAnICsgdGhpcy50MS5zaGFwZSArICcgYW5kICcgKyB0aGlzLnQyLnNoYXBlICtcbiAgICAgICAgICAgICcgbXVzdCBtYXRjaC4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFN1YnRyYWN0Tm9kZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkgVDEgPSAndDEnO1xuICBzdGF0aWMgcmVhZG9ubHkgVDIgPSAndDInO1xuXG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgcHJpdmF0ZSB0MTogVGVuc29yLCBwcml2YXRlIHQyOiBUZW5zb3IpIHtcbiAgICBzdXBlcihcbiAgICAgICAgZ3JhcGgsICdTdWJ0cmFjdCcsIHt0MSwgdDJ9LFxuICAgICAgICBuZXcgVGVuc29yKHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgPyB0Mi5zaGFwZSA6IHQxLnNoYXBlKSk7XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSksXG4gICAgICAgICdFcnJvciBhZGRpbmcgc3VidHJhY3Qgb3A6IG9uZSBvZiBpbnB1dHMgbXVzdCBiZSBzY2FsYXIgb3IgdGhlICcgK1xuICAgICAgICAgICAgJ3NoYXBlcyAnICsgdGhpcy50MS5zaGFwZSArICcgYW5kICcgKyB0aGlzLnQyLnNoYXBlICtcbiAgICAgICAgICAgICcgbXVzdCBtYXRjaC4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpcGx5Tm9kZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkgVDEgPSAndDEnO1xuICBzdGF0aWMgcmVhZG9ubHkgVDIgPSAndDInO1xuXG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgcHJpdmF0ZSB0MTogVGVuc29yLCBwcml2YXRlIHQyOiBUZW5zb3IpIHtcbiAgICBzdXBlcihcbiAgICAgICAgZ3JhcGgsICdNdWx0aXBseScsIHt0MSwgdDJ9LFxuICAgICAgICBuZXcgVGVuc29yKHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgPyB0Mi5zaGFwZSA6IHQxLnNoYXBlKSk7XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSksXG4gICAgICAgICdFcnJvciBhZGRpbmcgbXVsdGlwbHkgb3A6IG9uZSBvZiBpbnB1dHMgbXVzdCBiZSBzY2FsYXIgb3IgdGhlICcgK1xuICAgICAgICAgICAgJ3NoYXBlcyAnICsgdGhpcy50MS5zaGFwZSArICcgYW5kICcgKyB0aGlzLnQyLnNoYXBlICtcbiAgICAgICAgICAgICcgbXVzdCBtYXRjaC4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIERpdmlkZU5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFQxID0gJ3QxJztcbiAgc3RhdGljIHJlYWRvbmx5IFQyID0gJ3QyJztcblxuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHByaXZhdGUgdDE6IFRlbnNvciwgcHJpdmF0ZSB0MjogVGVuc29yKSB7XG4gICAgc3VwZXIoXG4gICAgICAgIGdyYXBoLCAnRGl2aWRlJywge3QxLCB0Mn0sXG4gICAgICAgIG5ldyBUZW5zb3IodXRpbC5zaXplRnJvbVNoYXBlKHQxLnNoYXBlKSA9PT0gMSA/IHQyLnNoYXBlIDogdDEuc2hhcGUpKTtcbiAgfVxuXG4gIHZhbGlkYXRlKCkge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50MS5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQyLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh0aGlzLnQxLnNoYXBlLCB0aGlzLnQyLnNoYXBlKSxcbiAgICAgICAgJ0Vycm9yIGFkZGluZyBkaXZpZGUgb3A6IG9uZSBvZiBpbnB1dHMgbXVzdCBiZSBzY2FsYXIgb3IgdGhlICcgK1xuICAgICAgICAgICAgJ3NoYXBlcyAnICsgdGhpcy50MS5zaGFwZSArICcgYW5kICcgKyB0aGlzLnQyLnNoYXBlICtcbiAgICAgICAgICAgICcgbXVzdCBtYXRjaC4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlZHVjZVN1bU5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFggPSAneCc7XG5cbiAgY29uc3RydWN0b3IoZ3JhcGg6IEdyYXBoLCB4OiBUZW5zb3IpIHtcbiAgICBzdXBlcihncmFwaCwgJ1JlZHVjZVN1bScsIHt4fSwgbmV3IFRlbnNvcihbXSkpO1xuICB9XG5cbiAgdmFsaWRhdGUoKSB7fVxufVxuXG4vKipcbiAqIENvbmNhdDNETm9kZSByZXByZXNlbnRzIGEgM0QgY29uY2F0ZW5hdGlvbiBvZiB0d28gdGVuc29ycyBhbG9uZyBhbiBheGlzLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQ29uY2F0M0ROb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBYMSA9ICd4MSc7XG4gIHN0YXRpYyByZWFkb25seSBYMiA9ICd4Mic7XG4gIHN0YXRpYyByZWFkb25seSBBWElTID0gJ2F4aXMnO1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIGdyYXBoOiBHcmFwaCwgcHJpdmF0ZSB4MTogVGVuc29yLCBwcml2YXRlIHgyOiBUZW5zb3IsXG4gICAgICBwdWJsaWMgYXhpczogbnVtYmVyKSB7XG4gICAgc3VwZXIoXG4gICAgICAgIGdyYXBoLCAnQ29uY2F0M0QnLCB7eDEsIHgyfSxcbiAgICAgICAgbmV3IFRlbnNvcihjb25jYXQzZF91dGlsLmNvbXB1dGVDb25jYXQzRE91dHB1dFNoYXBlKFxuICAgICAgICAgICAgeDEuc2hhcGUsIHgyLnNoYXBlLCBheGlzKSkpO1xuICB9XG4gIHZhbGlkYXRlKCkge1xuICAgIGNvbmNhdDNkX3V0aWwuYXNzZXJ0Q29uY2F0M0RTaGFwZXNNYXRjaChcbiAgICAgICAgdGhpcy54MS5zaGFwZSwgdGhpcy54Mi5zaGFwZSwgdGhpcy5heGlzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNYXRNdWxPdXRwdXRTaGFwZSh4MVNoYXBlOiBudW1iZXJbXSwgeDJTaGFwZTogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gIGlmICh4MVNoYXBlLmxlbmd0aCA9PT0gMSAmJiB4MlNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBbMV07XG4gIH0gZWxzZSBpZiAoeDFTaGFwZS5sZW5ndGggPT09IDEgJiYgeDJTaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gW3gyU2hhcGVbMV1dO1xuICB9IGVsc2UgaWYgKHgxU2hhcGUubGVuZ3RoID09PSAyICYmIHgyU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIFt4MVNoYXBlWzBdXTtcbiAgfVxuICByZXR1cm4gW3gxU2hhcGVbMF0sIHgyU2hhcGVbMV1dO1xufVxuXG4vKipcbiAqIE1hdE11bE5vZGUgcmVwcmVzZW50cyBhIGZ1bGx5IGNvbm5lY3RlZCBsYXllciBpbiB0aGUgZ3JhcGguXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRNdWxOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBYMSA9ICd4MSc7XG4gIHN0YXRpYyByZWFkb25seSBYMiA9ICd4Mic7XG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgcHJpdmF0ZSB4MTogVGVuc29yLCBwcml2YXRlIHgyOiBUZW5zb3IpIHtcbiAgICBzdXBlcihcbiAgICAgICAgZ3JhcGgsICdNYXRNdWwnLCB7eDEsIHgyfSxcbiAgICAgICAgbmV3IFRlbnNvcihnZXRNYXRNdWxPdXRwdXRTaGFwZSh4MS5zaGFwZSwgeDIuc2hhcGUpKSk7XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy54MS5zaGFwZS5sZW5ndGggPT09IDIgJiYgdGhpcy54Mi5zaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgIHRoaXMueDEuc2hhcGVbMV0gPT09IHRoaXMueDIuc2hhcGVbMF0sXG4gICAgICAgICAgJ0Vycm9yIGFkZGluZyBtYXRtdWwgb3A6IGlubmVyIHNoYXBlcyBvZiBtYXRyaWNlcyB3aXRoIHNoYXBlcyAnICtcbiAgICAgICAgICAgICAgdGhpcy54MS5zaGFwZSArICcgYW5kICcgKyB0aGlzLngyLnNoYXBlICsgJyBtdXN0IG1hdGNoLicpO1xuICAgIH0gZWxzZSBpZiAodGhpcy54MS5zaGFwZS5sZW5ndGggPT09IDIgJiYgdGhpcy54Mi5zaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgIHRoaXMueDEuc2hhcGVbMV0gPT09IHRoaXMueDIuc2hhcGVbMF0sXG4gICAgICAgICAgJ0Vycm9yIGFkZGluZyBtYXRtdWwgb3A6IHNlY29uZCBkaW1lbnNpb24gb2YgbWF0cml4IHdpdGggc2hhcGUgJyArXG4gICAgICAgICAgICAgIHRoaXMueDEuc2hhcGUgKyAnIG11c3QgbWF0Y2ggc2l6ZSBvZiB2ZWN0b3Igd2l0aCBzaGFwZSAnICtcbiAgICAgICAgICAgICAgdGhpcy54Mi5zaGFwZSArICcuJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLngxLnNoYXBlLmxlbmd0aCA9PT0gMSAmJiB0aGlzLngyLnNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgdGhpcy54MS5zaGFwZVswXSA9PT0gdGhpcy54Mi5zaGFwZVswXSxcbiAgICAgICAgICAnRXJyb3IgYWRkaW5nIG1hdG11bCBvcDogc2l6ZSBvZiB2ZWN0b3Igd2l0aCBzaGFwZSAnICsgdGhpcy54MS5zaGFwZSArXG4gICAgICAgICAgICAgICcgbXVzdCBtYXRjaCBmaXJzdCBkaW1lbnNpb24gb2YgbWF0cml4IHdpdGggJyArXG4gICAgICAgICAgICAgICdzaGFwZSAnICsgdGhpcy54Mi5zaGFwZSArICcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRXJyb3IgYWRkaW5nIG1hdG11bCBvcDogaW5wdXRzIG11c3QgYmUgdmVjdG9ycyBvciBtYXRyaWNlcy4nKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb252b2x1dGlvbjJETm9kZSByZXByZXNlbnRzIGEgMmQgY29udm9sdXRpb24gb3BlcmF0aW9uIGluIHRoZSBncmFwaC5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnZvbHV0aW9uMkROb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBYID0gJ3gnO1xuICBzdGF0aWMgcmVhZG9ubHkgVyA9ICd3JztcbiAgc3RhdGljIHJlYWRvbmx5IEIgPSAnYic7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgZ3JhcGg6IEdyYXBoLCBwcml2YXRlIHg6IFRlbnNvciwgcHJpdmF0ZSB3OiBUZW5zb3IsIHByaXZhdGUgYjogVGVuc29yLFxuICAgICAgcHVibGljIGZpZWxkU2l6ZTogbnVtYmVyLCBwdWJsaWMgb3V0cHV0RGVwdGg6IG51bWJlciwgcHVibGljIHN0cmlkZSA9IDEsXG4gICAgICBwdWJsaWMgemVyb1BhZD86IG51bWJlcikge1xuICAgIHN1cGVyKFxuICAgICAgICBncmFwaCwgJ0NvbnZvbHV0aW9uIDJEJywge3gsIHcsIGJ9LFxuICAgICAgICBuZXcgVGVuc29yKGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRChcbiAgICAgICAgICAgIHguc2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBmaWVsZFNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsXG4gICAgICAgICAgICB6ZXJvUGFkKSkpO1xuICB9XG4gIHZhbGlkYXRlKCkge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB0aGlzLnguc2hhcGUubGVuZ3RoID09PSAzLFxuICAgICAgICAnRXJyb3IgYWRkaW5nIGNvbnYyZCBvcDogaW5wdXQgbXVzdCBiZSBvZiByYW5rIDMsIGJ1dCBnb3Qgc2hhcGU6ICcgK1xuICAgICAgICAgICAgdGhpcy54LnNoYXBlICsgJy4nKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdGhpcy53LnNoYXBlLmxlbmd0aCA9PT0gNCxcbiAgICAgICAgJ0Vycm9yIGFkZGluZyBjb252MmQgb3A6IHdlaWdodHMgbXVzdCBiZSBvZiByYW5rIDQsIGJ1dCBnb3Qgc2hhcGU6ICcgK1xuICAgICAgICAgICAgdGhpcy53LnNoYXBlICsgJy4nKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdGhpcy5iLnNoYXBlLmxlbmd0aCA9PT0gMSxcbiAgICAgICAgJ0Vycm9yIGFkZGluZyBjb252MmQgb3A6IGJpYXNlcyBtdXN0IGJlIG9mIHJhbmsgMSwgYnV0IGdvdCBzaGFwZTogJyArXG4gICAgICAgICAgICB0aGlzLmIuc2hhcGUgKyAnLicpO1xuXG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHRoaXMueC5zaGFwZVsyXSA9PT0gdGhpcy53LnNoYXBlWzJdLFxuICAgICAgICAnRXJyb3IgYWRkaW5nIGNvbnYyZCBvcDogZGVwdGggb2YgaW5wdXQgKCcgKyB0aGlzLnguc2hhcGVbMl0gK1xuICAgICAgICAgICAgJykgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3Igd2VpZ2h0cyAoJyArIHRoaXMudy5zaGFwZVsyXSArICcpLicpO1xuICB9XG59XG5cbi8qKlxuICogTWF4UG9vbE5vZGUgcmVwcmVzZW50cyBhIDJkIG1heCBwb29sIG9wZXJhdGlvbiBpbiB0aGUgZ3JhcGguXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXhQb29sTm9kZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkgWCA9ICd4JztcbiAgY29uc3RydWN0b3IoXG4gICAgICBncmFwaDogR3JhcGgsIHByaXZhdGUgeDogVGVuc29yLCBwdWJsaWMgZmllbGRTaXplOiBudW1iZXIsXG4gICAgICBwdWJsaWMgc3RyaWRlID0gMSwgcHVibGljIHplcm9QYWQ/OiBudW1iZXIpIHtcbiAgICBzdXBlcihcbiAgICAgICAgZ3JhcGgsICdNYXggcG9vbCcsIHt4fSxcbiAgICAgICAgbmV3IFRlbnNvcihjb252X3V0aWwuY29tcHV0ZU91dHB1dFNoYXBlM0QoXG4gICAgICAgICAgICB4LnNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZmllbGRTaXplLCB4LnNoYXBlWzJdLCBzdHJpZGUsXG4gICAgICAgICAgICB6ZXJvUGFkKSkpO1xuICB9XG4gIHZhbGlkYXRlKCkge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB0aGlzLnguc2hhcGUubGVuZ3RoID09PSAzLFxuICAgICAgICAnRXJyb3IgYWRkaW5nIG1heFBvb2wgb3A6IGlucHV0IG11c3QgYmUgb2YgcmFuayAzLCBidXQgZ290IHNoYXBlOiAnICtcbiAgICAgICAgICAgIHRoaXMueC5zaGFwZSArICcuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZUxVTm9kZSByZXByZXNlbnRzIGEgUmVMVSBvcGVyYXRpb24gaW4gdGhlIGdyYXBoLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgUmVMVU5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFggPSAneCc7XG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgeDogVGVuc29yKSB7XG4gICAgc3VwZXIoZ3JhcGgsICdSZUxVJywge3h9LCBuZXcgVGVuc29yKHguc2hhcGUpKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHt9XG59XG5cbi8qKlxuICogRXhwTm9kZSByZXByZXNlbnRzIGEgRXhwb25lbnRpYXRpb24gb3BlcmF0aW9uIGluIHRoZSBncmFwaC5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIEV4cE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFggPSAneCc7XG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgeDogVGVuc29yKSB7XG4gICAgc3VwZXIoZ3JhcGgsICdFeHAnLCB7eH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpO1xuICB9XG4gIHZhbGlkYXRlKCkge31cbn1cblxuLyoqXG4gKiBMb2dOb2RlIHJlcHJlc2VudHMgYSBFeHBvbmVudGlhdGlvbiBvcGVyYXRpb24gaW4gdGhlIGdyYXBoLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgTG9nTm9kZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkgWCA9ICd4JztcbiAgY29uc3RydWN0b3IoZ3JhcGg6IEdyYXBoLCB4OiBUZW5zb3IpIHtcbiAgICBzdXBlcihncmFwaCwgJ0xvZycsIHt4fSwgbmV3IFRlbnNvcih4LnNoYXBlKSk7XG4gIH1cbiAgdmFsaWRhdGUoKSB7fVxufVxuXG4vKipcbiAqIFRhbkhOb2RlIHJlcHJlc2VudHMgYSB0YW5oIG9wZXJhdGlvbiBpbiB0aGUgZ3JhcGguXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYW5ITm9kZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkgWCA9ICd4JztcbiAgY29uc3RydWN0b3IoZ3JhcGg6IEdyYXBoLCB4OiBUZW5zb3IpIHtcbiAgICBzdXBlcihncmFwaCwgJ1RhbkgnLCB7eH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpO1xuICB9XG4gIHZhbGlkYXRlKCkge31cbn1cblxuLyoqXG4gKiBTaWdtb2lkTm9kZSByZXByZXNlbnRzIGEgc2lnbW9pZCBvcGVyYXRpb24gaW4gdGhlIGdyYXBoLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgU2lnbW9pZE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFggPSAneCc7XG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgeDogVGVuc29yKSB7XG4gICAgc3VwZXIoZ3JhcGgsICdTaWdtb2lkJywge3h9LCBuZXcgVGVuc29yKHguc2hhcGUpKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHt9XG59XG5cbi8qKlxuICogU3F1YXJlIG5vZGUgcmVwcmVzZW50cyBhbiBlbGVtZW50LXdpc2Ugc3F1YXJlIG9wZXJhdGlvbiBpbiB0aGUgZ3JhcGguXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBTcXVhcmVOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBYID0gJ3gnO1xuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHg6IFRlbnNvcikge1xuICAgIHN1cGVyKGdyYXBoLCAnU3F1YXJlJywge3h9LCBuZXcgVGVuc29yKHguc2hhcGUpKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHt9XG59XG5cbi8qKlxuICogU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlIHJlcHJlc2VudHMgYSBzb2Z0bWF4IGNyb3NzLWVudHJvcHkgY29zdCBvcGVyYXRpb25cbiAqIGluIHRoZSBncmFwaC5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkgWCA9ICd4JztcbiAgc3RhdGljIHJlYWRvbmx5IFRBUkdFVCA9ICd0YXJnZXQnO1xuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHByaXZhdGUgeDogVGVuc29yLCBwcml2YXRlIHRhcmdldDogVGVuc29yKSB7XG4gICAgc3VwZXIoZ3JhcGgsICdTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCcsIHt4LCB0YXJnZXR9LCBuZXcgVGVuc29yKFtdKSk7XG4gIH1cbiAgdmFsaWRhdGUoKSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy54LnNoYXBlLCB0aGlzLnRhcmdldC5zaGFwZSksXG4gICAgICAgICdFcnJvciBhZGRpbmcgc29mdG1heENyb3NzRW50cm9weUNvc3Qgb3A6IHggc2hhcGUgKCcgKyB0aGlzLnguc2hhcGUgK1xuICAgICAgICAgICAgJykgbXVzdCBtYXRjaCB0YXJnZXQgc2hhcGUgKCcgKyB0aGlzLnRhcmdldC5zaGFwZSArICcpLicpO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgU29mdG1heE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFggPSAneCc7XG5cbiAgY29uc3RydWN0b3IoZ3JhcGg6IEdyYXBoLCBwcml2YXRlIHg6IFRlbnNvcikge1xuICAgIHN1cGVyKGdyYXBoLCAnU29mdG1heCcsIHt4fSwgbmV3IFRlbnNvcih4LnNoYXBlKSk7XG4gIH1cbiAgdmFsaWRhdGUoKSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHRoaXMueC5zaGFwZS5sZW5ndGggPT09IDEsXG4gICAgICAgICdUaGUgaW5wdXQgdG8gYSBzb2Z0bWF4IG11c3QgYmUgYSAxLUQgdGVuc29yJyk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHRoaXMueC5zaGFwZVswXSA+PSAyLFxuICAgICAgICAnVGhlIGlucHV0IHRvIGEgc29mdG1heCBtdXN0IGhhdmUgYXQgbGVhc3QgMiB2YWx1ZXMnKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lYW5TcXVhcmVkQ29zdE5vZGUgcmVwcmVzZW50cyBhIG1lYW4gc3F1YXJlZCBjb3N0IG9wZXJhdGlvblxuICogaW4gdGhlIGdyYXBoLlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIE1lYW5TcXVhcmVkQ29zdE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IExBQkVMID0gJ2xhYmVsJztcbiAgc3RhdGljIHJlYWRvbmx5IFBSRURJQ1RJT04gPSAncHJlZGljdGlvbic7XG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgcHJpdmF0ZSBsYWJlbDogVGVuc29yLCBwcml2YXRlIHByZWRpY3Rpb246IFRlbnNvcikge1xuICAgIHN1cGVyKGdyYXBoLCAnTWVhbiBTcXVhcmVkIENvc3QnLCB7bGFiZWwsIHByZWRpY3Rpb259LCBuZXcgVGVuc29yKFtdKSk7XG4gIH1cbiAgdmFsaWRhdGUoKSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy5sYWJlbC5zaGFwZSwgdGhpcy5wcmVkaWN0aW9uLnNoYXBlKSxcbiAgICAgICAgJ0Vycm9yIGFkZGluZyBtZWFuU3F1YXJlZENvc3Qgb3A6IGxhYmVsIHNoYXBlICgnICsgdGhpcy5sYWJlbC5zaGFwZSArXG4gICAgICAgICAgICAnKSBtdXN0IG1hdGNoIHByZWRpY3Rpb24gc2hhcGUgKCcgKyB0aGlzLnByZWRpY3Rpb24uc2hhcGUgKyAnKS4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEFyZ01heE5vZGUgcmVwcmVzZW50cyBhbiBhcmdtYXggb3BlcmF0aW9uIGluIHRoZSBncmFwaC5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIEFyZ01heE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFggPSAneCc7XG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgcHVibGljIHg6IFRlbnNvcikge1xuICAgIHN1cGVyKGdyYXBoLCAnQXJnTWF4Jywge3h9LCBuZXcgVGVuc29yKFsxXSkpO1xuICB9XG4gIHZhbGlkYXRlKCkge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy54LnNoYXBlKSA+IDAsXG4gICAgICAgICdFcnJvciBhZGRpbmcgYXJnbWF4IG9wOiBpbnB1dCB0ZW5zb3IgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBlbnRyeS4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEFyZ01heEVxdWFsc05vZGUgcmVwcmVzZW50cyBhIGFyZ21heCBlcXVhbHMgb3BlcmF0aW9uIGluIHRoZSBncmFwaC5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIEFyZ01heEVxdWFsc05vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFgxID0gJ3gxJztcbiAgc3RhdGljIHJlYWRvbmx5IFgyID0gJ3gyJztcbiAgY29uc3RydWN0b3IoZ3JhcGg6IEdyYXBoLCBwcml2YXRlIHgxOiBUZW5zb3IsIHByaXZhdGUgeDI6IFRlbnNvcikge1xuICAgIHN1cGVyKGdyYXBoLCAnQXJnTWF4RXF1YWxzJywge3gxLCB4Mn0sIG5ldyBUZW5zb3IoWzFdKSk7XG4gIH1cbiAgdmFsaWRhdGUoKSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy54MS5zaGFwZSwgdGhpcy54Mi5zaGFwZSksXG4gICAgICAgICdFcnJvciBhZGRpbmcgQXJnTWF4RXF1YWxzIG9wOiB4MSBzaGFwZSAoJyArIHRoaXMueDEuc2hhcGUgK1xuICAgICAgICAgICAgJykgbXVzdCBtYXRjaCB4MiBzaGFwZSAoJyArIHRoaXMueDIuc2hhcGUgKyAnKS4nKTtcbiAgfVxufVxuXG4vKipcbiAqIFNwbGl0IG5vZGVzIGFyZSB1c2VkIHRvIGFjY3VtdWxhdGUgYmFja3Byb3AgZGVyaXZhdGl2ZXMgd2hlbiBhIG5vZGUncyBvdXRwdXRcbiAqIHRlbnNvciBpcyBjb25zdW1lZCBieSBtdWx0aXBsZSBub2Rlcy5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFNwbGl0Tm9kZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkgWCA9ICd4JztcblxuICBvdXRwdXRzOiBUZW5zb3JbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgeDogVGVuc29yKSB7XG4gICAgc3VwZXIoZ3JhcGgsICdTcGxpdE5vZGUnLCB7eH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIG5ldyBjb25zdW1lciBvZiB0aGlzIHNwbGl0IG5vZGUsIGkuZS4gYSBuZXcgbm9kZSB0aGF0IHVzZXMgdGhlXG4gICAqIG5vZGUncyBvdXRwdXQgdGVuc29yLlxuICAgKi9cbiAgZ2V0TmV3T3V0cHV0VGVuc29yKCk6IFRlbnNvciB7XG4gICAgY29uc3Qgb3V0cHV0ID0gbmV3IFRlbnNvcih0aGlzLmlucHV0c1tTcGxpdE5vZGUuWF0uc2hhcGUpO1xuICAgIG91dHB1dC5ub2RlID0gdGhpcztcbiAgICB0aGlzLm91dHB1dHMucHVzaChvdXRwdXQpO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgdmFsaWRhdGUoKSB7fVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IHR5cGUgQXJyYXlEYXRhID1cbiAgICBOREFycmF5fG51bWJlcnxudW1iZXJbXXxudW1iZXJbXVtdfG51bWJlcltdW11bXXxudW1iZXJbXVtdW11bXTtcbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtHcmFwaCwgVGVuc29yfSBmcm9tICcuL2dyYXBoJztcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbmltcG9ydCB7SW5pdGlhbGl6ZXIsIFZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyLCBaZXJvc0luaXRpYWxpemVyfSBmcm9tICcuL2luaXRpYWxpemVycyc7XG5cbi8qKlxuICogQSBsYXllcnMgc3VnYXIgY2xhc3MgYXJvdW5kIHRoZSBncmFwaCB0aGF0IGluaXRpYWxpemVzIHZhcmlhYmxlc1xuICogYXV0b21hdGljYWxseSBmb3IgbGF5ZXJzLlxuICovXG5leHBvcnQgY2xhc3MgR3JhcGhMYXllcnMge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGc6IEdyYXBoKSB7fVxuXG4gIGRlbnNlKFxuICAgICAgbmFtZTogc3RyaW5nLCB4OiBUZW5zb3IsIHVuaXRzOiBudW1iZXIsXG4gICAgICBhY3RpdmF0aW9uOiAoKHg6IFRlbnNvcikgPT4gVGVuc29yKXxudWxsID0gbnVsbCwgdXNlQmlhcyA9IHRydWUsXG4gICAgICBrZXJuZWxJbml0aWFsaXplcjogSW5pdGlhbGl6ZXIgPSBuZXcgVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXIoKSxcbiAgICAgIGJpYXNJbml0aWFsaXplcjogSW5pdGlhbGl6ZXIgPSBuZXcgWmVyb3NJbml0aWFsaXplcigpKSB7XG4gICAgY29uc3Qgd2VpZ2h0cyA9IHRoaXMuZy52YXJpYWJsZShcbiAgICAgICAgbmFtZSArICctd2VpZ2h0cycsXG4gICAgICAgIGtlcm5lbEluaXRpYWxpemVyLmluaXRpYWxpemUoW3guc2hhcGVbMF0sIHVuaXRzXSwgeC5zaGFwZVswXSwgdW5pdHMpKTtcblxuICAgIGxldCBvdXQgPSB0aGlzLmcubWF0bXVsKHgsIHdlaWdodHMpO1xuXG4gICAgaWYgKHVzZUJpYXMpIHtcbiAgICAgIGNvbnN0IGJpYXMgPSB0aGlzLmcudmFyaWFibGUoXG4gICAgICAgICAgbmFtZSArICctYmlhcycsXG4gICAgICAgICAgYmlhc0luaXRpYWxpemVyLmluaXRpYWxpemUoW3VuaXRzXSwgeC5zaGFwZVswXSwgdW5pdHMpKTtcbiAgICAgIG91dCA9IHRoaXMuZy5hZGQob3V0LCBiaWFzKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICBvdXQgPSBhY3RpdmF0aW9uKG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge0lucHV0UHJvdmlkZXJ9IGZyb20gJy4vaW5wdXRfcHJvdmlkZXInO1xuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtOREFycmF5LCBTY2FsYXJ9IGZyb20gJy4vbWF0aC9uZGFycmF5JztcbmltcG9ydCB7T3B0aW1pemVyfSBmcm9tICcuL29wdGltaXplcic7XG5pbXBvcnQge0Nvc3RSZWR1Y3Rpb24sIEZlZWRFbnRyeSwgU2Vzc2lvbn0gZnJvbSAnLi9zZXNzaW9uJztcblxuY29uc3QgREVGQVVMVF9FVkFMX0lOVEVSVkFMX01TID0gMTUwMDtcbmNvbnN0IERFRkFVTFRfQ09TVF9JTlRFUlZBTF9NUyA9IDUwMDtcbmNvbnN0IERFRkFVTFRfSU5GRVJFTkNFX0VYQU1QTEVfSU5URVJWQUxfTVMgPSAzMDAwO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdyYXBoUnVubmVyRXZlbnRPYnNlcnZlciB7XG4gIGJhdGNoZXNUcmFpbmVkQ2FsbGJhY2s/OiAodG90YWxCYXRjaGVzVHJhaW5lZDogbnVtYmVyKSA9PiB2b2lkO1xuICBhdmdDb3N0Q2FsbGJhY2s/OiAoYXZnQ29zdDogU2NhbGFyKSA9PiB2b2lkO1xuICBtZXRyaWNDYWxsYmFjaz86IChtZXRyaWM6IE5EQXJyYXkpID0+IHZvaWQ7XG4gIGluZmVyZW5jZUV4YW1wbGVzQ2FsbGJhY2s/OlxuICAgICAgKGZlZWRzOiBGZWVkRW50cnlbXVtdLCBpbmZlcmVuY2VWYWx1ZXM6IE5EQXJyYXlbXSkgPT4gdm9pZDtcbiAgaW5mZXJlbmNlRXhhbXBsZXNQZXJTZWNDYWxsYmFjaz86IChleGFtcGxlc1BlclNlYzogbnVtYmVyKSA9PiB2b2lkO1xuICB0cmFpbkV4YW1wbGVzUGVyU2VjQ2FsbGJhY2s/OiAoZXhhbXBsZXNQZXJTZWM6IG51bWJlcikgPT4gdm9pZDtcbiAgdG90YWxUaW1lQ2FsbGJhY2s/OiAodG90YWxUaW1lU2VjOiBudW1iZXIpID0+IHZvaWQ7XG4gIGRvbmVUcmFpbmluZ0NhbGxiYWNrPzogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGVudW0gTWV0cmljUmVkdWN0aW9uIHtcbiAgU1VNLFxuICBNRUFOXG59XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGRyaXZlcyB0aGUgdHJhaW5pbmcgb2YgYSBncmFwaCBtb2RlbCBnaXZlbiBhIGRhdGFzZXQuIEl0IGFsbG93c1xuICogdGhlIHVzZXIgdG8gcHJvdmlkZSBhIHNldCBvZiBjYWxsYmFja3MgZm9yIG1lYXN1cmVtZW50cyBsaWtlIGNvc3QsIGFjY3VyYWN5LFxuICogYW5kIHNwZWVkIG9mIHRyYWluaW5nLlxuICovXG5leHBvcnQgY2xhc3MgR3JhcGhSdW5uZXIge1xuICBwcml2YXRlIGNvc3RUZW5zb3I6IFRlbnNvcjtcbiAgcHJpdmF0ZSB0cmFpbkZlZWRFbnRyaWVzOiBGZWVkRW50cnlbXTtcbiAgcHJpdmF0ZSBiYXRjaFNpemU6IG51bWJlcjtcbiAgcHJpdmF0ZSBvcHRpbWl6ZXI6IE9wdGltaXplcjtcbiAgcHJpdmF0ZSBjdXJyZW50VHJhaW5Mb29wTnVtQmF0Y2hlczogbnVtYmVyfHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBjb3N0SW50ZXJ2YWxNczogbnVtYmVyO1xuXG4gIHByaXZhdGUgbWV0cmljVGVuc29yOiBUZW5zb3J8dW5kZWZpbmVkO1xuICBwcml2YXRlIG1ldHJpY0ZlZWRFbnRyaWVzOiBGZWVkRW50cnlbXXx1bmRlZmluZWQ7XG4gIHByaXZhdGUgbWV0cmljQmF0Y2hTaXplOiBudW1iZXJ8dW5kZWZpbmVkO1xuICBwcml2YXRlIG1ldHJpY1JlZHVjdGlvbjogTWV0cmljUmVkdWN0aW9uO1xuICBwcml2YXRlIG1ldHJpY0ludGVydmFsTXM6IG51bWJlcjtcblxuICBwcml2YXRlIGluZmVyZW5jZVRlbnNvcjogVGVuc29yO1xuICBwcml2YXRlIGluZmVyZW5jZUZlZWRFbnRyaWVzOiBGZWVkRW50cnlbXXx1bmRlZmluZWQ7XG4gIHByaXZhdGUgaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXM6IG51bWJlcjtcbiAgcHJpdmF0ZSBpbmZlcmVuY2VFeGFtcGxlQ291bnQ6IG51bWJlcjtcblxuICAvLyBSdW50aW1lIGluZm9ybWF0aW9uLlxuICBwcml2YXRlIGlzVHJhaW5pbmc6IGJvb2xlYW47XG4gIHByaXZhdGUgdG90YWxCYXRjaGVzVHJhaW5lZDogbnVtYmVyO1xuICBwcml2YXRlIGJhdGNoZXNUcmFpbmVkVGhpc1J1bjogbnVtYmVyO1xuICBwcml2YXRlIGxhc3RDb21wdXRlZE1ldHJpYzogTkRBcnJheTtcblxuICBwcml2YXRlIGlzSW5mZXJyaW5nOiBib29sZWFuO1xuICBwcml2YXRlIGN1cnJlbnRJbmZlcmVuY2VMb29wTnVtUGFzc2VzOiBudW1iZXJ8dW5kZWZpbmVkO1xuICBwcml2YXRlIGluZmVyZW5jZVBhc3Nlc1RoaXNSdW46IG51bWJlcjtcblxuICBwcml2YXRlIHRyYWluU3RhcnRUaW1lc3RhbXA6IG51bWJlcjtcbiAgcHJpdmF0ZSBsYXN0Q29zdFRpbWVzdGFtcCA9IDA7XG4gIHByaXZhdGUgbGFzdEV2YWxUaW1lc3RhbXAgPSAwO1xuXG4gIHByaXZhdGUgbGFzdFN0b3BUaW1lc3RhbXA6IG51bWJlcnxudWxsO1xuICBwcml2YXRlIHRvdGFsSWRsZVRpbWVNcyA9IDA7XG5cbiAgcHJpdmF0ZSB6ZXJvU2NhbGFyOiBTY2FsYXI7XG4gIHByaXZhdGUgbWV0cmljQmF0Y2hTaXplU2NhbGFyOiBTY2FsYXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIG1hdGg6IE5EQXJyYXlNYXRoLCBwcml2YXRlIHNlc3Npb246IFNlc3Npb24sXG4gICAgICBwcml2YXRlIGV2ZW50T2JzZXJ2ZXI6IEdyYXBoUnVubmVyRXZlbnRPYnNlcnZlcikge1xuICAgIHRoaXMucmVzZXRTdGF0aXN0aWNzKCk7XG4gICAgdGhpcy56ZXJvU2NhbGFyID0gU2NhbGFyLm5ldygwKTtcbiAgfVxuXG4gIHJlc2V0U3RhdGlzdGljcygpIHtcbiAgICB0aGlzLnRvdGFsQmF0Y2hlc1RyYWluZWQgPSAwO1xuICAgIHRoaXMudG90YWxJZGxlVGltZU1zID0gMDtcbiAgICB0aGlzLmxhc3RTdG9wVGltZXN0YW1wID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgdHJhaW5pbmcgbG9vcCB3aXRoIGFuIG9wdGlvbmFsIG51bWJlciBvZiBiYXRjaGVzIHRvIHRyYWluIGZvci5cbiAgICogT3B0aW9uYWxseSB0YWtlcyBhIG1ldHJpYyB0ZW5zb3IgYW5kIGZlZWQgZW50cmllcyB0byBjb21wdXRlIHBlcmlvZGljYWxseS5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCBmb3IgY29tcHV0aW5nIGFjY3VyYWN5LCBvciBhIHNpbWlsYXIgbWV0cmljLlxuICAgKi9cbiAgdHJhaW4oXG4gICAgICBjb3N0VGVuc29yOiBUZW5zb3IsIHRyYWluRmVlZEVudHJpZXM6IEZlZWRFbnRyeVtdLCBiYXRjaFNpemU6IG51bWJlcixcbiAgICAgIG9wdGltaXplcjogT3B0aW1pemVyLCBudW1CYXRjaGVzPzogbnVtYmVyLCBtZXRyaWNUZW5zb3I/OiBUZW5zb3IsXG4gICAgICBtZXRyaWNGZWVkRW50cmllcz86IEZlZWRFbnRyeVtdLCBtZXRyaWNCYXRjaFNpemU/OiBudW1iZXIsXG4gICAgICBtZXRyaWNSZWR1Y3Rpb24gPSBNZXRyaWNSZWR1Y3Rpb24uTUVBTixcbiAgICAgIGV2YWxJbnRlcnZhbE1zID0gREVGQVVMVF9FVkFMX0lOVEVSVkFMX01TLFxuICAgICAgY29zdEludGVydmFsTXMgPSBERUZBVUxUX0NPU1RfSU5URVJWQUxfTVMpIHtcbiAgICB0aGlzLmNvc3RUZW5zb3IgPSBjb3N0VGVuc29yO1xuICAgIHRoaXMudHJhaW5GZWVkRW50cmllcyA9IHRyYWluRmVlZEVudHJpZXM7XG4gICAgdGhpcy5tZXRyaWNUZW5zb3IgPSBtZXRyaWNUZW5zb3I7XG4gICAgdGhpcy5tZXRyaWNGZWVkRW50cmllcyA9IG1ldHJpY0ZlZWRFbnRyaWVzO1xuICAgIGlmIChtZXRyaWNCYXRjaFNpemUgIT0gbnVsbCAmJiB0aGlzLm1ldHJpY0JhdGNoU2l6ZSAhPT0gbWV0cmljQmF0Y2hTaXplKSB7XG4gICAgICBpZiAodGhpcy5tZXRyaWNCYXRjaFNpemVTY2FsYXIgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLm1ldHJpY0JhdGNoU2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1ldHJpY0JhdGNoU2l6ZVNjYWxhciA9IFNjYWxhci5uZXcobWV0cmljQmF0Y2hTaXplKTtcbiAgICB9XG4gICAgdGhpcy5tZXRyaWNCYXRjaFNpemUgPSBtZXRyaWNCYXRjaFNpemU7XG4gICAgdGhpcy5tZXRyaWNSZWR1Y3Rpb24gPSBtZXRyaWNSZWR1Y3Rpb247XG4gICAgdGhpcy5iYXRjaFNpemUgPSBiYXRjaFNpemU7XG4gICAgdGhpcy5vcHRpbWl6ZXIgPSBvcHRpbWl6ZXI7XG5cbiAgICB0aGlzLm1ldHJpY0ludGVydmFsTXMgPSBldmFsSW50ZXJ2YWxNcztcbiAgICB0aGlzLmNvc3RJbnRlcnZhbE1zID0gY29zdEludGVydmFsTXM7XG4gICAgdGhpcy5jdXJyZW50VHJhaW5Mb29wTnVtQmF0Y2hlcyA9IG51bUJhdGNoZXM7XG5cbiAgICB0aGlzLmJhdGNoZXNUcmFpbmVkVGhpc1J1biA9IDA7XG4gICAgdGhpcy5pc1RyYWluaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnRyYWluU3RhcnRUaW1lc3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLnRyYWluTmV0d29yaygpO1xuICB9XG5cbiAgc3RvcFRyYWluaW5nKCkge1xuICAgIHRoaXMuaXNUcmFpbmluZyA9IGZhbHNlO1xuICAgIHRoaXMubGFzdFN0b3BUaW1lc3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfVxuXG4gIHJlc3VtZVRyYWluaW5nKCkge1xuICAgIHRoaXMuaXNUcmFpbmluZyA9IHRydWU7XG4gICAgaWYgKHRoaXMubGFzdFN0b3BUaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgdGhpcy50b3RhbElkbGVUaW1lTXMgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLmxhc3RTdG9wVGltZXN0YW1wO1xuICAgIH1cbiAgICB0aGlzLnRyYWluTmV0d29yaygpO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmFpbk5ldHdvcmsoKSB7XG4gICAgaWYgKHRoaXMuYmF0Y2hlc1RyYWluZWRUaGlzUnVuID09PSB0aGlzLmN1cnJlbnRUcmFpbkxvb3BOdW1CYXRjaGVzKSB7XG4gICAgICB0aGlzLnN0b3BUcmFpbmluZygpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1RyYWluaW5nKSB7XG4gICAgICBpZiAodGhpcy5ldmVudE9ic2VydmVyLmRvbmVUcmFpbmluZ0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5ldmVudE9ic2VydmVyLmRvbmVUcmFpbmluZ0NhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBzaG91bGRDb21wdXRlQ29zdCA9IHRoaXMuZXZlbnRPYnNlcnZlci5hdmdDb3N0Q2FsbGJhY2sgIT0gbnVsbCAmJlxuICAgICAgICAoc3RhcnQgLSB0aGlzLmxhc3RDb3N0VGltZXN0YW1wID4gdGhpcy5jb3N0SW50ZXJ2YWxNcyk7XG4gICAgaWYgKHNob3VsZENvbXB1dGVDb3N0KSB7XG4gICAgICB0aGlzLmxhc3RDb3N0VGltZXN0YW1wID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgY29uc3QgY29zdFJlZHVjdGlvbiA9XG4gICAgICAgIHNob3VsZENvbXB1dGVDb3N0ID8gQ29zdFJlZHVjdGlvbi5NRUFOIDogQ29zdFJlZHVjdGlvbi5OT05FO1xuXG4gICAgdGhpcy5tYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBjb25zdCBhdmdDb3N0ID0gdGhpcy5zZXNzaW9uLnRyYWluKFxuICAgICAgICAgIHRoaXMuY29zdFRlbnNvciwgdGhpcy50cmFpbkZlZWRFbnRyaWVzLCB0aGlzLmJhdGNoU2l6ZSxcbiAgICAgICAgICB0aGlzLm9wdGltaXplciwgY29zdFJlZHVjdGlvbik7XG5cbiAgICAgIGlmIChzaG91bGRDb21wdXRlQ29zdCkge1xuICAgICAgICBjb25zdCB0cmFpblRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuXG4gICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlci5hdmdDb3N0Q2FsbGJhY2shKGF2Z0Nvc3QpO1xuXG4gICAgICAgIGlmICh0aGlzLmV2ZW50T2JzZXJ2ZXIudHJhaW5FeGFtcGxlc1BlclNlY0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBleGFtcGxlc1BlclNlYyA9ICh0aGlzLmJhdGNoU2l6ZSAqIDEwMDAgLyB0cmFpblRpbWUpO1xuICAgICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlci50cmFpbkV4YW1wbGVzUGVyU2VjQ2FsbGJhY2soZXhhbXBsZXNQZXJTZWMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmV2ZW50T2JzZXJ2ZXIubWV0cmljQ2FsbGJhY2sgIT0gbnVsbCAmJlxuICAgICAgICAgIHRoaXMubWV0cmljRmVlZEVudHJpZXMgIT0gbnVsbCAmJlxuICAgICAgICAgIHN0YXJ0IC0gdGhpcy5sYXN0RXZhbFRpbWVzdGFtcCA+IHRoaXMubWV0cmljSW50ZXJ2YWxNcykge1xuICAgICAgICB0aGlzLmxhc3RFdmFsVGltZXN0YW1wID0gc3RhcnQ7XG5cbiAgICAgICAgaWYgKHRoaXMubGFzdENvbXB1dGVkTWV0cmljICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmxhc3RDb21wdXRlZE1ldHJpYy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMgPSB0aGlzLmNvbXB1dGVNZXRyaWMoKTtcbiAgICAgICAgdGhpcy5ldmVudE9ic2VydmVyLm1ldHJpY0NhbGxiYWNrKHRoaXMubGFzdENvbXB1dGVkTWV0cmljKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZXZlbnRPYnNlcnZlci50b3RhbFRpbWVDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlci50b3RhbFRpbWVDYWxsYmFjayhcbiAgICAgICAgICAgIChzdGFydCAtIHRoaXMudHJhaW5TdGFydFRpbWVzdGFtcCkgLyAxMDAwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5iYXRjaGVzVHJhaW5lZFRoaXNSdW4rKztcbiAgICAgIHRoaXMudG90YWxCYXRjaGVzVHJhaW5lZCsrO1xuXG4gICAgICBpZiAodGhpcy5ldmVudE9ic2VydmVyLmJhdGNoZXNUcmFpbmVkQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIuYmF0Y2hlc1RyYWluZWRDYWxsYmFjayh0aGlzLnRvdGFsQmF0Y2hlc1RyYWluZWQpO1xuICAgICAgfVxuXG4gICAgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRyYWluTmV0d29yaygpKTtcbiAgfVxuXG4gIGluZmVyKFxuICAgICAgaW5mZXJlbmNlVGVuc29yOiBUZW5zb3IsIGluZmVyZW5jZUZlZWRFbnRyaWVzOiBGZWVkRW50cnlbXSxcbiAgICAgIGluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zID0gREVGQVVMVF9JTkZFUkVOQ0VfRVhBTVBMRV9JTlRFUlZBTF9NUyxcbiAgICAgIGluZmVyZW5jZUV4YW1wbGVDb3VudCA9IDUsIG51bVBhc3Nlcz86IG51bWJlcikge1xuICAgIGlmICh0aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNDYWxsYmFjayA9PSBudWxsICYmXG4gICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc1BlclNlY0NhbGxiYWNrID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IHN0YXJ0IGluZmVyZW5jZSBsb29wLCBubyBpbmZlcmVuY2UgZXhhbXBsZSBvciAnICtcbiAgICAgICAgICAnZXhhbXBsZXMvc2VjIG9ic2VydmVyIHByb3ZpZGVkLicpO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgZmVlZCB2YWx1ZXMgYXJlIHByb3ZpZGVycywgYW5kIG5vdCBOREFycmF5cy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZmVyZW5jZUZlZWRFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmZWVkRW50cnkgPSBpbmZlcmVuY2VGZWVkRW50cmllc1tpXTtcblxuICAgICAgaWYgKGZlZWRFbnRyeS5kYXRhIGluc3RhbmNlb2YgTkRBcnJheSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2Fubm90IHN0YXJ0IGluZmVyZW5jZSBvbiB0aGUgbW9kZWwgcnVubmVyIHdpdGggZmVlZCBlbnRyaWVzIG9mICcgK1xuICAgICAgICAgICAgJ3R5cGUgTkRBcnJheS4gUGxlYXNlIHVzZSBJbnB1dFByb3ZpZGVycy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zID0gaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXM7XG4gICAgdGhpcy5pbmZlcmVuY2VUZW5zb3IgPSBpbmZlcmVuY2VUZW5zb3I7XG4gICAgdGhpcy5pbmZlcmVuY2VGZWVkRW50cmllcyA9IGluZmVyZW5jZUZlZWRFbnRyaWVzO1xuICAgIHRoaXMuaW5mZXJlbmNlRXhhbXBsZUNvdW50ID0gaW5mZXJlbmNlRXhhbXBsZUNvdW50O1xuICAgIHRoaXMuY3VycmVudEluZmVyZW5jZUxvb3BOdW1QYXNzZXMgPSBudW1QYXNzZXM7XG4gICAgaWYgKCF0aGlzLmlzSW5mZXJyaW5nKSB7XG4gICAgICB0aGlzLmluZmVyZW5jZVBhc3Nlc1RoaXNSdW4gPSAwO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmluZmVyTmV0d29yaygpKTtcbiAgICB9XG4gICAgdGhpcy5pc0luZmVycmluZyA9IHRydWU7XG4gIH1cblxuICBwcml2YXRlIGluZmVyTmV0d29yaygpIHtcbiAgICBpZiAoIXRoaXMuaXNJbmZlcnJpbmcgfHxcbiAgICAgICAgdGhpcy5pbmZlcmVuY2VQYXNzZXNUaGlzUnVuID09PSB0aGlzLmN1cnJlbnRJbmZlcmVuY2VMb29wTnVtUGFzc2VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tYXRoLnNjb3BlKChrZWVwLCB0cmFjaykgPT4ge1xuICAgICAgY29uc3QgZmVlZHM6IEZlZWRFbnRyeVtdW10gPSBbXTtcbiAgICAgIGNvbnN0IGluZmVyZW5jZVZhbHVlczogTkRBcnJheVtdID0gW107XG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5mZXJlbmNlRXhhbXBsZUNvdW50OyBpKyspIHtcbiAgICAgICAgLy8gUG9wdWxhdGUgYSBuZXcgRmVlZEVudHJ5W10gcG9wdWxhdGVkIHdpdGggTkRBcnJheXMuXG4gICAgICAgIGNvbnN0IG5kYXJyYXlGZWVkRW50cmllczogRmVlZEVudHJ5W10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmluZmVyZW5jZUZlZWRFbnRyaWVzIS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGZlZWRFbnRyeSA9IHRoaXMuaW5mZXJlbmNlRmVlZEVudHJpZXMhW2pdO1xuICAgICAgICAgIG5kYXJyYXlGZWVkRW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgIHRlbnNvcjogZmVlZEVudHJ5LnRlbnNvcixcbiAgICAgICAgICAgIGRhdGE6XG4gICAgICAgICAgICAgICAgdHJhY2soKGZlZWRFbnRyeS5kYXRhIGFzIElucHV0UHJvdmlkZXIpLmdldE5leHRDb3B5KHRoaXMubWF0aCkpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmVlZHMucHVzaChuZGFycmF5RmVlZEVudHJpZXMpO1xuXG4gICAgICAgIGluZmVyZW5jZVZhbHVlcy5wdXNoKFxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmV2YWwodGhpcy5pbmZlcmVuY2VUZW5zb3IsIG5kYXJyYXlGZWVkRW50cmllcykpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzUGVyU2VjQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAvLyBGb3JjZSBhIEdQVSBkb3dubG9hZCwgc2luY2UgaW5mZXJlbmNlIHJlc3VsdHMgYXJlIGdlbmVyYWxseSBuZWVkZWQgb25cbiAgICAgICAgLy8gdGhlIENQVSBhbmQgaXQncyBtb3JlIGZhaXIgdG8gaW5jbHVkZSBibG9ja2luZyBvbiB0aGUgR1BVIHRvIGNvbXBsZXRlXG4gICAgICAgIC8vIGl0cyB3b3JrIGZvciB0aGUgaW5mZXJlbmNlIG1lYXN1cmVtZW50LlxuICAgICAgICBpbmZlcmVuY2VWYWx1ZXNbaW5mZXJlbmNlVmFsdWVzLmxlbmd0aCAtIDFdLmdldFZhbHVlcygpO1xuXG4gICAgICAgIGNvbnN0IGluZmVyZW5jZUV4YW1wbGVzUGVyU2VjVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQ7XG5cbiAgICAgICAgY29uc3QgZXhhbXBsZXNQZXJTZWMgPVxuICAgICAgICAgICAgKHRoaXMuaW5mZXJlbmNlRXhhbXBsZUNvdW50ICogMTAwMCAvIGluZmVyZW5jZUV4YW1wbGVzUGVyU2VjVGltZSk7XG4gICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc1BlclNlY0NhbGxiYWNrIShleGFtcGxlc1BlclNlYyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc0NhbGxiYWNrKGZlZWRzLCBpbmZlcmVuY2VWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbmZlcmVuY2VQYXNzZXNUaGlzUnVuKys7XG5cbiAgICB9KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaW5mZXJOZXR3b3JrKCksIHRoaXMuaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXMpO1xuICB9XG5cbiAgc3RvcEluZmVycmluZygpIHtcbiAgICB0aGlzLmlzSW5mZXJyaW5nID0gZmFsc2U7XG4gIH1cblxuICBpc0luZmVyZW5jZVJ1bm5pbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbmZlcnJpbmc7XG4gIH1cblxuICBjb21wdXRlTWV0cmljKCk6IFNjYWxhciB7XG4gICAgaWYgKHRoaXMubWV0cmljRmVlZEVudHJpZXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcHV0ZSBtZXRyaWMsIG5vIG1ldHJpYyBGZWVkRW50cmllcyBwcm92aWRlZC4nKTtcbiAgICB9XG5cbiAgICBsZXQgbWV0cmljID0gdGhpcy56ZXJvU2NhbGFyO1xuXG4gICAgcmV0dXJuIHRoaXMubWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1ldHJpY0JhdGNoU2l6ZSE7IGkrKykge1xuICAgICAgICBjb25zdCBtZXRyaWNWYWx1ZSA9XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uZXZhbCh0aGlzLm1ldHJpY1RlbnNvciEsIHRoaXMubWV0cmljRmVlZEVudHJpZXMhKTtcblxuICAgICAgICBtZXRyaWMgPSB0aGlzLm1hdGguYWRkKG1ldHJpYywgbWV0cmljVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tZXRyaWNSZWR1Y3Rpb24gPT09IE1ldHJpY1JlZHVjdGlvbi5NRUFOKSB7XG4gICAgICAgIG1ldHJpYyA9IHRoaXMubWF0aC5kaXZpZGUobWV0cmljLCB0aGlzLm1ldHJpY0JhdGNoU2l6ZVNjYWxhcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXRyaWM7XG4gICAgfSk7XG4gIH1cblxuICBnZXRUb3RhbEJhdGNoZXNUcmFpbmVkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxCYXRjaGVzVHJhaW5lZDtcbiAgfVxuXG4gIGdldExhc3RDb21wdXRlZE1ldHJpYygpOiBTY2FsYXIge1xuICAgIHJldHVybiB0aGlzLmxhc3RDb21wdXRlZE1ldHJpYztcbiAgfVxuXG4gIHNldE1hdGgobWF0aDogTkRBcnJheU1hdGgpIHtcbiAgICB0aGlzLm1hdGggPSBtYXRoO1xuICB9XG5cbiAgc2V0U2Vzc2lvbihzZXNzaW9uOiBTZXNzaW9uKSB7XG4gICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgfVxuXG4gIHNldEluZmVyZW5jZVRlbnNvcihpbmZlcmVuY2VUZW5zb3I6IFRlbnNvcikge1xuICAgIHRoaXMuaW5mZXJlbmNlVGVuc29yID0gaW5mZXJlbmNlVGVuc29yO1xuICB9XG5cbiAgc2V0SW5mZXJlbmNlRXhhbXBsZUNvdW50KGluZmVyZW5jZUV4YW1wbGVDb3VudDogbnVtYmVyKSB7XG4gICAgdGhpcy5pbmZlcmVuY2VFeGFtcGxlQ291bnQgPSBpbmZlcmVuY2VFeGFtcGxlQ291bnQ7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtDb25zdGFudE5vZGUsIE5vZGUsIFRlbnNvcn0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQgKiBhcyBwcmlvcml0eV9xdWV1ZSBmcm9tICcuL3ByaW9yaXR5X3F1ZXVlJztcbmltcG9ydCB7UHJpb3JpdHlRdWV1ZX0gZnJvbSAnLi9wcmlvcml0eV9xdWV1ZSc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuL3RlbnNvcl9hcnJheV9tYXAnO1xuXG4vKipcbiAqIEdpdmVuIGEgdGFyZ2V0IG5vZGUgaW4gYSBncmFwaCwgYWNjdW11bGF0ZSB0aGUgc2V0IG9mIGFsbCBub2RlcyB0aGF0IG5lZWQgdG9cbiAqIGJlIGV2YWx1YXRlZCBpbiBvcmRlciB0byBldmFsdWF0ZSB0aGUgdGFyZ2V0IGdyYXBoLiBUcmF2ZXJzYWwgc3RvcHMgYW55d2hlcmVcbiAqIGEgbm9kZSdzIHZhbHVlcyBhcmUgZmVkIGluIGV4dGVybmFsbHkgdmlhIFwiZmVlZCBkaWN0c1wiLlxuICogQHBhcmFtIG5vZGVzIFRoZSBub2RlcyB0byBiZSBldmFsdWF0ZWQuXG4gKiBAcGFyYW0gdGVybWluYXRpbmdOb2RlcyBUaGUgc2V0IG9mIG5vZGVzIHRoYXQgc3RvcCB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIFRoZSB1bm9yZGVyZWQgc2V0IG9mIG5vZGVzIHRoYXQgbmVlZCB0byBiZSBldmFsdWF0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbm9yZGVyZWRFdmFsdWF0aW9uU2V0KFxuICAgIG5vZGVzOiBOb2RlW10sIHRlcm1pbmF0aW5nTm9kZXM6IE5vZGVbXSk6IE5vZGVbXSB7XG4gIGNvbnN0IHRlcm1pbmF0aW5nTm9kZU1hcDoge1tpZDogbnVtYmVyXTogTm9kZX0gPSB7fTtcbiAgY29uc3Qgc2Vlbjoge1tpZDogbnVtYmVyXTogTm9kZX0gPSB7fTtcbiAgY29uc3Qgc2V0OiBOb2RlW10gPSBbXTtcbiAgY29uc3QgdmlzaXQ6IE5vZGVbXSA9IG5vZGVzLnNsaWNlKCk7XG4gIHRlcm1pbmF0aW5nTm9kZXMuZm9yRWFjaChub2RlID0+IHRlcm1pbmF0aW5nTm9kZU1hcFtub2RlLmlkXSA9IG5vZGUpO1xuICAvKiBGbG9vZCBmaWxsOiBXaGlsZSB0aGUgJ3RvIHZpc2l0JyBzdGFjayBpcyBub3QgZW1wdHksIHBvcCBhIG5vZGUgb2ZmIG9mIGl0LlxuICAgKiBJZiB0aGUgbm9kZSBoYXMgbm90IHlldCBiZWVuIHZpc2l0ZWQsIGFkZCBpdCB0byB0aGUgc2V0LCBtYXJrIGl0IGFzIHNlZW4sXG4gICAqIGFuZCBlbnF1ZXVlIGFsbCBvZiBpdHMgYW5jZXN0b3IgKGlucHV0KSBub2Rlcy4gKi9cbiAgd2hpbGUgKHZpc2l0Lmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGN1ciA9IHZpc2l0LnBvcCgpITtcbiAgICBpZiAoc2VlbltjdXIuaWRdID09IG51bGwpIHtcbiAgICAgIGlmICh0ZXJtaW5hdGluZ05vZGVNYXBbY3VyLmlkXSA9PSBudWxsKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGN1ci5pbnB1dHMpXG4gICAgICAgICAgICAubWFwKGlucHV0TmFtZSA9PiBjdXIuaW5wdXRzW2lucHV0TmFtZV0pXG4gICAgICAgICAgICAuZm9yRWFjaChpbnB1dCA9PiB2aXNpdC5wdXNoKGlucHV0Lm5vZGUpKTtcbiAgICAgIH1cbiAgICAgIHNldC5wdXNoKGN1cik7XG4gICAgICBzZWVuW2N1ci5pZF0gPSBjdXI7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXQ7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBzZXQgb2Ygbm9kZXMsIGNvbXB1dGUgdGhlaXIgb3JkZXIgc3VjaCB0aGF0IGFsbCBkZXBlbmRlbnQgbm9kZXMgYXJlXG4gKiBldmFsdWF0ZWQgYWZ0ZXIgdGhlaXIgZGVwZW5kZWVzLiBUaGlzIGlzIHRoZSAnaW5mZXJlbmNlIG9yZGVyJyBmb3Igbm9kZXMgaW5cbiAqIHRoZSBvcGVyYXRpb24gZ3JhcGguXG4gKiBAcGFyYW0gdW5vcmRlcmVkRXZhbHVhdGlvblNldCBUaGUgdW5vcmRlcmVkIHNldCBvZiBub2RlcyB0aGF0IG5lZWQgdG8gYmVcbiAqIGV2YWx1YXRlZC5cbiAqIEByZXR1cm4gVGhlIGlucHV0IG5vZGVzIGluIGZvcndhcmQgZXZhbHVhdGlvbiBvcmRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9yZGVyZWRFdmFsdWF0aW9uU2V0KHVub3JkZXJlZEV2YWx1YXRpb25TZXQ6IE5vZGVbXSk6XG4gICAgTm9kZVtdIHtcbiAgLyogQSBwcmlvcml0eSBxdWV1ZSBpcyB1c2VkLCB3aGVyZSB0aGUgcHJpb3JpdHkgaXMgdGhlIHJlbWFpbmluZyBudW1iZXIgb2ZcbiAgICogdW5ldmFsdWF0ZWQgbm9kZXMgd2hvc2UgaW5wdXRzIGNvbWUgZnJvbSB0aGUgZWxlbWVudCBub2RlLiBUaGlzIGd1YXJhbnRlZXNcbiAgICogdGhhdCBhbGwgZG93bnN0cmVhbSBub2RlcyB3aWxsIGJlIGRlcXVldWVkIGJlZm9yZSB0aGVpciBhbmNlc3RvcnMuICovXG4gIGNvbnN0IHNldDogTm9kZVtdID0gW107XG4gIGNvbnN0IG5vZGVJbmRpY2VzOiB7W2lkOiBudW1iZXJdOiBudW1iZXJ9ID0ge307XG4gIGNvbnN0IHBlbmRpbmdEZXBlbmRlbmNpZXM6IHtbaWQ6IG51bWJlcl06IG51bWJlcn0gPSB7fTtcblxuICAvKiBUaGUgcXVldWUgcHJpb3JpdHkgY2FsbGJhY2sgbG9va3MgYXQgdGhlIG51bWJlciBvZiBwZW5kaW5nIGRlcGVuZGVuY2llcyBvZlxuICAgKiBhIGdpdmVuIG5vZGUuIFRoZSBxdWV1ZSBpbmRleCBvYnNlcnZlciBjYWxsYmFjayBtYWludGFpbnMgdGhlIGxvY2F0aW9uIG9mXG4gICAqIGVhY2ggbm9kZSBpbiB0aGUgYXJyYXksIGZvciBwcmlvcml0eSB1cGRhdGVzLiAqL1xuICBjb25zdCBub2RlUXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZTxOb2RlPihcbiAgICAgIChhOiBOb2RlLCBiOiBOb2RlKSA9PiBwcmlvcml0eV9xdWV1ZS5kZWZhdWx0Q29tcGFyZShcbiAgICAgICAgICBwZW5kaW5nRGVwZW5kZW5jaWVzW2EuaWRdLCBwZW5kaW5nRGVwZW5kZW5jaWVzW2IuaWRdKSxcbiAgICAgIChub2RlOiBOb2RlLCBuZXdJbmRleDogbnVtYmVyKSA9PiBub2RlSW5kaWNlc1tub2RlLmlkXSA9IG5ld0luZGV4KTtcblxuICB1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmZvckVhY2gobm9kZSA9PiBwZW5kaW5nRGVwZW5kZW5jaWVzW25vZGUuaWRdID0gMCk7XG5cbiAgLyogRm9yIGV2ZXJ5IGRlc2NlbmRlbnQgb2YgYSBub2RlIChvdXRwdXQgb2YgYW5jZXN0b3IgaXMgaW5wdXQgdG8gZGVzY2VuZGFudCksXG4gICAqIGluY3JlbWVudCB0aGUgJ3BlbmRpbmcgZGVwZW5kZW5jeSBjb3VudCcgZm9yIHRoZSBhbmNlc3Rvci4gVGhpcyBwcmVwYXJlc1xuICAgKiB0aGUgJ3BlbmRpbmcgZGVwZW5kZW5jeSBjb3VudCcgYXMgYSBwcmlvcml0eSBtYXAuICovXG4gIHVub3JkZXJlZEV2YWx1YXRpb25TZXQuZm9yRWFjaChcbiAgICAgIG5vZGUgPT4gT2JqZWN0LmtleXMobm9kZS5pbnB1dHMpXG4gICAgICAgICAgICAgICAgICAubWFwKGtleSA9PiBub2RlLmlucHV0c1trZXldKVxuICAgICAgICAgICAgICAgICAgLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5vcmRlcmVkRXZhbHVhdGlvblNldC5pbmRleE9mKGlucHV0Lm5vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdEZXBlbmRlbmNpZXNbaW5wdXQubm9kZS5pZF0rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gIHVub3JkZXJlZEV2YWx1YXRpb25TZXQuZm9yRWFjaChub2RlID0+IG5vZGVRdWV1ZS5lbnF1ZXVlKG5vZGUpKTtcblxuICB3aGlsZSAoIW5vZGVRdWV1ZS5lbXB0eSgpKSB7XG4gICAgc2V0LnVuc2hpZnQobm9kZVF1ZXVlLmRlcXVldWUoKSk7XG4gICAgLyogQXMgZWFjaCBub2RlIGlzIHZpc2l0ZWQsIGRlY3JlbWVudCB0aGUgJ3BlbmRpbmcgZGVwZW5kZW5jeSBjb3VudCcgb2ZcbiAgICAgKiBlYWNoIGFuY2VzdG9yLCBhbmQgdGVsbCB0aGUgcHJpb3JpdHkgcXVldWUgdGhhdCB0aGUgcHJpb3JpdHkgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgT2JqZWN0LmtleXMoc2V0WzBdLmlucHV0cykubWFwKGtleSA9PiBzZXRbMF0uaW5wdXRzW2tleV0pLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgaWYgKHVub3JkZXJlZEV2YWx1YXRpb25TZXQuaW5kZXhPZihpbnB1dC5ub2RlKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGVuZGluZ0RlcGVuZGVuY2llc1tpbnB1dC5ub2RlLmlkXS0tO1xuICAgICAgbm9kZVF1ZXVlLnVwZGF0ZShpbnB1dC5ub2RlLCBub2RlSW5kaWNlc1tpbnB1dC5ub2RlLmlkXSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc2V0O1xufVxuXG4vKipcbiAqIEByZXR1cm4gVHJ1ZSBpZmYgdGhlIG5vZGUgaXMgYW4gaW5wdXQgbm9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW5wdXROb2RlKG5vZGU6IE5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG5vZGUuaW5wdXRzKS5sZW5ndGggPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRCYWNrUHJvcCh0OiBUZW5zb3IpOiBib29sZWFuIHtcbiAgcmV0dXJuICEodC5ub2RlIGluc3RhbmNlb2YgQ29uc3RhbnROb2RlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGFzc3Rocm91Z2hOb2RlKG5vZGU6IE5vZGUsIG1hcDogVGVuc29yQXJyYXlNYXApOiBib29sZWFuIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUuaW5wdXRzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaW5wdXQgPSBub2RlLmlucHV0c1trZXlzW2ldXTtcbiAgICBpZiAobWFwLmdldChpbnB1dCwgdHJ1ZSkgPT09IG1hcC5nZXQobm9kZS5vdXRwdXQsIHRydWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQgKiBhcyBjb252X3V0aWwgZnJvbSAnLi9tYXRoL2NvbnZfdXRpbCc7XG5pbXBvcnQgKiBhcyBncGdwdV91dGlsIGZyb20gJy4vbWF0aC93ZWJnbC9ncGdwdV91dGlsJztcbmltcG9ydCAqIGFzIHJlbmRlcl9uZGFycmF5X2dwdV91dGlsIGZyb20gJy4vbWF0aC93ZWJnbC9yZW5kZXJfbmRhcnJheV9ncHVfdXRpbCc7XG5pbXBvcnQgKiBhcyB3ZWJnbF91dGlsIGZyb20gJy4vbWF0aC93ZWJnbC93ZWJnbF91dGlsJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IHtDaGVja3BvaW50TG9hZGVyfSBmcm9tICcuL2NoZWNrcG9pbnRfbG9hZGVyJztcbmV4cG9ydCB7RGF0YVN0YXRzLCBJbk1lbW9yeURhdGFzZXR9IGZyb20gJy4vZGF0YXNldCc7XG5leHBvcnQge0dyYXBoLCBUZW5zb3J9IGZyb20gJy4vZ3JhcGgnO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuZXhwb3J0IHtHcmFwaFJ1bm5lciwgR3JhcGhSdW5uZXJFdmVudE9ic2VydmVyLCBNZXRyaWNSZWR1Y3Rpb259IGZyb20gJy4vZ3JhcGhfcnVubmVyJztcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbmV4cG9ydCB7Q29uc3RhbnRJbml0aWFsaXplciwgSW5pdGlhbGl6ZXIsIE5EQXJyYXlJbml0aWFsaXplciwgT25lc0luaXRpYWxpemVyLCBSYW5kb21Ob3JtYWxJbml0aWFsaXplciwgUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIsIFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplciwgVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXIsIFplcm9zSW5pdGlhbGl6ZXJ9IGZyb20gJy4vaW5pdGlhbGl6ZXJzJztcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbmV4cG9ydCB7SW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLCBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIsIElucHV0UHJvdmlkZXJ9IGZyb20gJy4vaW5wdXRfcHJvdmlkZXInO1xuZXhwb3J0IHtNYXRyaXhPcmllbnRhdGlvbiwgTkRBcnJheU1hdGh9IGZyb20gJy4vbWF0aC9tYXRoJztcbmV4cG9ydCB7TkRBcnJheU1hdGhDUFV9IGZyb20gJy4vbWF0aC9tYXRoX2NwdSc7XG5leHBvcnQge05EQXJyYXlNYXRoR1BVfSBmcm9tICcuL21hdGgvbWF0aF9ncHUnO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuZXhwb3J0IHtBcnJheTFELCBBcnJheTJELCBBcnJheTNELCBBcnJheTRELCBOREFycmF5LCBTY2FsYXJ9IGZyb20gJy4vbWF0aC9uZGFycmF5JztcbmV4cG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL21hdGgvd2ViZ2wvZ3BncHVfY29udGV4dCc7XG5leHBvcnQge09wdGltaXplcn0gZnJvbSAnLi9vcHRpbWl6ZXInO1xuZXhwb3J0IHtDb3N0UmVkdWN0aW9uLCBGZWVkRW50cnksIFNlc3Npb259IGZyb20gJy4vc2Vzc2lvbic7XG5leHBvcnQge1NHRE9wdGltaXplcn0gZnJvbSAnLi9zZ2Rfb3B0aW1pemVyJztcbi8vIFNlY29uZCBsZXZlbCBleHBvcnRzLlxuZXhwb3J0IHtjb252X3V0aWwsIGdwZ3B1X3V0aWwsIHJlbmRlcl9uZGFycmF5X2dwdV91dGlsLCB1dGlsLCB3ZWJnbF91dGlsfTtcbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtOREFycmF5fSBmcm9tICcuL21hdGgvbmRhcnJheSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXIgaW50ZXJmYWNlLCBhbGwgaW5pdGlhbGl6ZXIgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEluaXRpYWxpemVyIHtcbiAgaW5pdGlhbGl6ZSh3ZWlnaHRzU2hhcGU6IG51bWJlcltdLCBpbnB1dFVuaXRzOiBudW1iZXIsIG91dHB1dFVuaXRzOiBudW1iZXIpOlxuICAgICAgTkRBcnJheTtcbn1cblxuZXhwb3J0IGNsYXNzIFZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyIGltcGxlbWVudHMgSW5pdGlhbGl6ZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgc2NhbGUgPSAxLjAsXG4gICAgICBwcml2YXRlIG1vZGU6ICdmYW5faW4nfCdmYW5fb3V0J3wnZmFuX2F2ZycgPSAnZmFuX2luJyxcbiAgICAgIHByaXZhdGUgZGlzdHJpYnV0aW9uOiAndW5pZm9ybSd8J25vcm1hbCcgPSAnbm9ybWFsJykge31cblxuICBpbml0aWFsaXplKHdlaWdodHNTaGFwZTogbnVtYmVyW10sIGlucHV0VW5pdHM6IG51bWJlciwgb3V0cHV0VW5pdHM6IG51bWJlcik6XG4gICAgICBOREFycmF5IHtcbiAgICBsZXQgbiA9IDA7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ2Zhbl9pbicpIHtcbiAgICAgIG4gPSBpbnB1dFVuaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSAnZmFuX291dCcpIHtcbiAgICAgIG4gPSBvdXRwdXRVbml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2Zhbl9hdmcnKSB7XG4gICAgICBuID0gKGlucHV0VW5pdHMgKyBvdXRwdXRVbml0cykgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1VuZXhwZWN0ZWQgbW9kZSBmb3IgdmFyaWFuY2Ugc2NhbGluZyBpbml0aWFsaXplcjogJyArIHRoaXMubW9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlzdHJpYnV0aW9uID09PSAnbm9ybWFsJykge1xuICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZFRydW5jYXRlZE5vcm1hbChcbiAgICAgICAgICB3ZWlnaHRzU2hhcGUsIDAuMCwgTWF0aC5zcXJ0KHRoaXMuc2NhbGUgLyBuKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRpc3RyaWJ1dGlvbiA9PT0gJ3VuaWZvcm0nKSB7XG4gICAgICByZXR1cm4gTkRBcnJheS5yYW5kVW5pZm9ybShcbiAgICAgICAgICB3ZWlnaHRzU2hhcGUsIDAuMCwgTWF0aC5zcXJ0KDMgKiB0aGlzLnNjYWxlIC8gbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1VuZXhwZWN0ZWQgZGlzdHJpYnV0aW9uIGZvciB2YXJpYW5jZSBzY2FsaW5nIGluaXRpYWxpemVyOiAnICtcbiAgICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBaZXJvc0luaXRpYWxpemVyIGltcGxlbWVudHMgSW5pdGlhbGl6ZXIge1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgaW5pdGlhbGl6ZSh3ZWlnaHRzU2hhcGU6IG51bWJlcltdLCBpbnB1dFVuaXRzOiBudW1iZXIsIG91dHB1dFVuaXRzOiBudW1iZXIpOlxuICAgICAgTkRBcnJheSB7XG4gICAgcmV0dXJuIE5EQXJyYXkuemVyb3Mod2VpZ2h0c1NoYXBlKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgT25lc0luaXRpYWxpemVyIGltcGxlbWVudHMgSW5pdGlhbGl6ZXIge1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgaW5pdGlhbGl6ZSh3ZWlnaHRzU2hhcGU6IG51bWJlcltdLCBpbnB1dFVuaXRzOiBudW1iZXIsIG91dHB1dFVuaXRzOiBudW1iZXIpOlxuICAgICAgTkRBcnJheSB7XG4gICAgY29uc3QgdmFsdWVzID0gTkRBcnJheS56ZXJvcyh3ZWlnaHRzU2hhcGUpO1xuICAgIHZhbHVlcy5maWxsKDEpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENvbnN0YW50SW5pdGlhbGl6ZXIgaW1wbGVtZW50cyBJbml0aWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdmFsdWUgPSAwKSB7fVxuXG4gIGluaXRpYWxpemUod2VpZ2h0c1NoYXBlOiBudW1iZXJbXSwgaW5wdXRVbml0czogbnVtYmVyLCBvdXRwdXRVbml0czogbnVtYmVyKTpcbiAgICAgIE5EQXJyYXkge1xuICAgIGNvbnN0IHZhbHVlcyA9IE5EQXJyYXkuemVyb3Mod2VpZ2h0c1NoYXBlKTtcbiAgICB2YWx1ZXMuZmlsbCh0aGlzLnZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOREFycmF5SW5pdGlhbGl6ZXIgaW1wbGVtZW50cyBJbml0aWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbmRhcnJheTogTkRBcnJheSkge31cblxuICBpbml0aWFsaXplKHdlaWdodHNTaGFwZTogbnVtYmVyW10sIGlucHV0VW5pdHM6IG51bWJlciwgb3V0cHV0VW5pdHM6IG51bWJlcik6XG4gICAgICBOREFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5uZGFycmF5O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSYW5kb21Ob3JtYWxJbml0aWFsaXplciBpbXBsZW1lbnRzIEluaXRpYWxpemVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBtZWFuID0gMCwgcHJpdmF0ZSBzdGRldiA9IC4wNSkge31cblxuICBpbml0aWFsaXplKHdlaWdodHNTaGFwZTogbnVtYmVyW10sIGlucHV0VW5pdHM6IG51bWJlciwgb3V0cHV0VW5pdHM6IG51bWJlcik6XG4gICAgICBOREFycmF5IHtcbiAgICByZXR1cm4gTkRBcnJheS5yYW5kTm9ybWFsKHdlaWdodHNTaGFwZSwgdGhpcy5tZWFuLCB0aGlzLnN0ZGV2KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIgaW1wbGVtZW50cyBJbml0aWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbWVhbiA9IDAsIHByaXZhdGUgc3RkZXYgPSAuMDUpIHt9XG5cbiAgaW5pdGlhbGl6ZSh3ZWlnaHRzU2hhcGU6IG51bWJlcltdLCBpbnB1dFVuaXRzOiBudW1iZXIsIG91dHB1dFVuaXRzOiBudW1iZXIpOlxuICAgICAgTkRBcnJheSB7XG4gICAgcmV0dXJuIE5EQXJyYXkucmFuZFRydW5jYXRlZE5vcm1hbCh3ZWlnaHRzU2hhcGUsIHRoaXMubWVhbiwgdGhpcy5zdGRldik7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplciBpbXBsZW1lbnRzIEluaXRpYWxpemVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBtaW52YWwgPSAtLjA1LCBwcml2YXRlIG1heHZhbCA9IC4wNSkge31cblxuICBpbml0aWFsaXplKHdlaWdodHNTaGFwZTogbnVtYmVyW10sIGlucHV0VW5pdHM6IG51bWJlciwgb3V0cHV0VW5pdHM6IG51bWJlcik6XG4gICAgICBOREFycmF5IHtcbiAgICByZXR1cm4gTkRBcnJheS5yYW5kVW5pZm9ybSh3ZWlnaHRzU2hhcGUsIHRoaXMubWludmFsLCB0aGlzLm1heHZhbCk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtOREFycmF5fSBmcm9tICcuL21hdGgvbmRhcnJheSc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogVGhlIGludGVyZmFjZSBmb3IgaW5wdXQgcHJvdmlkZXJzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElucHV0UHJvdmlkZXIge1xuICAvKipcbiAgICogR2V0IHRoZSBuZXh0IGlucHV0IGFzIGEgY29weS4gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgZGF0YSBtaWdodFxuICAgKiBnZXQgdXBsb2FkZWQgdG8gdGhlIEdQVSBhbmQgbW9kaWZ5IHRoZSBvcmlnaW5hbCBkYXRhLlxuICAgKiBAcGFyYW0gbWF0aCBOREFycmF5TWF0aFxuICAgKi9cbiAgZ2V0TmV4dENvcHkobWF0aDogTkRBcnJheU1hdGgpOiBOREFycmF5O1xuICAvKipcbiAgICogRGlzcG9zZSB0aGUgaW5wdXQgY29weS5cbiAgICogQHBhcmFtIG1hdGggTkRBcnJheU1hdGhcbiAgICogQHBhcmFtIGNvcHkgVGhlIGNvcHkgcHJvdmlkZWQgZnJvbSBnZXROZXh0Q29weVxuICAgKi9cbiAgZGlzcG9zZUNvcHkobWF0aDogTkRBcnJheU1hdGgsIGNvcHk6IE5EQXJyYXkpOiB2b2lkO1xufVxuXG4vKipcbiAqIEEgY29tbW9uIGludGVyZmFjZSBmb3Igc2h1ZmZsZWQgaW5wdXQgcHJvdmlkZXIgYnVpbGRlcnMuIFRoaXMgcmV0dXJuc1xuICogSW5wdXRQcm92aWRlcnMgdGhhdCBhcmUgc3luY2hyb25pemVkLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIge1xuICBnZXRJbnB1dFByb3ZpZGVycygpOiBJbnB1dFByb3ZpZGVyW107XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyIGltcGxlbWVudHNcbiAgICBTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyIHtcbiAgcHJvdGVjdGVkIHNodWZmbGVkSW5kaWNlczogVWludDMyQXJyYXk7XG4gIHByb3RlY3RlZCBudW1JbnB1dHM6IG51bWJlcjtcblxuICBwcm90ZWN0ZWQgaWR4ID0gMDtcbiAgLy8gQ291bnRlciBmb3IgaG93IG1hbnkgdGltZXMgdGhlIGN1cnJlbnQgaW5kZXggaGFzIGJlZW4gY2FsbGVkLiBSZXNldHMgdG8gMFxuICAvLyB3aGVuIGl0IHJlYWNoZXMgdGhlIG51bWJlciBvZiBpbnB1dHMuXG4gIHByb3RlY3RlZCBpbnB1dENvdW50ZXIgPSAwO1xuICBwcm90ZWN0ZWQgZXBvY2ggPSAwO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIGBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlcmAuIEFsbCBvZiB0aGUgaW5wdXRzIG11c3QgYmVcbiAgICogaW4gbWVtb3J5LlxuICAgKiBAcGFyYW0gaW5wdXRzIEFsbCBvZiB0aGUgaW5wdXRzLCBzaXplOiBbbnVtYmVyIG9mIGlucHV0c11bbnVtYmVyIG9mXG4gICAqIGV4YW1wbGVzXS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBpbnB1dHM6IE5EQXJyYXlbXVtdKSB7XG4gICAgdGhpcy5zaHVmZmxlZEluZGljZXMgPSB1dGlsLmNyZWF0ZVNodWZmbGVkSW5kaWNlcyhpbnB1dHNbMF0ubGVuZ3RoKTtcbiAgICB0aGlzLm51bUlucHV0cyA9IGlucHV0cy5sZW5ndGg7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIG51bWJlciBvZiBleGFtcGxlcyBpbiBlYWNoIGlucHV0IG1hdGNoZXMuXG4gICAgY29uc3QgbnVtRXhhbXBsZXMgPSB0aGlzLmlucHV0c1swXS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bUlucHV0czsgaSsrKSB7XG4gICAgICB1dGlsLmFzc2VydChcbiAgICAgICAgICB0aGlzLmlucHV0c1tpXS5sZW5ndGggPT09IG51bUV4YW1wbGVzLFxuICAgICAgICAgICdOdW1iZXIgb2YgZXhhbXBsZXMgbXVzdCBtYXRjaCBhY3Jvc3MgZGlmZmVyZW50IGlucHV0cy4nKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIHNoYXBlcyB3aXRoaW4gaW5wdXRzIGFsbCBtYXRjaC5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtSW5wdXRzOyBpKyspIHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSB0aGlzLmlucHV0c1tpXVswXS5zaGFwZTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5pbnB1dHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChpbnB1dFNoYXBlLCB0aGlzLmlucHV0c1tpXVtqXS5zaGFwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGdldEN1cnJlbnRFeGFtcGxlSW5kZXgoKTogbnVtYmVyIHtcbiAgICBjb25zdCByZXR1cm5JZHggPSB0aGlzLmlkeDtcblxuICAgIHRoaXMuaW5wdXRDb3VudGVyKys7XG4gICAgaWYgKHRoaXMuaW5wdXRDb3VudGVyID49IHRoaXMubnVtSW5wdXRzKSB7XG4gICAgICB0aGlzLmlkeCsrO1xuICAgICAgdGhpcy5pbnB1dENvdW50ZXIgPSAwO1xuXG4gICAgICBpZiAodGhpcy5pZHggPj0gdGhpcy5pbnB1dHNbMF0ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuaWR4ID0gMDtcbiAgICAgICAgdGhpcy5lcG9jaCsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuSWR4O1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldE5leHRJbnB1dChpbnB1dElkOiBudW1iZXIpOiBOREFycmF5IHtcbiAgICBjb25zdCBjdXJyZW50RXhhbXBsZUluZGV4ID0gdGhpcy5nZXRDdXJyZW50RXhhbXBsZUluZGV4KCk7XG5cbiAgICByZXR1cm4gdGhpcy5pbnB1dHNbaW5wdXRJZF1bdGhpcy5zaHVmZmxlZEluZGljZXNbY3VycmVudEV4YW1wbGVJbmRleF1dO1xuICB9XG5cbiAgZ2V0RXBvY2goKSB7XG4gICAgcmV0dXJuIHRoaXMuZXBvY2g7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpbnB1dCBwcm92aWRlcnMgd2hpY2ggc2h1ZmZsZSB0aGUgaW5wdXRzIGFuZCBzdGF5IGluIHN5bmMuXG4gICAqL1xuICBnZXRJbnB1dFByb3ZpZGVycygpOiBJbnB1dFByb3ZpZGVyW10ge1xuICAgIGNvbnN0IGlucHV0UHJvdmlkZXJzOiBJbnB1dFByb3ZpZGVyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1JbnB1dHM7IGkrKykge1xuICAgICAgaW5wdXRQcm92aWRlcnMucHVzaCh0aGlzLmdldElucHV0UHJvdmlkZXIoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm92aWRlcnM7XG4gIH1cblxuICBhYnN0cmFjdCBnZXRJbnB1dFByb3ZpZGVyKGlucHV0SWQ6IG51bWJlcik6IElucHV0UHJvdmlkZXI7XG59XG5cbi8qKlxuICogQW4gaW4gQ1BVIG1lbW9yeSBTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyIHRoYXQgc2h1ZmZsZXMgTkRBcnJheXMgb24gdGhlXG4gKiBDUFUgYW5kIGtlZXBzIHRoZW0gbXV0dWFsbHkgaW4gc3luYy5cbiAqL1xuZXhwb3J0IGNsYXNzIEluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciBleHRlbmRzXG4gICAgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyIHtcbiAgZ2V0SW5wdXRQcm92aWRlcihpbnB1dElkOiBudW1iZXIpIHtcbiAgICBjb25zdCBzaHVmZmxlZElucHV0UHJvdmlkZXIgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldE5leHRDb3B5KG1hdGg6IE5EQXJyYXlNYXRoKTogTkRBcnJheSB7XG4gICAgICAgIHJldHVybiBOREFycmF5Lmxpa2Uoc2h1ZmZsZWRJbnB1dFByb3ZpZGVyLmdldE5leHRJbnB1dChpbnB1dElkKSk7XG4gICAgICB9LFxuICAgICAgZGlzcG9zZUNvcHkobWF0aDogTkRBcnJheU1hdGgsIGNvcHk6IE5EQXJyYXkpIHtcbiAgICAgICAgY29weS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGluIEdQVSBtZW1vcnkgU2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciB0aGF0IHNodWZmbGVzIE5EQXJyYXlzIG9uIHRoZVxuICogR1BVIGFuZCBrZWVwcyB0aGVtIG11dHVhbGx5IGluIHN5bmMuIFRoaXMgaXMgbW9yZSBwZXJmb3JtYW50IHRoYW4gdGhlIENQVVxuICogdmVyc2lvbiBhcyB0ZXh0dXJlcyB3aWxsIHN0YXkgaW4gbWVtb3J5LCBob3dldmVyIHRoaXMgaXMgbW9yZSBHUFUgbWVtb3J5XG4gKiBpbnRlbnNpdmUgYXMgaXQga2VlcHMgdGV4dHVyZXMgcmVzaWRlbnQgaW4gR1BVIG1lbW9yeS5cbiAqL1xuZXhwb3J0IGNsYXNzIEluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciBleHRlbmRzXG4gICAgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyIHtcbiAgZ2V0SW5wdXRQcm92aWRlcihpbnB1dElkOiBudW1iZXIpIHtcbiAgICBjb25zdCBzaHVmZmxlZElucHV0UHJvdmlkZXIgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldE5leHRDb3B5KG1hdGg6IE5EQXJyYXlNYXRoKTogTkRBcnJheSB7XG4gICAgICAgIHJldHVybiBtYXRoLmNsb25lKHNodWZmbGVkSW5wdXRQcm92aWRlci5nZXROZXh0SW5wdXQoaW5wdXRJZCkpO1xuICAgICAgfSxcbiAgICAgIGRpc3Bvc2VDb3B5KG1hdGg6IE5EQXJyYXlNYXRoLCBjb3B5OiBOREFycmF5KSB7XG4gICAgICAgIGNvcHkuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi9tYXRoJztcbmltcG9ydCB7TkRBcnJheSwgU2NhbGFyfSBmcm9tICcuL25kYXJyYXknO1xuXG4vKiogQSBub2RlJ3MgYWN0aXZhdGlvbiBmdW5jdGlvbiBhbmQgaXRzIGRlcml2YXRpdmUuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjdGl2YXRpb25GdW5jdGlvbiB7XG4gIG91dHB1dDxUIGV4dGVuZHMgTkRBcnJheT4obWF0aDogTkRBcnJheU1hdGgsIGlucHV0OiBUKTogVDtcbiAgZGVyPFQgZXh0ZW5kcyBOREFycmF5PihtYXRoOiBOREFycmF5TWF0aCwgaW5wdXQ6IFQsIG91dHB1dDogVCk6IFQ7XG59XG5cbmV4cG9ydCBjbGFzcyBUYW5IRnVuYyBpbXBsZW1lbnRzIEFjdGl2YXRpb25GdW5jdGlvbiB7XG4gIG91dHB1dDxUIGV4dGVuZHMgTkRBcnJheT4obWF0aDogTkRBcnJheU1hdGgsIHg6IFQpIHtcbiAgICByZXR1cm4gbWF0aC5zY29wZSgoKSA9PiB7XG4gICAgICByZXR1cm4gbWF0aC50YW5oKHgpO1xuICAgIH0pO1xuICB9XG5cbiAgZGVyPFQgZXh0ZW5kcyBOREFycmF5PihtYXRoOiBOREFycmF5TWF0aCwgeDogVCwgeTogVCkge1xuICAgIHJldHVybiBtYXRoLnNjb3BlKCgpID0+IHtcbiAgICAgIGNvbnN0IHlTcXVhcmVkID0gbWF0aC5lbGVtZW50V2lzZU11bCh5LCB5KTtcbiAgICAgIC8vIDEgLSB5XjIuXG4gICAgICByZXR1cm4gbWF0aC5zY2FsYXJNaW51c0FycmF5KFNjYWxhci5PTkUsIHlTcXVhcmVkKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVMVUZ1bmMgaW1wbGVtZW50cyBBY3RpdmF0aW9uRnVuY3Rpb24ge1xuICBvdXRwdXQ8VCBleHRlbmRzIE5EQXJyYXk+KG1hdGg6IE5EQXJyYXlNYXRoLCB4OiBUKSB7XG4gICAgcmV0dXJuIG1hdGguc2NvcGUoKCkgPT4ge1xuICAgICAgcmV0dXJuIG1hdGgucmVsdSh4KTtcbiAgICB9KTtcbiAgfVxuXG4gIGRlcjxUIGV4dGVuZHMgTkRBcnJheT4obWF0aDogTkRBcnJheU1hdGgsIHg6IFQsIHk6IFQpIHtcbiAgICByZXR1cm4gbWF0aC5zY29wZSgoKSA9PiB7XG4gICAgICByZXR1cm4gbWF0aC5zdGVwKHgpO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaWdtb2lkRnVuYyBpbXBsZW1lbnRzIEFjdGl2YXRpb25GdW5jdGlvbiB7XG4gIG91dHB1dDxUIGV4dGVuZHMgTkRBcnJheT4obWF0aDogTkRBcnJheU1hdGgsIHg6IFQpIHtcbiAgICByZXR1cm4gbWF0aC5zY29wZSgoKSA9PiB7XG4gICAgICByZXR1cm4gbWF0aC5zaWdtb2lkKHgpO1xuICAgIH0pO1xuICB9XG5cbiAgZGVyPFQgZXh0ZW5kcyBOREFycmF5PihtYXRoOiBOREFycmF5TWF0aCwgeDogVCwgeTogVCk6IFQge1xuICAgIHJldHVybiBtYXRoLnNjb3BlKCgpID0+IHtcbiAgICAgIC8vIHkgKiAoMSAtIHkpID0geSAtIHleMlxuICAgICAgY29uc3QgeVNxdWFyZWQgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHksIHkpO1xuICAgICAgcmV0dXJuIG1hdGguc3ViU3RyaWN0KHksIHlTcXVhcmVkKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3F1YXJlRnVuYyBpbXBsZW1lbnRzIEFjdGl2YXRpb25GdW5jdGlvbiB7XG4gIG91dHB1dDxUIGV4dGVuZHMgTkRBcnJheT4obWF0aDogTkRBcnJheU1hdGgsIHg6IFQpIHtcbiAgICByZXR1cm4gbWF0aC5zY29wZSgoKSA9PiB7XG4gICAgICByZXR1cm4gbWF0aC5lbGVtZW50V2lzZU11bCh4LCB4KTtcbiAgICB9KTtcbiAgfVxuXG4gIGRlcjxUIGV4dGVuZHMgTkRBcnJheT4obWF0aDogTkRBcnJheU1hdGgsIHg6IFQsIHk6IFQpIHtcbiAgICByZXR1cm4gbWF0aC5zY29wZSgoKSA9PiB7XG4gICAgICAvLyBkeS9keCA9IDIqeC5cbiAgICAgIHJldHVybiBtYXRoLnNjYWxhclRpbWVzQXJyYXkoU2NhbGFyLlRXTywgeCk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydENvbmNhdDNEU2hhcGVzTWF0Y2goXG4gICAgeDFTaGFwZTogbnVtYmVyW10sIHgyU2hhcGU6IG51bWJlcltdLCBheGlzOiBudW1iZXIsXG4gICAgZXJyb3JNZXNzYWdlUHJlZml4ID0gJycpIHtcbiAgdXRpbC5hc3NlcnQoXG4gICAgICB4MVNoYXBlLmxlbmd0aCA9PT0gMyxcbiAgICAgIGVycm9yTWVzc2FnZVByZWZpeCArICdDb25jYXQzRCB4MSBzaGFwZSBzaG91bGQgYmUgb2YgcmFuayAzLicpO1xuICB1dGlsLmFzc2VydChcbiAgICAgIHgyU2hhcGUubGVuZ3RoID09PSAzLFxuICAgICAgZXJyb3JNZXNzYWdlUHJlZml4ICsgJ0NvbmNhdDNEIHgyIHNoYXBlIHNob3VsZCBiZSBvZiByYW5rIDMuJyk7XG5cbiAgdXRpbC5hc3NlcnQoXG4gICAgICBheGlzID49IDAgJiYgYXhpcyA8IDMsICdBeGlzIGZvciBjb25jYXQzRCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMi4nKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAoaSA9PT0gYXhpcykgfHwgKHgxU2hhcGVbaV0gPT09IHgyU2hhcGVbaV0pLFxuICAgICAgICBlcnJvck1lc3NhZ2VQcmVmaXggK1xuICAgICAgICAgICAgYFNoYXBlICgke3gxU2hhcGV9KSBkb2VzIG5vdCBtYXRjaCAoJHt4MlNoYXBlfSkgYWxvbmcgYCArXG4gICAgICAgICAgICBgbm9uLWNvbmNhdGVuYXRlZCBheGlzLmApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQ29uY2F0M0RPdXRwdXRTaGFwZShcbiAgICB4MVNoYXBlOiBudW1iZXJbXSwgeDJTaGFwZTogbnVtYmVyW10sXG4gICAgYXhpczogbnVtYmVyKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgdXRpbC5hc3NlcnQoeDFTaGFwZS5sZW5ndGggPT09IDMsICdDb25jYXQzRCB4MSBzaGFwZSBzaG91bGQgYmUgb2YgcmFuayAzLicpO1xuICB1dGlsLmFzc2VydCh4MlNoYXBlLmxlbmd0aCA9PT0gMywgJ0NvbmNhdDNEIHgyc2hhcGUgc2hvdWxkIGJlIG9mIHJhbmsgMy4nKTtcblxuICBjb25zdCBvdXRwdXRTaGFwZSA9IHgxU2hhcGUuc2xpY2UoKTtcbiAgb3V0cHV0U2hhcGVbYXhpc10gKz0geDJTaGFwZVtheGlzXTtcbiAgcmV0dXJuIG91dHB1dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbn0iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlT3V0cHV0U2hhcGUzRChcbiAgICBpbnB1dFNoYXBlUm93Q29sRGVwdGg6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZmllbGRTaXplOiBudW1iZXIsXG4gICAgZGVwdGg6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIHplcm9QYWQ/OiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuICBpZiAoemVyb1BhZCA9PSBudWxsKSB7XG4gICAgemVyb1BhZCA9IGNvbXB1dGVEZWZhdWx0UGFkKGlucHV0U2hhcGVSb3dDb2xEZXB0aCwgZmllbGRTaXplLCBzdHJpZGUpO1xuICB9XG4gIGNvbnN0IGlucHV0Um93cyA9IGlucHV0U2hhcGVSb3dDb2xEZXB0aFswXTtcbiAgY29uc3QgaW5wdXRDb2xzID0gaW5wdXRTaGFwZVJvd0NvbERlcHRoWzFdO1xuICBjb25zdCBvdXRwdXRSb3dzID0gKGlucHV0Um93cyAtIGZpZWxkU2l6ZSArIDIgKiB6ZXJvUGFkKSAvIHN0cmlkZSArIDE7XG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgdXRpbC5pc0ludChvdXRwdXRSb3dzKSxcbiAgICAgIGBUaGUgb3V0cHV0ICMgb2Ygcm93cyAoJHtvdXRwdXRSb3dzfSkgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIGAgK1xuICAgICAgICAgIGBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNgKTtcblxuICBjb25zdCBvdXRwdXRDb2xzID0gKGlucHV0Q29scyAtIGZpZWxkU2l6ZSArIDIgKiB6ZXJvUGFkKSAvIHN0cmlkZSArIDE7XG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgdXRpbC5pc0ludChvdXRwdXRDb2xzKSxcbiAgICAgIGBUaGUgb3V0cHV0ICMgb2YgY29sdW1ucyAoJHtvdXRwdXRDb2xzfSkgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgYCArXG4gICAgICAgICAgYHRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNgKTtcblxuICByZXR1cm4gW291dHB1dFJvd3MsIG91dHB1dENvbHMsIGRlcHRoXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVEZWZhdWx0UGFkKFxuICAgIGlucHV0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZmllbGRTaXplOiBudW1iZXIsXG4gICAgc3RyaWRlOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5mbG9vcigoaW5wdXRTaGFwZVswXSAqIChzdHJpZGUgLSAxKSAtIHN0cmlkZSArIGZpZWxkU2l6ZSkgLyAyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVUZXhTaGFwZUZyb20zRChcbiAgICBzaGFwZVJvd0NvbERlcHRoOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgcmV0dXJuIFtzaGFwZVJvd0NvbERlcHRoWzBdLCBzaGFwZVJvd0NvbERlcHRoWzFdICogc2hhcGVSb3dDb2xEZXB0aFsyXV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlV2VpZ2h0c1NoYXBlNEQoXG4gICAgaW5wdXREZXB0aDogbnVtYmVyLCBvdXRwdXREZXB0aDogbnVtYmVyLFxuICAgIGZTaXplOiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gIHJldHVybiBbZlNpemUsIGZTaXplLCBpbnB1dERlcHRoLCBvdXRwdXREZXB0aF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlV2VpZ2h0c1RleFNoYXBlKFxuICAgIGlucHV0RGVwdGg6IG51bWJlciwgb3V0cHV0RGVwdGg6IG51bWJlcixcbiAgICBmaWVsZFNpemU6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0ge1xuICByZXR1cm4gW2ZpZWxkU2l6ZSAqIGZpZWxkU2l6ZSAqIGlucHV0RGVwdGgsIG91dHB1dERlcHRoXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCaWFzZXNUZXhTaGFwZShvdXRwdXREZXB0aDogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSB7XG4gIHJldHVybiBbMSwgb3V0cHV0RGVwdGhdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZURpbGF0ZWRSQyhcbiAgICByYzogW251bWJlciwgbnVtYmVyXSwgb3JpZ1N0cmlkZTogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSB7XG4gIGNvbnN0IHJvd3NEaWxhdGVkID0gKHJjWzBdIC0gMSkgKiBvcmlnU3RyaWRlICsgMTtcbiAgY29uc3QgY29sc0RpbGF0ZWQgPSAocmNbMV0gLSAxKSAqIG9yaWdTdHJpZGUgKyAxO1xuICByZXR1cm4gW3Jvd3NEaWxhdGVkLCBjb2xzRGlsYXRlZF07XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVNoYXBlcyhcbiAgICBzb3VyY2VTaXplOiBbbnVtYmVyLCBudW1iZXJdLCBkZXN0U2l6ZTogW251bWJlciwgbnVtYmVyXSkge1xuICBjb25zdCBzcmNBcmVhID0gc291cmNlU2l6ZVswXSAqIHNvdXJjZVNpemVbMV07XG4gIGNvbnN0IGRzdEFyZWEgPSBkZXN0U2l6ZVswXSAqIGRlc3RTaXplWzFdO1xuICBpZiAoc3JjQXJlYSAhPT0gZHN0QXJlYSkge1xuICAgIGNvbnN0IHNyY1N0ciA9ICdbJyArIHNvdXJjZVNpemVbMF0gKyAnLCAnICsgc291cmNlU2l6ZVsxXSArICddJztcbiAgICBjb25zdCBkc3RTdHIgPSAnWycgKyBkZXN0U2l6ZVswXSArICcsICcgKyBkZXN0U2l6ZVsxXSArICddJztcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdjb3B5MkQgc2hhcGVzIGhhdmUgZGlmZmVyZW50IGFyZWFzOlxcbiAgc291cmNlU2l6ZSAnICsgc3JjU3RyICtcbiAgICAgICAgJywgYXJlYSAnICsgc3JjQXJlYSArICdcXG4gIGRlc3RTaXplICcgKyBkc3RTdHIgKyAnLCBhcmVhICcgKyBkc3RBcmVhKTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuL21hdGgnO1xuaW1wb3J0IHtOREFycmF5LCBTY2FsYXJ9IGZyb20gJy4vbmRhcnJheSc7XG5cbi8qKlxuICogQW4gZXJyb3IgZnVuY3Rpb24gYW5kIGl0cyBkZXJpdmF0aXZlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVsZW1lbnRXaXNlQ29zdEZ1bmN0aW9uIHtcbiAgY29zdDxUIGV4dGVuZHMgTkRBcnJheT4obWF0aDogTkRBcnJheU1hdGgsIHgxOiBULCB4MjogVCk6IFQ7XG4gIGRlcjxUIGV4dGVuZHMgTkRBcnJheT4obWF0aDogTkRBcnJheU1hdGgsIHgxOiBULCB4MjogVCk6IFQ7XG4gIGRpc3Bvc2UoKTogdm9pZDtcbn1cblxuZXhwb3J0IGNsYXNzIFNxdWFyZUNvc3RGdW5jIGltcGxlbWVudHMgRWxlbWVudFdpc2VDb3N0RnVuY3Rpb24ge1xuICBwcml2YXRlIGhhbGZPbmUgPSBTY2FsYXIubmV3KDAuNSk7XG5cbiAgY29zdDxUIGV4dGVuZHMgTkRBcnJheT4obWF0aDogTkRBcnJheU1hdGgsIHgxOiBULCB4MjogVCk6IFQge1xuICAgIGNvbnN0IGRpZmYgPSBtYXRoLnN1YlN0cmljdCh4MSwgeDIpO1xuICAgIGNvbnN0IGRpZmZTcXVhcmVkID0gbWF0aC5lbGVtZW50V2lzZU11bChkaWZmLCBkaWZmKTtcbiAgICBjb25zdCByZXN1bHQgPSBtYXRoLnNjYWxhclRpbWVzQXJyYXkodGhpcy5oYWxmT25lLCBkaWZmU3F1YXJlZCk7XG5cbiAgICBkaWZmLmRpc3Bvc2UoKTtcbiAgICBkaWZmU3F1YXJlZC5kaXNwb3NlKCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZGVyPFQgZXh0ZW5kcyBOREFycmF5PihtYXRoOiBOREFycmF5TWF0aCwgeDE6IFQsIHgyOiBUKTogVCB7XG4gICAgcmV0dXJuIG1hdGguc3ViU3RyaWN0KHgxLCB4Mik7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuaGFsZk9uZS5kaXNwb3NlKCk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCAqIGFzIGNvbmNhdDNkX3V0aWwgZnJvbSAnLi9jb25jYXQzZF91dGlsJztcbmltcG9ydCAqIGFzIGNvcHkyZF91dGlsIGZyb20gJy4vY29weTJkX3V0aWwnO1xuXG5pbXBvcnQge0FycmF5MUQsIEFycmF5MkQsIEFycmF5M0QsIEFycmF5NEQsIE5EQXJyYXksIFNjYWxhcn0gZnJvbSAnLi9uZGFycmF5JztcblxuZXhwb3J0IHR5cGUgU2NvcGVSZXN1bHQgPSBOREFycmF5W118TkRBcnJheXx2b2lkO1xuXG5leHBvcnQgaW50ZXJmYWNlIExTVE1DZWxsIHtcbiAgKGRhdGE6IEFycmF5MkQsIGM6IEFycmF5MkQsIGg6IEFycmF5MkQpOiBbQXJyYXkyRCwgQXJyYXkyRF07XG59XG5cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE5EQXJyYXlNYXRoIHtcbiAgcHJpdmF0ZSBuZGFycmF5U2NvcGVzOiBOREFycmF5W11bXSA9IFtdO1xuICBwcml2YXRlIGFjdGl2ZVNjb3BlOiBOREFycmF5W107XG5cbiAgcHJpdmF0ZSBuZGFycmF5c1RvS2VlcDogTkRBcnJheVtdW10gPSBbXTtcbiAgcHJpdmF0ZSBhY3RpdmVTY29wZU5EQXJyYXlzVG9LZWVwOiBOREFycmF5W10gPSBbXTtcblxuICBwcml2YXRlIGRlYnVnTW9kZSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gc2FmZU1vZGUgSW4gc2FmZSBtb2RlLCB5b3UgbXVzdCB1c2UgbWF0aCBvcGVyYXRpb25zIGluc2lkZVxuICAgKiAgICAgYSBtYXRoLnNjb3BlKCkgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGNsZWFuIHVwIGludGVybWVkaWF0ZSBOREFycmF5cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc2FmZU1vZGU6IGJvb2xlYW4pIHt9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBtYXRoIHNjb3BlLiBQdXQgY2hhaW5lZCBtYXRoIG9wZXJhdGlvbnMgaW5zaWRlIGEgc2NvcGVcbiAgICogZnVuY3Rpb24gY2xvc3VyZSBzbyB0aGF0IHRoZSBsaWJyYXJ5IGF1dG9tYXRpY2FsbHkgY2xlYW5zIHVwIE5EQXJyYXlzXG4gICAqIGZyb20gaW50ZXJtZWRpYXRlIG1hdGggb3BlcmF0aW9ucy4gWW91IG11c3QgY3JlYXRlIGEgc2NvcGUgaW4gc2FmZSBtb2RlXG4gICAqIHRvIGNhbGwgbWF0aCBvcGVyYXRpb25zLiBJZiBhIHJlc3VsdCBpcyByZXR1cm5lZCBmcm9tIHRoZSBzY29wZSwgaXQgd2lsbFxuICAgKiBhbHNvIGJlIHRyYWNrZWQsIHdoaWNoIG1lYW5zIHRoZXJlIG11c3QgYmUgeWV0IGFub3RoZXIgd3JhcHBpbmcgc2NvcGUuXG4gICAqIEBwYXJhbSBzY29wZUZuIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIHdpdGggY2hhaW5lZCBtYXRoIG9wZXJhdGlvbnMuXG4gICAqL1xuICBzY29wZTxUIGV4dGVuZHMgU2NvcGVSZXN1bHQ+KFxuICAgICAgc2NvcGVGbjpcbiAgICAgICAgICAoa2VlcDogPFQxIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVDEpID0+IFQxLFxuICAgICAgICAgICB0cmFjazogPFQyIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVDIpID0+IFQyKSA9PiBUKSB7XG4gICAgdGhpcy5zdGFydFNjb3BlKCk7XG5cbiAgICBjb25zdCBrZWVwRm4gPSA8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUID0+IHRoaXMua2VlcChuZGFycmF5KTtcbiAgICBjb25zdCB0cmFja0ZuID0gPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVCA9PiB0aGlzLnRyYWNrKG5kYXJyYXkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHNjb3BlRm4oa2VlcEZuLCB0cmFja0ZuKTtcblxuICAgIHRoaXMuZW5kU2NvcGUocmVzdWx0KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBJbiBkZWJ1ZyBtb2RlLCB0aGUgb3V0cHV0IG9mIGV2ZXJ5IG1hdGggY2FsbCB3aWxsIGJlIGRvd25sb2FkZWQgdG8gdGhlIENQVVxuICAgKiBhbmQgY2hlY2tlZCBmb3IgTmFOcy4gVGhpcyBzaWduaWZpY2FudGx5IGltcGFjdHMgcGVyZm9ybWFuY2UuXG4gICAqL1xuICBlbmFibGVEZWJ1Z01vZGUoKSB7XG4gICAgdGhpcy5kZWJ1Z01vZGUgPSB0cnVlO1xuICAgIGNvbnNvbGUud2FybignRGVidWdnaW5nIG1vZGUgaXMgT04uIFRoZSBvdXRwdXQgb2YgZXZlcnkgbWF0aCBjYWxsIHdpbGwgJyArXG4gICAgICAgICAgICAgICAgICAnYmUgZG93bmxvYWRlZCB0byBDUFUgYW5kIGNoZWNrZWQgZm9yIE5hTnMuICcgK1xuICAgICAgICAgICAgICAgICAgJ1RoaXMgc2lnbmlmaWNhbnRseSBpbXBhY3RzIHBlcmZvcm1hbmNlLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgc2NvcGUuIFVzZSB0aGlzIHdpdGggZW5kU2NvcGUoKSB0byBhY2hpZXZlIHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHlcbiAgICogYXMgc2NvcGUoKSB3aXRob3V0IHRoZSBuZWVkIGZvciBhIGZ1bmN0aW9uIGNsb3N1cmUuXG4gICAqL1xuICBzdGFydFNjb3BlKCkge1xuICAgIGNvbnN0IG5ld1Njb3BlOiBOREFycmF5W10gPSBbXTtcbiAgICB0aGlzLm5kYXJyYXlTY29wZXMucHVzaChuZXdTY29wZSk7XG4gICAgdGhpcy5hY3RpdmVTY29wZSA9IG5ld1Njb3BlO1xuXG4gICAgY29uc3QgbmV3TkRBcnJheXNUb0tlZXA6IE5EQXJyYXlbXSA9IFtdO1xuICAgIHRoaXMubmRhcnJheXNUb0tlZXAucHVzaChuZXdOREFycmF5c1RvS2VlcCk7XG4gICAgdGhpcy5hY3RpdmVTY29wZU5EQXJyYXlzVG9LZWVwID0gbmV3TkRBcnJheXNUb0tlZXA7XG4gIH1cblxuICAvKipcbiAgICogRW5kIGEgc2NvcGUuIFVzZSB0aGlzIHdpdGggc3RhcnRTY29wZSgpIHRvIGFjaGlldmUgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eVxuICAgKiBhcyBzY29wZSgpIHdpdGhvdXQgdGhlIG5lZWQgZm9yIGEgZnVuY3Rpb24gY2xvc3VyZS5cbiAgICovXG4gIGVuZFNjb3BlKHJlc3VsdDogU2NvcGVSZXN1bHQpIHtcbiAgICBsZXQgYXJyYXlzVG9LZWVwID0gdGhpcy5hY3RpdmVTY29wZU5EQXJyYXlzVG9LZWVwO1xuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgYXJyYXlzVG9LZWVwID0gYXJyYXlzVG9LZWVwLmNvbmNhdChyZXN1bHQgYXMgTkRBcnJheXxOREFycmF5W10pO1xuICAgIH1cbiAgICAvLyBEaXNwb3NlIHRoZSBjdXJyZW50IHNjb3BlLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hY3RpdmVTY29wZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbmRhcnJheSA9IHRoaXMuYWN0aXZlU2NvcGVbaV07XG4gICAgICBpZiAodGhpcy5pc05EQXJyYXlEYXRhSW5MaXN0KG5kYXJyYXksIGFycmF5c1RvS2VlcCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBuZGFycmF5LmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICAvLyBQb3AgdGhlIGN1cnJlbnQgc2NvcGUuXG4gICAgdGhpcy5uZGFycmF5U2NvcGVzLnBvcCgpO1xuICAgIHRoaXMuYWN0aXZlU2NvcGUgPSB0aGlzLm5kYXJyYXlTY29wZXMubGVuZ3RoID09PSAwID9cbiAgICAgICAgbnVsbCEgOlxuICAgICAgICB0aGlzLm5kYXJyYXlTY29wZXNbdGhpcy5uZGFycmF5U2NvcGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gVHJhY2sgdGhlIGN1cnJlbnQgcmVzdWx0IGluIHRoZSBwYXJlbnQgc2NvcGUuXG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIE5EQXJyYXkgJiZcbiAgICAgICAgIXRoaXMuaXNOREFycmF5RGF0YUluTGlzdChyZXN1bHQsIHRoaXMuYWN0aXZlU2NvcGVOREFycmF5c1RvS2VlcCkpIHtcbiAgICAgIHRoaXMudHJhY2socmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgcmVzdWx0LmZvckVhY2gociA9PiB7XG4gICAgICAgIGlmIChyIGluc3RhbmNlb2YgTkRBcnJheSAmJlxuICAgICAgICAgICAgIXRoaXMuaXNOREFycmF5RGF0YUluTGlzdChyLCB0aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXApKSB7XG4gICAgICAgICAgdGhpcy50cmFjayhyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5uZGFycmF5c1RvS2VlcC5wb3AoKTtcbiAgICB0aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXAgPSB0aGlzLm5kYXJyYXlzVG9LZWVwLmxlbmd0aCA9PT0gMCA/XG4gICAgICAgIG51bGwhIDpcbiAgICAgICAgdGhpcy5uZGFycmF5c1RvS2VlcFt0aGlzLm5kYXJyYXlzVG9LZWVwLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgcHJpdmF0ZSBpc05EQXJyYXlEYXRhSW5MaXN0KG5kYXJyYXk6IE5EQXJyYXksIG5kYXJyYXlMaXN0OiBOREFycmF5W10pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5kYXJyYXlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobmRhcnJheUxpc3RbaV0uZ2V0RGF0YSgpID09PSBuZGFycmF5LmdldERhdGEoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEtlZXBzIGFuIE5EQXJyYXkgaW4gdGhlIGN1cnJlbnQgc2NvcGUgZnJvbSBiZWluZyBkaXNwb3NlZCBhdXRvbWF0aWNhbGx5LlxuICAgKiBAcGFyYW0gcmVzdWx0IFRoZSBOREFycmF5IHRvIGtlZXAgZnJvbSBiZWluZyBkaXNwb3NlZC5cbiAgICovXG4gIGtlZXA8VCBleHRlbmRzIE5EQXJyYXk+KHJlc3VsdDogVCk6IFQge1xuICAgIGlmICh0aGlzLmFjdGl2ZVNjb3BlID09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnNhZmVNb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdZb3UgYXJlIHVzaW5nIG1hdGggaW4gc2FmZSBtb2RlLiBFbmNsb3NlIGFsbCAnICtcbiAgICAgICAgICAgICdtYXRoLm1ldGhvZCgpIGNhbGxzIGluc2lkZSBhIHNjb3BlOiAnICtcbiAgICAgICAgICAgICdtYXRoLnNjb3BlKCgpID0+IHttYXRoLm1ldGhvZCgpOy4uLn0pIHRvIGF2b2lkIG1lbW9yeSAnICtcbiAgICAgICAgICAgICdsZWFrcy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlU2NvcGVOREFycmF5c1RvS2VlcC5wdXNoKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tGb3JOYU4oYXJyOiBOREFycmF5KTogdm9pZCB7XG4gICAgY29uc3QgdmFscyA9IGFyci5nZXRWYWx1ZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpc05hTih2YWxzW2ldKSkge1xuICAgICAgICB0aHJvdyBFcnJvcignVGhlIHJlc3VsdCBOREFycmF5IG9mIHRoZSBsYXN0IG1hdGggY2FsbCBoYXMgTmFOcy4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhY2tzIGFuIE5EQXJyYXkgaW4gdGhlIGN1cnJlbnQgc2NvcGUgdG8gYmUgYXV0b21hdGljYWxseSBjbGVhbmVkIHVwIHdoZW5cbiAgICogdGhlIGN1cnJlbnQgc2NvcGUgZW5kcywgYW5kIHJldHVybnMgdGhlIHZhbHVlLlxuICAgKiBAcGFyYW0gcmVzdWx0IFRoZSBOREFycmF5IHRvIHRyYWNrIGluIHRoZSBjdXJyZW50IHNjb3BlLlxuICAgKi9cbiAgdHJhY2s8VCBleHRlbmRzIE5EQXJyYXk+KHJlc3VsdDogVCk6IFQge1xuICAgIGlmICh0aGlzLmRlYnVnTW9kZSkge1xuICAgICAgdGhpcy5jaGVja0Zvck5hTihyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hY3RpdmVTY29wZSA9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5zYWZlTW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnWW91IGFyZSB1c2luZyBtYXRoIGluIHNhZmUgbW9kZS4gRW5jbG9zZSBhbGwgJyArXG4gICAgICAgICAgICAnbWF0aC5tZXRob2QoKSBjYWxscyBpbnNpZGUgYSBzY29wZTogJyArXG4gICAgICAgICAgICAnbWF0aC5zY29wZSgoKSA9PiB7bWF0aC5tZXRob2QoKTsuLi59KSB0byBhdm9pZCBtZW1vcnkgJyArXG4gICAgICAgICAgICAnbGVha3MuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZVNjb3BlLnB1c2gocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gbWF0cmljZXMsIEEgKiBCLiBUaGVzZSBtdXN0IGJlIG1hdHJpY2VzLFxuICAgKiB1c2UgbWF0cml4VGltZXNWZWN0b3IgYW5kIHZlY3RvclRpbWVzTWF0cml4LCBkb3RQcm9kdWN0LCBhbmQgb3V0ZXJQcm9kdWN0XG4gICAqIGluIG90aGVyIGNhc2VzLlxuICAgKiBAcGFyYW0gYSBGaXJzdCBtYXRyaXggaW4gZG90IHByb2R1Y3Qgb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gYiBTZWNvbmQgbWF0cml4IGluIGRvdCBwcm9kdWN0IG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIGFPcmllbnRhdGlvbiBUaGUgTWF0cml4T3JpZW50YXRpb24gb2YgQS4gSWYgdXNpbmcgVFJBTlNQT1NFRCwgd2lsbFxuICAgKiBjb21wdXRlIEFeVCAqIEIuXG4gICAqIEBwYXJhbSBiT3JpZW50YXRpb24gVGhlIE1hdHJpeE9yaWVudGF0aW9uIG9mIEIuIElmIHVzaW5nIFRSQU5TUE9TRUQsIHdpbGxcbiAgICogY29tcHV0ZSBBICogQl5ULlxuICAgKi9cbiAgbWF0TXVsKFxuICAgICAgYTogQXJyYXkyRCwgYjogQXJyYXkyRCwgYU9yaWVudGF0aW9uID0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUixcbiAgICAgIGJPcmllbnRhdGlvbiA9IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpOiBBcnJheTJEIHtcbiAgICBjb25zdCBpbm5lclNoYXBlQSA9XG4gICAgICAgIChhT3JpZW50YXRpb24gPT09IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYS5zaGFwZVsxXSA6IGEuc2hhcGVbMF07XG4gICAgY29uc3QgaW5uZXJTaGFwZUIgPVxuICAgICAgICAoYk9yaWVudGF0aW9uID09PSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGIuc2hhcGVbMF0gOiBiLnNoYXBlWzFdO1xuXG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGEucmFuayA9PT0gMiAmJiBiLnJhbmsgPT09IDIsXG4gICAgICAgIGBFcnJvciBpbiBtYXRNdWw6IGlucHV0cyBtdXN0IGJlIHJhbmsgMiwgZ290IHJhbmtzICR7YS5yYW5rfWAgK1xuICAgICAgICAgICAgYGFuZCAke2IucmFua30uYCk7XG5cbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgaW5uZXJTaGFwZUEgPT09IGlubmVyU2hhcGVCLFxuICAgICAgICBgRXJyb3IgaW4gbWF0TXVsOiBpbm5lciBzaGFwZXMgKCR7aW5uZXJTaGFwZUF9KSBhbmQgKGAgK1xuICAgICAgICAgICAgYCR7aW5uZXJTaGFwZUJ9KSBvZiBOREFycmF5cyB3aXRoIHNoYXBlcyAke2Euc2hhcGV9IGFuZCBgICtcbiAgICAgICAgICAgIGAke2Iuc2hhcGV9IGFuZCBvcmllbnRhdGlvbnMgJHtNYXRyaXhPcmllbnRhdGlvblthT3JpZW50YXRpb25dfWAgK1xuICAgICAgICAgICAgYCBhbmQgJHtNYXRyaXhPcmllbnRhdGlvbltiT3JpZW50YXRpb25dfSBtdXN0IG1hdGNoLmApO1xuXG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5tYXRNdWxJbnRlcm5hbChhLCBiLCBhT3JpZW50YXRpb24sIGJPcmllbnRhdGlvbikpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBtYXRNdWxJbnRlcm5hbChcbiAgICAgIGE6IEFycmF5MkQsIGI6IEFycmF5MkQsIGFPcmllbnRhdGlvbjogTWF0cml4T3JpZW50YXRpb24sXG4gICAgICBiT3JpZW50YXRpb246IE1hdHJpeE9yaWVudGF0aW9uKTogQXJyYXkyRDtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIGEgdmVjdG9yIGFuZCBhIG1hdHJpeCwgdiAqIEIuXG4gICAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgaW4gZG90IHByb2R1Y3Qgb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gbWF0cml4IFRoZSBtYXRyaXggaW4gZG90IHByb2R1Y3Qgb3BlcmF0aW9uLlxuICAgKi9cbiAgdmVjdG9yVGltZXNNYXRyaXgodjogQXJyYXkxRCwgbWF0cml4OiBBcnJheTJEKTogQXJyYXkxRCB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHYucmFuayA9PT0gMSxcbiAgICAgICAgYEVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBmaXJzdCBpbnB1dCBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCBgICtcbiAgICAgICAgICAgIGByYW5rICR7di5yYW5rfS5gKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgbWF0cml4LnJhbmsgPT09IDIsXG4gICAgICAgIGBFcnJvciBpbiB2ZWN0b3JUaW1lc01hdHJpeDogc2Vjb25kIGlucHV0IG11c3QgYmUgcmFuayAyLCBidXQgZ290IGAgK1xuICAgICAgICAgICAgYHJhbmsgJHttYXRyaXgucmFua30uYCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHYuc2l6ZSA9PT0gbWF0cml4LnNoYXBlWzBdLFxuICAgICAgICBgRXJyb3IgaW4gdmVjdG9yVGltZXNNYXRyaXg6IHNpemUgb2YgZmlyc3QgcmFuayAxIGlucHV0ICgke3Yuc2l6ZX0pIGAgK1xuICAgICAgICAgICAgYG11c3QgbWF0Y2ggaW5uZXIgZGltZW5zaW9uIG9mIHNlY29uZCByYW5rIDIgaW5wdXQsIGJ1dCBnb3QgYCArXG4gICAgICAgICAgICBgcmFuayAke21hdHJpeC5yYW5rfS5gKTtcblxuICAgIHJldHVybiB0aGlzLm1hdE11bCh2LmFzMkQoMSwgdi5zaXplKSwgbWF0cml4KS5hczFEKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIGEgbWF0cml4IGFuZCB2ZWN0b3IsIEEgKiB2LlxuICAgKiBAcGFyYW0gbWF0cml4IFRoZSBtYXRyaXggaW4gZG90IHByb2R1Y3Qgb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gdiBUaGUgdmVjdG9yIGluIGRvdCBwcm9kdWN0IG9wZXJhdGlvbi5cbiAgICovXG4gIG1hdHJpeFRpbWVzVmVjdG9yKG1hdHJpeDogQXJyYXkyRCwgdjogQXJyYXkxRCk6IEFycmF5MUQge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB2LnJhbmsgPT09IDEsXG4gICAgICAgIGBFcnJvciBpbiB2ZWN0b3JUaW1lc01hdHJpeDogc2Vjb25kIGlucHV0IG11c3QgcmFuayAxLCBidXQgZ290IGAgK1xuICAgICAgICAgICAgYHJhbmsgJHt2LnJhbmt9LmApO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBtYXRyaXgucmFuayA9PT0gMixcbiAgICAgICAgYEVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBmaXJzdCBpbnB1dCBtdXN0IGJlIGEgcmFuayAyLCBidXQgZ290IGAgK1xuICAgICAgICAgICAgYHJhbmsgJHttYXRyaXgucmFua30uYCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHYuc2l6ZSA9PT0gbWF0cml4LnNoYXBlWzFdLFxuICAgICAgICBgRXJyb3IgaW4gdmVjdG9yVGltZXNNYXRyaXg6IHNpemUgb2YgZmlyc3QgcmFuayAxIGlucHV0ICR7di5zaXplfSBgICtcbiAgICAgICAgICAgIGBtdXN0IG1hdGNoIGlubmVyIGRpbWVuc2lvbiBvZiBzZWNvbmQgcmFuayAyIGlucHV0LCBidXQgZ290IGAgK1xuICAgICAgICAgICAgYHNoYXBlICR7bWF0cml4LnNoYXBlfS5gKTtcblxuICAgIHJldHVybiB0aGlzLm1hdE11bChtYXRyaXgsIHYuYXMyRCh2LnNpemUsIDEpKS5hczFEKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzLCB2MSAqIHYyLlxuICAgKiBAcGFyYW0gdjEgVGhlIGZpcnN0IHZlY3RvciBpbiB0aGUgZG90IHByb2R1Y3Qgb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IgaW4gdGhlIGRvdCBwcm9kdWN0IG9wZXJhdGlvbi5cbiAgICovXG4gIGRvdFByb2R1Y3QodjE6IEFycmF5MUQsIHYyOiBBcnJheTFEKTogU2NhbGFyIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdjEucmFuayA9PT0gMSAmJiB2Mi5yYW5rID09PSAxLFxuICAgICAgICBgRXJyb3IgaW4gZG90UHJvZHVjdDogaW5wdXRzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmtzIGAgK1xuICAgICAgICAgICAgYCR7djEucmFua30gYW5kICR7djIucmFua30uYCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHYxLnNpemUgPT09IHYyLnNpemUsXG4gICAgICAgIGBFcnJvciBpbiBkb3RQcm9kdWN0OiBzaXplIG9mIGlucHV0cyAoJHt2MS5zaXplfSkgYW5kIChgICtcbiAgICAgICAgICAgIGAke3YyLnNpemV9KSBtdXN0IG1hdGNoLmApO1xuICAgIHJldHVybiB0aGlzLm1hdE11bCh2MS5hczJEKDEsIHYxLnNpemUpLCB2Mi5hczJEKHYyLnNpemUsIDEpKS5hc1NjYWxhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBvdXRlciBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzLCB2MSBhbmQgdjIuXG4gICAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yIGluIHRoZSBvdXRlciBwcm9kdWN0IG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIHYyIFRoZSBzZWNvbmQgdmVjdG9yIGluIHRoZSBkb3QgcHJvZHVjdCBvcGVyYXRpb24uXG4gICAqL1xuICBvdXRlclByb2R1Y3QodjE6IEFycmF5MUQsIHYyOiBBcnJheTFEKTogQXJyYXkyRCB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHYxLnJhbmsgPT09IDEgJiYgdjIucmFuayA9PT0gMSxcbiAgICAgICAgYEVycm9yIGluIG91dGVyUHJvZHVjdDogaW5wdXRzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmtzIGAgK1xuICAgICAgICAgICAgYCR7djEucmFua30gYW5kICR7djIucmFua30uYCk7XG5cbiAgICByZXR1cm4gdGhpcy5tYXRNdWwodjEuYXMyRCh2MS5zaXplLCAxKSwgdjIuYXMyRCgxLCB2Mi5zaXplKSk7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy9cbiAgLy8gU2hhcGUgb3BzIC8vXG4gIC8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiBDbG9uZXMgYW4gTkRBcnJheSBvZiBhbnkgc2hhcGUuXG4gICAqIEBwYXJhbSBuZGFycmF5IFRoZSBOREFycmF5IHRvIGNsb25lLlxuICAgKi9cbiAgY2xvbmU8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLmNsb25lSW50ZXJuYWwobmRhcnJheSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBjbG9uZUludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVDtcblxuICAvKipcbiAgICogUmVzaGFwZXMgYW4gTkRBcnJheSB0byBhIG5ldyBzaGFwZS4gVGhlIHNpemUgb2YgdGhlIGlucHV0IE5EQXJyYXkgbXVzdFxuICAgKiBtYXRjaCB0aGUgc2l6ZSBvZiB0aGUgcmVxdWVzdGVkIHNoYXBlLlxuICAgKiBAcGFyYW0gbmRhcnJheSBUaGUgaW5wdXQgTkRBcnJheS5cbiAgICogQHBhcmFtIG5ld1NoYXBlIFRoZSBuZXcgc2hhcGUgdG8gcmVzaGFwZSB0aGUgTkRBcnJheSB0by4gTXVzdCBiZSB0aGUgc2FtZVxuICAgKiBzaXplIGFzIHRoZSBOREFycmF5LlxuICAgKi9cbiAgcmVzaGFwZTxUMSBleHRlbmRzIE5EQXJyYXksIFQyIGV4dGVuZHMgTkRBcnJheT4oXG4gICAgICBuZGFycmF5OiBUMSwgbmV3U2hhcGU6IG51bWJlcltdKTogVDIge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBuZGFycmF5LnNpemUgPT09IHV0aWwuc2l6ZUZyb21TaGFwZShuZXdTaGFwZSksXG4gICAgICAgIGBFcnJvciBpbiByZXNoYXBlOiBvbGQgc2l6ZSAke25kYXJyYXkuc2l6ZX0gbXVzdCBtYXRjaCBuZXcgc2l6ZSBgICtcbiAgICAgICAgICAgIGAke3V0aWwuc2l6ZUZyb21TaGFwZShuZXdTaGFwZSl9LmApO1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMucmVzaGFwZUludGVybmFsPFQxLCBUMj4obmRhcnJheSwgbmV3U2hhcGUpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVzaGFwZUludGVybmFsPFQxIGV4dGVuZHMgTkRBcnJheSwgVDIgZXh0ZW5kcyBOREFycmF5PihcbiAgICAgIG5kYXJyYXk6IFQxLCBuZXdTaGFwZTogbnVtYmVyW10pOiBUMjtcblxuICAvKipcbiAgICogRXh0cmFjdHMgYSBzbGljZSBmcm9tIGEgbWF0cml4LiBUaGUgb3BlcmF0aW9uIGV4dHJhY2VzIGEgc2xpY2UgZnJvbSBpbnB1dFxuICAgKiB0aGF0IHN0YXJ0cyBhdCBjb29yZGluYXRlcyBgYmVnaW5gIGFuZCBpcyBvZiBzaXplIGBzaXplYC5cbiAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBtYXRyaXggdG8gc2xpY2UgZnJvbS5cbiAgICogQHBhcmFtIGJlZ2luIFRoZSAyRCBjb29yZGluYXRlcyBpbiB0aGUgaW5wdXQgbWF0cml4IHRvIHN0YXJ0IHRoZSBzbGljZVxuICAgKiBmcm9tLlxuICAgKiBAcGFyYW0gc2l6ZSBUaGUgc2ljZSBvZiB0aGUgMkQgd2luZG93IHRvIHNsaWNlLlxuICAgKi9cbiAgc2xpY2UyRChpbnB1dDogQXJyYXkyRCwgYmVnaW46IFtudW1iZXIsIG51bWJlcl0sIHNpemU6IFtudW1iZXIsIG51bWJlcl0pOlxuICAgICAgQXJyYXkyRCB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGJlZ2luWzBdICsgc2l6ZVswXSA8PSBpbnB1dC5zaGFwZVswXSAmJlxuICAgICAgICAgICAgYmVnaW5bMV0gKyBzaXplWzFdIDw9IGlucHV0LnNoYXBlWzFdLFxuICAgICAgICBgRXJyb3IgaW4gc2xpY2UyRDogcmVxdWVzdGVkIHN0YXJ0IHBvc2l0aW9uICR7YmVnaW59IGFuZCBzaXplIGAgK1xuICAgICAgICAgICAgYCR7c2l6ZX0gd291bGQgb3ZlcmZsb3cgaW5wdXQgb2Ygc2hhcGUgJHtpbnB1dC5zaGFwZX0uYCk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5zbGljZTJESW50ZXJuYWwoaW5wdXQsIGJlZ2luLCBzaXplKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHNsaWNlMkRJbnRlcm5hbChcbiAgICAgIGlucHV0OiBBcnJheTJELCBiZWdpbjogW251bWJlciwgbnVtYmVyXSwgc2l6ZTogW251bWJlciwgbnVtYmVyXSk6IEFycmF5MkQ7XG5cbiAgLyoqXG4gICAqIENvcGllcyBhIHdpbmRvdyBmcm9tIHRoZSBgc291cmNlYCBtYXRyaXggc3RhcnRpbmcgYXQgYHNvdXJjZUJlZ2luYCBhbmQgaXNcbiAgICogb2Ygc2l6ZSBgc291cmNlU2l6ZWAgdG8gYSB3aW5kb3cgaW4gdGhlIGBkZXN0YCBtYXRyaXggc3RhcnRpbmcgYXRcbiAgICogYGRlc3RCZWdpbmAgYW5kIGlzIG9mIHNpemUgYGRlc3RTaXplYC9cbiAgICogQHBhcmFtIHNvdXJjZSBUaGUgc291cmNlIG1hdHJpeCB0byBjb3B5IGZyb20uXG4gICAqIEBwYXJhbSBzb3VyY2VCZWdpbiBUaGUgY29vcmRpbmF0ZXMgdG8gc3RhcnQgdGhlIGNvcHkgZnJvbS5cbiAgICogQHBhcmFtIHNvdXJjZVNpemUgVGhlIHNpemUgb2YgdGhlIGNvcHkgd2luZG93LlxuICAgKiBAcGFyYW0gZGVzdCBUaGUgZGVzdGluYXRpb24gbWF0cml4IHRvIGNvcHkgdG8uXG4gICAqIEBwYXJhbSBkZXN0QmVnaW4gVGhlIGNvb3JkaW5hdGVzIGluIGBkZXN0YCB0byBjb3B5IHRvLlxuICAgKiBAcGFyYW0gZGVzdFNpemUgVGhlIHNpemUgb2YgdGhlIGRlc3RpbmF0aW9uIHdpbmRvdy5cbiAgICovXG4gIGNvcHkyRChcbiAgICAgIHNvdXJjZTogQXJyYXkyRCwgc291cmNlQmVnaW46IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBzb3VyY2VTaXplOiBbbnVtYmVyLCBudW1iZXJdLCBkZXN0OiBBcnJheTJELCBkZXN0QmVnaW46IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBkZXN0U2l6ZTogW251bWJlciwgbnVtYmVyXSkge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBzb3VyY2VCZWdpblswXSArIHNvdXJjZVNpemVbMF0gPD0gc291cmNlLnNoYXBlWzBdICYmXG4gICAgICAgICAgICBzb3VyY2VCZWdpblsxXSArIHNvdXJjZVNpemVbMV0gPD0gc291cmNlLnNoYXBlWzFdLFxuICAgICAgICBgRXJyb3IgaW4gY29weTJEOiByZXF1ZXN0ZWQgc291cmNlIHN0YXJ0IHBvc2l0aW9uICR7c291cmNlQmVnaW59IGAgK1xuICAgICAgICAgICAgYGFuZCBzb3VyY2Ugc2l6ZSAke3NvdXJjZVNpemV9IHdvdWxkIG92ZXJmbG93IHNvdXJjZSBOREFycmF5YCArXG4gICAgICAgICAgICBgb2Ygc2hhcGUgJHtzb3VyY2Uuc2hhcGV9LmApO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBkZXN0QmVnaW5bMF0gKyBkZXN0U2l6ZVswXSA8PSBkZXN0LnNoYXBlWzBdICYmXG4gICAgICAgICAgICBkZXN0QmVnaW5bMV0gKyBkZXN0U2l6ZVsxXSA8PSBkZXN0LnNoYXBlWzFdLFxuICAgICAgICBgRXJyb3IgaW4gY29weTJEOiByZXF1ZXN0ZWQgZGVzdCBzdGFydCBwb3NpdGlvbiAke2Rlc3RCZWdpbn0gYCArXG4gICAgICAgICAgICBgYW5kIHNvdXJjZSBzaXplICR7ZGVzdFNpemV9IHdvdWxkIG92ZXJmbG93IGRlc3QgTkRBcnJheSBvZmAgK1xuICAgICAgICAgICAgYHNoYXBlICR7ZGVzdC5zaGFwZX0uYCk7XG4gICAgY29weTJkX3V0aWwudmFsaWRhdGVTaGFwZXMoc291cmNlU2l6ZSwgZGVzdFNpemUpO1xuXG4gICAgcmV0dXJuIHRoaXMuY29weTJESW50ZXJuYWwoXG4gICAgICAgIHNvdXJjZSwgc291cmNlQmVnaW4sIHNvdXJjZVNpemUsIGRlc3QsIGRlc3RCZWdpbiwgZGVzdFNpemUpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBjb3B5MkRJbnRlcm5hbChcbiAgICAgIHNvdXJjZTogQXJyYXkyRCwgc291cmNlQmVnaW46IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBzb3VyY2VTaXplOiBbbnVtYmVyLCBudW1iZXJdLCBkZXN0OiBBcnJheTJELCBkZXN0QmVnaW46IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBkZXN0U2l6ZTogW251bWJlciwgbnVtYmVyXSk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlcyB0d28gM0QgbmRhcnJheXMgYWxvbmcgYSBnaXZlbiBheGlzLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgaWY6XG4gICAqIEE6IHNoYXBlKDIsIDEsIDMpID0gfCByMSwgZzEsIGIxIHxcbiAgICogICAgICAgICAgICAgICAgICAgICB8IHIyLCBnMiwgYjIgfFxuICAgKlxuICAgKiBCOiBzaGFwZSgyLCAxLCAzKSA9IHwgcjMsIGczLCBiMyB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgfCByNCwgZzQsIGI0IHxcbiAgICpcbiAgICogQyA9IGNvbmNhdDNEKEEsIEIsIGF4aXMpXG4gICAqXG4gICAqIGlmIGF4aXMgPSAwOlxuICAgKiBDOiBzaGFwZSg0LCAxLCAzKSA9IHwgcjEsIGcxLCBiMSB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgfCByMiwgZzIsIGIyIHxcbiAgICogICAgICAgICAgICAgICAgICAgICB8IHIzLCBnMywgYjMgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHwgcjQsIGc0LCBiNCB8XG4gICAqXG4gICAqIGlmIGF4aXMgPSAxOlxuICAgKiBDOiBzaGFwZSgyLCAyLCAzKSA9IHwgcjEsIGcxLCBiMSwgcjMsIGczLCBiMyB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgfCByMiwgZzIsIGIyLCByNCwgZzQsIGI0IHxcbiAgICpcbiAgICogaWYgYXhpcyA9IDI6XG4gICAqIEMgPSBzaGFwZSgyLCAxLCA2KSA9IHwgcjEsIGcxLCBiMSwgcjMsIGczLCBiMyB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgIHwgcjIsIGcyLCBiMiwgcjQsIGc0LCBiNCB8XG4gICAqXG4gICAqIEBwYXJhbSBuZGFycmF5MSBUaGUgZmlyc3QgYXJyYXkgdG8gY29uY2F0LlxuICAgKiBAcGFyYW0gbmRhcnJheTIgVGhlIHNlY29uZCBhcnJheSB0byBjb25hdC5cbiAgICogQHBhcmFtIGF4aXMgVGhlIGF4aXMgdG8gY29uY2F0ZSBhbG9uZy5cbiAgICovXG4gIGNvbmNhdDNEKG5kYXJyYXkxOiBBcnJheTNELCBuZGFycmF5MjogQXJyYXkzRCwgYXhpczogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgY29uY2F0M2RfdXRpbC5hc3NlcnRDb25jYXQzRFNoYXBlc01hdGNoKFxuICAgICAgICBuZGFycmF5MS5zaGFwZSwgbmRhcnJheTIuc2hhcGUsIGF4aXMsICdFcnJvciBpbiBjb25jYXQzZDogJyk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5jb25jYXQzREludGVybmFsKG5kYXJyYXkxLCBuZGFycmF5MiwgYXhpcykpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBjb25jYXQzREludGVybmFsKFxuICAgICAgbmRhcnJheTE6IEFycmF5M0QsIG5kYXJyYXkyOiBBcnJheTNELCBheGlzOiBudW1iZXIpOiBBcnJheTNEO1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gUmVkdWN0aW9uIG9wcyAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSB0aGUgbG9nKHN1bShlIF4geCkpIGZvciBlYWNoIHggaW4gdGhlIGlucHV0IG5kYXJyYXkuXG4gICAqIEBwYXJhbSBuZGFycmF5IFRoZSBpbnB1dCBOREFycmF5IHRvIGNvbXB1dGUgdGhlIGxvZ1N1bUV4cCBvdmVyLlxuICAgKi9cbiAgbG9nU3VtRXhwKG5kYXJyYXk6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMubG9nU3VtRXhwSW50ZXJuYWwobmRhcnJheSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBsb2dTdW1FeHBJbnRlcm5hbChuZGFycmF5OiBOREFycmF5KTogU2NhbGFyO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3VtIG9mIGFsbCB0aGUgZW50cmllcyBpbiB0aGUgaW5wdXQgTkRBcnJheS5cbiAgICogQHBhcmFtIG5kYXJyYXkgVGhlIGlucHV0IE5EQXJyYXkgdG8gY29tcHV0ZSB0aGUgc3VtIG92ZXIuXG4gICAqL1xuICBzdW0obmRhcnJheTogTkRBcnJheSk6IFNjYWxhciB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5zdW1JbnRlcm5hbChuZGFycmF5KSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHN1bUludGVybmFsKG5kYXJyYXk6IE5EQXJyYXkpOiBTY2FsYXI7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBmbGF0dGVuZWQgaW5kZXggb2YgdGhlIG1pbmltdW0gZWxlbWVudCBpbiB0aGUgbmRhcnJheS5cbiAgICogQHBhcmFtIG5kYXJyYXkgVGhlIGlucHV0IE5EQXJyYXkuXG4gICAqL1xuICBhcmdNaW4obmRhcnJheTogTkRBcnJheSk6IFNjYWxhciB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5hcmdNaW5JbnRlcm5hbChuZGFycmF5KSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGFyZ01pbkludGVybmFsKG5kYXJyYXk6IE5EQXJyYXkpOiBTY2FsYXI7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBmbGF0dGVuZWQgaW5kZXggb2YgdGhlIG1heGltdW0gZWxlbWVudCBpbiB0aGUgbmRhcnJheS5cbiAgICogQHBhcmFtIG5kYXJyYXkgVGhlIGlucHV0IE5EQXJyYXkuXG4gICAqL1xuICBhcmdNYXgobmRhcnJheTogTkRBcnJheSk6IFNjYWxhciB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5hcmdNYXhJbnRlcm5hbChuZGFycmF5KSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGFyZ01heEludGVybmFsKG5kYXJyYXk6IE5EQXJyYXkpOiBTY2FsYXI7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSAxIGlmIHRoZSBhcmdNYXggb2YgeDEgYW5kIHgyIGFyZSB0aGUgc2FtZSwgb3RoZXJ3aXNlIDAuXG4gICAqIEBwYXJhbSB4MSBUaGUgZmlyc3QgaW5wdXQgTkRBcnJheS5cbiAgICogQHBhcmFtIHgyIFRoZSBzZWNvbmQgaW5wdXQgTkRBcnJheS5cbiAgICovXG4gIGFyZ01heEVxdWFscyh4MTogTkRBcnJheSwgeDI6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goeDEuc2hhcGUsIHgyLnNoYXBlLCAnRXJyb3IgaW4gYXJnTWF4RXF1YWxzOiAnKTtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLmFyZ01heEVxdWFsc0ludGVybmFsKHgxLCB4MikpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBhcmdNYXhFcXVhbHNJbnRlcm5hbCh4MTogTkRBcnJheSwgeDI6IE5EQXJyYXkpOiBTY2FsYXI7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSB0b3AgSyB2YWx1ZXMgYW5kIGZsYXR0ZW5lZCBpbmRpY2VzLlxuICAgKiBAcGFyYW0gbmRhcnJheSBUaGUgaW5wdXQgTkRBcnJheS5cbiAgICogQHBhcmFtIGsgSG93IG1hbnkgdG9wIHZhbHVlcyB0byBjb21wdXRlLlxuICAgKi9cbiAgdG9wSyhuZGFycmF5OiBOREFycmF5LCBrOiBudW1iZXIpOiB7dmFsdWVzOiBBcnJheTFELCBpbmRpY2VzOiBBcnJheTFEfSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGsgPD0gbmRhcnJheS5zaXplLFxuICAgICAgICBgRXJyb3IgaW4gdG9wSzogayB2YWx1ZSAoJHtrfSkgbXVzdCBiZSBsZXNzIHRoYW4gc2l6ZSBvZiBpbnB1dCBgICtcbiAgICAgICAgICAgIGBuZGFycmF5LCBnb3Qgc2hhcGUgJHtuZGFycmF5LnNoYXBlfS5gKTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRvcEtJbnRlcm5hbChuZGFycmF5LCBrKTtcbiAgICB0aGlzLnRyYWNrKHJlc3VsdC52YWx1ZXMpO1xuICAgIHRoaXMudHJhY2socmVzdWx0LmluZGljZXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHRvcEtJbnRlcm5hbChuZGFycmF5OiBOREFycmF5LCBrOiBudW1iZXIpOlxuICAgICAge3ZhbHVlczogQXJyYXkxRCwgaW5kaWNlczogQXJyYXkxRH07XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIGZyb20gdGhlIGlucHV0LlxuICAgKiBAcGFyYW0gbmRhcnJheSBUaGUgaW5wdXQgTkRBcnJheS5cbiAgICovXG4gIG1pbihuZGFycmF5OiBOREFycmF5KTogU2NhbGFyIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLm1pbkludGVybmFsKG5kYXJyYXkpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgbWluSW50ZXJuYWwobmRhcnJheTogTkRBcnJheSk6IFNjYWxhcjtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIG1heGltdW0gdmFsdWUgZnJvbSB0aGUgaW5wdXQuXG4gICAqIEBwYXJhbSBuZGFycmF5IFRoZSBpbnB1dCBOREFycmF5LlxuICAgKi9cbiAgbWF4KG5kYXJyYXk6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMubWF4SW50ZXJuYWwobmRhcnJheSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBtYXhJbnRlcm5hbChuZGFycmF5OiBOREFycmF5KTogU2NhbGFyO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc29mdG1heCBub3JtYWxpemVkIHZlY3RvciBmcm9tIHRoZSBpbnB1dCB2ZWN0b3IuXG4gICAqIEBwYXJhbSB4IFRoZSBpbnB1dCB2ZWN0b3IuXG4gICAqL1xuICBzb2Z0bWF4KHg6IEFycmF5MUQpOiBBcnJheTFEIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZSgoKSA9PiB7XG4gICAgICAvLyBEbyBpdCBpbiBsb2cgc3BhY2UgZm9yIG51bWVyaWNhbCBzdGFiaWxpdHkuXG4gICAgICAvLyBleHAoWCAtIGxvZ1N1bUV4cChYKSlcbiAgICAgIGNvbnN0IGxzZSA9IHRoaXMubG9nU3VtRXhwKHgpO1xuICAgICAgY29uc3QgbG9nUmVzdWx0ID0gdGhpcy5hcnJheU1pbnVzU2NhbGFyKHgsIGxzZSk7XG4gICAgICByZXR1cm4gdGhpcy5leHAobG9nUmVzdWx0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gRWxlbWVudC13aXNlIG9wcyAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGRpbWVuc2lvbnMgb2YgdGhlIGlucHV0IE5EQXJyYXkuXG4gICAqIEBwYXJhbSBhIFRoZSBpbnB1dCBOREFycmF5LlxuICAgKiBAcGFyYW0gbmV3RGltIFRoZSBuZXcgaW5kaWNlcyB0aGF0IGRlZmluZSB3aGljaCBzaGFwZXMgdmFsdWVzIHRvIHN3aXRjaC5cbiAgICovXG4gIHN3aXRjaERpbTxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgbmV3RGltOiBudW1iZXJbXSk6IFQge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBhLnJhbmsgPT09IG5ld0RpbS5sZW5ndGgsXG4gICAgICAgIGBFcnJvciBpbiBzd2l0Y2hEaW06IGxlbmd0aCBvZiBpbnB1dCBzaGFwZSAke2Euc2hhcGV9IGAgK1xuICAgICAgICAgICAgYG11c3QgbWF0Y2ggc2l6ZSBvZiBuZXdEaW0gYXJyYXkgJHtuZXdEaW19LmApO1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuc3dpdGNoRGltSW50ZXJuYWwoYSwgbmV3RGltKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHN3aXRjaERpbUludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihcbiAgICAgIGE6IFQsIG5ld0RpbTogbnVtYmVyW10pOiBUO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBhIHNjYWxhciBwbHVzIE5EQXJyYXksIGMgKyBBLlxuICAgKiBAcGFyYW0gYyBUaGUgc2NhbGFyIGMgaW4gYyArIEEuXG4gICAqIEBwYXJhbSBhIFRoZSBOREFycmF5IEEgaW4gYyArIEEuXG4gICAqL1xuICBzY2FsYXJQbHVzQXJyYXk8VCBleHRlbmRzIE5EQXJyYXk+KGM6IFNjYWxhciwgYTogVCk6IFQge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBjLnNpemUgPT09IDEsXG4gICAgICAgIGBFcnJvciBpbiBzY2FsYXJQbHVzQXJyYXk6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgZ290IGAgK1xuICAgICAgICAgICAgYHJhbmsgJHtjLnJhbmt9LmApO1xuICAgIHJldHVybiB0aGlzLmFkZChjLCBhKSBhcyBUO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGEgc2NhbGFyIG1pbnVzIE5EQXJyYXksIGMgLSBBLlxuICAgKiBAcGFyYW0gYyBUaGUgc2NhbGFyIGMgaW4gYyAtIEEuXG4gICAqIEBwYXJhbSBhIFRoZSBOREFycmF5IEEgaW4gYyAtIEEuXG4gICAqL1xuICBzY2FsYXJNaW51c0FycmF5PFQgZXh0ZW5kcyBOREFycmF5PihjOiBTY2FsYXIsIGE6IFQpOiBUIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgYy5zaXplID09PSAxLFxuICAgICAgICBgRXJyb3IgaW4gc2NhbGFyTWludXNBcnJheTogZmlyc3QgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBnb3QgYCArXG4gICAgICAgICAgICBgcmFuayAke2MucmFua30uYCk7XG4gICAgcmV0dXJuIHRoaXMuc3ViKGMsIGEpIGFzIFQ7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgQSAtIGMuIEEgaXMgTkRBcnJheSwgYyBpcyBTY2FsYXIuXG4gICAqIEBwYXJhbSBhIFRoZSBOREFycmF5IEEgaW4gQSAtIGMuXG4gICAqIEBwYXJhbSBjIFRoZSBTY2FsYXIgYyBpbiBBIC0gYy5cbiAgICovXG4gIGFycmF5TWludXNTY2FsYXI8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQsIGM6IFNjYWxhcik6IFQge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBjLnNpemUgPT09IDEsXG4gICAgICAgIGBFcnJvciBpbiBhcnJheU1pbnVzU2NhbGFyOiBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBgICtcbiAgICAgICAgICAgIGBnb3QgcmFuayAke2MucmFua30uYCk7XG4gICAgcmV0dXJuIHRoaXMuc3ViKGEsIGMpIGFzIFQ7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgLTEgKiBBIGVsZW1lbnQtd2lzZS5cbiAgICogQHBhcmFtIGEgVGhlIGlucHV0IGFycmF5LlxuICAgKi9cbiAgbmVnPFQgZXh0ZW5kcyBOREFycmF5PihhOiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5uZWdJbnRlcm5hbChhKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IG5lZ0ludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihhOiBUKTogVDtcblxuICAvKipcbiAgICogQWRkcyB0d28gTkRBcnJheXMgZWxlbWVudC13aXNlLCBBICsgQi4gU3VwcG9ydHMgYnJvYWRjYXN0aW5nLlxuICAgKiBGb3IgYSBzdHJpY3RlciB2ZXJzaW9uIHdpdGhvdXQgYnJvYWRjYXN0aW5nIHVzZSBtYXRoLmFkZFN0cmljdCgpLlxuICAgKlxuICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgTkRBcnJheSB0byBhZGQgZWxlbWVudC13aXNlLlxuICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIE5EQXJyYXkgdG8gYWRkIGVsZW1lbnQtd2lzZS5cbiAgICovXG4gIGFkZChhOiBOREFycmF5LCBiOiBOREFycmF5KTogTkRBcnJheSB7XG4gICAgdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuYWRkSW50ZXJuYWwoYSwgYikpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBhZGRJbnRlcm5hbChhOiBOREFycmF5LCBiOiBOREFycmF5KTogTkRBcnJheTtcblxuICAvKipcbiAgICogQWRkcyB0d28gTkRBcnJheXMgZWxlbWVudC13aXNlLCBBICsgQi4gSW5wdXRzIG11c3RcbiAgICogYmUgdGhlIHNhbWUgc2hhcGUuIEZvciBicm9hZGNhc3Rpbmcgc3VwcG9ydCwgdXNlIG1hdGguYWRkKCkgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIGEgVGhlIGZpcnN0IE5EQXJyYXkgdG8gbXVsdGlwbHkgZWxlbWVudC13aXNlLlxuICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIE5EQXJyYXkgdG8gbXVsdGlwbHkgZWxlbWVudC13aXNlLlxuICAgKi9cbiAgYWRkU3RyaWN0PFQgZXh0ZW5kcyBOREFycmF5PihhOiBULCBiOiBUKTogVCB7XG4gICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gYWRkU3RyaWN0OiAnKTtcbiAgICByZXR1cm4gdGhpcy5hZGQoYSwgYikgYXMgVDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdHMgdHdvIE5EQXJyYXlzIGVsZW1lbnQtd2lzZSwgQSAtIEIuIFN1cHBvcnRzIGJyb2FkY2FzdGluZy5cbiAgICogRm9yIGEgc3RyaWN0ZXIgdmVyc2lvbiB3aXRob3V0IGJyb2FkY2FzdGluZyB1c2UgbWF0aC5zdWJTdHJpY3QoKS5cbiAgICpcbiAgICogQHBhcmFtIGEgVGhlIGZpcnN0IE5EQXJyYXkgdG8gc3VidHJhY3QgZWxlbWVudC13aXNlLlxuICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIE5EQXJyYXkgdG8gc3VidHJhY3QgZWxlbWVudC13aXNlLlxuICAgKi9cbiAgc3ViKGE6IE5EQXJyYXksIGI6IE5EQXJyYXkpOiBOREFycmF5IHtcbiAgICB1dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdGVkU2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5zdWJJbnRlcm5hbChhLCBiKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHN1YkludGVybmFsKGE6IE5EQXJyYXksIGI6IE5EQXJyYXkpOiBOREFycmF5O1xuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdHMgdHdvIE5EQXJyYXlzIGVsZW1lbnQtd2lzZSwgQSAtIEIuIElucHV0cyBtdXN0XG4gICAqIGJlIHRoZSBzYW1lIHNoYXBlLiBGb3IgYnJvYWRjYXN0aW5nIHN1cHBvcnQsIHVzZSBtYXRoLnN1YigpIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBhIFRoZSBmaXJzdCBOREFycmF5IHRvIG11bHRpcGx5IGVsZW1lbnQtd2lzZS5cbiAgICogQHBhcmFtIGIgVGhlIHNlY29uZCBOREFycmF5IHRvIG11bHRpcGx5IGVsZW1lbnQtd2lzZS5cbiAgICovXG4gIHN1YlN0cmljdDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgYjogVCk6IFQge1xuICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIHN1YlN0cmljdDogJyk7XG4gICAgcmV0dXJuIHRoaXMuc3ViKGEsIGIpIGFzIFQ7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0d28gTkRBcnJheXMgZWxlbWVudC13aXNlLCBBICogQi4gU3VwcG9ydHMgYnJvYWRjYXN0aW5nLlxuICAgKiBGb3IgYSBzdHJpY3RlciB2ZXJzaW9uIHdpdGhvdXQgYnJvYWRjYXN0aW5nIHVzZSBtYXRoLm11bHRpcGx5U3RyaWN0KCkuXG4gICAqXG4gICAqIEBwYXJhbSBhIFRoZSBmaXJzdCBOREFycmF5IHRvIG11bHRpcGx5IGVsZW1lbnQtd2lzZS5cbiAgICogQHBhcmFtIGIgVGhlIHNlY29uZCBOREFycmF5IHRvIG11bHRpcGx5IGVsZW1lbnQtd2lzZS5cbiAgICovXG4gIG11bHRpcGx5KGE6IE5EQXJyYXksIGI6IE5EQXJyYXkpOiBOREFycmF5IHtcbiAgICB1dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdGVkU2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5tdWx0aXBseUludGVybmFsKGEsIGIpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgbXVsdGlwbHlJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgYjogVCk6IFQ7XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXRoLm11bHRpcGx5U3RyaWN0KCkgaW5zdGVhZC5cbiAgICovXG4gIGVsZW1lbnRXaXNlTXVsPFQgZXh0ZW5kcyBOREFycmF5PihhOiBULCBiOiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTdHJpY3QoYSwgYik7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0d28gTkRBcnJheXMgZWxlbWVudC13aXNlLCBBICogQi4gSW5wdXRzIG11c3RcbiAgICogYmUgdGhlIHNhbWUgc2hhcGUuIEZvciBicm9hZGNhc3Rpbmcgc3VwcG9ydCwgdXNlIG1hdGgubXVsdGlwbHkoKSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgTkRBcnJheSB0byBtdWx0aXBseSBlbGVtZW50LXdpc2UuXG4gICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgTkRBcnJheSB0byBtdWx0aXBseSBlbGVtZW50LXdpc2UuXG4gICAqL1xuICBtdWx0aXBseVN0cmljdDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgYjogVCk6IFQge1xuICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIG11bHRpcGx5U3RyaWN0OiAnKTtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseShhLCBiKSBhcyBUO1xuICB9XG5cbiAgLyoqXG4gICAqIERpdmlkZXMgdHdvIE5EQXJyYXlzIGVsZW1lbnQtd2lzZSwgQSAvIEIuIFN1cHBvcnRzIGJyb2FkY2FzdGluZy5cbiAgICogRm9yIGEgc3RyaWN0ZXIgdmVyc2lvbiB3aXRob3V0IGJyb2FkY2FzdGluZyB1c2UgbWF0aC5kaXZpZGVTdHJpY3QoKS5cbiAgICpcbiAgICogQHBhcmFtIGEgVGhlIGZpcnN0IE5EQXJyYXkgdG8gZGl2aWRlIGVsZW1lbnQtd2lzZS5cbiAgICogQHBhcmFtIGIgVGhlIHNlY29uZCBOREFycmF5IHRvIGRpdmlkZSBlbGVtZW50LXdpc2UuXG4gICAqL1xuICBkaXZpZGUoYTogTkRBcnJheSwgYjogTkRBcnJheSk6IE5EQXJyYXkge1xuICAgIHV0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0ZWRTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLmRpdmlkZUludGVybmFsKGEsIGIpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZGl2aWRlSW50ZXJuYWwoYTogTkRBcnJheSwgYjogTkRBcnJheSk6IE5EQXJyYXk7XG5cbiAgLyoqXG4gICAqIERpdmlkZXMgdHdvIE5EQXJyYXlzIGVsZW1lbnQtd2lzZSwgQSAvIEIuIElucHV0cyBtdXN0XG4gICAqIGJlIHRoZSBzYW1lIHNoYXBlLiBGb3IgYnJvYWRjYXN0aW5nIHN1cHBvcnQsIHVzZSBtYXRoLmRpdmlkZSgpIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBhIFRoZSBmaXJzdCBOREFycmF5IHRvIG11bHRpcGx5IGVsZW1lbnQtd2lzZS5cbiAgICogQHBhcmFtIGIgVGhlIHNlY29uZCBOREFycmF5IHRvIG11bHRpcGx5IGVsZW1lbnQtd2lzZS5cbiAgICovXG4gIGRpdmlkZVN0cmljdDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgYjogVCk6IFQge1xuICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIGRpdmlkZVN0cmljdDogJyk7XG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlKGEsIGIpIGFzIFQ7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgYSBzY2FsYXIgZGl2aWRlZCBieSBhbiBOREFycmF5LCBicm9hZGNhc3RlZCBvdmVyIHRoZSBOREFycmF5LCBjIC9cbiAgICogQS5cbiAgICogQHBhcmFtIGMgVGhlIHNjYWxhciB2YWx1ZSBpbiBjIC8gQS5cbiAgICogQHBhcmFtIGEgVGhlIE5EQXJyYXkgdmFsdWUgaW4gYyAvIEEuXG4gICAqL1xuICBzY2FsYXJEaXZpZGVkQnlBcnJheTxUIGV4dGVuZHMgTkRBcnJheT4oYzogU2NhbGFyLCBhOiBUKTogVCB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGMuc2l6ZSA9PT0gMSxcbiAgICAgICAgYEVycm9yIGluIHNjYWxhckRpdmlkZWRCeUFycmF5OiBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IGAgK1xuICAgICAgICAgICAgYGdvdCBOREFycmF5IG9mIHJhbmsgJHtjLnJhbmt9LmApO1xuICAgIHJldHVybiB0aGlzLmRpdmlkZShjLCBhKSBhcyBUO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGFuIE5EQXJyYXkgZGl2aWRlZCBieSBhIHNjYWxhciwgYnJvYWRjYXN0ZWQgb3ZlciB0aGUgTkRBcnJheSwgQSAvXG4gICAqIGMuXG4gICAqIEBwYXJhbSBhIFRoZSBOREFycmF5IHZhbHVlIGluIEEgLyBjLlxuICAgKiBAcGFyYW0gYyBUaGUgc2NhbGFyIHZhbHVlIGluIEEgLyBjLlxuICAgKi9cbiAgYXJyYXlEaXZpZGVkQnlTY2FsYXI8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQsIGM6IFNjYWxhcik6IFQge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBjLnNpemUgPT09IDEsXG4gICAgICAgIGBFcnJvciBpbiBhcnJheURpdmlkZWRCeVNjYWxhcjogc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBgICtcbiAgICAgICAgICAgIGBidXQgZ290IE5EQXJyYXkgb2YgcmFuayAke2MucmFua30uYCk7XG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlKGEsIGMpIGFzIFQ7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgZXhwb25lbnRpYWwgb2YgdGhlIGlucHV0IE5EQXJyYXkgZWxlbWVudC13aXNlLiB5ID0gZSBeIHhcbiAgICogQHBhcmFtIG5kYXJyYXkgVGhlIGlucHV0IE5EQXJyYXkuXG4gICAqL1xuICBleHA8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLmV4cEludGVybmFsKG5kYXJyYXkpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZXhwSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBuYXR1cmFsIGxvZ2FyaXRobSBvZiB0aGUgaW5wdXQgTkRBcnJheSBlbGVtZW50LXdpc2UuIHkgPSBsbih4KVxuICAgKiBAcGFyYW0gbmRhcnJheSBUaGUgaW5wdXQgTkRBcnJheS5cbiAgICovXG4gIGxvZzxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQge1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMubG9nSW50ZXJuYWwobmRhcnJheSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBsb2dJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQ7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHJlY3RpZmllZCBsaW5lYXIgZWxlbWVudC13aXNlLCBtYXgoeCwgMCkuXG4gICAqIEBwYXJhbSBuZGFycmF5IFRoZSBpbnB1dCBOREFycmF5LlxuICAgKi9cbiAgcmVsdTxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQge1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMucmVsdUludGVybmFsKG5kYXJyYXkpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVsdUludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVDtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgc2lnbW9pZCBlbGVtZW50LXdpc2UsIHkgPSAxIC8gKDEgKyBleHAoLXgpKS5cbiAgICogQHBhcmFtIG5kYXJyYXkgVGhlIGlucHV0IE5EQXJyYXkuXG4gICAqL1xuICBzaWdtb2lkPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5zaWdtb2lkSW50ZXJuYWwobmRhcnJheSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzaWdtb2lkSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBoeXBlcmJvbGljIHRhbmdlbnQgb2YgdGhlIGlucHV0IE5EQXJyYXkgZWxlbWVudC13aXNlLlxuICAgKiBAcGFyYW0gbmRhcnJheSBUaGUgaW5wdXQgTkRBcnJheS5cbiAgICovXG4gIHRhbmg8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLnRhbmhJbnRlcm5hbChuZGFycmF5KSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHRhbmhJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQ7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHNpbiBvZiB0aGUgaW5wdXQgTkRBcnJheSBlbGVtZW50LXdpc2UsIHkgPSBzaW4oeCkuXG4gICAqIEBwYXJhbSBuZGFycmF5IFRoZSBpbnB1dCBOREFycmF5LlxuICAgKi9cbiAgc2luPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5zaW5JbnRlcm5hbChuZGFycmF5KSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHNpbkludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVDtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgc3RlcCBvZiB0aGUgaW5wdXQgTkRBcnJheSBlbGVtZW50LXdpc2UsIHkgPSAxIGlmIHggPiAwIHwgMCBpZiB4IDw9XG4gICAqIDBcbiAgICogQHBhcmFtIG5kYXJyYXkgVGhlIGlucHV0IE5EQXJyYXkuXG4gICAqL1xuICBzdGVwPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5zdGVwSW50ZXJuYWwobmRhcnJheSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzdGVwSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBhIHNjYWxlZCBhcnJheSBhZGQgb3BlcmF0aW9uLCBjMSAqIEEgKyBjMiAqIEIuXG4gICAqIEBwYXJhbSBjMSBUaGUgZmlyc3Qgc2NhbGFyIGluIHRoZSBzY2FsZWQgYXJyYXkgYWRkIGNvbXB1dGF0aW9uLlxuICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgTkRBcnJheSBpbiB0aGUgc2NhbGVkIGFycmF5IGFkZCBjb21wdXRhdGlvbi5cbiAgICogQHBhcmFtIGMyIFRoZSBzZWNvbmQgc2NhbGFyIGluIHRoZSBzY2FsZWQgYXJyYXkgYWRkIGNvbXB1dGF0aW9uLlxuICAgKiBAcGFyYW0gY2IgVGhlIHNlY29uZCBOREFycmF5IGluIHRoZSBzY2FsZWQgYXJyYXkgYWRkIGNvbXB1dGF0aW9uLlxuICAgKi9cbiAgc2NhbGVkQXJyYXlBZGQ8VCBleHRlbmRzIE5EQXJyYXk+KGMxOiBTY2FsYXIsIGE6IFQsIGMyOiBTY2FsYXIsIGI6IFQpOiBUIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgYzEuc2l6ZSA9PT0gMSxcbiAgICAgICAgYEVycm9yIGluIHNjYWxlZEFycmF5QWRkOiBmaXJzdCBhcmd1bWVudCBtdXN0IHJhbmsgMCwgYnV0IGdvdCBgICtcbiAgICAgICAgICAgIGAgcmFuayAke2MxLnJhbmt9LmApO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBjMi5zaXplID09PSAxLFxuICAgICAgICBgRXJyb3IgaW4gc2NhbGVkQXJyYXlBZGQ6IHRoaXJkIGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgZ290IGAgK1xuICAgICAgICAgICAgYE5EQXJyYXkgb2YgcmFuayAke2MyLnJhbmt9LmApO1xuICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIHNjYWxlZEFycmF5QWRkOiAnKTtcblxuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuc2NhbGVkQXJyYXlBZGRJbnRlcm5hbChjMSwgYSwgYzIsIGIpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgc2NhbGVkQXJyYXlBZGRJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oXG4gICAgICBjMTogU2NhbGFyLCBhOiBULCBjMjogU2NhbGFyLCBiOiBUKTogVDtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgYSBzY2FsYXIgdGltZXMgYXJyYXkgb3BlcmF0aW9uIGJyb2FkY2FzdGVkIG92ZXIgdGhlIE5EQXJyYXksIGMgKlxuICAgKiBBLlxuICAgKiBAcGFyYW0gYyBUaGUgc2NhbGFyIGluIHRoZSBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBBIHRoZSBOREFycmF5IGluIHRoZSBvcGVyYXRpb24gdGhhdCB3aWxsIGJlIGJyb2FkY2FzdGVkIG92ZXIuXG4gICAqL1xuICBzY2FsYXJUaW1lc0FycmF5PFQgZXh0ZW5kcyBOREFycmF5PihjOiBTY2FsYXIsIGE6IFQpOiBUIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgYy5zaXplID09PSAxLFxuICAgICAgICBgRXJyb3IgaW4gYXJyYXlEaXZpZGVkQnlTY2FsYXI6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgYCArXG4gICAgICAgICAgICBgZ290IHJhbmsgJHtjLnJhbmt9LmApO1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5KGMsIGEpIGFzIFQ7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1hdGgubXVsdGlwbHkoKSBpbnN0ZWFkLlxuICAgKi9cbiAgZWxlbWVudFdpc2VNdWxCcm9hZGNhc3QoYTogQXJyYXkyRCwgYjogQXJyYXkyRCk6IEFycmF5MkQge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBhLnJhbmsgPT09IDIsXG4gICAgICAgIGBFcnJvciBpbiBlbGVtZW50V2lzZU11bEJyb2FkY2FzdDogZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBgICtcbiAgICAgICAgICAgIGByYW5rIDIsIGJ1dCBnb3QgcmFuayAke2EucmFua30uYCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGIucmFuayA9PT0gMixcbiAgICAgICAgYEVycm9yIGluIGVsZW1lbnRXaXNlTXVsQnJvYWRjYXN0OiBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBgICtcbiAgICAgICAgICAgIGByYW5rIDIsIGJ1dCBnb3QgcmFuayAke2IucmFua30uYCk7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoYSwgYikgYXMgQXJyYXkyRDtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBDb252b2x1dGlvbiBvcHMgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGEgMkQgY29udm9sdXRpb24gb3ZlciB0aGUgaW5wdXQgeC5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IGltYWdlLCBtdXN0IGJlIHJhbmsgMywgb2Ygc2hhcGUgW3Jvd3MsIGNvbHMsIGRlcHRoMV0uXG4gICAqIEBwYXJhbSB3ZWlnaHRzIFRoZSB3ZWlnaHRzIE5EQXJyYXksIG11c3QgYmUgcmFuayA0LCBvZiBzaGFwZSBbZiwgZiwgZGVwdGgxLFxuICAgKiBkZXB0aDJdLlxuICAgKiBAcGFyYW0gYmlhc2VzIE9wdGlvbmFsIGJpYXNlcyBOREFycmF5LCBtdXN0IGJlIHJhbmsgMSBvZiBzaGFwZSBbZGVwdGgyXS5cbiAgICogQHBhcmFtIHN0cmlkZSBUaGUgc3RyaWRlIG9mIHRoZSBjb252b2x1dGlvbi5cbiAgICogQHBhcmFtIHplcm9QYWQgVGhlIHplcm8gcGFkZGluZyBvZiBlYWNoIHNpZGUgb2YgdGhlIGlucHV0IE5EQXJyYXkuIFdpbGwgcGFkXG4gICAqIGVxdWFsbHkgb24gYWxsIHNpZGVzLlxuICAgKi9cbiAgY29udjJkKFxuICAgICAgeDogQXJyYXkzRCwgd2VpZ2h0czogQXJyYXk0RCwgYmlhc2VzOiBBcnJheTFEfG51bGwsIHN0cmlkZTogbnVtYmVyLFxuICAgICAgemVyb1BhZDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHgucmFuayA9PT0gMyxcbiAgICAgICAgYEVycm9yIGluIGNvbnYyZDogeCBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCByYW5rICR7eC5yYW5rfS5gKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgd2VpZ2h0cy5yYW5rID09PSA0LFxuICAgICAgICBgRXJyb3IgaW4gY29udjJkOiB3ZWlnaHRzIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgYCArXG4gICAgICAgICAgICBgJHt3ZWlnaHRzLnJhbmt9LmApO1xuICAgIGlmIChiaWFzZXMgIT0gbnVsbCkge1xuICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgYmlhc2VzLnJhbmsgPT09IDEsXG4gICAgICAgICAgYEVycm9yIGluIGNvbnYyZDogYmlhc2VzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmsgYCArXG4gICAgICAgICAgICAgIGAke2JpYXNlcy5yYW5rfS5gKTtcbiAgICB9XG5cbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgeC5zaGFwZVsyXSA9PT0gd2VpZ2h0cy5zaGFwZVsyXSxcbiAgICAgICAgYEVycm9yIGluIGNvbnYyZDogZGVwdGggb2YgaW5wdXQgKCR7eC5zaGFwZVsyXX0pIG11c3QgbWF0Y2ggIGAgK1xuICAgICAgICAgICAgYGlucHV0IGRlcHRoIGZvciB3ZWlnaHRzICR7d2VpZ2h0cy5zaGFwZVsyXX0uYCk7XG5cblxuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuY29udjJkSW50ZXJuYWwoeCwgd2VpZ2h0cywgYmlhc2VzLCBzdHJpZGUsIHplcm9QYWQpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgY29udjJkSW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCB3ZWlnaHRzOiBBcnJheTRELCBiaWFzZXM6IEFycmF5MUR8bnVsbCwgc3RyaWRlOiBudW1iZXIsXG4gICAgICB6ZXJvUGFkOiBudW1iZXIpOiBBcnJheTNEO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgYmFja3Byb3Agb2YgYSAyRCBjb252b2x1dGlvbi5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IGltYWdlLCBtdXN0IGJlIHJhbmsgMywgb2Ygc2hhcGUgW3hyb3dzLCB4Y29scywgZGVwdGgxXS5cbiAgICogQHBhcmFtIGR5IFRoZSBkeSBpbWFnZSwgbXVzdCBiZSByYW5rIDMsIG9mIHNoYXBlIFt5cm93cywgeWNvbHMsIGRlcHRoMl0uXG4gICAqIEBwYXJhbSB3ZWlnaHRzIFRoZSB3ZWlnaHRzIE5EQXJyYXksIG11c3QgYmUgcmFuayA0LCBvZiBzaGFwZSBbZiwgZiwgZGVwdGgxLFxuICAgKiBkZXB0aDJdLlxuICAgKiBAcGFyYW0gc3RyaWRlIFRoZSBzdHJpZGUgb2YgdGhlIG9yaWdpbmFsIGNvbnZvbHV0aW9uLlxuICAgKiBAcGFyYW0gcGFkIFRoZSBwYWRkaW5nIG9mIHRoZSBvcmlnaW5hbCBjb252b2x1dGlvbi5cbiAgICovXG4gIGNvbnYyZEJhY2tQcm9wKFxuICAgICAgeDogQXJyYXkzRCwgZHk6IEFycmF5M0QsIHdlaWdodHM6IEFycmF5NEQsIHN0cmlkZTogbnVtYmVyLFxuICAgICAgcGFkOiBudW1iZXIpOiB7ZHg6IEFycmF5M0QsIGR3OiBBcnJheTRELCBkYjogQXJyYXkxRH0ge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB4LnJhbmsgPT09IDMsXG4gICAgICAgIGBFcnJvciBpbiBjb252MmRCYWNrUHJvcDogeCBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCBzaGFwZSBgICtcbiAgICAgICAgICAgIGAke3guc2hhcGV9LmApO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBkeS5yYW5rID09PSAzLFxuICAgICAgICBgRXJyb3IgaW4gY29udjJkQmFja1Byb3A6IGR5IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHNoYXBlIGAgK1xuICAgICAgICAgICAgYCR7ZHkuc2hhcGV9LmApO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB3ZWlnaHRzLnJhbmsgPT09IDQsXG4gICAgICAgIGBFcnJvciBpbiBjb252MmRCYWNrUHJvcDogd2VpZ2h0cyBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBzaGFwZSBgICtcbiAgICAgICAgICAgIGAke3dlaWdodHMuc2hhcGV9LmApO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB4LnNoYXBlWzJdID09PSB3ZWlnaHRzLnNoYXBlWzJdLFxuICAgICAgICBgRXJyb3IgaW4gY29udjJkQmFja1Byb3A6IGRlcHRoIG9mIHggJHt4LnNoYXBlWzJdfSkgbXVzdCBgICtcbiAgICAgICAgICAgIGBtYXRjaCBpbnB1dCBkZXB0aCBmb3Igd2VpZ2h0cyAoJHt3ZWlnaHRzLnNoYXBlWzJdfS5gKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgZHkuc2hhcGVbMl0gPT09IHdlaWdodHMuc2hhcGVbM10sXG4gICAgICAgIGBFcnJvciBpbiBjb252MmRCYWNrUHJvcDogZGVwdGggb2YgZHkgKCR7ZHkuc2hhcGVbMl19KSBtdXN0IGAgK1xuICAgICAgICAgICAgYG1hdGNoIG91dHB1dCBkZXB0aCBmb3Igd2VpZ2h0cyAoJHt3ZWlnaHRzLnNoYXBlWzNdfSkuYCk7XG5cbiAgICBjb25zdCBiYWNrcHJvcFJlc3VsdCA9XG4gICAgICAgIHRoaXMuY29udjJkQmFja1Byb3BJbnRlcm5hbCh4LCBkeSwgd2VpZ2h0cywgc3RyaWRlLCBwYWQpO1xuXG4gICAgdGhpcy50cmFjayhiYWNrcHJvcFJlc3VsdC5kYik7XG4gICAgdGhpcy50cmFjayhiYWNrcHJvcFJlc3VsdC5kdyk7XG4gICAgdGhpcy50cmFjayhiYWNrcHJvcFJlc3VsdC5keCk7XG5cbiAgICByZXR1cm4gYmFja3Byb3BSZXN1bHQ7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGNvbnYyZEJhY2tQcm9wSW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBkeTogQXJyYXkzRCwgd2VpZ2h0czogQXJyYXk0RCwgc3RyaWRlOiBudW1iZXIsXG4gICAgICBwYWQ6IG51bWJlcik6IHtkeDogQXJyYXkzRCwgZHc6IEFycmF5NEQsIGRiOiBBcnJheTFEfTtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHRyYW5zcG9zZWQgMkQgY29udm9sdXRpb24gb2YgYW4gaW1hZ2UsIGFsc28ga25vd24gYXMgYVxuICAgKiBkZWNvbnZvbHV0aW9uLlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgaW1hZ2UsIG11c3QgYmUgcmFuayAzLCBvZiBzaGFwZSBbeHJvd3MsIHhjb2xzLCBkZXB0aDFdLlxuICAgKiBAcGFyYW0gd2VpZ2h0cyBUaGUgd2VpZ2h0cyBOREFycmF5LCBtdXN0IGJlIHJhbmsgNCwgb2Ygc2hhcGUgW2YsIGYsIGRlcHRoMSxcbiAgICogZGVwdGgyXS5cbiAgICogQHBhcmFtIGJpYXNlcyBPcHRpb25hbCBiaWFzZXMgTkRBcnJheSwgbXVzdCBiZSByYW5rIDEgb2Ygc2hhcGUgW2RlcHRoMl0uXG4gICAqIEBwYXJhbSBzdHJpZGUgVGhlIHN0cmlkZSBvZiB0aGUgY29udm9sdXRpb24uXG4gICAqIEBwYXJhbSBwYWQgVGhlIHBhZGRpbmcgb2YgZWFjaCBzaWRlIG9mIHRoZSBpbnB1dCBOREFycmF5LiBXaWxsIHBhZCBlcXVhbGx5XG4gICAqIG9uIGFsbCBzaWRlcy5cbiAgICovXG4gIGNvbnYyZFRyYW5zcG9zZShcbiAgICAgIHg6IEFycmF5M0QsIHdlaWdodHM6IEFycmF5NEQsIGJpYXNlczogQXJyYXkxRHxudWxsLCBzdHJpZGU6IG51bWJlcixcbiAgICAgIHBhZDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHgucmFuayA9PT0gMyxcbiAgICAgICAgYEVycm9yIGluIGNvbnYyZFRyYW5zcG9zZTogeCBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCByYW5rIGAgK1xuICAgICAgICAgICAgYCR7eC5yYW5rfS5gKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgd2VpZ2h0cy5yYW5rID09PSA0LFxuICAgICAgICBgRXJyb3IgaW4gY29udjJkVHJhbnNwb3NlOiB3ZWlnaHRzIG11c3QgYmUgcmFuayA0LCBidXQgZ290IGAgK1xuICAgICAgICAgICAgYHJhbmsgJHt3ZWlnaHRzLnJhbmt9YCk7XG4gICAgaWYgKGJpYXNlcyAhPSBudWxsKSB7XG4gICAgICB1dGlsLmFzc2VydChcbiAgICAgICAgICBiaWFzZXMucmFuayA9PT0gMSxcbiAgICAgICAgICBgRXJyb3IgaW4gY29udjJkVHJhbnNwb3NlOiBiaWFzZXMgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgJyArXG4gICAgICAgICAgICAgICdyYW5rICR7Ymlhc2VzLnJhbmt9LmApO1xuICAgIH1cbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgeC5zaGFwZVsyXSA9PT0gd2VpZ2h0cy5zaGFwZVszXSxcbiAgICAgICAgYEVycm9yIGluIGNvbnYyZFRyYW5zcG9zZTogZGVwdGggb2YgaW5wdXQgKCR7eC5zaGFwZVsyXX0pIG11c3QgYCArXG4gICAgICAgICAgICBgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIHdlaWdodHMgJHt3ZWlnaHRzLnNoYXBlWzNdfS5gKTtcblxuICAgIHJldHVybiB0aGlzLnRyYWNrKFxuICAgICAgICB0aGlzLmNvbnYyZFRyYW5zcG9zZUludGVybmFsKHgsIHdlaWdodHMsIGJpYXNlcywgc3RyaWRlLCBwYWQpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgY29udjJkVHJhbnNwb3NlSW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCB3ZWlnaHRzOiBBcnJheTRELCBiaWFzZXM6IEFycmF5MUR8bnVsbCwgc3RyaWRlOiBudW1iZXIsXG4gICAgICBwYWQ6IG51bWJlcik6IEFycmF5M0Q7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSAyRCBtYXggcG9vbGluZyBvZiBhbiBpbWFnZS5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IGltYWdlLCBtdXN0IGJlIHJhbmsgMy5cbiAgICogQHBhcmFtIGZTaXplIFRoZSBmaWVsZCBzaXplIG9mIHRoZSBtYXggcG9vbC5cbiAgICogQHBhcmFtIHN0cmlkZSBUaGUgc3RyaWRlIG9mIHRoZSBtYXggcG9vbC5cbiAgICogQHBhcmFtIHBhZCBUaGUgcGFkZGluZyBvZiBlYWNoIHNpZGUgb2YgdGhlIGlucHV0IE5EQXJyYXkuIFdpbGwgcGFkIGVxdWFsbHlcbiAgICogb24gYWxsIHNpZGVzLlxuICAgKi9cbiAgbWF4UG9vbCh4OiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgcGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgeC5yYW5rID09PSAzLFxuICAgICAgICAnRXJyb3IgaW4gbWF4UG9vbDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgJyArIHgucmFuayArICcuJyk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5tYXhQb29sSW50ZXJuYWwoeCwgZlNpemUsIHN0cmlkZSwgcGFkKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IG1heFBvb2xJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCBwYWQ6IG51bWJlcik6IEFycmF5M0Q7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBiYWNrcHJvcCBvZiBhIG1heCBwb29sLlxuICAgKiBAcGFyYW0gZHkgVGhlIGR5IGVycm9yLlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgaW1hZ2UsIG11c3QgYmUgcmFuayAzLlxuICAgKiBAcGFyYW0gZlNpemUgVGhlIGZpZWxkIHNpemUgb2YgdGhlIG1heCBwb29sLlxuICAgKiBAcGFyYW0gc3RyaWRlIFRoZSBzdHJpZGUgb2YgdGhlIG1heCBwb29sLlxuICAgKiBAcGFyYW0gcGFkIFRoZSBwYWRkaW5nIG9mIGVhY2ggc2lkZSBvZiB0aGUgaW5wdXQgTkRBcnJheS4gV2lsbCBwYWQgZXF1YWxseVxuICAgKiBvbiBhbGwgc2lkZXMuXG4gICAqL1xuICBtYXhQb29sQmFja3Byb3AoXG4gICAgICBkeTogQXJyYXkzRCwgeDogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsXG4gICAgICBwYWQ6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBkeS5yYW5rID09PSAzLFxuICAgICAgICBgRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgYCArXG4gICAgICAgICAgICBgJHtkeS5yYW5rfS5gKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgeC5yYW5rID09PSAzLFxuICAgICAgICBgRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBgICtcbiAgICAgICAgICAgIGAke3gucmFua30uYCk7XG5cbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLm1heFBvb2xCYWNrcHJvcEludGVybmFsKGR5LCB4LCBmU2l6ZSwgc3RyaWRlLCBwYWQpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgbWF4UG9vbEJhY2twcm9wSW50ZXJuYWwoXG4gICAgICBkeTogQXJyYXkzRCwgeDogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsXG4gICAgICBwYWQ6IG51bWJlcik6IEFycmF5M0Q7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSAyRCBtaW4gcG9vbGluZyBvZiBhbiBpbWFnZS5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IGltYWdlLCBtdXN0IGJlIHJhbmsgMy5cbiAgICogQHBhcmFtIGZTaXplIFRoZSBmaWVsZCBzaXplIG9mIHRoZSBtYXggcG9vbC5cbiAgICogQHBhcmFtIHN0cmlkZSBUaGUgc3RyaWRlIG9mIHRoZSBtYXggcG9vbC5cbiAgICogQHBhcmFtIHBhZCBUaGUgcGFkZGluZyBvZiBlYWNoIHNpZGUgb2YgdGhlIGlucHV0IE5EQXJyYXkuIFdpbGwgcGFkIGVxdWFsbHlcbiAgICogb24gYWxsIHNpZGVzLlxuICAgKi9cbiAgbWluUG9vbCh4OiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgcGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgeC5yYW5rID09PSAzLFxuICAgICAgICBgRXJyb3IgaW4gbWluUG9vbDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgJHt4LnJhbmt9LmApO1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMubWluUG9vbEludGVybmFsKHgsIGZTaXplLCBzdHJpZGUsIHBhZCkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBtaW5Qb29sSW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgcGFkOiBudW1iZXIpOiBBcnJheTNEO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgMkQgYXZlcmFnZSBwb29saW5nIG9mIGFuIGltYWdlLlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgaW1hZ2UsIG11c3QgYmUgcmFuayAzLlxuICAgKiBAcGFyYW0gZlNpemUgVGhlIGZpZWxkIHNpemUgb2YgdGhlIG1heCBwb29sLlxuICAgKiBAcGFyYW0gc3RyaWRlIFRoZSBzdHJpZGUgb2YgdGhlIG1heCBwb29sLlxuICAgKiBAcGFyYW0gcGFkIFRoZSBwYWRkaW5nIG9mIGVhY2ggc2lkZSBvZiB0aGUgaW5wdXQgTkRBcnJheS4gV2lsbCBwYWQgZXF1YWxseVxuICAgKiBvbiBhbGwgc2lkZXMuXG4gICAqL1xuICBhdmdQb29sKHg6IEFycmF5M0QsIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCBwYWQ6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB4LnJhbmsgPT09IDMsXG4gICAgICAgIGBFcnJvciBpbiBhdmdQb29sOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayAke3gucmFua30uYCk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5hdmdQb29sSW50ZXJuYWwoeCwgZlNpemUsIHN0cmlkZSwgcGFkKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGF2Z1Bvb2xJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCBwYWQ6IG51bWJlcik6IEFycmF5M0Q7XG5cbiAgLypcbiAgICogQmlsaW5lYXIgcmVzaXplIGEgM0QgYXJyYXkgcGVyIGVhY2ggY2hhbm5lbCB0byBhIG5ldyAyRCBzaGFwZS5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IEFycmF5M0QuXG4gICAqIEBwYXJhbSBuZXdTaGFwZTJEIFRoZSBuZXcgc2hhcGUgdG8gcmVzaXplIHRoZSBBcnJheTNEIHRvLiBFYWNoIGNoYW5uZWwgaXNcbiAgICogcmVzaXplZCBpbmRpdmlkdWFsbHkuXG4gICAqIEBwYXJhbSBhbGlnbkNvcm5lcnMgQW4gb3B0aW9uYWwgYm9vbC4gRGVmYXVsdHMgdG8gRmFsc2UuIElmIHRydWUsIHJlc2NhbGVcbiAgICogaW5wdXQgYnkgKG5ld19oZWlnaHQgLSAxKSAvIChoZWlnaHQgLSAxKSwgd2hpY2ggZXhhY3RseSBhbGlnbnMgdGhlIDRcbiAgICogY29ybmVycyBvZiBpbWFnZXMgYW5kIHJlc2l6ZWQgaW1hZ2VzLiBJZiBmYWxzZSwgcmVzY2FsZSBieSBuZXdfaGVpZ2h0IC9cbiAgICogaGVpZ2h0LiBUcmVhdCBzaW1pbGFybHkgdGhlIHdpZHRoIGRpbWVuc2lvbi5cbiAgICovXG4gIHJlc2l6ZUJpbGluZWFyM0QoXG4gICAgICB4OiBBcnJheTNELCBuZXdTaGFwZTJEOiBbbnVtYmVyLCBudW1iZXJdLCBhbGlnbkNvcm5lcnMgPSBmYWxzZSk6IEFycmF5M0Qge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB4LnJhbmsgPT09IDMsXG4gICAgICAgIGBFcnJvciBpbiByZXNpemVCaWxpbmVhcjNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayAke3gucmFua30uYCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIG5ld1NoYXBlMkQubGVuZ3RoID09PSAyLFxuICAgICAgICBgRXJyb3IgaW4gcmVzaXplQmlsaW5lYXIzRDogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgYCArXG4gICAgICAgICAgICBgJHtuZXdTaGFwZTJEfS5gKTtcbiAgICByZXR1cm4gdGhpcy50cmFjayhcbiAgICAgICAgdGhpcy5yZXNpemVCaWxpbmVhcjNESW50ZXJuYWwoeCwgbmV3U2hhcGUyRCwgYWxpZ25Db3JuZXJzKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlc2l6ZUJpbGluZWFyM0RJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIG5ld1NoYXBlMkQ6IFtudW1iZXIsIG51bWJlcl0sIGFsaWduQ29ybmVyczogYm9vbGVhbik6IEFycmF5M0Q7XG5cbiAgLyoqXG4gICAqIEJhdGNoIG5vcm1hbGl6YXRpb24gM0QuIE1lYW4sIHZhcmlhbmNlLCBzY2FsZSwgYW5kIG9mZnNldCBjYW4gYmUgb2YgdHdvXG4gICAqIHNoYXBlczogMSkgVGhlIHNhbWUgc2hhcGUgYXMgdGhlIGlucHV0OiBhbiBBcnJheTNELiAyKSBJbiB0aGUgY29tbW9uIGNhc2UsXG4gICAqIHRoZSBkZXB0aCBkaW1lbnNpb24gaXMgdGhlIGxhc3QgZGltZW5zaW9uIG9mIHgsIHNvIHRoZSB2YWx1ZXMgd291bGQgYmUgYW5cbiAgICogQXJyYXkxRCBvZiBzaGFwZSBbZGVwdGhdLlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgTkRBcnJheS5cbiAgICogQHBhcmFtIG1lYW4gQSBtZWFuIE5EQXJyYXkuXG4gICAqIEBwYXJhbSB2YXJpYW5jZSBBIHZhcmlhbmNlIE5EQXJyYXkuXG4gICAqIEBwYXJhbSB2YXJpYW5jZUVwc2lsb24gQSBzbWFsbCBmbG9hdCBudW1iZXIgdG8gYXZvaWQgZGl2aWRpbmcgYnkgMC5cbiAgICogQHBhcmFtIHNjYWxlIEEgc2NhbGUgTkRBcnJheS5cbiAgICogQHBhcmFtIG9mZnNldCBBbiBvZmZzZXQgTkRBcnJheS5cbiAgICovXG4gIGJhdGNoTm9ybWFsaXphdGlvbjNEKFxuICAgICAgeDogQXJyYXkzRCwgbWVhbjogQXJyYXkzRHxBcnJheTFELCB2YXJpYW5jZTogQXJyYXkzRHxBcnJheTFELFxuICAgICAgdmFyaWFuY2VFcHNpbG9uID0gLjAwMSwgc2NhbGU/OiBBcnJheTNEfEFycmF5MUQsXG4gICAgICBvZmZzZXQ/OiBBcnJheTNEfEFycmF5MUQpOiBBcnJheTNEIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgeC5yYW5rID09PSAzLFxuICAgICAgICBgRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIGAgK1xuICAgICAgICAgICAgYCR7eC5yYW5rfS5gKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgbWVhbi5yYW5rID09PSAzIHx8IG1lYW4ucmFuayA9PT0gMSxcbiAgICAgICAgYEVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBtZWFuIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgYCArXG4gICAgICAgICAgICBgZ290IHJhbmsgJHttZWFuLnJhbmt9LmApO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB2YXJpYW5jZS5yYW5rID09PSAzIHx8IHZhcmlhbmNlLnJhbmsgPT09IDEsXG4gICAgICAgIGBFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGAgK1xuICAgICAgICAgICAgYGJ1dCBnb3QgcmFuayAke3ZhcmlhbmNlLnJhbmt9LmApO1xuICAgIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgICB1dGlsLmFzc2VydChcbiAgICAgICAgICBzY2FsZS5yYW5rID09PSAzIHx8IHNjYWxlLnJhbmsgPT09IDEsXG4gICAgICAgICAgYEVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYCArXG4gICAgICAgICAgICAgIGBidXQgZ290IHJhbmsgJHtzY2FsZSEucmFua30uYCk7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgb2Zmc2V0LnJhbmsgPT09IDMgfHwgb2Zmc2V0LnJhbmsgPT09IDEsXG4gICAgICAgICAgYEVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGAgK1xuICAgICAgICAgICAgICBgYnV0IGdvdCByYW5rICR7b2Zmc2V0IS5yYW5rfS5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLmJhdGNoTm9ybWFsaXphdGlvbjNESW50ZXJuYWwoXG4gICAgICAgIHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgYmF0Y2hOb3JtYWxpemF0aW9uM0RJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIG1lYW46IEFycmF5M0R8QXJyYXkxRCwgdmFyaWFuY2U6IEFycmF5M0R8QXJyYXkxRCxcbiAgICAgIHZhcmlhbmNlRXBzaWxvbjogbnVtYmVyLCBzY2FsZT86IEFycmF5M0R8QXJyYXkxRCxcbiAgICAgIG9mZnNldD86IEFycmF5M0R8QXJyYXkxRCk6IEFycmF5M0Q7XG5cbiAgLy8vLy8vLy8vLy8vLy9cbiAgLy8gTFNUTSBvcHMgLy9cbiAgLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIG5leHQgc3RhdGVzIGFuZCBvdXRwdXRzIG9mIGEgc3RhY2sgb2YgTFNUTUNlbGxzLlxuICAgKiBFYWNoIGNlbGwgb3V0cHV0IGlzIHVzZWQgYXMgaW5wdXQgdG8gdGhlIG5leHQgY2VsbC5cbiAgICogVGhpcyBpcyBvbmx5IHRoZSBmb3J3YXJkIG1vZGUuXG4gICAqIERlcml2ZWQgZnJvbSB0Zi5jb250cmliLnJuLk11bHRpUk5OQ2VsbC5cbiAgICogQHBhcmFtIGxzdG1DZWxscyBBcnJheSBvZiBMU1RNQ2VsbCBmdW5jdGlvbnMuXG4gICAqIEBwYXJhbSBkYXRhIFRoZSBpbnB1dCB0byB0aGUgY2VsbC5cbiAgICogQHBhcmFtIGMgQXJyYXkgb2YgcHJldmlvdXMgY2VsbCBzdGF0ZXMuXG4gICAqIEBwYXJhbSBoIEFycmF5IG9mIHByZXZpb3VzIGNlbGwgb3V0cHV0cy5cbiAgICogQHJldHVybiBUdXBsZSBbbmV4dENlbGxTdGF0ZXMsIGNlbGxPdXRwdXRzXVxuICAgKi9cbiAgbXVsdGlSTk5DZWxsKGxzdG1DZWxsczogTFNUTUNlbGxbXSwgZGF0YTogQXJyYXkyRCwgYzogQXJyYXkyRFtdLFxuICAgICAgaDogQXJyYXkyRFtdKTogW0FycmF5MkRbXSwgQXJyYXkyRFtdXSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGRhdGEuc2hhcGVbMF0gPT09IDEsXG4gICAgICAgIGBFcnJvciBpbiBtdWx0aVJOTkNlbGw6IGZpcnN0IGRpbWVuc2lvbiBvZiBkYXRhIGlzICR7ZGF0YS5zaGFwZVswXX0sIGAgK1xuICAgICAgICAgICAgYGJ1dCBiYXRjaCBzaXplcyA+IDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkLmApO1xuICAgIGNvbnN0IHJlcyA9IHRoaXMuc2NvcGUoKCkgPT4ge1xuICAgICAgbGV0IGlucHV0ID0gZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3RtQ2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gbHN0bUNlbGxzW2ldKGlucHV0LCBjW2ldLCBoW2ldKTtcbiAgICAgICAgbmV3U3RhdGVzLnB1c2gob3V0cHV0WzBdKTtcbiAgICAgICAgbmV3U3RhdGVzLnB1c2gob3V0cHV0WzFdKTtcbiAgICAgICAgaW5wdXQgPSBvdXRwdXRbMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdTdGF0ZXM7XG4gICAgfSk7XG4gICAgY29uc3QgbmV3QzogQXJyYXkyRFtdID0gW107XG4gICAgY29uc3QgbmV3SDogQXJyYXkyRFtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIG5ld0MucHVzaChyZXNbaV0gYXMgQXJyYXkyRCk7XG4gICAgICBuZXdILnB1c2gocmVzW2kgKyAxXSBhcyBBcnJheTJEKTtcbiAgICB9XG4gICAgcmV0dXJuIFtuZXdDLCBuZXdIXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgbmV4dCBzdGF0ZSBhbmQgb3V0cHV0IG9mIGEgQmFzaWNMU1RNQ2VsbC5cbiAgICogVGhpcyBpcyBvbmx5IHRoZSBmb3J3YXJkIG1vZGUuXG4gICAqIERlcml2ZWQgZnJvbSB0Zi5jb250cmliLnJubi5CYXNpY0xTVE1DZWxsLlxuICAgKiBAcGFyYW0gZm9yZ2V0QmlhcyBGb3JnZXQgYmlhcyBmb3IgdGhlIGNlbGwuXG4gICAqIEBwYXJhbSBsc3RtS2VybmVsIFRoZSB3ZWlnaHRzIGZvciB0aGUgY2VsbC5cbiAgICogQHBhcmFtIGxzdG1CaWFzIFRoZSBiaWFzZXMgZm9yIHRoZSBjZWxsLlxuICAgKiBAcGFyYW0gZGF0YSBUaGUgaW5wdXQgdG8gdGhlIGNlbGwuXG4gICAqIEBwYXJhbSBjIFByZXZpb3VzIGNlbGwgc3RhdGUuXG4gICAqIEBwYXJhbSBoIFByZXZpb3VzIGNlbGwgb3V0cHV0LlxuICAgKiBAcmV0dXJuIFR1cGxlIFtuZXh0Q2VsbFN0YXRlLCBjZWxsT3V0cHV0XVxuICAgKi9cbiAgYmFzaWNMU1RNQ2VsbChmb3JnZXRCaWFzOiBTY2FsYXIsIGxzdG1LZXJuZWw6IEFycmF5MkQsIGxzdG1CaWFzOiBBcnJheTFELFxuICAgICAgZGF0YTogQXJyYXkyRCwgYzogQXJyYXkyRCwgaDogQXJyYXkyRCk6IFtBcnJheTJELCBBcnJheTJEXSB7XG4gICAgY29uc3QgcmVzID0gdGhpcy5zY29wZSgoKSA9PiB7XG4gICAgICB1dGlsLmFzc2VydChcbiAgICAgICAgICBkYXRhLnNoYXBlWzBdID09PSAxLFxuICAgICAgICAgIGBFcnJvciBpbiBtdWx0aVJOTkNlbGw6IGZpcnN0IGRpbWVuc2lvbiBvZiBkYXRhIGlzIGAgK1xuICAgICAgICAgICAgICBgJHtkYXRhLnNoYXBlWzBdfSwgYnV0IGJhdGNoIHNpemVzID4gMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQuYCk7XG4gICAgICAvLyBjb25jYXQoaW5wdXRzLCBoLCAxKVxuICAgICAgLy8gVGhlcmUgaXMgbm8gY29uY2F0MWQsIHNvIHJlc2hhcGUgaW5wdXRzIGFuZCBoIHRvIDNkLCBjb25jYXQsIHRoZW5cbiAgICAgIC8vIHJlc2hhcGUgYmFjayB0byAyZC5cbiAgICAgIGNvbnN0IGRhdGEzRCA9IGRhdGEuYXMzRCgxLCAxLCBkYXRhLnNoYXBlWzFdKTtcbiAgICAgIGNvbnN0IGgzRCA9IGguYXMzRCgxLCAxLCBoLnNoYXBlWzFdKTtcbiAgICAgIGNvbnN0IGNvbWJpbmVkM0QgPSB0aGlzLmNvbmNhdDNEKGRhdGEzRCwgaDNELCAyKTtcbiAgICAgIGNvbnN0IGNvbWJpbmVkMkQgPSBjb21iaW5lZDNELmFzMkQoMSwgZGF0YS5zaGFwZVsxXSArIGguc2hhcGVbMV0pO1xuXG4gICAgICBjb25zdCB3ZWlnaHRlZCA9IHRoaXMubWF0TXVsKGNvbWJpbmVkMkQsIGxzdG1LZXJuZWwpO1xuICAgICAgY29uc3QgcmVzID0gdGhpcy5hZGQod2VpZ2h0ZWQsIGxzdG1CaWFzKSBhcyBBcnJheTJEO1xuXG4gICAgICAvLyBpID0gaW5wdXRfZ2F0ZSwgaiA9IG5ld19pbnB1dCwgZiA9IGZvcmdldF9nYXRlLCBvID0gb3V0cHV0X2dhdGVcbiAgICAgIGNvbnN0IGkgPSB0aGlzLnNsaWNlMkQocmVzLCBbMCwgMF0sIFtyZXMuc2hhcGVbMF0sIHJlcy5zaGFwZVsxXSAvIDRdKTtcbiAgICAgIGNvbnN0IGogPSB0aGlzLnNsaWNlMkQocmVzLCBbMCwgcmVzLnNoYXBlWzFdIC8gNCAqIDFdLFxuICAgICAgICAgIFtyZXMuc2hhcGVbMF0sIHJlcy5zaGFwZVsxXSAvIDRdKTtcbiAgICAgIGNvbnN0IGYgPSB0aGlzLnNsaWNlMkQocmVzLCBbMCwgcmVzLnNoYXBlWzFdIC8gNCAqIDJdLFxuICAgICAgICAgIFtyZXMuc2hhcGVbMF0sIHJlcy5zaGFwZVsxXSAvIDRdKTtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLnNsaWNlMkQocmVzLCBbMCwgcmVzLnNoYXBlWzFdIC8gNCAqIDNdLFxuICAgICAgICAgIFtyZXMuc2hhcGVbMF0sIHJlcy5zaGFwZVsxXSAvIDRdKTtcblxuICAgICAgY29uc3QgbmV3QyA9IHRoaXMuYWRkKFxuICAgICAgICAgIHRoaXMubXVsdGlwbHlTdHJpY3QoYyxcbiAgICAgICAgICAgICAgdGhpcy5zaWdtb2lkKHRoaXMuc2NhbGFyUGx1c0FycmF5KGZvcmdldEJpYXMsIGYpKSksXG4gICAgICAgICAgdGhpcy5tdWx0aXBseVN0cmljdCh0aGlzLnNpZ21vaWQoaSksIHRoaXMudGFuaChqKSkpIGFzIEFycmF5MkQ7XG4gICAgICBjb25zdCBuZXdIID0gdGhpcy5tdWx0aXBseVN0cmljdChcbiAgICAgICAgICB0aGlzLnRhbmgobmV3QyksIHRoaXMuc2lnbW9pZChvKSkgYXMgQXJyYXkyRDtcblxuICAgICAgcmV0dXJuIFtuZXdDLCBuZXdIXTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Jlc1swXSwgcmVzWzFdXTtcbiAgfVxuXG59XG5cbmV4cG9ydCBlbnVtIE1hdHJpeE9yaWVudGF0aW9uIHtcbiAgUkVHVUxBUixcbiAgVFJBTlNQT1NFRFxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQgKiBhcyBjb252X3V0aWwgZnJvbSAnLi4vbWF0aC9jb252X3V0aWwnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0ICogYXMgY29uY2F0M2RfdXRpbCBmcm9tICcuL2NvbmNhdDNkX3V0aWwnO1xuaW1wb3J0ICogYXMgY29weTJEX3V0aWwgZnJvbSAnLi9jb3B5MmRfdXRpbCc7XG5pbXBvcnQge01hdHJpeE9yaWVudGF0aW9uLCBOREFycmF5TWF0aH0gZnJvbSAnLi9tYXRoJztcbmltcG9ydCB7QXJyYXkxRCwgQXJyYXkyRCwgQXJyYXkzRCwgQXJyYXk0RCwgTkRBcnJheSwgU2NhbGFyfSBmcm9tICcuL25kYXJyYXknO1xuXG5leHBvcnQgY2xhc3MgTkRBcnJheU1hdGhDUFUgZXh0ZW5kcyBOREFycmF5TWF0aCB7XG4gIGNvbnN0cnVjdG9yKHNhZmVNb2RlID0gZmFsc2UpIHtcbiAgICBzdXBlcihzYWZlTW9kZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2xvbmVJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQge1xuICAgIHJldHVybiBOREFycmF5Lm1ha2U8VD4oXG4gICAgICAgIG5kYXJyYXkuc2hhcGUsIHt2YWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5nZXRWYWx1ZXMoKSl9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZXNoYXBlSW50ZXJuYWw8VDEgZXh0ZW5kcyBOREFycmF5LCBUMiBleHRlbmRzIE5EQXJyYXk+KFxuICAgICAgbmRhcnJheTogVDEsIG5ld1NoYXBlOiBudW1iZXJbXSk6IFQyIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZUludGVybmFsKG5kYXJyYXkpLnJlc2hhcGU8VDI+KG5ld1NoYXBlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzbGljZTJESW50ZXJuYWwoXG4gICAgICBpbnB1dDogQXJyYXkyRCwgYmVnaW5Sb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBzaXplUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdKTogQXJyYXkyRCB7XG4gICAgY29uc3QgcmVzdWx0ID0gQXJyYXkyRC56ZXJvcyhzaXplUm93Q29sKTtcbiAgICB0aGlzLmNvcHkyREludGVybmFsKFxuICAgICAgICBpbnB1dCwgYmVnaW5Sb3dDb2wsIHNpemVSb3dDb2wsIHJlc3VsdCwgWzAsIDBdLCBzaXplUm93Q29sKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJvdGVjdGVkIGNvcHkyREludGVybmFsKFxuICAgICAgc291cmNlOiBBcnJheTJELCBzb3VyY2VCZWdpblJvd0NvbDogW251bWJlciwgbnVtYmVyXSxcbiAgICAgIHNvdXJjZVNpemVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sIGRlc3Q6IEFycmF5MkQsXG4gICAgICBkZXN0QmVnaW5Sb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBkZXN0U2l6ZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSk6IHZvaWQge1xuICAgIGNvcHkyRF91dGlsLnZhbGlkYXRlU2hhcGVzKHNvdXJjZVNpemVSb3dDb2wsIGRlc3RTaXplUm93Q29sKTtcbiAgICBjb25zdCBzcmNWYWx1ZXMgPSBzb3VyY2UuZ2V0VmFsdWVzKCk7XG4gICAgY29uc3QgZHN0VmFsdWVzID0gZGVzdC5nZXRWYWx1ZXMoKTtcbiAgICBjb25zdCBuID0gc291cmNlU2l6ZVJvd0NvbFswXSAqIHNvdXJjZVNpemVSb3dDb2xbMV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IHNyY1JvdyA9IHNvdXJjZUJlZ2luUm93Q29sWzBdICsgTWF0aC5mbG9vcihpIC8gc291cmNlU2l6ZVJvd0NvbFsxXSk7XG4gICAgICBjb25zdCBzcmNDb2wgPSBzb3VyY2VCZWdpblJvd0NvbFsxXSArIChpICUgc291cmNlU2l6ZVJvd0NvbFsxXSk7XG4gICAgICBjb25zdCBzcmNPZmYgPSBzcmNSb3cgKiBzb3VyY2Uuc2hhcGVbMV0gKyBzcmNDb2w7XG4gICAgICBjb25zdCBkc3RSb3cgPSBkZXN0QmVnaW5Sb3dDb2xbMF0gKyBNYXRoLmZsb29yKGkgLyBkZXN0U2l6ZVJvd0NvbFsxXSk7XG4gICAgICBjb25zdCBkc3RDb2wgPSBkZXN0QmVnaW5Sb3dDb2xbMV0gKyAoaSAlIGRlc3RTaXplUm93Q29sWzFdKTtcbiAgICAgIGNvbnN0IGRzdE9mZiA9IGRzdFJvdyAqIGRlc3Quc2hhcGVbMV0gKyBkc3RDb2w7XG4gICAgICBkc3RWYWx1ZXNbZHN0T2ZmXSA9IHNyY1ZhbHVlc1tzcmNPZmZdO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBjb25jYXQzREludGVybmFsKHgxOiBBcnJheTNELCB4MjogQXJyYXkzRCwgYXhpczogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPVxuICAgICAgICBjb25jYXQzZF91dGlsLmNvbXB1dGVDb25jYXQzRE91dHB1dFNoYXBlKHgxLnNoYXBlLCB4Mi5zaGFwZSwgYXhpcyk7XG5cbiAgICBjb25zdCB2YWx1ZXMgPSBBcnJheTNELnplcm9zKG91dHB1dFNoYXBlKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0U2hhcGVbMF07IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvdXRwdXRTaGFwZVsxXTsgaisrKSB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgb3V0cHV0U2hhcGVbMl07IGsrKykge1xuICAgICAgICAgIC8vIFNoYWRlciBiZWdpbnMuXG4gICAgICAgICAgY29uc3QgaW5kZXg6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFtpLCBqLCBrXTtcbiAgICAgICAgICBsZXQgdmFsdWU6IG51bWJlcjtcbiAgICAgICAgICBpZiAoaW5kZXhbYXhpc10gPCB4MS5zaGFwZVtheGlzXSkge1xuICAgICAgICAgICAgdmFsdWUgPSB4MS5nZXQoaSwgaiwgayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4W2F4aXNdIC09IHgxLnNoYXBlW2F4aXNdO1xuICAgICAgICAgICAgY29uc3QgW2kyLCBqMiwgazJdID0gaW5kZXg7XG4gICAgICAgICAgICB2YWx1ZSA9IHgyLmdldChpMiwgajIsIGsyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZXMuc2V0KHZhbHVlLCBpLCBqLCBrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2NhbGVkQXJyYXlBZGRJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oXG4gICAgICBjMTogU2NhbGFyLCBhOiBULCBjMjogU2NhbGFyLCBiOiBUKSB7XG4gICAgY29uc3QgbmV3U2hhcGUgPSB1dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdGVkU2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgY29uc3QgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh1dGlsLnNpemVGcm9tU2hhcGUobmV3U2hhcGUpKTtcblxuICAgIGNvbnN0IGFWYWx1ZXMgPSBhLmdldFZhbHVlcygpO1xuICAgIGNvbnN0IGJWYWx1ZXMgPSBiLmdldFZhbHVlcygpO1xuICAgIGNvbnN0IGMxVmFsID0gYzEuZ2V0KCk7XG4gICAgY29uc3QgYzJWYWwgPSBjMi5nZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1ZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgbmV3VmFsdWVzW2ldID0gYzFWYWwgKiBhVmFsdWVzW2kgJSBhLnNpemVdICsgYzJWYWwgKiBiVmFsdWVzW2kgJSBiLnNpemVdO1xuICAgIH1cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPFQ+KG5ld1NoYXBlLCB7dmFsdWVzOiBuZXdWYWx1ZXN9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBuZWdJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCk6IFQge1xuICAgIHJldHVybiB0aGlzLnNjYWxhclRpbWVzQXJyYXkoU2NhbGFyLk5FR19PTkUsIGEpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFkZEludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihhOiBULCBiOiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVkQXJyYXlBZGRJbnRlcm5hbDxUPihTY2FsYXIuT05FLCBhLCBTY2FsYXIuT05FLCBiKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdWJJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgYjogVCk6IFQge1xuICAgIHJldHVybiB0aGlzLnNjYWxlZEFycmF5QWRkSW50ZXJuYWw8VD4oU2NhbGFyLk9ORSwgYSwgU2NhbGFyLk5FR19PTkUsIGIpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1hdE11bEludGVybmFsKFxuICAgICAgYTogQXJyYXkyRCwgYjogQXJyYXkyRCwgYU9yaWVudGF0aW9uID0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUixcbiAgICAgIGJPcmllbnRhdGlvbiA9IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpOiBBcnJheTJEIHtcbiAgICBjb25zdCBzaGFyZWREaW0gPVxuICAgICAgICAoYU9yaWVudGF0aW9uID09PSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGEuc2hhcGVbMV0gOiBhLnNoYXBlWzBdO1xuXG4gICAgY29uc3QgbGVmdERpbSA9XG4gICAgICAgIChhT3JpZW50YXRpb24gPT09IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYS5zaGFwZVswXSA6IGEuc2hhcGVbMV07XG4gICAgY29uc3QgcmlnaHREaW0gPVxuICAgICAgICAoYk9yaWVudGF0aW9uID09PSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGIuc2hhcGVbMV0gOiBiLnNoYXBlWzBdO1xuXG4gICAgY29uc3Qgbm9ybWFsR2V0dGVyID0gKG1hdHJpeDogQXJyYXkyRCwgaTogbnVtYmVyLCBqOiBudW1iZXIpID0+XG4gICAgICAgIG1hdHJpeC5nZXQoaSwgaik7XG4gICAgY29uc3QgdHJhbnNwb3NlZEdldHRlciA9IChtYXRyaXg6IEFycmF5MkQsIGk6IG51bWJlciwgajogbnVtYmVyKSA9PlxuICAgICAgICBtYXRyaXguZ2V0KGosIGkpO1xuXG4gICAgY29uc3QgYUdldHRlciA9IChhT3JpZW50YXRpb24gPT09IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID9cbiAgICAgICAgbm9ybWFsR2V0dGVyIDpcbiAgICAgICAgdHJhbnNwb3NlZEdldHRlcjtcbiAgICBjb25zdCBiR2V0dGVyID0gKGJPcmllbnRhdGlvbiA9PT0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgP1xuICAgICAgICBub3JtYWxHZXR0ZXIgOlxuICAgICAgICB0cmFuc3Bvc2VkR2V0dGVyO1xuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobGVmdERpbSAqIHJpZ2h0RGltKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0RGltOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmlnaHREaW07ICsraikge1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBzaGFyZWREaW07ICsraykge1xuICAgICAgICAgIC8vIFRPRE86IG9wdGltaXplIENQVSBtYXRtdWwuXG4gICAgICAgICAgc3VtICs9IGFHZXR0ZXIoYSwgaSwgaykgKiBiR2V0dGVyKGIsIGssIGopO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1tpbmRleCsrXSA9IHN1bTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5MkQubmV3KFtsZWZ0RGltLCByaWdodERpbV0sIHZhbHVlcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbXVsdGlwbHlJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgYjogVCk6IFQge1xuICAgIGNvbnN0IG5ld1NoYXBlID0gdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgIGNvbnN0IG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodXRpbC5zaXplRnJvbVNoYXBlKG5ld1NoYXBlKSk7XG5cbiAgICBjb25zdCBhVmFsdWVzID0gYS5nZXRWYWx1ZXMoKTtcbiAgICBjb25zdCBiVmFsdWVzID0gYi5nZXRWYWx1ZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1ZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgbmV3VmFsdWVzW2ldID0gYVZhbHVlc1tpICUgYS5zaXplXSAqIGJWYWx1ZXNbaSAlIGIuc2l6ZV07XG4gICAgfVxuICAgIHJldHVybiBOREFycmF5Lm1ha2U8VD4obmV3U2hhcGUsIHt2YWx1ZXM6IG5ld1ZhbHVlc30pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGRpdmlkZUludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihhOiBULCBiOiBUKTogVCB7XG4gICAgY29uc3QgbmV3U2hhcGUgPSB1dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdGVkU2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgY29uc3QgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh1dGlsLnNpemVGcm9tU2hhcGUobmV3U2hhcGUpKTtcblxuICAgIGNvbnN0IGFWYWx1ZXMgPSBhLmdldFZhbHVlcygpO1xuICAgIGNvbnN0IGJWYWx1ZXMgPSBiLmdldFZhbHVlcygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdWYWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIG5ld1ZhbHVlc1tpXSA9IGFWYWx1ZXNbaSAlIGEuc2l6ZV0gLyBiVmFsdWVzW2kgJSBiLnNpemVdO1xuICAgIH1cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPFQ+KG5ld1NoYXBlLCB7dmFsdWVzOiBuZXdWYWx1ZXN9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdW1JbnRlcm5hbChuZGFycmF5OiBOREFycmF5KTogU2NhbGFyIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBzdW0gKz0gdmFsdWVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gU2NhbGFyLm5ldyhzdW0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFyZ01pbkludGVybmFsKG5kYXJyYXk6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIGxldCBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGxldCBtaW5JbmRleCA9IC0xO1xuICAgIGNvbnN0IHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gU2NhbGFyLm5ldyhOYU4pO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICBtaW5JbmRleCA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTY2FsYXIubmV3KG1pbkluZGV4KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcmdNYXhJbnRlcm5hbChuZGFycmF5OiBOREFycmF5KTogU2NhbGFyIHtcbiAgICBsZXQgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXhJbmRleCA9IC0xO1xuICAgIGNvbnN0IHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gU2NhbGFyLm5ldyhOYU4pO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICBtYXhJbmRleCA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTY2FsYXIubmV3KG1heEluZGV4KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcmdNYXhFcXVhbHNJbnRlcm5hbCh4MTogTkRBcnJheSwgeDI6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIGNvbnN0IGFyZ01heDEgPSB0aGlzLmFyZ01heEludGVybmFsKHgxKS5nZXQoKTtcbiAgICBjb25zdCBhcmdNYXgyID0gdGhpcy5hcmdNYXhJbnRlcm5hbCh4MikuZ2V0KCk7XG4gICAgaWYgKGlzTmFOKGFyZ01heDEpIHx8IGlzTmFOKGFyZ01heDIpKSB7XG4gICAgICByZXR1cm4gU2NhbGFyLm5ldyhOYU4pO1xuICAgIH1cbiAgICByZXR1cm4gU2NhbGFyLm5ldygrKGFyZ01heDEgPT09IGFyZ01heDIpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB0b3BLSW50ZXJuYWwobmRhcnJheTogTkRBcnJheSwgazogbnVtYmVyKTpcbiAgICAgIHt2YWx1ZXM6IEFycmF5MUQsIGluZGljZXM6IEFycmF5MUR9IHtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgIGNvbnN0IHZhbHVlc0FuZEluZGljZXM6IEFycmF5PHt2YWx1ZTogbnVtYmVyLCBpbmRleDogbnVtYmVyfT4gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzQW5kSW5kaWNlcy5wdXNoKHt2YWx1ZTogdmFsdWVzW2ldLCBpbmRleDogaX0pO1xuICAgIH1cbiAgICB2YWx1ZXNBbmRJbmRpY2VzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIHJldHVybiBiLnZhbHVlIC0gYS52YWx1ZTtcbiAgICB9KTtcbiAgICBjb25zdCB0b3BrVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShrKTtcbiAgICBjb25zdCB0b3BrSW5kaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgIHRvcGtWYWx1ZXNbaV0gPSB2YWx1ZXNBbmRJbmRpY2VzW2ldLnZhbHVlO1xuICAgICAgdG9wa0luZGljZXNbaV0gPSB2YWx1ZXNBbmRJbmRpY2VzW2ldLmluZGV4O1xuICAgIH1cbiAgICByZXR1cm4ge3ZhbHVlczogQXJyYXkxRC5uZXcodG9wa1ZhbHVlcyksIGluZGljZXM6IEFycmF5MUQubmV3KHRvcGtJbmRpY2VzKX07XG4gIH1cblxuICBwcm90ZWN0ZWQgbWluSW50ZXJuYWwobmRhcnJheTogTkRBcnJheSk6IFNjYWxhciB7XG4gICAgY29uc3QgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICBsZXQgbWluID0gdmFsdWVzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFNjYWxhci5uZXcoTmFOKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFNjYWxhci5uZXcobWluKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtYXhJbnRlcm5hbChuZGFycmF5OiBOREFycmF5KTogU2NhbGFyIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgIGxldCBtYXggPSB2YWx1ZXNbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gU2NhbGFyLm5ldyhOYU4pO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU2NhbGFyLm5ldyhtYXgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGV4cEludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVCB7XG4gICAgY29uc3QgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICBjb25zdCBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmV4cCh2YWx1ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPFQ+KG5kYXJyYXkuc2hhcGUsIHt2YWx1ZXM6IG5ld1ZhbHVlc30pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGxvZ0ludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVCB7XG4gICAgY29uc3QgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICBjb25zdCBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGgubG9nKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihuZGFycmF5LnNoYXBlLCB7dmFsdWVzOiBuZXdWYWx1ZXN9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBsb2dTdW1FeHBJbnRlcm5hbChuZGFycmF5OiBOREFycmF5KTogU2NhbGFyIHtcbiAgICBjb25zdCB4TWF4ID0gdGhpcy5tYXgobmRhcnJheSk7XG4gICAgY29uc3QgYSA9IHRoaXMuYXJyYXlNaW51c1NjYWxhcihuZGFycmF5LCB4TWF4KTtcbiAgICBjb25zdCBiID0gdGhpcy5leHAoYSk7XG4gICAgY29uc3QgYyA9IHRoaXMuc3VtKGIpO1xuICAgIGNvbnN0IGQgPSB0aGlzLmxvZyhjKTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFkZCh4TWF4LCBkKTtcblxuICAgIHhNYXguZGlzcG9zZSgpO1xuICAgIGEuZGlzcG9zZSgpO1xuICAgIGIuZGlzcG9zZSgpO1xuICAgIGMuZGlzcG9zZSgpO1xuICAgIGQuZGlzcG9zZSgpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByb3RlY3RlZCByZWx1SW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUIHtcbiAgICBjb25zdCByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgY29uc3QgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5tYXgoMCwgdmFsdWVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihuZGFycmF5LnNoYXBlLCB7dmFsdWVzOiByZXN1bHRWYWx1ZXN9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzaWdtb2lkSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUIHtcbiAgICBjb25zdCByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgY29uc3QgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0VmFsdWVzW2ldID0gMSAvICgxICsgTWF0aC5leHAoLXZhbHVlc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPFQ+KG5kYXJyYXkuc2hhcGUsIHt2YWx1ZXM6IHJlc3VsdFZhbHVlc30pO1xuICB9XG5cbiAgcHJvdGVjdGVkIHRhbmhJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQge1xuICAgIGNvbnN0IHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICByZXN1bHRWYWx1ZXNbaV0gPSB1dGlsLnRhbmgodmFsdWVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihuZGFycmF5LnNoYXBlLCB7dmFsdWVzOiByZXN1bHRWYWx1ZXN9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzaW5JbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQge1xuICAgIGNvbnN0IHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLnNpbih2YWx1ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPFQ+KG5kYXJyYXkuc2hhcGUsIHt2YWx1ZXM6IHJlc3VsdFZhbHVlc30pO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN0ZXBJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQge1xuICAgIGNvbnN0IHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHZhbHVlID4gMCA/IDEgOiAodmFsdWUgPCAwID8gMCA6IHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihuZGFycmF5LnNoYXBlLCB7dmFsdWVzOiByZXN1bHRWYWx1ZXN9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbWFnZSBpcyBvZiBzaGFwZSBbciwgYywgZDFdLlxuICAgKiB3ZWlnaHRzIGlzIG9mIHNoYXBlIFtGLCBGLCBkMSwgZDJdLlxuICAgKi9cbiAgcHJvdGVjdGVkIGNvbnYyZEludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgd2VpZ2h0czogQXJyYXk0RCwgYmlhc2VzOiBBcnJheTFEfG51bGwsIHN0cmlkZTogbnVtYmVyLFxuICAgICAgcGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICBjb25zdCBbeFJvd3MsIHhDb2xzLCBpbnB1dERlcHRoXSA9IHguc2hhcGU7XG4gICAgY29uc3QgZmllbGRTaXplID0gd2VpZ2h0cy5zaGFwZVswXTtcbiAgICBjb25zdCBvdXRwdXREZXB0aCA9IHdlaWdodHMuc2hhcGVbM107XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZU91dHB1dFNoYXBlM0QoXG4gICAgICAgIFt4Um93cywgeENvbHMsIGlucHV0RGVwdGhdLCBmaWVsZFNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHBhZCk7XG4gICAgY29uc3QgeSA9IEFycmF5M0QuemVyb3Mob3V0cHV0U2hhcGUpO1xuICAgIGZvciAobGV0IGQyID0gMDsgZDIgPCBvdXRwdXREZXB0aDsgKytkMikge1xuICAgICAgZm9yIChsZXQgeVIgPSAwOyB5UiA8IHkuc2hhcGVbMF07ICsreVIpIHtcbiAgICAgICAgY29uc3QgeFJDb3JuZXIgPSB5UiAqIHN0cmlkZSAtIHBhZDtcbiAgICAgICAgY29uc3QgeFJNaW4gPSBNYXRoLm1heCgwLCB4UkNvcm5lcik7XG4gICAgICAgIGNvbnN0IHhSTWF4ID0gTWF0aC5taW4oeFJvd3MsIGZpZWxkU2l6ZSArIHhSQ29ybmVyKTtcbiAgICAgICAgZm9yIChsZXQgeUMgPSAwOyB5QyA8IHkuc2hhcGVbMV07ICsreUMpIHtcbiAgICAgICAgICBjb25zdCB4Q0Nvcm5lciA9IHlDICogc3RyaWRlIC0gcGFkO1xuICAgICAgICAgIGNvbnN0IHhDTWluID0gTWF0aC5tYXgoMCwgeENDb3JuZXIpO1xuICAgICAgICAgIGNvbnN0IHhDTWF4ID0gTWF0aC5taW4oeENvbHMsIGZpZWxkU2l6ZSArIHhDQ29ybmVyKTtcbiAgICAgICAgICBsZXQgZG90UHJvZCA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgeFIgPSB4Uk1pbjsgeFIgPCB4Uk1heDsgKyt4Uikge1xuICAgICAgICAgICAgY29uc3Qgd1IgPSB4UiAtIHhSQ29ybmVyO1xuICAgICAgICAgICAgZm9yIChsZXQgeEMgPSB4Q01pbjsgeEMgPCB4Q01heDsgKyt4Qykge1xuICAgICAgICAgICAgICBjb25zdCB3QyA9IHhDIC0geENDb3JuZXI7XG4gICAgICAgICAgICAgIGZvciAobGV0IGQxID0gMDsgZDEgPCBpbnB1dERlcHRoOyArK2QxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGl4ZWwgPSB4LmdldCh4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3ZWlnaHQgPSB3ZWlnaHRzLmdldCh3Uiwgd0MsIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIHdlaWdodDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBiaWFzID0gKGJpYXNlcyAhPSBudWxsKSA/IGJpYXNlcy5nZXQoZDIpIDogMDtcbiAgICAgICAgICB5LnNldChkb3RQcm9kICsgYmlhcywgeVIsIHlDLCBkMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY29udjJkQmFja1Byb3BJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIGR5OiBBcnJheTNELCB3ZWlnaHRzOiBBcnJheTRELCBzdHJpZGU6IG51bWJlcixcbiAgICAgIHBhZDogbnVtYmVyKToge2R4OiBBcnJheTNELCBkdzogQXJyYXk0RCwgZGI6IEFycmF5MUR9IHtcbiAgICBjb25zdCBmU2l6ZSA9IHdlaWdodHMuc2hhcGVbMF07XG4gICAgY29uc3QgZHcgPSB0aGlzLmNvbnYyZERlcldlaWdodHMoeCwgZHksIGZTaXplLCBzdHJpZGUsIHBhZCk7XG4gICAgY29uc3QgZGIgPSB0aGlzLmNvbnYyZERlckJpYXMoZHkpO1xuICAgIGNvbnN0IGR4ID0gdGhpcy5jb252MmRUcmFuc3Bvc2VJbnRlcm5hbChkeSwgd2VpZ2h0cywgbnVsbCwgc3RyaWRlLCBwYWQpO1xuICAgIHJldHVybiB7ZHgsIGRiLCBkd307XG4gIH1cblxuICAvKipcbiAgICogaW1hZ2UgaXMgb2Ygc2hhcGUgW3IsIGMsIGQxXS5cbiAgICogd2VpZ2h0cyBpcyBvZiBzaGFwZSBbRiwgRiwgZDEsIGQyXS5cbiAgICovXG4gIHByb3RlY3RlZCBjb252MmRUcmFuc3Bvc2VJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIHdlaWdodHM6IEFycmF5NEQsIGJpYXNlczogQXJyYXkxRHxudWxsLCBvcmlnU3RyaWRlOiBudW1iZXIsXG4gICAgICBvcmlnUGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICBjb25zdCBmU2l6ZSA9IHdlaWdodHMuc2hhcGVbMF07XG4gICAgY29uc3QgcGFkID0gZlNpemUgLSAxIC0gb3JpZ1BhZDtcbiAgICBjb25zdCBvcmlnSW5wdXREZXB0aCA9IHdlaWdodHMuc2hhcGVbMl07XG4gICAgY29uc3Qgb3JpZ091dHB1dERlcHRoID0gd2VpZ2h0cy5zaGFwZVszXTtcbiAgICBjb25zdCB4Um93cyA9IHguc2hhcGVbMF07XG4gICAgY29uc3QgeENvbHMgPSB4LnNoYXBlWzFdO1xuXG4gICAgLy8gRGlsYXRlIHRoZSBpbnB1dC5cbiAgICBjb25zdCB4Um93c0RpbGF0ZWQgPSAoeFJvd3MgLSAxKSAqIG9yaWdTdHJpZGUgKyAxO1xuICAgIGNvbnN0IHhDb2xzRGlsYXRlZCA9ICh4Q29scyAtIDEpICogb3JpZ1N0cmlkZSArIDE7XG5cbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRChcbiAgICAgICAgW3hSb3dzRGlsYXRlZCwgeENvbHNEaWxhdGVkLCBvcmlnT3V0cHV0RGVwdGhdLCBmU2l6ZSwgb3JpZ0lucHV0RGVwdGgsIDEsXG4gICAgICAgIHBhZCk7XG4gICAgY29uc3QgeSA9IEFycmF5M0QuemVyb3Mob3V0cHV0U2hhcGUpO1xuICAgIGZvciAobGV0IGQyID0gMDsgZDIgPCBvcmlnSW5wdXREZXB0aDsgKytkMikge1xuICAgICAgZm9yIChsZXQgeVIgPSAwOyB5UiA8IHkuc2hhcGVbMF07ICsreVIpIHtcbiAgICAgICAgY29uc3QgeFJDb3JuZXIgPSB5UiAtIHBhZDtcbiAgICAgICAgY29uc3QgeFJNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoeFJDb3JuZXIgLyBvcmlnU3RyaWRlKSk7XG4gICAgICAgIGNvbnN0IHhSTWF4ID0gTWF0aC5taW4oeFJvd3MsIChmU2l6ZSArIHhSQ29ybmVyKSAvIG9yaWdTdHJpZGUpO1xuXG4gICAgICAgIGZvciAobGV0IHlDID0gMDsgeUMgPCB5LnNoYXBlWzFdOyArK3lDKSB7XG4gICAgICAgICAgY29uc3QgeENDb3JuZXIgPSB5QyAtIHBhZDtcbiAgICAgICAgICBjb25zdCB4Q01pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh4Q0Nvcm5lciAvIG9yaWdTdHJpZGUpKTtcbiAgICAgICAgICBjb25zdCB4Q01heCA9IE1hdGgubWluKHhDb2xzLCAoZlNpemUgKyB4Q0Nvcm5lcikgLyBvcmlnU3RyaWRlKTtcblxuICAgICAgICAgIGxldCBkb3RQcm9kID0gMDtcbiAgICAgICAgICBmb3IgKGxldCB4UiA9IHhSTWluOyB4UiA8IHhSTWF4OyArK3hSKSB7XG4gICAgICAgICAgICBjb25zdCB3UiA9IHhSICogb3JpZ1N0cmlkZSAtIHhSQ29ybmVyO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB4QyA9IHhDTWluOyB4QyA8IHhDTWF4OyArK3hDKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHdDID0geEMgKiBvcmlnU3RyaWRlIC0geENDb3JuZXI7XG5cbiAgICAgICAgICAgICAgZm9yIChsZXQgZDEgPSAwOyBkMSA8IG9yaWdPdXRwdXREZXB0aDsgKytkMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0geC5nZXQoeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID1cbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0cy5nZXQoZlNpemUgLSAxIC0gd1IsIGZTaXplIC0gMSAtIHdDLCBkMiwgZDEpO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYmlhcyA9IGJpYXNlcyAhPSBudWxsID8gYmlhc2VzLmdldChkMikgOiAwO1xuICAgICAgICAgIHkuc2V0KGRvdFByb2QgKyBiaWFzLCB5UiwgeUMsIGQyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbWFnZSBpcyBvZiBzaGFwZSBbciwgYywgZDFdLlxuICAgKiB3ZWlnaHRzIGlzIG9mIHNoYXBlIFtGLCBGLCBkMSwgZDJdLlxuICAgKi9cbiAgcHJvdGVjdGVkIGNvbnYyZFRyYW5zcG9zZVNoYWRlckxpa2UoXG4gICAgICB4OiBBcnJheTNELCBvcmlnV2VpZ2h0czogQXJyYXk0RCwgb3JpZ1N0cmlkZTogbnVtYmVyLFxuICAgICAgb3JpZ1BhZDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgY29uc3QgZlNpemUgPSBvcmlnV2VpZ2h0cy5zaGFwZVswXTtcbiAgICBjb25zdCBwYWQgPSBmU2l6ZSAtIDEgLSBvcmlnUGFkO1xuICAgIGNvbnN0IG9yaWdJbnB1dERlcHRoID0gb3JpZ1dlaWdodHMuc2hhcGVbMl07XG4gICAgY29uc3Qgb3JpZ091dHB1dERlcHRoID0gb3JpZ1dlaWdodHMuc2hhcGVbM107XG4gICAgY29uc3QgeFJvd3MgPSB4LnNoYXBlWzBdO1xuICAgIGNvbnN0IHhDb2xzID0geC5zaGFwZVsxXTtcblxuICAgIC8vIERpbGF0ZSB0aGUgaW5wdXQuXG4gICAgY29uc3QgeFJvd3NEaWxhdGVkID0gKHhSb3dzIC0gMSkgKiBvcmlnU3RyaWRlICsgMTtcbiAgICBjb25zdCB4Q29sc0RpbGF0ZWQgPSAoeENvbHMgLSAxKSAqIG9yaWdTdHJpZGUgKyAxO1xuXG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZU91dHB1dFNoYXBlM0QoXG4gICAgICAgIFt4Um93c0RpbGF0ZWQsIHhDb2xzRGlsYXRlZCwgb3JpZ091dHB1dERlcHRoXSwgZlNpemUsIG9yaWdJbnB1dERlcHRoLCAxLFxuICAgICAgICBwYWQpO1xuICAgIGNvbnN0IHkgPSBBcnJheTNELnplcm9zKG91dHB1dFNoYXBlKTtcblxuICAgIGZvciAobGV0IGQyID0gMDsgZDIgPCBvcmlnSW5wdXREZXB0aDsgKytkMikge1xuICAgICAgZm9yIChsZXQgeVIgPSAwOyB5UiA8IHkuc2hhcGVbMF07ICsreVIpIHtcbiAgICAgICAgZm9yIChsZXQgeUMgPSAwOyB5QyA8IHkuc2hhcGVbMV07ICsreUMpIHtcbiAgICAgICAgICAvLyBTaGFkZXIgY29kZSBiZWdpbnMuXG4gICAgICAgICAgY29uc3QgeFJDb3JuZXIgPSB5UiAtIHBhZDtcbiAgICAgICAgICBjb25zdCB4Q0Nvcm5lciA9IHlDIC0gcGFkO1xuICAgICAgICAgIGxldCBkb3RQcm9kID0gMDtcbiAgICAgICAgICBmb3IgKGxldCB3UiA9IDA7IHdSIDwgZlNpemU7ICsrd1IpIHtcbiAgICAgICAgICAgIGNvbnN0IHhSID0gKHhSQ29ybmVyICsgd1IpIC8gb3JpZ1N0cmlkZTtcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0geFJvd3MgfHwgTWF0aC5mbG9vcih4UikgIT09IHhSKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgd0MgPSAwOyB3QyA8IGZTaXplOyArK3dDKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHhDID0gKHhDQ29ybmVyICsgd0MpIC8gb3JpZ1N0cmlkZTtcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSB4Q29scyB8fCBNYXRoLmZsb29yKHhDKSAhPT0geEMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGxldCBkMSA9IDA7IGQxIDwgb3JpZ091dHB1dERlcHRoOyArK2QxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGl4ZWwgPSB4LmdldCh4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3ZWlnaHQgPVxuICAgICAgICAgICAgICAgICAgICBvcmlnV2VpZ2h0cy5nZXQoZlNpemUgLSAxIC0gd1IsIGZTaXplIC0gMSAtIHdDLCBkMiwgZDEpO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgeS5zZXQoZG90UHJvZCwgeVIsIHlDLCBkMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHk7XG4gIH1cblxuICBjb252MmREZXJXZWlnaHRzKFxuICAgICAgeDogQXJyYXkzRCwgZFk6IEFycmF5M0QsIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLFxuICAgICAgemVyb1BhZDogbnVtYmVyKTogQXJyYXk0RCB7XG4gICAgY29uc3QgaW5wdXREZXB0aCA9IHguc2hhcGVbMl07XG4gICAgY29uc3Qgb3V0cHV0RGVwdGggPSBkWS5zaGFwZVsyXTtcbiAgICBjb25zdCB3ZWlnaHRzU2hhcGUgPVxuICAgICAgICBjb252X3V0aWwuY29tcHV0ZVdlaWdodHNTaGFwZTREKGlucHV0RGVwdGgsIG91dHB1dERlcHRoLCBmU2l6ZSk7XG4gICAgY29uc3QgZFcgPSBBcnJheTRELnplcm9zKHdlaWdodHNTaGFwZSk7XG5cbiAgICBjb25zdCB5TnVtUm93cyA9IGRZLnNoYXBlWzBdO1xuICAgIGNvbnN0IHlOdW1Db2xzID0gZFkuc2hhcGVbMV07XG4gICAgY29uc3QgeE51bVJvd3MgPSB4LnNoYXBlWzBdO1xuICAgIGNvbnN0IHhOdW1Db2xzID0geC5zaGFwZVsxXTtcblxuICAgIGZvciAobGV0IHdSID0gMDsgd1IgPCBmU2l6ZTsgKyt3Uikge1xuICAgICAgY29uc3QgeVJNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHplcm9QYWQgLSB3UikgLyBzdHJpZGUpKTtcbiAgICAgIGNvbnN0IHlSTWF4ID0gTWF0aC5taW4oeU51bVJvd3MsICh4TnVtUm93cyArIHplcm9QYWQgLSB3UikgLyBzdHJpZGUpO1xuXG4gICAgICBmb3IgKGxldCB3QyA9IDA7IHdDIDwgZlNpemU7ICsrd0MpIHtcbiAgICAgICAgY29uc3QgeUNNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHplcm9QYWQgLSB3QykgLyBzdHJpZGUpKTtcbiAgICAgICAgY29uc3QgeUNNYXggPSBNYXRoLm1pbih5TnVtQ29scywgKHhOdW1Db2xzICsgemVyb1BhZCAtIHdDKSAvIHN0cmlkZSk7XG5cbiAgICAgICAgZm9yIChsZXQgZDEgPSAwOyBkMSA8IGlucHV0RGVwdGg7ICsrZDEpIHtcbiAgICAgICAgICBmb3IgKGxldCBkMiA9IDA7IGQyIDwgb3V0cHV0RGVwdGg7ICsrZDIpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY29udm9sdmUuXG4gICAgICAgICAgICBsZXQgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB5UiA9IHlSTWluOyB5UiA8IHlSTWF4OyArK3lSKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHhSID0gd1IgKyB5UiAqIHN0cmlkZSAtIHplcm9QYWQ7XG4gICAgICAgICAgICAgIGZvciAobGV0IHlDID0geUNNaW47IHlDIDwgeUNNYXg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4QyA9IHdDICsgeUMgKiBzdHJpZGUgLSB6ZXJvUGFkO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geC5nZXQoeFIsIHhDLCBkMSkgKiBkWS5nZXQoeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRXLnNldChkb3RQcm9kLCB3Uiwgd0MsIGQxLCBkMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkVztcbiAgfVxuXG4gIGNvbnYyZERlckJpYXMoZFk6IEFycmF5M0QpOiBBcnJheTFEIHtcbiAgICBjb25zdCBvdXRwdXREZXB0aCA9IGRZLnNoYXBlWzJdO1xuICAgIGNvbnN0IG51bVJvd3MgPSBkWS5zaGFwZVswXTtcbiAgICBjb25zdCBudW1Db2xzID0gZFkuc2hhcGVbMV07XG4gICAgY29uc3QgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShvdXRwdXREZXB0aCk7XG4gICAgZm9yIChsZXQgZDIgPSAwOyBkMiA8IG91dHB1dERlcHRoOyArK2QyKSB7XG4gICAgICBsZXQgc3VtID0gMDtcbiAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgbnVtUm93czsgKytyKSB7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbnVtQ29sczsgKytjKSB7XG4gICAgICAgICAgc3VtICs9IGRZLmdldChyLCBjLCBkMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhbHVlc1tkMl0gPSBzdW07XG4gICAgfVxuICAgIHJldHVybiBBcnJheTFELm5ldyh2YWx1ZXMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN3aXRjaERpbUludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5Pih0OiBULCBuZXdEaW06IG51bWJlcltdKTogVCB7XG4gICAgY29uc3QgbmV3U2hhcGU6IG51bWJlcltdID0gbmV3IEFycmF5KHQucmFuayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3U2hhcGVbaV0gPSB0LnNoYXBlW25ld0RpbVtpXV07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodC5zaXplKTtcbiAgICBjb25zdCB2YWx1ZXMgPSB0LmdldFZhbHVlcygpO1xuICAgIGNvbnN0IHJlc3VsdCA9IE5EQXJyYXkubWFrZTxUPihuZXdTaGFwZSwge3ZhbHVlczogcmVzdWx0VmFsdWVzfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0LnNpemU7ICsraSkge1xuICAgICAgY29uc3QgbG9jID0gdC5pbmRleFRvTG9jKGkpO1xuXG4gICAgICAvLyBQZXJtdXRlIGxvY2F0aW9uLlxuICAgICAgY29uc3QgbmV3TG9jOiBudW1iZXJbXSA9IG5ldyBBcnJheShsb2MubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3TG9jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0xvY1tpXSA9IGxvY1tuZXdEaW1baV1dO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdJbmRleCA9IHJlc3VsdC5sb2NUb0luZGV4KG5ld0xvYyk7XG4gICAgICByZXN1bHRWYWx1ZXNbbmV3SW5kZXhdID0gdmFsdWVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBwb29sKFxuICAgICAgeDogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIHBhZDogbnVtYmVyLFxuICAgICAgcG9vbFR5cGU6ICdtYXgnfCdtaW4nfCdhdmcnKSB7XG4gICAgY29uc3QgW3hSb3dzLCB4Q29scywgZGVwdGhdID0geC5zaGFwZTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRChcbiAgICAgICAgW3hSb3dzLCB4Q29scywgZGVwdGhdLCBmU2l6ZSwgZGVwdGgsIHN0cmlkZSwgcGFkKTtcbiAgICBjb25zdCB5ID0gQXJyYXkzRC56ZXJvcyhvdXRwdXRTaGFwZSk7XG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkZXB0aDsgKytkKSB7XG4gICAgICBmb3IgKGxldCB5UiA9IDA7IHlSIDwgeS5zaGFwZVswXTsgKyt5Uikge1xuICAgICAgICBjb25zdCB4UkNvcm5lciA9IHlSICogc3RyaWRlIC0gcGFkO1xuICAgICAgICBjb25zdCB4Uk1pbiA9IE1hdGgubWF4KDAsIHhSQ29ybmVyKTtcbiAgICAgICAgY29uc3QgeFJNYXggPSBNYXRoLm1pbih4Um93cywgZlNpemUgKyB4UkNvcm5lcik7XG4gICAgICAgIGZvciAobGV0IHlDID0gMDsgeUMgPCB5LnNoYXBlWzFdOyArK3lDKSB7XG4gICAgICAgICAgY29uc3QgeENDb3JuZXIgPSB5QyAqIHN0cmlkZSAtIHBhZDtcbiAgICAgICAgICBjb25zdCB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICBjb25zdCB4Q01heCA9IE1hdGgubWluKHhDb2xzLCBmU2l6ZSArIHhDQ29ybmVyKTtcblxuXG4gICAgICAgICAgbGV0IG1pbk1heFZhbHVlID1cbiAgICAgICAgICAgICAgKHBvb2xUeXBlID09PSAnbWF4JyA/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICAgIGxldCBhdmdWYWx1ZSA9IDA7XG5cbiAgICAgICAgICBmb3IgKGxldCB4UiA9IHhSTWluOyB4UiA8IHhSTWF4OyArK3hSKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4QyA9IHhDTWluOyB4QyA8IHhDTWF4OyArK3hDKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0geC5nZXQoeFIsIHhDLCBkKTtcbiAgICAgICAgICAgICAgaWYgKGlzTmFOKHBpeGVsKSkge1xuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gTmFOO1xuICAgICAgICAgICAgICAgIGF2Z1ZhbHVlID0gTmFOO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICgocG9vbFR5cGUgPT09ICdtYXgnICYmIHBpeGVsID4gbWluTWF4VmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAocG9vbFR5cGUgPT09ICdtaW4nICYmIHBpeGVsIDwgbWluTWF4VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSBwaXhlbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycpIHtcbiAgICAgICAgICAgICAgICBhdmdWYWx1ZSArPSBwaXhlbCAvIChmU2l6ZSAqIGZTaXplKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmFOKG1pbk1heFZhbHVlKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgeS5zZXQocG9vbFR5cGUgPT09ICdhdmcnID8gYXZnVmFsdWUgOiBtaW5NYXhWYWx1ZSwgeVIsIHlDLCBkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtYXhQb29sSW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgcGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICByZXR1cm4gdGhpcy5wb29sKHgsIGZTaXplLCBzdHJpZGUsIHBhZCwgJ21heCcpO1xuICB9XG5cbiAgbWF4UG9vbFBvc2l0aW9ucyh4OiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgcGFkOiBudW1iZXIpIHtcbiAgICBjb25zdCBbeFJvd3MsIHhDb2xzLCBkZXB0aF0gPSB4LnNoYXBlO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID1cbiAgICAgICAgY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKHguc2hhcGUsIGZTaXplLCBkZXB0aCwgc3RyaWRlLCBwYWQpO1xuICAgIGNvbnN0IG1heFBvc2l0aW9ucyA9IEFycmF5M0QuemVyb3Mob3V0cHV0U2hhcGUpO1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGVwdGg7ICsrZCkge1xuICAgICAgZm9yIChsZXQgeVIgPSAwOyB5UiA8IG91dHB1dFNoYXBlWzBdOyArK3lSKSB7XG4gICAgICAgIGNvbnN0IHhSQ29ybmVyID0geVIgKiBzdHJpZGUgLSBwYWQ7XG4gICAgICAgIGNvbnN0IHhSTWluID0gTWF0aC5tYXgoMCwgeFJDb3JuZXIpO1xuICAgICAgICBjb25zdCB4Uk1heCA9IE1hdGgubWluKHhSb3dzLCBmU2l6ZSArIHhSQ29ybmVyKTtcbiAgICAgICAgZm9yIChsZXQgeUMgPSAwOyB5QyA8IG91dHB1dFNoYXBlWzFdOyArK3lDKSB7XG4gICAgICAgICAgY29uc3QgeENDb3JuZXIgPSB5QyAqIHN0cmlkZSAtIHBhZDtcbiAgICAgICAgICBjb25zdCB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICBjb25zdCB4Q01heCA9IE1hdGgubWluKHhDb2xzLCBmU2l6ZSArIHhDQ29ybmVyKTtcbiAgICAgICAgICBsZXQgbWF4VmFsdWUgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgbGV0IG1heFBvc2l0aW9uID0gLTE7XG4gICAgICAgICAgZm9yIChsZXQgeFIgPSB4Uk1pbjsgeFIgPCB4Uk1heDsgKyt4Uikge1xuICAgICAgICAgICAgY29uc3Qgd1IgPSB4UiAtIHhSQ29ybmVyO1xuICAgICAgICAgICAgZm9yIChsZXQgeEMgPSB4Q01pbjsgeEMgPCB4Q01heDsgKyt4Qykge1xuICAgICAgICAgICAgICBjb25zdCB3QyA9IHhDIC0geENDb3JuZXI7XG4gICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0geC5nZXQoeFIsIHhDLCBkKTtcbiAgICAgICAgICAgICAgaWYgKHBpeGVsID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgIG1heFBvc2l0aW9uID0gd1IgKiBmU2l6ZSArIHdDO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG1heFBvc2l0aW9ucy5zZXQobWF4UG9zaXRpb24sIHlSLCB5QywgZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heFBvc2l0aW9ucztcbiAgfVxuXG4gIHByb3RlY3RlZCBtYXhQb29sQmFja3Byb3BJbnRlcm5hbChcbiAgICAgIGR5OiBBcnJheTNELCB4OiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBvcmlnU3RyaWRlOiBudW1iZXIsXG4gICAgICBvcmlnUGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICBjb25zdCBtYXhQb3NpdGlvbnMgPSB0aGlzLm1heFBvb2xQb3NpdGlvbnMoeCwgZlNpemUsIG9yaWdTdHJpZGUsIG9yaWdQYWQpO1xuICAgIGNvbnN0IHBhZCA9IGZTaXplIC0gMSAtIG9yaWdQYWQ7XG4gICAgY29uc3QgW2R5Um93cywgZHlDb2xzLCBkZXB0aF0gPSBkeS5zaGFwZTtcblxuICAgIC8vIERpbGF0ZSB0aGUgaW5wdXQuXG4gICAgY29uc3QgZHlSb3dzRGlsYXRlZCA9IChkeVJvd3MgLSAxKSAqIG9yaWdTdHJpZGUgKyAxO1xuICAgIGNvbnN0IGR4Q29sc0RpbGF0ZWQgPSAoZHlDb2xzIC0gMSkgKiBvcmlnU3RyaWRlICsgMTtcblxuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKFxuICAgICAgICBbZHlSb3dzRGlsYXRlZCwgZHhDb2xzRGlsYXRlZCwgZGVwdGhdLCBmU2l6ZSwgZGVwdGgsIDEsIHBhZCk7XG4gICAgY29uc3QgZHggPSBBcnJheTNELnplcm9zKG91dHB1dFNoYXBlKTtcblxuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGVwdGg7ICsrZCkge1xuICAgICAgZm9yIChsZXQgZHhSID0gMDsgZHhSIDwgZHguc2hhcGVbMF07ICsrZHhSKSB7XG4gICAgICAgIGZvciAobGV0IGR4QyA9IDA7IGR4QyA8IGR4LnNoYXBlWzFdOyArK2R4Qykge1xuICAgICAgICAgIC8vIFNoYWRlciBjb2RlIGJlZ2lucy5cbiAgICAgICAgICBjb25zdCBkeVJDb3JuZXIgPSBkeFIgLSBwYWQ7XG4gICAgICAgICAgY29uc3QgZHlDQ29ybmVyID0gZHhDIC0gcGFkO1xuICAgICAgICAgIGxldCBkb3RQcm9kID0gMDtcbiAgICAgICAgICBmb3IgKGxldCB3UiA9IDA7IHdSIDwgZlNpemU7ICsrd1IpIHtcbiAgICAgICAgICAgIGNvbnN0IGR5UiA9IChkeVJDb3JuZXIgKyB3UikgLyBvcmlnU3RyaWRlO1xuICAgICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49IGR5Um93cyB8fCBNYXRoLmZsb29yKGR5UikgIT09IGR5Uikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHdDID0gMDsgd0MgPCBmU2l6ZTsgKyt3Qykge1xuICAgICAgICAgICAgICBjb25zdCBkeUMgPSAoZHlDQ29ybmVyICsgd0MpIC8gb3JpZ1N0cmlkZTtcbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49IGR5Q29scyB8fCBNYXRoLmZsb29yKGR5QykgIT09IGR5Qykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IG1heFBvcyA9IGZTaXplICogZlNpemUgLSAxIC0gbWF4UG9zaXRpb25zLmdldChkeVIsIGR5QywgZCk7XG4gICAgICAgICAgICAgIGNvbnN0IGN1clBvcyA9IHdSICogZlNpemUgKyB3QztcblxuICAgICAgICAgICAgICBjb25zdCBtYXNrID0gbWF4UG9zID09PSBjdXJQb3MgPyAxIDogMDtcbiAgICAgICAgICAgICAgaWYgKG1hc2sgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0gZHkuZ2V0KGR5UiwgZHlDLCBkKTtcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIG1hc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGR4LnNldChkb3RQcm9kLCBkeFIsIGR4QywgZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGR4O1xuICB9XG5cbiAgcHJvdGVjdGVkIG1pblBvb2xJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCBwYWQ6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIHJldHVybiB0aGlzLnBvb2woeCwgZlNpemUsIHN0cmlkZSwgcGFkLCAnbWluJyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXZnUG9vbEludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIHBhZDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgcmV0dXJuIHRoaXMucG9vbCh4LCBmU2l6ZSwgc3RyaWRlLCBwYWQsICdhdmcnKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZXNpemVCaWxpbmVhcjNESW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBuZXdTaGFwZTJEOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgYWxpZ25Db3JuZXJzOiBib29sZWFuKTogQXJyYXkzRCB7XG4gICAgY29uc3Qgb3V0cHV0ID0gQXJyYXkzRC56ZXJvcyhbbmV3U2hhcGUyRFswXSwgbmV3U2hhcGUyRFsxXSwgeC5zaGFwZVsyXV0pO1xuXG4gICAgY29uc3QgZWZmZWN0aXZlSW5wdXRTaXplID1cbiAgICAgICAgYWxpZ25Db3JuZXJzID8gW3guc2hhcGVbMF0gLSAxLCB4LnNoYXBlWzFdIC0gMSwgeC5zaGFwZVsyXV0gOiB4LnNoYXBlO1xuICAgIGNvbnN0IGVmZmVjdGl2ZU91dHB1dFNpemUgPSBhbGlnbkNvcm5lcnMgP1xuICAgICAgICBbb3V0cHV0LnNoYXBlWzBdIC0gMSwgb3V0cHV0LnNoYXBlWzFdIC0gMSwgb3V0cHV0LnNoYXBlWzJdXSA6XG4gICAgICAgIG91dHB1dC5zaGFwZTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IG91dHB1dC5zaGFwZVswXTsgcisrKSB7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IG91dHB1dC5zaGFwZVsxXTsgYysrKSB7XG4gICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgb3V0cHV0LnNoYXBlWzJdOyBkKyspIHtcbiAgICAgICAgICAvLyBCZWdpbiBzaGFkZXIuXG5cbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBmcmFjdGlvbmFsIGluZGV4IG9mIHRoZSBzb3VyY2UuXG4gICAgICAgICAgY29uc3Qgc291cmNlRnJhY1JvdyA9XG4gICAgICAgICAgICAgIChlZmZlY3RpdmVJbnB1dFNpemVbMF0pICogciAvIChlZmZlY3RpdmVPdXRwdXRTaXplWzBdKTtcbiAgICAgICAgICBjb25zdCBzb3VyY2VGcmFjQ29sID1cbiAgICAgICAgICAgICAgKGVmZmVjdGl2ZUlucHV0U2l6ZVsxXSkgKiBjIC8gKGVmZmVjdGl2ZU91dHB1dFNpemVbMV0pO1xuXG4gICAgICAgICAgY29uc3Qgc291cmNlUm93Rmxvb3IgPSBNYXRoLmZsb29yKHNvdXJjZUZyYWNSb3cpO1xuICAgICAgICAgIGNvbnN0IHNvdXJjZVJvd0NlaWwgPVxuICAgICAgICAgICAgICBNYXRoLm1pbih4LnNoYXBlWzBdIC0gMSwgTWF0aC5jZWlsKHNvdXJjZUZyYWNSb3cpKTtcbiAgICAgICAgICBjb25zdCBzb3VyY2VDb2xGbG9vciA9IE1hdGguZmxvb3Ioc291cmNlRnJhY0NvbCk7XG4gICAgICAgICAgY29uc3Qgc291cmNlQ29sQ2VpbCA9XG4gICAgICAgICAgICAgIE1hdGgubWluKHguc2hhcGVbMV0gLSAxLCBNYXRoLmNlaWwoc291cmNlRnJhY0NvbCkpO1xuXG4gICAgICAgICAgY29uc3QgdG9wTGVmdCA9IHguZ2V0KHNvdXJjZVJvd0Zsb29yLCBzb3VyY2VDb2xGbG9vciwgZCk7XG4gICAgICAgICAgY29uc3QgYm90dG9tTGVmdCA9IHguZ2V0KHNvdXJjZVJvd0NlaWwsIHNvdXJjZUNvbEZsb29yLCBkKTtcbiAgICAgICAgICBjb25zdCB0b3BSaWdodCA9IHguZ2V0KHNvdXJjZVJvd0Zsb29yLCBzb3VyY2VDb2xDZWlsLCBkKTtcbiAgICAgICAgICBjb25zdCBib3R0b21SaWdodCA9IHguZ2V0KHNvdXJjZVJvd0NlaWwsIHNvdXJjZUNvbENlaWwsIGQpO1xuXG4gICAgICAgICAgY29uc3Qgcm93RnJhYyA9IHNvdXJjZUZyYWNSb3cgLSBzb3VyY2VSb3dGbG9vcjtcbiAgICAgICAgICBjb25zdCBjb2xGcmFjID0gc291cmNlRnJhY0NvbCAtIHNvdXJjZUNvbEZsb29yO1xuXG4gICAgICAgICAgY29uc3QgdG9wID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogY29sRnJhYztcbiAgICAgICAgICBjb25zdCBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBjb2xGcmFjO1xuICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdG9wICsgKGJvdHRvbSAtIHRvcCkgKiByb3dGcmFjO1xuXG4gICAgICAgICAgb3V0cHV0LnNldChuZXdWYWx1ZSwgciwgYywgZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgcHJvdGVjdGVkIGJhdGNoTm9ybWFsaXphdGlvbjNESW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBtZWFuOiBBcnJheTNEfEFycmF5MUQsIHZhcmlhbmNlOiBBcnJheTNEfEFycmF5MUQsXG4gICAgICB2YXJpYW5jZUVwc2lsb24gPSAuMDAxLCBzY2FsZT86IEFycmF5M0R8QXJyYXkxRCxcbiAgICAgIG9mZnNldD86IEFycmF5M0R8QXJyYXkxRCk6IEFycmF5M0Qge1xuICAgIGNvbnN0IHhWYWx1ZXMgPSB4LmdldFZhbHVlcygpO1xuICAgIGNvbnN0IG1lYW5WYWx1ZXMgPSBtZWFuLmdldFZhbHVlcygpO1xuICAgIGNvbnN0IHZhcmlhbmNlVmFsdWVzID0gdmFyaWFuY2UuZ2V0VmFsdWVzKCk7XG4gICAgY29uc3Qgc2NhbGVWYWx1ZXMgPSBzY2FsZSA/IHNjYWxlLmdldFZhbHVlcygpIDogbmV3IEZsb2F0MzJBcnJheShbMV0pO1xuICAgIGNvbnN0IG9mZnNldFZhbHVlcyA9IG9mZnNldCA/IG9mZnNldC5nZXRWYWx1ZXMoKSA6IG5ldyBGbG9hdDMyQXJyYXkoWzBdKTtcbiAgICBjb25zdCBvdXRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHhWYWx1ZXMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0VmFsdWVzW2ldID0gb2Zmc2V0VmFsdWVzW2kgJSBvZmZzZXRWYWx1ZXMubGVuZ3RoXSArXG4gICAgICAgICAgKHhWYWx1ZXNbaV0gLSBtZWFuVmFsdWVzW2kgJSBtZWFuVmFsdWVzLmxlbmd0aF0pICpcbiAgICAgICAgICAgICAgc2NhbGVWYWx1ZXNbaSAlIHNjYWxlVmFsdWVzLmxlbmd0aF0gL1xuICAgICAgICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgICB2YXJpYW5jZVZhbHVlc1tpICUgdmFyaWFuY2VWYWx1ZXMubGVuZ3RoXSArIHZhcmlhbmNlRXBzaWxvbik7XG4gICAgfVxuICAgIHJldHVybiBOREFycmF5Lm1ha2U8QXJyYXkzRD4oeC5zaGFwZSwge3ZhbHVlczogb3V0VmFsdWVzfSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0ICogYXMgY29uY2F0M2RfdXRpbCBmcm9tICcuL2NvbmNhdDNkX3V0aWwnO1xuaW1wb3J0ICogYXMgY29udl91dGlsIGZyb20gJy4vY29udl91dGlsJztcbmltcG9ydCB7TWF0cml4T3JpZW50YXRpb24sIE5EQXJyYXlNYXRofSBmcm9tICcuL21hdGgnO1xuaW1wb3J0ICogYXMgbmRhcnJheSBmcm9tICcuL25kYXJyYXknO1xuaW1wb3J0IHtBcnJheTFELCBBcnJheTJELCBBcnJheTNELCBBcnJheTRELCBOREFycmF5LCBTY2FsYXJ9IGZyb20gJy4vbmRhcnJheSc7XG5pbXBvcnQgKiBhcyBhZGRzY2FsZWRtYXRfZ3B1IGZyb20gJy4vd2ViZ2wvYWRkc2NhbGVkbWF0X2dwdSc7XG5pbXBvcnQge0FyZ01heEVxdWFsc1Byb2dyYW19IGZyb20gJy4vd2ViZ2wvYXJnbWF4ZXF1YWxzX2dwdSc7XG5pbXBvcnQge0FyZ01pbk1heFByb2dyYW19IGZyb20gJy4vd2ViZ2wvYXJnbWlubWF4X2dwdSc7XG5pbXBvcnQgKiBhcyBhdmdfcG9vbF9ncHUgZnJvbSAnLi93ZWJnbC9hdmdfcG9vbF9ncHUnO1xuaW1wb3J0ICogYXMgYmF0Y2hub3JtX2dwdSBmcm9tICcuL3dlYmdsL2JhdGNobm9ybV9ncHUnO1xuaW1wb3J0ICogYXMgY29uY2F0M2RfZ3B1IGZyb20gJy4vd2ViZ2wvY29uY2F0M2RfZ3B1JztcbmltcG9ydCAqIGFzIGNvbnZfYmFja3Byb3BfZ3B1IGZyb20gJy4vd2ViZ2wvY29udl9iYWNrcHJvcF9ncHUnO1xuaW1wb3J0ICogYXMgY29udl9ncHUgZnJvbSAnLi93ZWJnbC9jb252X2dwdSc7XG5pbXBvcnQgKiBhcyBjb3B5X2dwdSBmcm9tICcuL3dlYmdsL2NvcHlfZ3B1JztcbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL3dlYmdsL2dwZ3B1X2NvbnRleHQnO1xuaW1wb3J0IHtCaW5hcnlPcFByb2dyYW19IGZyb20gJy4vd2ViZ2wvYmluYXJ5b3BfZ3B1JztcbmltcG9ydCB7R1BHUFVQcm9ncmFtLCBHUEdQVUJpbmFyeX0gZnJvbSAnLi93ZWJnbC9ncGdwdV9tYXRoJztcbmltcG9ydCAqIGFzIGdwZ3B1X21hdGggZnJvbSAnLi93ZWJnbC9ncGdwdV9tYXRoJztcbmltcG9ydCAqIGFzIGdwZ3B1X3V0aWwgZnJvbSAnLi93ZWJnbC9ncGdwdV91dGlsJztcbmltcG9ydCB7TG9nU3VtRXhwUHJvZ3JhbX0gZnJvbSAnLi93ZWJnbC9sb2dzdW1leHBfZ3B1JztcbmltcG9ydCAqIGFzIG1heF9wb29sX2JhY2twcm9wX2dwdSBmcm9tICcuL3dlYmdsL21heF9wb29sX2JhY2twcm9wX2dwdSc7XG5pbXBvcnQgKiBhcyBtYXhfcG9vbF9ncHUgZnJvbSAnLi93ZWJnbC9tYXhfcG9vbF9ncHUnO1xuaW1wb3J0ICogYXMgbWluX3Bvb2xfZ3B1IGZyb20gJy4vd2ViZ2wvbWluX3Bvb2xfZ3B1JztcbmltcG9ydCB7TWluTWF4UHJvZ3JhbX0gZnJvbSAnLi93ZWJnbC9taW5tYXhfZ3B1JztcbmltcG9ydCB7TWF0TXVsUHJvZ3JhbX0gZnJvbSAnLi93ZWJnbC9tdWxtYXRfZ3B1JztcbmltcG9ydCAqIGFzIHBvb2xfZ3B1IGZyb20gJy4vd2ViZ2wvcG9vbF9ncHUnO1xuaW1wb3J0IHtSZWR1Y2VTdW1Qcm9ncmFtfSBmcm9tICcuL3dlYmdsL3JlZHVjZXN1bV9ncHUnO1xuaW1wb3J0ICogYXMgcmVzaGFwZV9ncHUgZnJvbSAnLi93ZWJnbC9yZXNoYXBlX2dwdSc7XG5pbXBvcnQgKiBhcyByZXNpemVfYmlsaW5lYXJfZ3B1IGZyb20gJy4vd2ViZ2wvcmVzaXplX2JpbGluZWFyX2dwdSc7XG5pbXBvcnQge1RleHR1cmVNYW5hZ2VyfSBmcm9tICcuL3dlYmdsL3RleHR1cmVfbWFuYWdlcic7XG5pbXBvcnQgKiBhcyB3ZWJnbF91dGlsIGZyb20gJy4vd2ViZ2wvd2ViZ2xfdXRpbCc7XG5pbXBvcnQge1VuYXJ5T3BQcm9ncmFtLCBVbmFyeU9wfSBmcm9tICcuL3dlYmdsL3VuYXJ5b3BfZ3B1JztcblxuY29uc3QgQkFUQ0hOT1JNX1BST0cgPSAnYmF0Y2hub3JtJztcblxuY29uc3QgQ09QWV9QUk9HID0gJ2NvcHknO1xuY29uc3QgQ09OQ0FUX1BST0cgPSAnY29uY2F0JztcblxuLy8gTWF0cml4IGFsZ2VicmEuXG5jb25zdCBBRERfU0NBTEVEX01BVF9QUk9HID0gJ2FkZHNjYWxlZG1hdCc7XG5cbi8vIEVsZW1lbnQtd2lzZSBvcHMuXG5jb25zdCBSRVNIQVBFX1BST0cgPSAncmVzaGFwZSc7XG5cbi8vIENvbnZvbHV0aW9uLlxuY29uc3QgQ09OVjJEX1BST0cgPSAnY29udic7XG5jb25zdCBDT05WMkRfVFJBTlNQT1NFX1BST0cgPSAnY29udl90cmFuc3Bvc2UnO1xuY29uc3QgQ09OVjJEX0RFUldfUFJPRyA9ICdjb252X2RlcncnO1xuY29uc3QgQ09OVjJEX0RFUkJfUFJPRyA9ICdjb252X2RlcmInO1xuY29uc3QgTUFYX1BPT0xfUFJPRyA9ICdtYXhwb29sJztcbmNvbnN0IE1BWF9QT09MX1BPU0lUSU9OU19QUk9HID0gJ21heHBvb2xfcG9zbic7XG5jb25zdCBNQVhfUE9PTF9CQUNLUFJPUF9QUk9HID0gJ21heHBvb2xfYmFja3Byb3AnO1xuY29uc3QgTUlOX1BPT0xfUFJPRyA9ICdtaW5wb29sJztcbmNvbnN0IEFWR19QT09MX1BST0cgPSAnYXZncG9vbCc7XG5cbmNvbnN0IFJFU0laRV9CSUxJTkVBUl9QUk9HID0gJ3Jlc2l6ZWJpbGluJztcblxuZnVuY3Rpb24gbWFrZUNvcHlQcm9ncmFtTmFtZShcbiAgICBzb3VyY2VTaGFwZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSwgc291cmNlU2l6ZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSxcbiAgICBkZXN0U2l6ZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSk6IHN0cmluZyB7XG4gIGNvbnN0IHNoYXBlTmFtZSA9IGAke3NvdXJjZVNoYXBlUm93Q29sWzBdfV8ke3NvdXJjZVNoYXBlUm93Q29sWzFdfWA7XG4gIGNvbnN0IHNyY1NpemVOYW1lID0gYCR7c291cmNlU2l6ZVJvd0NvbFswXX1fJHtzb3VyY2VTaXplUm93Q29sWzFdfWA7XG4gIGNvbnN0IGRzdFNpemVOYW1lID0gYCR7ZGVzdFNpemVSb3dDb2xbMF19XyR7ZGVzdFNpemVSb3dDb2xbMV19YDtcbiAgcmV0dXJuIGAke0NPUFlfUFJPR31fJHtzaGFwZU5hbWV9XyR7c3JjU2l6ZU5hbWV9XyR7ZHN0U2l6ZU5hbWV9YDtcbn1cblxuZXhwb3J0IGNsYXNzIE5EQXJyYXlNYXRoR1BVIGV4dGVuZHMgTkRBcnJheU1hdGgge1xuICBwcml2YXRlIGdwZ3B1OiBHUEdQVUNvbnRleHQ7XG4gIHByaXZhdGUgdGV4dHVyZU1hbmFnZXI6IFRleHR1cmVNYW5hZ2VyO1xuICBwcml2YXRlIHByb2dyYW1DYWNoZToge1trZXk6IHN0cmluZ106IFdlYkdMUHJvZ3JhbX0gPSB7fTtcbiAgcHJpdmF0ZSBiaW5hcnlDYWNoZToge1trZXk6IHN0cmluZ106IEdQR1BVQmluYXJ5fSA9IHt9O1xuICBwcml2YXRlIGdwZ3B1Q3JlYXRlZExvY2FsbHk6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoZ3BncHU/OiBHUEdQVUNvbnRleHQsIHNhZmVNb2RlID0gdHJ1ZSkge1xuICAgIHN1cGVyKHNhZmVNb2RlKTtcbiAgICBpZiAoZ3BncHUgPT0gbnVsbCkge1xuICAgICAgY29uc3QgZ2wgPSBncGdwdV91dGlsLmNyZWF0ZVdlYkdMQ29udGV4dCgpO1xuICAgICAgdGhpcy5ncGdwdSA9IG5ldyBHUEdQVUNvbnRleHQoZ2wpO1xuICAgICAgdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ncGdwdSA9IGdwZ3B1O1xuICAgICAgdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0dXJlTWFuYWdlciA9IG5ldyBUZXh0dXJlTWFuYWdlcih0aGlzLmdwZ3B1KTtcblxuICAgIG5kYXJyYXkuaW5pdGlhbGl6ZUdQVSh0aGlzLmdwZ3B1LCB0aGlzLnRleHR1cmVNYW5hZ2VyKTtcbiAgfVxuXG4gIGdldEdQR1BVQ29udGV4dCgpOiBHUEdQVUNvbnRleHQge1xuICAgIHJldHVybiB0aGlzLmdwZ3B1O1xuICB9XG5cbiAgcHJvdGVjdGVkIGNsb25lSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUIHtcbiAgICBjb25zdCB0ZXh0dXJlU2hhcGVSQyA9IG5kYXJyYXkuZ2V0VGV4dHVyZVNoYXBlUkMoKTtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5nZXRBbmRTYXZlUHJvZ3JhbShcbiAgICAgICAgbWFrZUNvcHlQcm9ncmFtTmFtZSh0ZXh0dXJlU2hhcGVSQywgdGV4dHVyZVNoYXBlUkMsIHRleHR1cmVTaGFwZVJDKSxcbiAgICAgICAgKCkgPT4gY29weV9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoXG4gICAgICAgICAgICB0ZXh0dXJlU2hhcGVSQywgdGV4dHVyZVNoYXBlUkMsIHRleHR1cmVTaGFwZVJDKSk7XG5cbiAgICBjb25zdCByZXN1bHRUZXh0dXJlID0gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZSh0ZXh0dXJlU2hhcGVSQyk7XG5cbiAgICBjb3B5X2dwdS5jb3B5KFxuICAgICAgICB0aGlzLmdwZ3B1LCBwcm9ncmFtLCBuZGFycmF5LmdldFRleHR1cmUoKSwgdGV4dHVyZVNoYXBlUkMsIFswLCAwXSxcbiAgICAgICAgdGV4dHVyZVNoYXBlUkMsIHJlc3VsdFRleHR1cmUsIHRleHR1cmVTaGFwZVJDLCBbMCwgMF0sIHRleHR1cmVTaGFwZVJDKTtcblxuICAgIHJldHVybiBOREFycmF5Lm1ha2U8VD4oXG4gICAgICAgIG5kYXJyYXkuc2hhcGUsIHt0ZXh0dXJlOiByZXN1bHRUZXh0dXJlLCB0ZXh0dXJlU2hhcGVSQ30pO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlc2hhcGVJbnRlcm5hbDxUMSBleHRlbmRzIE5EQXJyYXksIFQyIGV4dGVuZHMgTkRBcnJheT4oXG4gICAgICBuZGFycmF5OiBUMSwgbmV3U2hhcGU6IG51bWJlcltdKTogVDIge1xuICAgIGxldCBuZXdUZXhTaGFwZTogW251bWJlciwgbnVtYmVyXTtcblxuICAgIHN3aXRjaCAobmV3U2hhcGUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIG5ld1RleFNoYXBlID0gWzEsIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgbmV3VGV4U2hhcGUgPSBbbmV3U2hhcGVbMF0sIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgbmV3VGV4U2hhcGUgPSBbbmV3U2hhcGVbMF0sIG5ld1NoYXBlWzFdXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIG5ld1RleFNoYXBlID0gW25ld1NoYXBlWzBdLCBuZXdTaGFwZVsxXSAqIG5ld1NoYXBlWzJdXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGBSZXNoYXBlcyBpbnRvICR7bmV3U2hhcGUubGVuZ3RofS1kaW0gbmRhcnJheSBpcyBub3QgeWV0IGAgK1xuICAgICAgICAgICAgYHN1cHBvcnRlZCBvbiBHUFVgKTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3R1YWxUZXhTaGFwZSA9IG5kYXJyYXkuZ2V0VGV4dHVyZVNoYXBlUkMobmV3VGV4U2hhcGUpO1xuICAgIGxldCBjbG9uZWRBcnJheTogVDE7XG4gICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGFjdHVhbFRleFNoYXBlLCBuZXdUZXhTaGFwZSkpIHtcbiAgICAgIGNsb25lZEFycmF5ID0gdGhpcy5yZXNoYXBlVGV4dHVyZShuZGFycmF5LCBuZXdUZXhTaGFwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb25lZEFycmF5ID0gdGhpcy5jbG9uZUludGVybmFsKG5kYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkQXJyYXkucmVzaGFwZTxUMj4obmV3U2hhcGUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNsaWNlMkRJbnRlcm5hbChcbiAgICAgIGlucHV0OiBBcnJheTJELCBiZWdpblJvd0NvbDogW251bWJlciwgbnVtYmVyXSxcbiAgICAgIHNpemVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0pOiBBcnJheTJEIHtcbiAgICBjb25zdCByZXN1bHQgPSBOREFycmF5Lm1ha2U8QXJyYXkyRD4oc2l6ZVJvd0NvbCwge1xuICAgICAgdGV4dHVyZTogdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZShzaXplUm93Q29sKSxcbiAgICAgIHRleHR1cmVTaGFwZVJDOiBzaXplUm93Q29sXG4gICAgfSk7XG4gICAgdGhpcy5jb3B5MkRJbnRlcm5hbChcbiAgICAgICAgaW5wdXQsIGJlZ2luUm93Q29sLCBzaXplUm93Q29sLCByZXN1bHQsIFswLCAwXSwgc2l6ZVJvd0NvbCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByb3RlY3RlZCBjb3B5MkRJbnRlcm5hbChcbiAgICAgIHNvdXJjZTogQXJyYXkyRCwgc291cmNlQmVnaW5Sb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBzb3VyY2VTaXplUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdLCBkZXN0OiBBcnJheTJELFxuICAgICAgZGVzdEJlZ2luUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgZGVzdFNpemVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0pOiB2b2lkIHtcbiAgICBjb25zdCBzb3VyY2VTaGFwZVJDID0gc291cmNlLmdldFRleHR1cmVTaGFwZVJDKCk7XG4gICAgY29uc3QgZGVzdFNoYXBlUkMgPSBkZXN0LmdldFRleHR1cmVTaGFwZVJDKCk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0oXG4gICAgICAgIG1ha2VDb3B5UHJvZ3JhbU5hbWUoc291cmNlU2hhcGVSQywgc291cmNlU2l6ZVJvd0NvbCwgZGVzdFNpemVSb3dDb2wpLFxuICAgICAgICAoKSA9PiBjb3B5X2dwdS5nZXRGcmFnbWVudFNoYWRlclNvdXJjZShcbiAgICAgICAgICAgIHNvdXJjZVNoYXBlUkMsIHNvdXJjZVNpemVSb3dDb2wsIGRlc3RTaXplUm93Q29sKSk7XG5cbiAgICBjb3B5X2dwdS5jb3B5KFxuICAgICAgICB0aGlzLmdwZ3B1LCBwcm9ncmFtLCBzb3VyY2UuZ2V0VGV4dHVyZSgpLCBzb3VyY2VTaGFwZVJDLFxuICAgICAgICBzb3VyY2VCZWdpblJvd0NvbCwgc291cmNlU2l6ZVJvd0NvbCwgZGVzdC5nZXRUZXh0dXJlKCksIGRlc3RTaGFwZVJDLFxuICAgICAgICBkZXN0QmVnaW5Sb3dDb2wsIGRlc3RTaXplUm93Q29sKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjb25jYXQzREludGVybmFsKHgxOiBBcnJheTNELCB4MjogQXJyYXkzRCwgYXhpczogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgY29uc3QgeDFUZXhTaGFwZVJDOiBbbnVtYmVyLCBudW1iZXJdID1cbiAgICAgICAgY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRCh4MS5zaGFwZSk7XG4gICAgY29uc3QgeDJUZXhTaGFwZVJDOiBbbnVtYmVyLCBudW1iZXJdID1cbiAgICAgICAgY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRCh4Mi5zaGFwZSk7XG5cbiAgICAvLyBJZiB0aGUgdGV4dHVyZSBzaGFwZXMgZG9lc24ndCBtYXRjaCB0aGUgc2hhcGVzIHRoYXQgc2hhZGVycyBleHBlY3QsXG4gICAgLy8gZG8gcGh5c2ljYWwgdGV4dHVyZSByZXNoYXBlcyBvbiB0aGUgR1BVLlxuICAgIGNvbnN0IGFjdHVhbFgxVGV4U2hhcGUgPSB4MS5nZXRUZXh0dXJlU2hhcGVSQyh4MVRleFNoYXBlUkMpO1xuICAgIGxldCBjbGVhbnVwWDEgPSBmYWxzZTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsWDFUZXhTaGFwZSwgeDFUZXhTaGFwZVJDKSkge1xuICAgICAgeDEgPSB0aGlzLnJlc2hhcGVUZXh0dXJlKHgxLCB4MVRleFNoYXBlUkMpO1xuICAgICAgY2xlYW51cFgxID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYWN0dWFsWDJUZXhTaGFwZSA9IHgyLmdldFRleHR1cmVTaGFwZVJDKHgyVGV4U2hhcGVSQyk7XG4gICAgbGV0IGNsZWFudXBYMiA9IGZhbHNlO1xuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhY3R1YWxYMlRleFNoYXBlLCB4MlRleFNoYXBlUkMpKSB7XG4gICAgICB4MiA9IHRoaXMucmVzaGFwZVRleHR1cmUoeDIsIHgyVGV4U2hhcGVSQyk7XG4gICAgICBjbGVhbnVwWDIgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdFNoYXBlUkNEID1cbiAgICAgICAgY29uY2F0M2RfdXRpbC5jb21wdXRlQ29uY2F0M0RPdXRwdXRTaGFwZSh4MS5zaGFwZSwgeDIuc2hhcGUsIGF4aXMpO1xuXG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0oXG4gICAgICAgIGAke0NPTkNBVF9QUk9HfV8ke3gxLnNoYXBlfV8ke3gyLnNoYXBlfV8ke2F4aXN9YCxcbiAgICAgICAgKCkgPT4gY29uY2F0M2RfZ3B1LmdldEZyYWdtZW50U2hhZGVyU291cmNlKFxuICAgICAgICAgICAgeDEuc2hhcGUsIHgyLnNoYXBlLCByZXN1bHRTaGFwZVJDRCwgYXhpcykpO1xuXG4gICAgY29uc3QgcmVzdWx0VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHJlc3VsdFNoYXBlUkNEKTtcbiAgICBjb25zdCByZXN1bHRUZXggPSB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKHJlc3VsdFRleFNoYXBlKTtcblxuICAgIGNvbmNhdDNkX2dwdS5jb25jYXQzRChcbiAgICAgICAgdGhpcy5ncGdwdSwgcHJvZ3JhbSwgeDEuZ2V0VGV4dHVyZSgpLCB4Mi5nZXRUZXh0dXJlKCksIHJlc3VsdFRleCxcbiAgICAgICAgcmVzdWx0VGV4U2hhcGUpO1xuXG4gICAgaWYgKGNsZWFudXBYMSkge1xuICAgICAgeDEuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIGlmIChjbGVhbnVwWDIpIHtcbiAgICAgIHgyLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPEFycmF5M0Q+KFxuICAgICAgICByZXN1bHRTaGFwZVJDRCwge3RleHR1cmU6IHJlc3VsdFRleCwgdGV4dHVyZVNoYXBlUkM6IHJlc3VsdFRleFNoYXBlfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2NhbGVkQXJyYXlBZGRJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oXG4gICAgICBjMTogU2NhbGFyLCBhOiBULCBjMjogU2NhbGFyLCBiOiBUKSB7XG4gICAgbGV0IGNsZWFudXBCID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmRvR1BVU2hhcGVzTWF0Y2goYSwgYikpIHtcbiAgICAgIGIgPSB0aGlzLnJlc2hhcGVUZXh0dXJlKGIsIGEuZ2V0VGV4dHVyZVNoYXBlUkMoKSk7XG4gICAgICBjbGVhbnVwQiA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0oXG4gICAgICAgIEFERF9TQ0FMRURfTUFUX1BST0csICgpID0+IGFkZHNjYWxlZG1hdF9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKSk7XG5cbiAgICBjb25zdCB0ZXh0dXJlU2hhcGVSQyA9IGEuZ2V0VGV4dHVyZVNoYXBlUkMoKTtcbiAgICBjb25zdCByZXN1bHRUZXh0dXJlID0gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZSh0ZXh0dXJlU2hhcGVSQyk7XG5cbiAgICBhZGRzY2FsZWRtYXRfZ3B1LmFkZFNjYWxlZE1hdHJpY2VzKFxuICAgICAgICB0aGlzLmdwZ3B1LCBwcm9ncmFtLCBhLmdldFRleHR1cmUoKSwgYi5nZXRUZXh0dXJlKCksIHRleHR1cmVTaGFwZVJDWzBdLFxuICAgICAgICB0ZXh0dXJlU2hhcGVSQ1sxXSwgYzEuZ2V0VGV4dHVyZSgpLCBjMi5nZXRUZXh0dXJlKCksIHJlc3VsdFRleHR1cmUpO1xuXG4gICAgaWYgKGNsZWFudXBCKSB7XG4gICAgICBiLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgLy8gQnJpbmcgdGhlIHJlc3VsdCBiYWNrIHRvIHRoZSBvcmlnaW5hbCBzaGFwZS5cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPFQ+KGEuc2hhcGUsIHt0ZXh0dXJlOiByZXN1bHRUZXh0dXJlLCB0ZXh0dXJlU2hhcGVSQ30pO1xuICB9XG5cbiAgcHJvdGVjdGVkIG5lZ0ludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihhOiBUKTogVCB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBVbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCBVbmFyeU9wLk5FRyk7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bjxULCBUPihwcm9ncmFtLCBbYV0pO1xuICB9XG5cbiAgcHJpdmF0ZSBtYWtlT3V0cHV0QXJyYXk8VCBleHRlbmRzIE5EQXJyYXk+KHNoYXBlOiBudW1iZXJbXSk6IFQge1xuICAgIGNvbnN0IHRleHR1cmVTaGFwZVJDID1cbiAgICAgICAgd2ViZ2xfdXRpbC5nZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlKHRoaXMuZ3BncHUuZ2wsIHNoYXBlKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZSh0ZXh0dXJlU2hhcGVSQyk7XG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihzaGFwZSwge3RleHR1cmUsIHRleHR1cmVTaGFwZVJDfSk7XG4gIH1cblxuICBwcml2YXRlIGNvbXBpbGVBbmRSdW48VCBleHRlbmRzIE5EQXJyYXksIEsgZXh0ZW5kcyBOREFycmF5PihcbiAgICAgIHByb2dyYW06IEdQR1BVUHJvZ3JhbSwgaW5wdXRzOiBUW10pOiBLIHtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheTxLPihwcm9ncmFtLm91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBrZXkgPSBncGdwdV9tYXRoLm1ha2VTaGFkZXJLZXkocHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQpO1xuICAgIGNvbnN0IGJpbmFyeSA9IHRoaXMuZ2V0QW5kU2F2ZUJpbmFyeShrZXksICgpID0+IHtcbiAgICAgIHJldHVybiBncGdwdV9tYXRoLmNvbXBpbGVQcm9ncmFtKHRoaXMuZ3BncHUsIHByb2dyYW0sIGlucHV0cywgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBncGdwdV9tYXRoLnJ1blByb2dyYW0oYmluYXJ5LCBpbnB1dHMsIG91dHB1dCk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIHByaXZhdGUgcmVzaGFwZVRleHR1cmU8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQsIG5ld1RleHR1cmVTaGFwZTogW1xuICAgIG51bWJlciwgbnVtYmVyXG4gIF0pOiBUIHtcbiAgICBjb25zdCBhVGV4U2hhcGUgPSBhLmdldFRleHR1cmVTaGFwZVJDKCk7XG5cbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5nZXRBbmRTYXZlUHJvZ3JhbShcbiAgICAgICAgUkVTSEFQRV9QUk9HLCAoKSA9PiByZXNoYXBlX2dwdS5nZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpKTtcblxuICAgIGNvbnN0IHJlc3VsdFRleHR1cmUgPSB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKG5ld1RleHR1cmVTaGFwZSk7XG4gICAgcmVzaGFwZV9ncHUucmVzaGFwZShcbiAgICAgICAgdGhpcy5ncGdwdSwgcHJvZ3JhbSwgYS5nZXRUZXh0dXJlKCksIGFUZXhTaGFwZVswXSwgYVRleFNoYXBlWzFdLFxuICAgICAgICByZXN1bHRUZXh0dXJlLCBuZXdUZXh0dXJlU2hhcGVbMF0sIG5ld1RleHR1cmVTaGFwZVsxXSk7XG5cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPFQ+KFxuICAgICAgICBhLnNoYXBlLCB7dGV4dHVyZTogcmVzdWx0VGV4dHVyZSwgdGV4dHVyZVNoYXBlUkM6IG5ld1RleHR1cmVTaGFwZX0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1hdE11bEludGVybmFsKFxuICAgICAgYTogQXJyYXkyRCwgYjogQXJyYXkyRCwgYU9yaWVudGF0aW9uOiBNYXRyaXhPcmllbnRhdGlvbixcbiAgICAgIGJPcmllbnRhdGlvbjogTWF0cml4T3JpZW50YXRpb24pOiBBcnJheTJEIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IE1hdE11bFByb2dyYW0oYS5zaGFwZSwgYi5zaGFwZSwgYU9yaWVudGF0aW9uLFxuICAgICAgICBiT3JpZW50YXRpb24pO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW48QXJyYXkyRCwgQXJyYXkyRD4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtdWx0aXBseUludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihhOiBULCBiOiBUKTogVCB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBCaW5hcnlPcFByb2dyYW0oJyonLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuPFQsIFQ+KHByb2dyYW0sIFthLCBiXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYmF0Y2hOb3JtYWxpemF0aW9uM0RJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIG1lYW46IEFycmF5M0R8QXJyYXkxRCwgdmFyaWFuY2U6IEFycmF5M0R8QXJyYXkxRCxcbiAgICAgIHZhcmlhbmNlRXBzaWxvbjogbnVtYmVyLCBzY2FsZT86IEFycmF5M0R8QXJyYXkxRCxcbiAgICAgIG9mZnNldD86IEFycmF5M0R8QXJyYXkxRCk6IEFycmF5M0Qge1xuICAgIGNvbnN0IHhUZXhTaGFwZSA9IHguZ2V0VGV4dHVyZVNoYXBlUkMoKTtcblxuICAgIGxldCBjbGVhbnVwTWVhbiA9IGZhbHNlO1xuICAgIGNvbnN0IHByZWZlcnJlZE1lYW5UZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSA9XG4gICAgICAgIG1lYW4ucmFuayA9PT0gMSA/IFsxLCBtZWFuLnNpemVdIDogeFRleFNoYXBlO1xuICAgIGxldCBtZWFuVGV4U2hhcGUgPSBtZWFuLmdldFRleHR1cmVTaGFwZVJDKHByZWZlcnJlZE1lYW5UZXhTaGFwZSk7XG4gICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKG1lYW5UZXhTaGFwZSwgcHJlZmVycmVkTWVhblRleFNoYXBlKSkge1xuICAgICAgbWVhbiA9IHRoaXMucmVzaGFwZVRleHR1cmUobWVhbiwgcHJlZmVycmVkTWVhblRleFNoYXBlKTtcbiAgICAgIG1lYW5UZXhTaGFwZSA9IHByZWZlcnJlZE1lYW5UZXhTaGFwZTtcbiAgICAgIGNsZWFudXBNZWFuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgY2xlYW51cFZhcmlhbmNlID0gZmFsc2U7XG4gICAgY29uc3QgcHJlZmVycmVkVmFyaWFuY2VUZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSA9XG4gICAgICAgIHZhcmlhbmNlLnJhbmsgPT09IDEgPyBbMSwgdmFyaWFuY2Uuc2l6ZV0gOiB4VGV4U2hhcGU7XG4gICAgbGV0IHZhcmlhbmNlVGV4U2hhcGUgPSB2YXJpYW5jZS5nZXRUZXh0dXJlU2hhcGVSQyhwcmVmZXJyZWRNZWFuVGV4U2hhcGUpO1xuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbCh2YXJpYW5jZVRleFNoYXBlLCBwcmVmZXJyZWRWYXJpYW5jZVRleFNoYXBlKSkge1xuICAgICAgdmFyaWFuY2UgPSB0aGlzLnJlc2hhcGVUZXh0dXJlKHZhcmlhbmNlLCBwcmVmZXJyZWRWYXJpYW5jZVRleFNoYXBlKTtcbiAgICAgIHZhcmlhbmNlVGV4U2hhcGUgPSBwcmVmZXJyZWRWYXJpYW5jZVRleFNoYXBlO1xuICAgICAgY2xlYW51cFZhcmlhbmNlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgc2NhbGVUZXhTaGFwZTogW251bWJlciwgbnVtYmVyXXxudWxsID0gbnVsbDtcbiAgICBsZXQgY2xlYW51cFNjYWxlID0gZmFsc2U7XG4gICAgaWYgKHNjYWxlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHByZWZlcnJlZFNjYWxlVGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0gPVxuICAgICAgICAgIHNjYWxlLnJhbmsgPT09IDEgPyBbMSwgc2NhbGUuc2l6ZV0gOiB4VGV4U2hhcGU7XG5cbiAgICAgIHNjYWxlVGV4U2hhcGUgPSBzY2FsZS5nZXRUZXh0dXJlU2hhcGVSQyhwcmVmZXJyZWRTY2FsZVRleFNoYXBlKTtcbiAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChzY2FsZVRleFNoYXBlLCBwcmVmZXJyZWRTY2FsZVRleFNoYXBlKSkge1xuICAgICAgICBzY2FsZSA9IHRoaXMucmVzaGFwZVRleHR1cmUoc2NhbGUsIHByZWZlcnJlZFNjYWxlVGV4U2hhcGUpO1xuICAgICAgICBzY2FsZVRleFNoYXBlID0gcHJlZmVycmVkU2NhbGVUZXhTaGFwZTtcbiAgICAgICAgY2xlYW51cFNjYWxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgb2Zmc2V0VGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl18bnVsbCA9IG51bGw7XG4gICAgbGV0IGNsZWFudXBPZmZzZXQgPSBmYWxzZTtcbiAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHByZWZlcnJlZE9mZnNldFRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdID1cbiAgICAgICAgICBvZmZzZXQucmFuayA9PT0gMSA/IFsxLCBvZmZzZXQuc2l6ZV0gOiB4VGV4U2hhcGU7XG5cbiAgICAgIG9mZnNldFRleFNoYXBlID0gb2Zmc2V0LmdldFRleHR1cmVTaGFwZVJDKHByZWZlcnJlZE9mZnNldFRleFNoYXBlKTtcbiAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChvZmZzZXRUZXhTaGFwZSwgcHJlZmVycmVkT2Zmc2V0VGV4U2hhcGUpKSB7XG4gICAgICAgIG9mZnNldCA9IHRoaXMucmVzaGFwZVRleHR1cmUob2Zmc2V0LCBwcmVmZXJyZWRPZmZzZXRUZXhTaGFwZSk7XG4gICAgICAgIG9mZnNldFRleFNoYXBlID0gcHJlZmVycmVkT2Zmc2V0VGV4U2hhcGU7XG4gICAgICAgIGNsZWFudXBPZmZzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdFRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdID0geC5nZXRUZXh0dXJlU2hhcGVSQygpO1xuXG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0oXG4gICAgICAgIGAke0JBVENITk9STV9QUk9HfV8ke3hUZXhTaGFwZX1fJHttZWFuVGV4U2hhcGV9XyR7dmFyaWFuY2VUZXhTaGFwZX1fYCArXG4gICAgICAgICAgICBgJHtzY2FsZVRleFNoYXBlIX1fJHtvZmZzZXRUZXhTaGFwZSF9XyR7dmFyaWFuY2VFcHNpbG9ufWAsXG4gICAgICAgICgpID0+IGJhdGNobm9ybV9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoXG4gICAgICAgICAgICB4VGV4U2hhcGUsIG1lYW5UZXhTaGFwZSwgdmFyaWFuY2VUZXhTaGFwZSwgb2Zmc2V0VGV4U2hhcGUsXG4gICAgICAgICAgICBzY2FsZVRleFNoYXBlLCB2YXJpYW5jZUVwc2lsb24pKTtcblxuICAgIGNvbnN0IHJlc3VsdFRleHR1cmUgPSB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKHJlc3VsdFRleFNoYXBlKTtcblxuICAgIGJhdGNobm9ybV9ncHUuYmF0Y2hOb3JtYWxpemF0aW9uKFxuICAgICAgICB0aGlzLmdwZ3B1LCBwcm9ncmFtLCB4LmdldFRleHR1cmUoKSwgeFRleFNoYXBlLCBtZWFuLmdldFRleHR1cmUoKSxcbiAgICAgICAgbWVhblRleFNoYXBlLCB2YXJpYW5jZS5nZXRUZXh0dXJlKCksIHZhcmlhbmNlVGV4U2hhcGUsXG4gICAgICAgIG9mZnNldCAhPSBudWxsID8gb2Zmc2V0LmdldFRleHR1cmUoKSA6IG51bGwsXG4gICAgICAgIG9mZnNldCAhPSBudWxsID8gb2Zmc2V0VGV4U2hhcGUgOiBudWxsLFxuICAgICAgICBzY2FsZSAhPSBudWxsID8gc2NhbGUuZ2V0VGV4dHVyZSgpIDogbnVsbCxcbiAgICAgICAgc2NhbGUgIT0gbnVsbCA/IHNjYWxlVGV4U2hhcGUgOiBudWxsLCByZXN1bHRUZXh0dXJlLCByZXN1bHRUZXhTaGFwZSk7XG5cbiAgICBpZiAoY2xlYW51cE1lYW4pIHtcbiAgICAgIG1lYW4uZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAoY2xlYW51cFZhcmlhbmNlKSB7XG4gICAgICB2YXJpYW5jZS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlmIChjbGVhbnVwU2NhbGUpIHtcbiAgICAgIHNjYWxlIS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlmIChjbGVhbnVwT2Zmc2V0KSB7XG4gICAgICBvZmZzZXQhLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPEFycmF5M0Q+KFxuICAgICAgICB4LnNoYXBlLCB7dGV4dHVyZTogcmVzdWx0VGV4dHVyZSwgdGV4dHVyZVNoYXBlUkM6IHJlc3VsdFRleFNoYXBlfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3dpdGNoRGltSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQsIG5ld0RpbTogbnVtYmVyW10pOiBUIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB5ZXQgaW1wbGVtZW50ZWQhJyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3VtSW50ZXJuYWwoYTogTkRBcnJheSk6IFNjYWxhciB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBSZWR1Y2VTdW1Qcm9ncmFtKGEuc2l6ZSk7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFyZ01pbkludGVybmFsKGE6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgQXJnTWluTWF4UHJvZ3JhbShhLnNpemUsICdtaW4nKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXJnTWF4SW50ZXJuYWwoYTogTkRBcnJheSk6IFNjYWxhciB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBBcmdNaW5NYXhQcm9ncmFtKGEuc2l6ZSwgJ21heCcpO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcmdNYXhFcXVhbHNJbnRlcm5hbCh4MTogTkRBcnJheSwgeDI6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgQXJnTWF4RXF1YWxzUHJvZ3JhbSh4MS5zaXplLCB4Mi5zaXplKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4MSwgeDJdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB0b3BLSW50ZXJuYWwobmRhcnJheTogTkRBcnJheSwgazogbnVtYmVyKTpcbiAgICAgIHt2YWx1ZXM6IEFycmF5MUQsIGluZGljZXM6IEFycmF5MUR9IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvcEsgR1BVIG5vdCB5ZXQgaW1wbGVtZW50ZWQhJyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbWluSW50ZXJuYWwoYTogTkRBcnJheSk6IFNjYWxhciB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBNaW5NYXhQcm9ncmFtKGEuc2l6ZSwgJ21pbicpO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtYXhJbnRlcm5hbChhOiBOREFycmF5KTogU2NhbGFyIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IE1pbk1heFByb2dyYW0oYS5zaXplLCAnbWF4Jyk7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGRpdmlkZUludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihhOiBULCBiOiBUKTogVCB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBCaW5hcnlPcFByb2dyYW0oJy8nLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuPE5EQXJyYXksIFQ+KHByb2dyYW0sIFthLCBiXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWRkSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQsIGI6IFQpOiBUIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IEJpbmFyeU9wUHJvZ3JhbSgnKycsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW48TkRBcnJheSwgVD4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdWJJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgYjogVCk6IFQge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgQmluYXJ5T3BQcm9ncmFtKCctJywgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bjxOREFycmF5LCBUPihwcm9ncmFtLCBbYSwgYl0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGxvZ1N1bUV4cEludGVybmFsKGE6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgTG9nU3VtRXhwUHJvZ3JhbShhLnNpemUpO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBleHBJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCk6IFQge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgVW5hcnlPcC5FWFApO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW48VCwgVD4ocHJvZ3JhbSwgW2FdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBsb2dJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCk6IFQge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgVW5hcnlPcC5MT0cpO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW48VCwgVD4ocHJvZ3JhbSwgW2FdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZWx1SW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQpOiBUIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIFVuYXJ5T3AuUkVMVSk7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bjxULCBUPihwcm9ncmFtLCBbYV0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNpZ21vaWRJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCk6IFQge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgVW5hcnlPcC5TSUdNT0lEKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuPFQsIFQ+KHByb2dyYW0sIFthXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdGFuaEludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihhOiBUKTogVCB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBVbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCBVbmFyeU9wLlRBTkgpO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW48VCwgVD4ocHJvZ3JhbSwgW2FdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzaW5JbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCk6IFQge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgVW5hcnlPcC5TSU4pO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW48VCwgVD4ocHJvZ3JhbSwgW2FdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdGVwSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQpOiBUIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIFVuYXJ5T3AuU1RFUCk7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bjxULCBUPihwcm9ncmFtLCBbYV0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNvbnYyZEludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgd2VpZ2h0czogQXJyYXk0RCwgYmlhc2VzOiBBcnJheTFEfG51bGwsIHN0cmlkZTogbnVtYmVyLFxuICAgICAgemVyb1BhZDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgY29uc3QgZmllbGRTaXplID0gd2VpZ2h0cy5zaGFwZVswXTtcbiAgICBjb25zdCBpbnB1dERlcHRoID0gd2VpZ2h0cy5zaGFwZVsyXTtcbiAgICBjb25zdCBvdXRwdXREZXB0aCA9IHdlaWdodHMuc2hhcGVbM107XG4gICAgY29uc3QgcHJvZ0tleSA9IFtcbiAgICAgIENPTlYyRF9QUk9HLCB4LnNoYXBlLCBvdXRwdXREZXB0aCwgZmllbGRTaXplLCBzdHJpZGUsIGJpYXNlcyAhPSBudWxsXG4gICAgXS5qb2luKCdfJyk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0ocHJvZ0tleSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNvbnZfZ3B1LmdldEZyYWdtZW50U2hhZGVyU291cmNlKFxuICAgICAgICAgIHguc2hhcGUsIG91dHB1dERlcHRoLCBmaWVsZFNpemUsIHN0cmlkZSwgemVyb1BhZCwgYmlhc2VzICE9IG51bGwpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgeFRleFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRCh4LnNoYXBlKTtcbiAgICBjb25zdCB3VGV4U2hhcGUgPVxuICAgICAgICBjb252X3V0aWwuY29tcHV0ZVdlaWdodHNUZXhTaGFwZShpbnB1dERlcHRoLCBvdXRwdXREZXB0aCwgZmllbGRTaXplKTtcbiAgICBjb25zdCBiaWFzVGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZUJpYXNlc1RleFNoYXBlKG91dHB1dERlcHRoKTtcblxuICAgIC8vIElmIHRoZSB0ZXh0dXJlIHNoYXBlcyBkb2Vzbid0IG1hdGNoIHRoZSBzaGFwZXMgdGhhdCBzaGFkZXJzIGV4cGVjdCxcbiAgICAvLyBkbyBwaHlzaWNhbCB0ZXh0dXJlIHJlc2hhcGVzIG9uIHRoZSBHUFUuXG4gICAgY29uc3QgYWN0dWFsWFRleFNoYXBlID0geC5nZXRUZXh0dXJlU2hhcGVSQyh4VGV4U2hhcGUpO1xuICAgIGxldCBjbGVhbnVwWCA9IGZhbHNlO1xuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhY3R1YWxYVGV4U2hhcGUsIHhUZXhTaGFwZSkpIHtcbiAgICAgIHggPSB0aGlzLnJlc2hhcGVUZXh0dXJlKHgsIHhUZXhTaGFwZSk7XG4gICAgICBjbGVhbnVwWCA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGNsZWFudXBXID0gZmFsc2U7XG4gICAgY29uc3QgYWN0dWFsV1RleFNoYXBlID0gd2VpZ2h0cy5nZXRUZXh0dXJlU2hhcGVSQyh3VGV4U2hhcGUpO1xuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhY3R1YWxXVGV4U2hhcGUsIHdUZXhTaGFwZSkpIHtcbiAgICAgIHdlaWdodHMgPSB0aGlzLnJlc2hhcGVUZXh0dXJlKHdlaWdodHMsIHdUZXhTaGFwZSk7XG4gICAgICBjbGVhbnVwVyA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGNsZWFudXBCID0gZmFsc2U7XG4gICAgaWYgKGJpYXNlcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBhY3R1YWxCVGV4U2hhcGUgPSBiaWFzZXMuZ2V0VGV4dHVyZVNoYXBlUkMoYmlhc1RleFNoYXBlKTtcbiAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhY3R1YWxCVGV4U2hhcGUsIGJpYXNUZXhTaGFwZSkpIHtcbiAgICAgICAgYmlhc2VzID0gdGhpcy5yZXNoYXBlVGV4dHVyZShiaWFzZXMsIGJpYXNUZXhTaGFwZSk7XG4gICAgICAgIGNsZWFudXBCID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHRTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRChcbiAgICAgICAgeC5zaGFwZSwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKTtcbiAgICBjb25zdCByZXN1bHRUZXhTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QocmVzdWx0U2hhcGUpO1xuICAgIGNvbnN0IHJlc3VsdFRleCA9IHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUocmVzdWx0VGV4U2hhcGUpO1xuXG4gICAgY29udl9ncHUuY29udm9sdmUoXG4gICAgICAgIHRoaXMuZ3BncHUsIHByb2dyYW0sIHguZ2V0VGV4dHVyZSgpLCB3ZWlnaHRzLmdldFRleHR1cmUoKSxcbiAgICAgICAgYmlhc2VzICE9IG51bGwgPyBiaWFzZXMuZ2V0VGV4dHVyZSgpIDogbnVsbCwgcmVzdWx0VGV4LCByZXN1bHRUZXhTaGFwZSk7XG5cbiAgICBpZiAoY2xlYW51cFgpIHtcbiAgICAgIHguZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAoY2xlYW51cFcpIHtcbiAgICAgIHdlaWdodHMuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAoY2xlYW51cEIgJiYgYmlhc2VzICE9IG51bGwpIHtcbiAgICAgIGJpYXNlcy5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxBcnJheTNEPihcbiAgICAgICAgcmVzdWx0U2hhcGUsIHt0ZXh0dXJlOiByZXN1bHRUZXgsIHRleHR1cmVTaGFwZVJDOiByZXN1bHRUZXhTaGFwZX0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNvbnYyZEJhY2tQcm9wSW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBkeTogQXJyYXkzRCwgd2VpZ2h0czogQXJyYXk0RCwgc3RyaWRlOiBudW1iZXIsXG4gICAgICBwYWQ6IG51bWJlcik6IHtkeDogQXJyYXkzRCwgZHc6IEFycmF5NEQsIGRiOiBBcnJheTFEfSB7XG4gICAgY29uc3QgZlNpemUgPSB3ZWlnaHRzLnNoYXBlWzBdO1xuICAgIGNvbnN0IGlucHV0RGVwdGggPSB3ZWlnaHRzLnNoYXBlWzJdO1xuICAgIGNvbnN0IG91dHB1dERlcHRoID0gd2VpZ2h0cy5zaGFwZVszXTtcbiAgICBjb25zdCB4VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHguc2hhcGUpO1xuICAgIGNvbnN0IHdUZXhTaGFwZSA9XG4gICAgICAgIGNvbnZfdXRpbC5jb21wdXRlV2VpZ2h0c1RleFNoYXBlKGlucHV0RGVwdGgsIG91dHB1dERlcHRoLCBmU2l6ZSk7XG4gICAgY29uc3QgeVRleFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRChkeS5zaGFwZSk7XG5cbiAgICAvLyBJZiB0aGUgdGV4dHVyZSBzaGFwZXMgZG9lc24ndCBtYXRjaCB0aGUgc2hhcGVzIHRoYXQgc2hhZGVycyBleHBlY3QsXG4gICAgLy8gZG8gcGh5c2ljYWwgdGV4dHVyZSByZXNoYXBlcyBvbiB0aGUgR1BVLlxuICAgIGxldCBjbGVhbnVwWCA9IGZhbHNlO1xuICAgIGNvbnN0IGFjdHVhbFhUZXhTaGFwZSA9IHguZ2V0VGV4dHVyZVNoYXBlUkMoeFRleFNoYXBlKTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsWFRleFNoYXBlLCB4VGV4U2hhcGUpKSB7XG4gICAgICB4ID0gdGhpcy5yZXNoYXBlVGV4dHVyZSh4LCB4VGV4U2hhcGUpO1xuICAgICAgY2xlYW51cFggPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCBjbGVhbnVwVyA9IGZhbHNlO1xuICAgIGNvbnN0IGFjdHVhbFdUZXhTaGFwZSA9IHdlaWdodHMuZ2V0VGV4dHVyZVNoYXBlUkMod1RleFNoYXBlKTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsV1RleFNoYXBlLCB3VGV4U2hhcGUpKSB7XG4gICAgICB3ZWlnaHRzID0gdGhpcy5yZXNoYXBlVGV4dHVyZSh3ZWlnaHRzLCB3VGV4U2hhcGUpO1xuICAgICAgY2xlYW51cFcgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCBjbGVhbnVwWSA9IGZhbHNlO1xuICAgIGNvbnN0IGFjdHVhbFlUZXhTaGFwZSA9IGR5LmdldFRleHR1cmVTaGFwZVJDKHlUZXhTaGFwZSk7XG4gICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGFjdHVhbFlUZXhTaGFwZSwgeVRleFNoYXBlKSkge1xuICAgICAgZHkgPSB0aGlzLnJlc2hhcGVUZXh0dXJlKGR5LCB5VGV4U2hhcGUpO1xuICAgICAgY2xlYW51cFkgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGR3ID0gdGhpcy5jb252MmREZXJXZWlnaHRzKHgsIGR5LCBmU2l6ZSwgc3RyaWRlLCBwYWQpO1xuICAgIGNvbnN0IGRiID0gdGhpcy5jb252MmREZXJCaWFzKGR5KTtcbiAgICBjb25zdCBkeCA9IHRoaXMuY29udjJkVHJhbnNwb3NlSW50ZXJuYWwoXG4gICAgICAgIGR5LCB3ZWlnaHRzLCBudWxsIC8qKiBiaWFzZXMgKi8sIHN0cmlkZSwgcGFkKTtcblxuICAgIGlmIChjbGVhbnVwWCkge1xuICAgICAgeC5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlmIChjbGVhbnVwVykge1xuICAgICAgd2VpZ2h0cy5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlmIChjbGVhbnVwWSkge1xuICAgICAgZHkuZGlzcG9zZSgpO1xuICAgIH1cbiAgICByZXR1cm4ge2R4LCBkYiwgZHd9O1xuICB9XG5cbiAgcHJvdGVjdGVkIGNvbnYyZFRyYW5zcG9zZUludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgd2VpZ2h0czogQXJyYXk0RCwgYmlhc2VzOiBBcnJheTFEfG51bGwsIG9yaWdTdHJpZGU6IG51bWJlcixcbiAgICAgIG9yaWdQYWQ6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIGNvbnN0IG9yaWdJbnB1dERlcHRoID0gd2VpZ2h0cy5zaGFwZVsyXTtcbiAgICBjb25zdCBvcmlnT3V0cHV0RGVwdGggPSB3ZWlnaHRzLnNoYXBlWzNdO1xuICAgIGNvbnN0IGZpZWxkU2l6ZSA9IHdlaWdodHMuc2hhcGVbMF07XG5cbiAgICBjb25zdCBwcm9nS2V5ID0gW1xuICAgICAgQ09OVjJEX1RSQU5TUE9TRV9QUk9HLCB4LnNoYXBlLCBmaWVsZFNpemUsIG9yaWdJbnB1dERlcHRoLCBvcmlnU3RyaWRlLFxuICAgICAgb3JpZ1BhZCwgYmlhc2VzICE9IG51bGxcbiAgICBdLmpvaW4oJ18nKTtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5nZXRBbmRTYXZlUHJvZ3JhbShwcm9nS2V5LCAoKSA9PiB7XG4gICAgICByZXR1cm4gY29udl9iYWNrcHJvcF9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJDb252VHJhbnNwb3NlU291cmNlKFxuICAgICAgICAgIHguc2hhcGUsIGZpZWxkU2l6ZSwgb3JpZ0lucHV0RGVwdGgsIG9yaWdTdHJpZGUsIG9yaWdQYWQsXG4gICAgICAgICAgYmlhc2VzICE9IG51bGwpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgeFRleFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRCh4LnNoYXBlKTtcbiAgICBjb25zdCB3VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVdlaWdodHNUZXhTaGFwZShcbiAgICAgICAgb3JpZ0lucHV0RGVwdGgsIG9yaWdPdXRwdXREZXB0aCwgZmllbGRTaXplKTtcbiAgICBjb25zdCBiaWFzVGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZUJpYXNlc1RleFNoYXBlKG9yaWdJbnB1dERlcHRoKTtcblxuICAgIC8vIElmIHRoZSB0ZXh0dXJlIHNoYXBlcyBkb2Vzbid0IG1hdGNoIHRoZSBzaGFwZXMgdGhhdCBzaGFkZXJzIGV4cGVjdCxcbiAgICAvLyBkbyBwaHlzaWNhbCB0ZXh0dXJlIHJlc2hhcGVzIG9uIHRoZSBHUFUuXG4gICAgY29uc3QgYWN0dWFsWFRleFNoYXBlID0geC5nZXRUZXh0dXJlU2hhcGVSQyh4VGV4U2hhcGUpO1xuICAgIGxldCBjbGVhbnVwWCA9IGZhbHNlO1xuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhY3R1YWxYVGV4U2hhcGUsIHhUZXhTaGFwZSkpIHtcbiAgICAgIHggPSB0aGlzLnJlc2hhcGVUZXh0dXJlKHgsIHhUZXhTaGFwZSk7XG4gICAgICBjbGVhbnVwWCA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGNsZWFudXBXID0gZmFsc2U7XG4gICAgY29uc3QgYWN0dWFsV1RleFNoYXBlID0gd2VpZ2h0cy5nZXRUZXh0dXJlU2hhcGVSQyh3VGV4U2hhcGUpO1xuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhY3R1YWxXVGV4U2hhcGUsIHdUZXhTaGFwZSkpIHtcbiAgICAgIHdlaWdodHMgPSB0aGlzLnJlc2hhcGVUZXh0dXJlKHdlaWdodHMsIHdUZXhTaGFwZSk7XG4gICAgICBjbGVhbnVwVyA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGNsZWFudXBCID0gZmFsc2U7XG4gICAgaWYgKGJpYXNlcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBhY3R1YWxCaWFzVGV4U2hhcGUgPSBiaWFzZXMuZ2V0VGV4dHVyZVNoYXBlUkMoYmlhc1RleFNoYXBlKTtcbiAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhY3R1YWxCaWFzVGV4U2hhcGUsIGJpYXNUZXhTaGFwZSkpIHtcbiAgICAgICAgYmlhc2VzID0gdGhpcy5yZXNoYXBlVGV4dHVyZShiaWFzZXMsIGJpYXNUZXhTaGFwZSk7XG4gICAgICAgIGNsZWFudXBCID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaWd1cmUgb3V0IHRoZSBvdXRwdXQgc2hhcGUgYnkgZGlsYXRpbmcgdGhlIGlucHV0LlxuICAgIGNvbnN0IGRpbGF0ZWRSQyA9XG4gICAgICAgIGNvbnZfdXRpbC5jb21wdXRlRGlsYXRlZFJDKFt4LnNoYXBlWzBdLCB4LnNoYXBlWzFdXSwgb3JpZ1N0cmlkZSk7XG4gICAgY29uc3QgcGFkID0gZmllbGRTaXplIC0gMSAtIG9yaWdQYWQ7XG4gICAgY29uc3QgcmVzdWx0U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZU91dHB1dFNoYXBlM0QoXG4gICAgICAgIFtkaWxhdGVkUkNbMF0sIGRpbGF0ZWRSQ1sxXSwgb3JpZ091dHB1dERlcHRoXSwgZmllbGRTaXplLFxuICAgICAgICBvcmlnSW5wdXREZXB0aCwgMSwgcGFkKTtcbiAgICBjb25zdCByZXN1bHRUZXhTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QocmVzdWx0U2hhcGUpO1xuICAgIGNvbnN0IHJlc3VsdFRleCA9IHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUocmVzdWx0VGV4U2hhcGUpO1xuXG4gICAgY29udl9iYWNrcHJvcF9ncHUuY29udlRyYW5zcG9zZShcbiAgICAgICAgdGhpcy5ncGdwdSwgcHJvZ3JhbSwgeC5nZXRUZXh0dXJlKCksIHdlaWdodHMuZ2V0VGV4dHVyZSgpLFxuICAgICAgICBiaWFzZXMgIT0gbnVsbCA/IGJpYXNlcy5nZXRUZXh0dXJlKCkgOiBudWxsLCByZXN1bHRUZXgsIHJlc3VsdFRleFNoYXBlKTtcblxuICAgIGlmIChjbGVhbnVwWCkge1xuICAgICAgeC5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlmIChjbGVhbnVwVykge1xuICAgICAgd2VpZ2h0cy5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlmIChjbGVhbnVwQikge1xuICAgICAgYmlhc2VzIS5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxBcnJheTNEPihcbiAgICAgICAgcmVzdWx0U2hhcGUsIHt0ZXh0dXJlOiByZXN1bHRUZXgsIHRleHR1cmVTaGFwZVJDOiByZXN1bHRUZXhTaGFwZX0pO1xuICB9XG5cbiAgY29udjJkRGVyV2VpZ2h0cyhcbiAgICAgIHg6IEFycmF5M0QsIGRZOiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlcixcbiAgICAgIHplcm9QYWQ6IG51bWJlcik6IEFycmF5NEQge1xuICAgIGNvbnN0IGlucHV0RGVwdGggPSB4LnNoYXBlWzJdO1xuICAgIGNvbnN0IG91dHB1dERlcHRoID0gZFkuc2hhcGVbMl07XG4gICAgY29uc3QgcHJvZ0tleSA9IFtcbiAgICAgIENPTlYyRF9ERVJXX1BST0csIHguc2hhcGUsIGZTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkXG4gICAgXS5qb2luKCdfJyk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0ocHJvZ0tleSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNvbnZfYmFja3Byb3BfZ3B1LmdldEZyYWdtZW50U2hhZGVyRGVyV2VpZ2h0c1NvdXJjZShcbiAgICAgICAgICB4LnNoYXBlLCBmU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB4VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHguc2hhcGUpO1xuICAgIGNvbnN0IHlTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRChcbiAgICAgICAgeC5zaGFwZSwgZlNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpO1xuICAgIGNvbnN0IHlUZXhTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoeVNoYXBlKTtcblxuICAgIC8vIElmIHRoZSB0ZXh0dXJlIHNoYXBlcyBkb2Vzbid0IG1hdGNoIHRoZSBzaGFwZXMgdGhhdCBzaGFkZXJzIGV4cGVjdCxcbiAgICAvLyBkbyBwaHlzaWNhbCB0ZXh0dXJlIHJlc2hhcGVzIG9uIHRoZSBHUFUuXG4gICAgY29uc3QgYWN0dWFsWFRleFNoYXBlID0geC5nZXRUZXh0dXJlU2hhcGVSQyh4VGV4U2hhcGUpO1xuICAgIGxldCBjbGVhbnVwWCA9IGZhbHNlO1xuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhY3R1YWxYVGV4U2hhcGUsIHhUZXhTaGFwZSkpIHtcbiAgICAgIHggPSB0aGlzLnJlc2hhcGVUZXh0dXJlKHgsIHhUZXhTaGFwZSk7XG4gICAgICBjbGVhbnVwWCA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGNsZWFudXBZID0gZmFsc2U7XG4gICAgY29uc3QgYWN0dWFsWVRleFNoYXBlID0gZFkuZ2V0VGV4dHVyZVNoYXBlUkMoeVRleFNoYXBlKTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsWVRleFNoYXBlLCB5VGV4U2hhcGUpKSB7XG4gICAgICBkWSA9IHRoaXMucmVzaGFwZVRleHR1cmUoZFksIHlUZXhTaGFwZSk7XG4gICAgICBjbGVhbnVwWSA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0VGV4U2hhcGUgPVxuICAgICAgICBjb252X3V0aWwuY29tcHV0ZVdlaWdodHNUZXhTaGFwZShpbnB1dERlcHRoLCBvdXRwdXREZXB0aCwgZlNpemUpO1xuICAgIGNvbnN0IHJlc3VsdFRleCA9IHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUocmVzdWx0VGV4U2hhcGUpO1xuXG4gICAgY29udl9iYWNrcHJvcF9ncHUuZGVyV2VpZ2h0cyhcbiAgICAgICAgdGhpcy5ncGdwdSwgcHJvZ3JhbSwgeC5nZXRUZXh0dXJlKCksIGRZLmdldFRleHR1cmUoKSwgcmVzdWx0VGV4LFxuICAgICAgICByZXN1bHRUZXhTaGFwZSk7XG5cbiAgICBpZiAoY2xlYW51cFgpIHtcbiAgICAgIHguZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAoY2xlYW51cFkpIHtcbiAgICAgIGRZLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICBjb25zdCB3ZWlnaHRzU2hhcGUgPVxuICAgICAgICBjb252X3V0aWwuY29tcHV0ZVdlaWdodHNTaGFwZTREKGlucHV0RGVwdGgsIG91dHB1dERlcHRoLCBmU2l6ZSk7XG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxBcnJheTREPihcbiAgICAgICAgd2VpZ2h0c1NoYXBlLCB7dGV4dHVyZTogcmVzdWx0VGV4LCB0ZXh0dXJlU2hhcGVSQzogcmVzdWx0VGV4U2hhcGV9KTtcbiAgfVxuXG4gIGNvbnYyZERlckJpYXMoZFk6IEFycmF5M0QpOiBBcnJheTFEIHtcbiAgICBjb25zdCBvdXRwdXREZXB0aCA9IGRZLnNoYXBlWzJdO1xuICAgIGNvbnN0IHByb2dLZXkgPSBbQ09OVjJEX0RFUkJfUFJPRywgZFkuc2hhcGVdLmpvaW4oJ18nKTtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5nZXRBbmRTYXZlUHJvZ3JhbShwcm9nS2V5LCAoKSA9PiB7XG4gICAgICByZXR1cm4gY29udl9iYWNrcHJvcF9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJEZXJCaWFzU291cmNlKGRZLnNoYXBlKTtcbiAgICB9KTtcbiAgICBjb25zdCB5VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKGRZLnNoYXBlKTtcblxuICAgIC8vIElmIHRoZSB0ZXh0dXJlIHNoYXBlcyBkb2Vzbid0IG1hdGNoIHRoZSBzaGFwZXMgdGhhdCBzaGFkZXJzIGV4cGVjdCxcbiAgICAvLyBkbyBwaHlzaWNhbCB0ZXh0dXJlIHJlc2hhcGVzIG9uIHRoZSBHUFUuXG4gICAgbGV0IGNsZWFudXBZID0gZmFsc2U7XG4gICAgY29uc3QgYWN0dWFsWVRleFNoYXBlID0gZFkuZ2V0VGV4dHVyZVNoYXBlUkMoeVRleFNoYXBlKTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsWVRleFNoYXBlLCB5VGV4U2hhcGUpKSB7XG4gICAgICBkWSA9IHRoaXMucmVzaGFwZVRleHR1cmUoZFksIHlUZXhTaGFwZSk7XG4gICAgICBjbGVhbnVwWSA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZUJpYXNlc1RleFNoYXBlKG91dHB1dERlcHRoKTtcbiAgICBjb25zdCByZXN1bHRUZXggPSB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKHJlc3VsdFRleFNoYXBlKTtcblxuICAgIGNvbnZfYmFja3Byb3BfZ3B1LmRlckJpYXMoXG4gICAgICAgIHRoaXMuZ3BncHUsIHByb2dyYW0sIGRZLmdldFRleHR1cmUoKSwgcmVzdWx0VGV4LCByZXN1bHRUZXhTaGFwZSk7XG5cbiAgICBpZiAoY2xlYW51cFkpIHtcbiAgICAgIGRZLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPEFycmF5MUQ+KFxuICAgICAgICBbb3V0cHV0RGVwdGhdLCB7dGV4dHVyZTogcmVzdWx0VGV4LCB0ZXh0dXJlU2hhcGVSQzogcmVzdWx0VGV4U2hhcGV9KTtcbiAgfVxuXG4gIHByaXZhdGUgcG9vbChcbiAgICAgIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgeDogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsXG4gICAgICBwYWQ6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIGNvbnN0IHhUZXhTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoeC5zaGFwZSk7XG5cbiAgICAvLyBJZiB0aGUgdGV4dHVyZSBzaGFwZXMgZG9lc24ndCBtYXRjaCB0aGUgc2hhcGVzIHRoYXQgc2hhZGVycyBleHBlY3QsXG4gICAgLy8gZG8gcGh5c2ljYWwgdGV4dHVyZSByZXNoYXBlcyBvbiB0aGUgR1BVLlxuICAgIGNvbnN0IGFjdHVhbFhUZXhTaGFwZSA9IHguZ2V0VGV4dHVyZVNoYXBlUkMoeFRleFNoYXBlKTtcbiAgICBsZXQgY2xlYW51cFggPSBmYWxzZTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsWFRleFNoYXBlLCB4VGV4U2hhcGUpKSB7XG4gICAgICB4ID0gdGhpcy5yZXNoYXBlVGV4dHVyZSh4LCB4VGV4U2hhcGUpO1xuICAgICAgY2xlYW51cFggPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdFNoYXBlID1cbiAgICAgICAgY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKHguc2hhcGUsIGZTaXplLCB4LnNoYXBlWzJdLCBzdHJpZGUsIHBhZCk7XG4gICAgY29uc3QgcmVzdWx0VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHJlc3VsdFNoYXBlKTtcbiAgICBjb25zdCBwb29sUmVzdWx0VGV4ID0gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZShyZXN1bHRUZXhTaGFwZSk7XG5cbiAgICBwb29sX2dwdS5wb29sQ29tbW9uKFxuICAgICAgICB0aGlzLmdwZ3B1LCBwcm9ncmFtLCB4LmdldFRleHR1cmUoKSwgcG9vbFJlc3VsdFRleCwgcmVzdWx0VGV4U2hhcGUpO1xuXG4gICAgaWYgKGNsZWFudXBYKSB7XG4gICAgICB4LmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPEFycmF5M0Q+KFxuICAgICAgICByZXN1bHRTaGFwZSwge3RleHR1cmU6IHBvb2xSZXN1bHRUZXgsIHRleHR1cmVTaGFwZVJDOiByZXN1bHRUZXhTaGFwZX0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1heFBvb2xJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCBwYWQ6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIGNvbnN0IG1heFBvb2xQcm9nS2V5ID1cbiAgICAgICAgW01BWF9QT09MX1BST0csIHguc2hhcGUsIGZTaXplLCBzdHJpZGUsIHBhZF0uam9pbignXycpO1xuICAgIGNvbnN0IG1heFBvb2xQcm9ncmFtID0gdGhpcy5nZXRBbmRTYXZlUHJvZ3JhbShtYXhQb29sUHJvZ0tleSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIG1heF9wb29sX2dwdS5nZXRGcmFnbWVudFNoYWRlck1heFBvb2xTb3VyY2UoXG4gICAgICAgICAgeC5zaGFwZSwgZlNpemUsIHN0cmlkZSwgcGFkKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLnBvb2wobWF4UG9vbFByb2dyYW0sIHgsIGZTaXplLCBzdHJpZGUsIHBhZCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbWluUG9vbEludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIHBhZDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgY29uc3QgbWluUG9vbFByb2dLZXkgPVxuICAgICAgICBbTUlOX1BPT0xfUFJPRywgeC5zaGFwZSwgZlNpemUsIHN0cmlkZSwgcGFkXS5qb2luKCdfJyk7XG4gICAgY29uc3QgbWluUG9vbFByb2dyYW0gPSB0aGlzLmdldEFuZFNhdmVQcm9ncmFtKG1pblBvb2xQcm9nS2V5LCAoKSA9PiB7XG4gICAgICByZXR1cm4gbWluX3Bvb2xfZ3B1LmdldEZyYWdtZW50U2hhZGVyTWluUG9vbFNvdXJjZShcbiAgICAgICAgICB4LnNoYXBlLCBmU2l6ZSwgc3RyaWRlLCBwYWQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMucG9vbChtaW5Qb29sUHJvZ3JhbSwgeCwgZlNpemUsIHN0cmlkZSwgcGFkKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhdmdQb29sSW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgcGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICBjb25zdCBhdmdQb29sUHJvZ0tleSA9XG4gICAgICAgIFtBVkdfUE9PTF9QUk9HLCB4LnNoYXBlLCBmU2l6ZSwgc3RyaWRlLCBwYWRdLmpvaW4oJ18nKTtcbiAgICBjb25zdCBhdmdQb29sUHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0oYXZnUG9vbFByb2dLZXksICgpID0+IHtcbiAgICAgIHJldHVybiBhdmdfcG9vbF9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJBdmdQb29sU291cmNlKFxuICAgICAgICAgIHguc2hhcGUsIGZTaXplLCBzdHJpZGUsIHBhZCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5wb29sKGF2Z1Bvb2xQcm9ncmFtLCB4LCBmU2l6ZSwgc3RyaWRlLCBwYWQpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1heFBvb2xCYWNrcHJvcEludGVybmFsKFxuICAgICAgZHk6IEFycmF5M0QsIHg6IEFycmF5M0QsIGZTaXplOiBudW1iZXIsIG9yaWdTdHJpZGU6IG51bWJlcixcbiAgICAgIG9yaWdQYWQ6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIGNvbnN0IG1heFBvb2xQb3NpdGlvbnNQcm9nS2V5ID0gW1xuICAgICAgTUFYX1BPT0xfUE9TSVRJT05TX1BST0csIHguc2hhcGUsIGZTaXplLCBvcmlnU3RyaWRlLCBvcmlnUGFkXG4gICAgXS5qb2luKCdfJyk7XG4gICAgY29uc3QgbWF4UG9vbFBvc2l0aW9uc1Byb2dyYW0gPVxuICAgICAgICB0aGlzLmdldEFuZFNhdmVQcm9ncmFtKG1heFBvb2xQb3NpdGlvbnNQcm9nS2V5LCAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG1heF9wb29sX2dwdS5nZXRGcmFnbWVudFNoYWRlck1heFBvb2xQb3NpdGlvbnNTb3VyY2UoXG4gICAgICAgICAgICAgIHguc2hhcGUsIGZTaXplLCBvcmlnU3RyaWRlLCBvcmlnUGFkKTtcbiAgICAgICAgfSk7XG5cbiAgICBjb25zdCBtYXhQb29sUmVzdWx0U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZU91dHB1dFNoYXBlM0QoXG4gICAgICAgIHguc2hhcGUsIGZTaXplLCB4LnNoYXBlWzJdLCBvcmlnU3RyaWRlLCBvcmlnUGFkKTtcbiAgICBjb25zdCBtYXhQb29sUmVzdWx0VGV4U2hhcGUgPVxuICAgICAgICBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKG1heFBvb2xSZXN1bHRTaGFwZSk7XG4gICAgY29uc3QgbWF4UG9vbFBvc2l0aW9uc1Jlc3VsdFRleCA9XG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUobWF4UG9vbFJlc3VsdFRleFNoYXBlKTtcbiAgICAvLyBJZiB0aGUgdGV4dHVyZSBzaGFwZXMgZG9lc24ndCBtYXRjaCB0aGUgc2hhcGVzIHRoYXQgc2hhZGVycyBleHBlY3QsXG4gICAgLy8gZG8gcGh5c2ljYWwgdGV4dHVyZSByZXNoYXBlcyBvbiB0aGUgR1BVLlxuICAgIGNvbnN0IHhUZXhTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoeC5zaGFwZSk7XG4gICAgY29uc3QgYWN0dWFsWFRleFNoYXBlID0geC5nZXRUZXh0dXJlU2hhcGVSQyh4VGV4U2hhcGUpO1xuICAgIGxldCBjbGVhbnVwWCA9IGZhbHNlO1xuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhY3R1YWxYVGV4U2hhcGUsIHhUZXhTaGFwZSkpIHtcbiAgICAgIHggPSB0aGlzLnJlc2hhcGVUZXh0dXJlKHgsIHhUZXhTaGFwZSk7XG4gICAgICBjbGVhbnVwWCA9IHRydWU7XG4gICAgfVxuXG4gICAgbWF4X3Bvb2xfZ3B1Lm1heFBvb2xDb21tb24oXG4gICAgICAgIHRoaXMuZ3BncHUsIG1heFBvb2xQb3NpdGlvbnNQcm9ncmFtLCB4LmdldFRleHR1cmUoKSxcbiAgICAgICAgbWF4UG9vbFBvc2l0aW9uc1Jlc3VsdFRleCwgbWF4UG9vbFJlc3VsdFRleFNoYXBlKTtcblxuICAgIGNvbnN0IG1heFBvb2xCYWNrcHJvcFByb2dLZXkgPSBbXG4gICAgICBNQVhfUE9PTF9CQUNLUFJPUF9QUk9HLCBkeS5zaGFwZSwgZlNpemUsIG9yaWdTdHJpZGUsIG9yaWdQYWRcbiAgICBdLmpvaW4oJ18nKTtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5nZXRBbmRTYXZlUHJvZ3JhbShtYXhQb29sQmFja3Byb3BQcm9nS2V5LCAoKSA9PiB7XG4gICAgICByZXR1cm4gbWF4X3Bvb2xfYmFja3Byb3BfZ3B1LmdldEZyYWdtZW50U2hhZGVyTWF4UG9vbEJhY2twcm9wKFxuICAgICAgICAgIGR5LnNoYXBlLCBmU2l6ZSwgb3JpZ1N0cmlkZSwgb3JpZ1BhZCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBkeVRleFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRChkeS5zaGFwZSk7XG5cbiAgICAvLyBJZiB0aGUgdGV4dHVyZSBzaGFwZXMgZG9lc24ndCBtYXRjaCB0aGUgc2hhcGVzIHRoYXQgc2hhZGVycyBleHBlY3QsXG4gICAgLy8gZG8gcGh5c2ljYWwgdGV4dHVyZSByZXNoYXBlcyBvbiB0aGUgR1BVLlxuICAgIGNvbnN0IGFjdHVhbER5VGV4U2hhcGUgPSBkeS5nZXRUZXh0dXJlU2hhcGVSQyhkeVRleFNoYXBlKTtcbiAgICBsZXQgY2xlYW51cER5ID0gZmFsc2U7XG4gICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGFjdHVhbER5VGV4U2hhcGUsIGR5VGV4U2hhcGUpKSB7XG4gICAgICBkeSA9IHRoaXMucmVzaGFwZVRleHR1cmUoZHksIGR5VGV4U2hhcGUpO1xuICAgICAgY2xlYW51cER5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBkaWxhdGVkRHlSQyA9XG4gICAgICAgIGNvbnZfdXRpbC5jb21wdXRlRGlsYXRlZFJDKFtkeS5zaGFwZVswXSwgZHkuc2hhcGVbMV1dLCBvcmlnU3RyaWRlKTtcbiAgICBjb25zdCBwYWQgPSBmU2l6ZSAtIDEgLSBvcmlnUGFkO1xuICAgIGNvbnN0IHJlc3VsdFNoYXBlUkNEID0gY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKFxuICAgICAgICBbZGlsYXRlZER5UkNbMF0sIGRpbGF0ZWREeVJDWzFdLCBkeS5zaGFwZVsyXV0sIGZTaXplLCBkeS5zaGFwZVsyXSwgMSxcbiAgICAgICAgcGFkKTtcbiAgICBjb25zdCByZXN1bHRUZXhTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QocmVzdWx0U2hhcGVSQ0QpO1xuICAgIGNvbnN0IHJlc3VsdFRleCA9IHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUocmVzdWx0VGV4U2hhcGUpO1xuXG4gICAgbWF4X3Bvb2xfYmFja3Byb3BfZ3B1Lm1heFBvb2xCYWNrcHJvcChcbiAgICAgICAgdGhpcy5ncGdwdSwgcHJvZ3JhbSwgZHkuZ2V0VGV4dHVyZSgpLCBtYXhQb29sUG9zaXRpb25zUmVzdWx0VGV4LFxuICAgICAgICByZXN1bHRUZXgsIHJlc3VsdFRleFNoYXBlKTtcblxuICAgIGlmIChjbGVhbnVwRHkpIHtcbiAgICAgIGR5LmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoY2xlYW51cFgpIHtcbiAgICAgIHguZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUoXG4gICAgICAgIG1heFBvb2xQb3NpdGlvbnNSZXN1bHRUZXgsIG1heFBvb2xSZXN1bHRUZXhTaGFwZSk7XG5cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPEFycmF5M0Q+KFxuICAgICAgICByZXN1bHRTaGFwZVJDRCwge3RleHR1cmU6IHJlc3VsdFRleCwgdGV4dHVyZVNoYXBlUkM6IHJlc3VsdFRleFNoYXBlfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVzaXplQmlsaW5lYXIzREludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgbmV3U2hhcGUyRDogW251bWJlciwgbnVtYmVyXSxcbiAgICAgIGFsaWduQ29ybmVyczogYm9vbGVhbik6IEFycmF5M0Qge1xuICAgIGNvbnN0IHByb2dyYW1LZXkgPVxuICAgICAgICBbUkVTSVpFX0JJTElORUFSX1BST0csIHguc2hhcGUsIG5ld1NoYXBlMkQsIGFsaWduQ29ybmVyc10uam9pbignXycpO1xuXG4gICAgY29uc3QgbmV3U2hhcGVSQ0Q6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9XG4gICAgICAgIFtuZXdTaGFwZTJEWzBdLCBuZXdTaGFwZTJEWzFdLCB4LnNoYXBlWzJdXTtcbiAgICBjb25zdCByZXN1bHRUZXhTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QobmV3U2hhcGVSQ0QpO1xuXG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0oXG4gICAgICAgIHByb2dyYW1LZXksXG4gICAgICAgICgpID0+IHJlc2l6ZV9iaWxpbmVhcl9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoXG4gICAgICAgICAgICB4LnNoYXBlLCBuZXdTaGFwZTJELCBhbGlnbkNvcm5lcnMpKTtcblxuICAgIGNvbnN0IHJlc3VsdFRleHR1cmUgPSB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKHJlc3VsdFRleFNoYXBlKTtcblxuICAgIHJlc2l6ZV9iaWxpbmVhcl9ncHUucmVzaXplQmlsaW5lYXIoXG4gICAgICAgIHRoaXMuZ3BncHUsIHByb2dyYW0sIHguZ2V0VGV4dHVyZSgpLCByZXN1bHRUZXh0dXJlLCByZXN1bHRUZXhTaGFwZSk7XG5cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPEFycmF5M0Q+KFxuICAgICAgICBuZXdTaGFwZVJDRCwge3RleHR1cmU6IHJlc3VsdFRleHR1cmUsIHRleHR1cmVTaGFwZVJDOiByZXN1bHRUZXhTaGFwZX0pO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBbmRTYXZlQmluYXJ5KGtleTogc3RyaW5nLCBnZXRCaW5hcnk6ICgpID0+IEdQR1BVQmluYXJ5KTpcbiAgICAgIEdQR1BVQmluYXJ5IHtcbiAgICBpZiAoIShrZXkgaW4gdGhpcy5iaW5hcnlDYWNoZSkpIHtcbiAgICAgIHRoaXMuYmluYXJ5Q2FjaGVba2V5XSA9IGdldEJpbmFyeSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5iaW5hcnlDYWNoZVtrZXldO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBbmRTYXZlUHJvZ3JhbShwcm9ncmFtS2V5OiBzdHJpbmcsIGdldFNoYWRlclNvdXJjZTogKCkgPT4gc3RyaW5nKTpcbiAgICAgIFdlYkdMUHJvZ3JhbSB7XG4gICAgaWYgKCEocHJvZ3JhbUtleSBpbiB0aGlzLnByb2dyYW1DYWNoZSkpIHtcbiAgICAgIHRoaXMucHJvZ3JhbUNhY2hlW3Byb2dyYW1LZXldID1cbiAgICAgICAgICB0aGlzLmdwZ3B1LmNyZWF0ZVByb2dyYW0oZ2V0U2hhZGVyU291cmNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9ncmFtQ2FjaGVbcHJvZ3JhbUtleV07XG4gIH1cblxuICBwcml2YXRlIGRvR1BVU2hhcGVzTWF0Y2goYTogTkRBcnJheSwgYjogTkRBcnJheSk6IGJvb2xlYW4ge1xuICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgaWYgKGEuaW5HUFUoKSkge1xuICAgICAgLy8gUHJlZmVyIEIgdG8gaGF2ZSB0aGUgc2hhcGUgb2YgQS5cbiAgICAgIGIuZ2V0VGV4dHVyZVNoYXBlUkMoYS5nZXRUZXh0dXJlU2hhcGVSQygpKTtcbiAgICB9IGVsc2UgaWYgKGIuaW5HUFUoKSkge1xuICAgICAgLy8gUHJlZmVyIEEgdG8gaGF2ZSB0aGUgc2hhcGUgb2YgQi5cbiAgICAgIGEuZ2V0VGV4dHVyZVNoYXBlUkMoYi5nZXRUZXh0dXJlU2hhcGVSQygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlzRXF1YWwoYS5nZXRUZXh0dXJlU2hhcGVSQygpLCBiLmdldFRleHR1cmVTaGFwZVJDKCkpO1xuICB9XG5cbiAgZ2V0VGV4dHVyZU1hbmFnZXIoKTogVGV4dHVyZU1hbmFnZXIge1xuICAgIHJldHVybiB0aGlzLnRleHR1cmVNYW5hZ2VyO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGNvbnN0IHByb2dyYW1LZXkgaW4gdGhpcy5wcm9ncmFtQ2FjaGUpIHtcbiAgICAgIGlmICh0aGlzLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShwcm9ncmFtS2V5KSkge1xuICAgICAgICB0aGlzLmdwZ3B1LmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtQ2FjaGVbcHJvZ3JhbUtleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmJpbmFyeUNhY2hlKSB7XG4gICAgICB0aGlzLmdwZ3B1LmRlbGV0ZVByb2dyYW0odGhpcy5iaW5hcnlDYWNoZVtrZXldLndlYkdMUHJvZ3JhbSk7XG4gICAgfVxuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIuZGlzcG9zZSgpO1xuXG4gICAgaWYgKHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSkge1xuICAgICAgdGhpcy5ncGdwdS5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL3dlYmdsL2dwZ3B1X2NvbnRleHQnO1xuaW1wb3J0IHtUZXh0dXJlTWFuYWdlcn0gZnJvbSAnLi93ZWJnbC90ZXh0dXJlX21hbmFnZXInO1xuaW1wb3J0ICogYXMgd2ViZ2xfdXRpbCBmcm9tICcuL3dlYmdsL3dlYmdsX3V0aWwnO1xuXG4vLyBUaGVzZSBnbG9iYWwgdmFyaWFibGVzIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gbnVsbCBzbyB0aGF0IGNsb3N1cmUga25vd3Ncbi8vIG5vdCB0byBzZWFsIHRoZW0uXG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IGxldCBHUEdQVTogR1BHUFVDb250ZXh0ID0gbnVsbCE7XG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IGxldCBURVhUVVJFX01BTkFHRVI6IFRleHR1cmVNYW5hZ2VyID0gbnVsbCE7XG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgaW50ZXJmYWNlIE5EQXJyYXlEYXRhIHtcbiAgdmFsdWVzPzogRmxvYXQzMkFycmF5O1xuICB0ZXh0dXJlPzogV2ViR0xUZXh0dXJlO1xuICAvKiogW3Jvd3MsIGNvbHVtbnNdIHNoYXBlIG9mIHRoZSB0ZXh0dXJlLiAqL1xuICB0ZXh0dXJlU2hhcGVSQz86IFtudW1iZXIsIG51bWJlcl07XG59XG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUdQVShcbiAgICBncGdwdTogR1BHUFVDb250ZXh0LCB0ZXh0dXJlTWFuYWdlcjogVGV4dHVyZU1hbmFnZXIpIHtcbiAgR1BHUFUgPSBncGdwdTtcbiAgVEVYVFVSRV9NQU5BR0VSID0gdGV4dHVyZU1hbmFnZXI7XG59XG5cbmZ1bmN0aW9uIHRocm93SWZHUFVOb3RJbml0aWFsaXplZCgpIHtcbiAgaWYgKEdQR1BVID09IG51bGwgfHwgVEVYVFVSRV9NQU5BR0VSID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dQVSBub3QgaW50aWFsaXplZC4nKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTkRBcnJheSB7XG4gIC8qKiBUaGUgc2hhcGUgb2YgdGhlIG5kYXJyYXkuICovXG4gIHNoYXBlOiBudW1iZXJbXTtcbiAgLyoqIE51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbmRhcnJheS4gKi9cbiAgc2l6ZTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBpbiBlYWNoIGRpbWVuc2lvbiB3aGVuIGluZGV4aW5nLiBTZWVcbiAgICogaHR0cHM6Ly9kb2NzLnNjaXB5Lm9yZy9kb2MvbnVtcHkvcmVmZXJlbmNlL2dlbmVyYXRlZFxuICAgKiAgICAgL251bXB5Lm5kYXJyYXkuc3RyaWRlcy5odG1sXG4gICAqL1xuICBwcm90ZWN0ZWQgc3RyaWRlczogbnVtYmVyW107XG5cbiAgcHJpdmF0ZSBkYXRhOiBOREFycmF5RGF0YTtcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3Ioc2hhcGU6IG51bWJlcltdLCBkYXRhOiBOREFycmF5RGF0YSkge1xuICAgIC8vIFNhbml0eSBjaGVja3MuXG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGRhdGEudmFsdWVzICE9IG51bGwgfHwgZGF0YS50ZXh0dXJlICE9IG51bGwsXG4gICAgICAgICdFaXRoZXIgYHZhbHVlc2Agb3IgYHRleHR1cmVgIG11c3QgYmUgZGVmaW5lZCcpO1xuXG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGRhdGEudGV4dHVyZSA9PSBudWxsIHx8IChkYXRhLnRleHR1cmVTaGFwZVJDICE9IG51bGwpLFxuICAgICAgICAnYHRleHR1cmVTaGFwZWAgbXVzdCBiZSBkZWZpbmVkIHdoZW4gYHRleHR1cmVgIGlzIGRlZmluZWQnKTtcblxuICAgIHRoaXMuc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG5cbiAgICBpZiAoZGF0YS52YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgdGhpcy5zaXplID09PSBkYXRhLnZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgJ0NvbnN0cnVjdGluZyBuZGFycmF5IG9mIHNoYXBlICgnICsgdGhpcy5zaXplICsgJykgc2hvdWxkIG1hdGNoIHRoZScgK1xuICAgICAgICAgICAgICAnIGxlbmd0aCBvZiB2YWx1ZXMgKCcgKyBkYXRhLnZhbHVlcy5sZW5ndGggKyAnKScpO1xuICAgIH1cblxuICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIGNvbnN0IGRpbSA9IHRoaXMuc2hhcGUubGVuZ3RoO1xuXG4gICAgaWYgKGRpbSA8IDIpIHtcbiAgICAgIHRoaXMuc3RyaWRlcyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMYXN0IGRpbWVuc2lvbiBoYXMgaW1wbGljaXQgc3RyaWRlIG9mIDEsIHRodXMgaGF2aW5nIEQtMSAoaW5zdGVhZCBvZiBEKVxuICAgICAgLy8gc3RyaWRlcy5cbiAgICAgIHRoaXMuc3RyaWRlcyA9IG5ldyBBcnJheShkaW0gLSAxKTtcbiAgICAgIHRoaXMuc3RyaWRlc1tkaW0gLSAyXSA9IHRoaXMuc2hhcGVbZGltIC0gMV07XG4gICAgICBmb3IgKGxldCBpID0gZGltIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdGhpcy5zdHJpZGVzW2ldID0gdGhpcy5zdHJpZGVzW2kgKyAxXSAqIHRoaXMuc2hhcGVbaSArIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBDcmVhdGVzIGEgbmRhcnJheSBvZiB6ZXJvcyB3aXRoIHRoZSBzcGVjaWZpZWQgc2hhcGUuICovXG4gIHN0YXRpYyB6ZXJvcyhzaGFwZTogbnVtYmVyW10pOiBOREFycmF5IHtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSkpO1xuICAgIHJldHVybiBOREFycmF5Lm1ha2Uoc2hhcGUsIHt2YWx1ZXN9KTtcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIGEgbmRhcnJheSBvZiB6ZXJvcyB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIHRoZSBzcGVjaWZpZWQgbmRhcnJheS5cbiAgICovXG4gIHN0YXRpYyB6ZXJvc0xpa2U8VCBleHRlbmRzIE5EQXJyYXk+KGFub3RoZXI6IFQpOiBUIHtcbiAgICByZXR1cm4gTkRBcnJheS56ZXJvcyhhbm90aGVyLnNoYXBlKSBhcyBUO1xuICB9XG5cbiAgLyoqIENyZWF0ZXMgYSBuZGFycmF5IHdpdGggdGhlIHNhbWUgdmFsdWVzL3NoYXBlIGFzIHRoZSBzcGVjaWZpZWQgbmRhcnJheS4gKi9cbiAgc3RhdGljIGxpa2U8VCBleHRlbmRzIE5EQXJyYXk+KGFub3RoZXI6IFQpOiBUIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBhbm90aGVyLmdldFZhbHVlcygpO1xuICAgIHJldHVybiBOREFycmF5Lm1ha2U8VD4oYW5vdGhlci5zaGFwZSwge3ZhbHVlczogbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMpfSk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgYSBuZXcgbmRhcnJheSB3aXRoIHRoZSBwcm92aWRlZCBzaGFwZSBhbmQgdmFsdWVzLiBWYWx1ZXMgc2hvdWxkIGJlIGluXG4gICAqIGEgZmxhdCBhcnJheS5cbiAgICovXG4gIHN0YXRpYyBtYWtlPFQgZXh0ZW5kcyBOREFycmF5PihzaGFwZTogbnVtYmVyW10sIGRhdGE6IE5EQXJyYXlEYXRhKTogVCB7XG4gICAgc3dpdGNoIChzaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXIoZGF0YSkgYXMgVDtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5MUQoZGF0YSkgYXMgYW55O1xuICAgICAgY2FzZSAyOlxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkyRChzaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdLCBkYXRhKSBhcyBhbnk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheTNEKHNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZGF0YSkgYXMgYW55O1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gbmV3IEFycmF5NEQoXG4gICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAgICAgICAgICAgIHNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCBkYXRhKSBhcyBhbnk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgIHJldHVybiBuZXcgTkRBcnJheShzaGFwZSwgZGF0YSkgYXMgYW55O1xuICAgIH1cbiAgfVxuXG4gIC8qKiBSZXNoYXBlcyB0aGUgY3VycmVudCBuZGFycmF5IGludG8gdGhlIHByb3ZpZGVkIHNoYXBlLiAqL1xuICByZXNoYXBlPFQgZXh0ZW5kcyBOREFycmF5PihuZXdTaGFwZTogbnVtYmVyW10pOiBUIHtcbiAgICBpZiAodXRpbC5hcnJheXNFcXVhbCh0aGlzLnNoYXBlLCBuZXdTaGFwZSkpIHtcbiAgICAgIC8vIE5vLW9wLlxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgcmV0dXJuIHRoaXMgYXMgYW55O1xuICAgIH1cblxuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB0aGlzLnNpemUgPT09IHV0aWwuc2l6ZUZyb21TaGFwZShuZXdTaGFwZSksXG4gICAgICAgICduZXcgc2hhcGUgYW5kIG9sZCBzaGFwZSBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLicpO1xuXG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihuZXdTaGFwZSwgdGhpcy5kYXRhKTtcbiAgfVxuXG4gIGFzU2NhbGFyKCk6IFNjYWxhciB7XG4gICAgdXRpbC5hc3NlcnQodGhpcy5zaXplID09PSAxLCAnVGhlIGFycmF5IG11c3QgaGF2ZSBvbmx5IDEgZWxlbWVudC4nKTtcbiAgICByZXR1cm4gdGhpcy5yZXNoYXBlPFNjYWxhcj4oW10pO1xuICB9XG5cbiAgYXMxRCgpOiBBcnJheTFEIHtcbiAgICByZXR1cm4gdGhpcy5yZXNoYXBlPEFycmF5MUQ+KFt0aGlzLnNpemVdKTtcbiAgfVxuXG4gIGFzMkQocm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIpOiBBcnJheTJEIHtcbiAgICByZXR1cm4gdGhpcy5yZXNoYXBlPEFycmF5MkQ+KFtyb3dzLCBjb2x1bW5zXSk7XG4gIH1cblxuICBhczNEKHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyLCBkZXB0aDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgcmV0dXJuIHRoaXMucmVzaGFwZTxBcnJheTNEPihbcm93cywgY29sdW1ucywgZGVwdGhdKTtcbiAgfVxuXG4gIGFzNEQocm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIsIGRlcHRoOiBudW1iZXIsIGRlcHRoMjogbnVtYmVyKTogQXJyYXk0RCB7XG4gICAgcmV0dXJuIHRoaXMucmVzaGFwZTxBcnJheTREPihbcm93cywgY29sdW1ucywgZGVwdGgsIGRlcHRoMl0pO1xuICB9XG5cbiAgZ2V0IHJhbmsoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGg7XG4gIH1cblxuICBnZXQoLi4ubG9jczogbnVtYmVyW10pIHtcbiAgICBsZXQgaW5kZXggPSBsb2NzW2xvY3MubGVuZ3RoIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgaW5kZXggKz0gdGhpcy5zdHJpZGVzW2ldICogbG9jc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKClbaW5kZXhdO1xuICB9XG5cbiAgYWRkKHZhbHVlOiBudW1iZXIsIC4uLmxvY3M6IG51bWJlcltdKSB7XG4gICAgdGhpcy5zZXQodGhpcy5nZXQoLi4ubG9jcykgKyB2YWx1ZSwgLi4ubG9jcyk7XG4gIH1cblxuICBzZXQodmFsdWU6IG51bWJlciwgLi4ubG9jczogbnVtYmVyW10pIHtcbiAgICBsZXQgaW5kZXggPSBsb2NzW2xvY3MubGVuZ3RoIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgaW5kZXggKz0gdGhpcy5zdHJpZGVzW2ldICogbG9jc1tpXTtcbiAgICB9XG4gICAgdGhpcy5nZXRWYWx1ZXMoKVtpbmRleF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGxvY1RvSW5kZXgobG9jczogbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGxldCBpbmRleCA9IGxvY3NbbG9jcy5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBpbmRleCArPSB0aGlzLnN0cmlkZXNbaV0gKiBsb2NzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBpbmRleFRvTG9jKGluZGV4OiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgY29uc3QgbG9jczogbnVtYmVyW10gPSBuZXcgQXJyYXkodGhpcy5zaGFwZS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGxvY3NbaV0gPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGVzW2ldKTtcbiAgICAgIGluZGV4IC09IGxvY3NbaV0gKiB0aGlzLnN0cmlkZXNbaV07XG4gICAgfVxuICAgIGxvY3NbbG9jcy5sZW5ndGggLSAxXSA9IGluZGV4O1xuICAgIHJldHVybiBsb2NzO1xuICB9XG5cbiAgZmlsbCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5nZXRWYWx1ZXMoKS5maWxsKHZhbHVlKTtcbiAgfVxuXG4gIGdldERhdGEoKTogTkRBcnJheURhdGEge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cblxuICBnZXRWYWx1ZXMoKTogRmxvYXQzMkFycmF5IHtcbiAgICBpZiAodGhpcy5kYXRhLnZhbHVlcyA9PSBudWxsKSB7XG4gICAgICB0aHJvd0lmR1BVTm90SW5pdGlhbGl6ZWQoKTtcbiAgICAgIHRoaXMuZGF0YS52YWx1ZXMgPSBHUEdQVS5kb3dubG9hZE1hdHJpeEZyb21UZXh0dXJlKFxuICAgICAgICAgIHRoaXMuZGF0YS50ZXh0dXJlISwgdGhpcy5kYXRhLnRleHR1cmVTaGFwZVJDIVswXSxcbiAgICAgICAgICB0aGlzLmRhdGEudGV4dHVyZVNoYXBlUkMhWzFdKTtcbiAgICAgIHRoaXMuZGlzcG9zZVRleHR1cmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGF0YS52YWx1ZXM7XG4gIH1cblxuICBwcml2YXRlIHVwbG9hZFRvR1BVKHByZWZlcnJlZFRleFNoYXBlPzogW251bWJlciwgbnVtYmVyXSkge1xuICAgIHRocm93SWZHUFVOb3RJbml0aWFsaXplZCgpO1xuICAgIHRoaXMuZGF0YS50ZXh0dXJlU2hhcGVSQyA9IHdlYmdsX3V0aWwuZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZShcbiAgICAgICAgR1BHUFUuZ2wsIHRoaXMuc2hhcGUsIHByZWZlcnJlZFRleFNoYXBlKTtcbiAgICB0aGlzLmRhdGEudGV4dHVyZSA9XG4gICAgICAgIFRFWFRVUkVfTUFOQUdFUi5hY3F1aXJlVGV4dHVyZSh0aGlzLmRhdGEudGV4dHVyZVNoYXBlUkMpO1xuXG4gICAgR1BHUFUudXBsb2FkTWF0cml4VG9UZXh0dXJlKFxuICAgICAgICB0aGlzLmRhdGEudGV4dHVyZSwgdGhpcy5kYXRhLnRleHR1cmVTaGFwZVJDWzBdLFxuICAgICAgICB0aGlzLmRhdGEudGV4dHVyZVNoYXBlUkNbMV0sIHRoaXMuZGF0YS52YWx1ZXMhKTtcblxuICAgIHRoaXMuZGF0YS52YWx1ZXMgPSBudWxsITtcbiAgfVxuXG4gIGdldFRleHR1cmUocHJlZmVycmVkU2hhcGVSQz86IFtudW1iZXIsIG51bWJlcl0pOiBXZWJHTFRleHR1cmUge1xuICAgIGlmICh0aGlzLmRhdGEudGV4dHVyZSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVwbG9hZFRvR1BVKHByZWZlcnJlZFNoYXBlUkMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhLnRleHR1cmUhO1xuICB9XG5cbiAgZ2V0VGV4dHVyZVNoYXBlUkMocHJlZmVycmVkU2hhcGVSQz86IFtudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICBpZiAodGhpcy5kYXRhLnRleHR1cmVTaGFwZVJDID09IG51bGwpIHtcbiAgICAgIHRoaXMudXBsb2FkVG9HUFUocHJlZmVycmVkU2hhcGVSQyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhdGEudGV4dHVyZVNoYXBlUkMhO1xuICB9XG5cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmRhdGEudmFsdWVzID0gbnVsbCE7XG4gICAgdGhpcy5zaGFwZSA9IG51bGwhO1xuICAgIGlmICh0aGlzLmRhdGEudGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VUZXh0dXJlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkaXNwb3NlVGV4dHVyZSgpIHtcbiAgICB0aHJvd0lmR1BVTm90SW5pdGlhbGl6ZWQoKTtcbiAgICBURVhUVVJFX01BTkFHRVIucmVsZWFzZVRleHR1cmUoXG4gICAgICAgIHRoaXMuZGF0YS50ZXh0dXJlISwgdGhpcy5kYXRhLnRleHR1cmVTaGFwZVJDISk7XG4gICAgdGhpcy5kYXRhLnRleHR1cmUgPSBudWxsITtcbiAgICB0aGlzLmRhdGEudGV4dHVyZVNoYXBlUkMgPSBudWxsITtcbiAgfVxuXG4gIGluR1BVKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmRhdGEudGV4dHVyZSAhPSBudWxsO1xuICB9XG5cbiAgZXF1YWxzKHQ6IE5EQXJyYXkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheXNFcXVhbCh0aGlzLnNoYXBlLCB0LnNoYXBlKSAmJlxuICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMuZ2V0VmFsdWVzKCksIHQuZ2V0VmFsdWVzKCkpO1xuICB9XG5cbiAgc3RhdGljIHJhbmQ8VCBleHRlbmRzIE5EQXJyYXk+KHNoYXBlOiBudW1iZXJbXSwgcmFuZEZ1bmN0aW9uOiAoKSA9PiBudW1iZXIpOlxuICAgICAgVCB7XG4gICAgY29uc3Qgc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgY29uc3QgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gcmFuZEZ1bmN0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihzaGFwZSwge3ZhbHVlc30pO1xuICB9XG5cbiAgc3RhdGljIHJhbmROb3JtYWw8VCBleHRlbmRzIE5EQXJyYXk+KHNoYXBlOiBudW1iZXJbXSwgbWVhbiA9IDAsIHN0ZERldiA9IDEpIHtcbiAgICByZXR1cm4gTkRBcnJheS5yYW5kPFQ+KHNoYXBlLCAoKSA9PiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYpKTtcbiAgfVxuXG4gIHN0YXRpYyByYW5kVHJ1bmNhdGVkTm9ybWFsPFQgZXh0ZW5kcyBOREFycmF5PihcbiAgICAgIHNoYXBlOiBudW1iZXJbXSwgbWVhbiA9IDAsIHN0ZERldiA9IDEpIHtcbiAgICByZXR1cm4gTkRBcnJheS5yYW5kPFQ+KHNoYXBlLCAoKSA9PiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIHRydWUpKTtcbiAgfVxuXG4gIHN0YXRpYyByYW5kVW5pZm9ybTxUIGV4dGVuZHMgTkRBcnJheT4oc2hhcGU6IG51bWJlcltdLCBhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICAgIHJldHVybiBOREFycmF5LnJhbmQ8VD4oc2hhcGUsICgpID0+IHV0aWwucmFuZFVuaWZvcm0oYSwgYikpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTY2FsYXIgZXh0ZW5kcyBOREFycmF5IHtcbiAgY29uc3RydWN0b3IoZGF0YTogTkRBcnJheURhdGEpIHtcbiAgICBpZiAoZGF0YS50ZXh0dXJlICE9IG51bGwpIHtcbiAgICAgIGRhdGEudGV4dHVyZVNoYXBlUkMgPSBbMSwgMV07XG4gICAgfVxuICAgIHN1cGVyKFtdLCBkYXRhKTtcbiAgfVxuXG4gIHN0YXRpYyBuZXcodmFsdWU6IG51bWJlcikge1xuICAgIHJldHVybiBuZXcgU2NhbGFyKHt2YWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkoW3ZhbHVlXSl9KTtcbiAgfVxuXG4gIHN0YXRpYyBaRVJPID0gU2NhbGFyLm5ldygwKTtcbiAgc3RhdGljIE9ORSA9IFNjYWxhci5uZXcoMSk7XG4gIHN0YXRpYyBUV08gPSBTY2FsYXIubmV3KDIpO1xuICBzdGF0aWMgTkVHX09ORSA9IFNjYWxhci5uZXcoLTEpO1xuXG4gIGdldCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygpWzBdO1xuICB9XG5cbiAgc2V0KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmdldFZhbHVlcygpWzBdID0gdmFsdWU7XG4gIH1cblxuICBhZGQodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZ2V0VmFsdWVzKClbMF0gKz0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFycmF5MUQgZXh0ZW5kcyBOREFycmF5IHtcbiAgc2hhcGU6IFtudW1iZXJdO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE6IE5EQXJyYXlEYXRhKSB7XG4gICAgY29uc3Qgc2hhcGUgPSAoZGF0YS52YWx1ZXMgIT0gbnVsbCkgP1xuICAgICAgICBbZGF0YS52YWx1ZXMubGVuZ3RoXSA6XG4gICAgICAgIFt1dGlsLnNpemVGcm9tU2hhcGUoZGF0YS50ZXh0dXJlU2hhcGVSQyEpXTtcbiAgICBzdXBlcihzaGFwZSwgZGF0YSk7XG4gIH1cblxuICBzdGF0aWMgbmV3KHZhbHVlczogRmxvYXQzMkFycmF5fG51bWJlcltdKSB7XG4gICAgaWYgKCEodmFsdWVzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkge1xuICAgICAgY29uc3QgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgaW5mZXJyZWRTaGFwZS5sZW5ndGggPT09IDEsXG4gICAgICAgICAgYEVycm9yIGNvbnN0cnVjdGluZyBBcnJheTFELiBTaGFwZSBvZiB2YWx1ZXMgJHtpbmZlcnJlZFNoYXBlfSBpcyBgICtcbiAgICAgICAgICAgICAgYG5vdCAxIGRpbWVuc2lvbmFsLmApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5MUQoe3ZhbHVlczogdG9UeXBlZEFycmF5KHZhbHVlcyl9KTtcbiAgfVxuXG4gIGdldChpOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygpW2ldO1xuICB9XG5cbiAgc2V0KHZhbHVlOiBudW1iZXIsIGk6IG51bWJlcikge1xuICAgIHRoaXMuZ2V0VmFsdWVzKClbaV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGFkZCh2YWx1ZTogbnVtYmVyLCBpOiBudW1iZXIpIHtcbiAgICB0aGlzLmdldFZhbHVlcygpW2ldICs9IHZhbHVlO1xuICB9XG5cbiAgbG9jVG9JbmRleChsb2M6IFtudW1iZXJdKTogbnVtYmVyIHtcbiAgICByZXR1cm4gbG9jWzBdO1xuICB9XG5cbiAgaW5kZXhUb0xvYyhpbmRleDogbnVtYmVyKTogW251bWJlcl0ge1xuICAgIHJldHVybiBbaW5kZXhdO1xuICB9XG5cbiAgc3RhdGljIHplcm9zKHNoYXBlOiBbbnVtYmVyXSk6IEFycmF5MUQge1xuICAgIHJldHVybiBOREFycmF5Lnplcm9zKHNoYXBlKSBhcyBBcnJheTFEO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBcnJheTJEIGV4dGVuZHMgTkRBcnJheSB7XG4gIHNoYXBlOiBbbnVtYmVyLCBudW1iZXJdO1xuXG4gIHByaXZhdGUgc3RyaWRlMDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHNoYXBlOiBbbnVtYmVyLCBudW1iZXJdLCBkYXRhOiBOREFycmF5RGF0YSkge1xuICAgIHV0aWwuYXNzZXJ0KHNoYXBlLmxlbmd0aCA9PT0gMiwgJ1NoYXBlIHNob3VsZCBiZSBvZiBsZW5ndGggMicpO1xuICAgIHN1cGVyKHNoYXBlLCBkYXRhKTtcbiAgICB0aGlzLnN0cmlkZTAgPSB0aGlzLnN0cmlkZXNbMF07XG4gIH1cblxuICBzdGF0aWMgbmV3KFxuICAgICAgc2hhcGU6IFtudW1iZXIsIG51bWJlcl0sIHZhbHVlczogRmxvYXQzMkFycmF5fG51bWJlcltdfG51bWJlcltdW10pIHtcbiAgICBpZiAoISh2YWx1ZXMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICBjb25zdCBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goXG4gICAgICAgICAgICBzaGFwZSwgaW5mZXJyZWRTaGFwZSxcbiAgICAgICAgICAgIGBFcnJvciB3aGVuIGNvbnN0cnVjdGluZyBBcnJheTJELiBTaGFwZSBvZiB2YWx1ZXMgYCArXG4gICAgICAgICAgICAgICAgYCR7aW5mZXJyZWRTaGFwZX0gZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHNoYXBlIGAgK1xuICAgICAgICAgICAgICAgIGAke3NoYXBlfS4gYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXkyRChzaGFwZSwge3ZhbHVlczogdG9UeXBlZEFycmF5KHZhbHVlcyl9KTtcbiAgfVxuXG4gIGdldChpOiBudW1iZXIsIGo6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyBqXTtcbiAgfVxuXG4gIHNldCh2YWx1ZTogbnVtYmVyLCBpOiBudW1iZXIsIGo6IG51bWJlcikge1xuICAgIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIGpdID0gdmFsdWU7XG4gIH1cblxuICBhZGQodmFsdWU6IG51bWJlciwgaTogbnVtYmVyLCBqOiBudW1iZXIpIHtcbiAgICB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyBqXSArPSB2YWx1ZTtcbiAgfVxuXG4gIGxvY1RvSW5kZXgobG9jczogW251bWJlciwgbnVtYmVyXSk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaWRlMCAqIGxvY3NbMF0gKyBsb2NzWzFdO1xuICB9XG5cbiAgaW5kZXhUb0xvYyhpbmRleDogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgcmV0dXJuIFtNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGUwKSwgaW5kZXggJSB0aGlzLnN0cmlkZTBdO1xuICB9XG5cbiAgc3RhdGljIHplcm9zKHNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogQXJyYXkyRCB7XG4gICAgcmV0dXJuIE5EQXJyYXkuemVyb3Moc2hhcGUpIGFzIEFycmF5MkQ7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFycmF5M0QgZXh0ZW5kcyBOREFycmF5IHtcbiAgc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgcHJpdmF0ZSBzdHJpZGUwOiBudW1iZXI7XG4gIHByaXZhdGUgc3RyaWRlMTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGRhdGE6IE5EQXJyYXlEYXRhKSB7XG4gICAgdXRpbC5hc3NlcnQoc2hhcGUubGVuZ3RoID09PSAzLCAnU2hhcGUgc2hvdWxkIGJlIG9mIGxlbmd0aCAzJyk7XG4gICAgc3VwZXIoc2hhcGUsIGRhdGEpO1xuICAgIHRoaXMuc3RyaWRlMCA9IHRoaXMuc3RyaWRlc1swXTtcbiAgICB0aGlzLnN0cmlkZTEgPSB0aGlzLnN0cmlkZXNbMV07XG4gIH1cblxuICBzdGF0aWMgbmV3KFxuICAgICAgc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgIHZhbHVlczogRmxvYXQzMkFycmF5fG51bWJlcltdfG51bWJlcltdW11bXSkge1xuICAgIGlmICghKHZhbHVlcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHtcbiAgICAgIGNvbnN0IGluZmVycmVkU2hhcGUgPSB1dGlsLmluZmVyU2hhcGUodmFsdWVzKTtcbiAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChcbiAgICAgICAgICAgIHNoYXBlLCBpbmZlcnJlZFNoYXBlLFxuICAgICAgICAgICAgYEVycm9yIHdoZW4gY29uc3RydWN0aW5nIEFycmF5M0QuIFNoYXBlIG9mIHZhbHVlcyBgICtcbiAgICAgICAgICAgICAgICBgJHtpbmZlcnJlZFNoYXBlfSBkb2VzIG5vdCBtYXRjaCB0aGUgcHJvdmlkZWQgc2hhcGUgYCArXG4gICAgICAgICAgICAgICAgYCR7c2hhcGV9LiBgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheTNEKHNoYXBlLCB7dmFsdWVzOiB0b1R5cGVkQXJyYXkodmFsdWVzKX0pO1xuICB9XG5cbiAgZ2V0KGk6IG51bWJlciwgajogbnVtYmVyLCBrOiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgdGhpcy5zdHJpZGUxICogaiArIGtdO1xuICB9XG5cbiAgc2V0KHZhbHVlOiBudW1iZXIsIGk6IG51bWJlciwgajogbnVtYmVyLCBrOiBudW1iZXIpIHtcbiAgICB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyB0aGlzLnN0cmlkZTEgKiBqICsga10gPSB2YWx1ZTtcbiAgfVxuXG4gIGFkZCh2YWx1ZTogbnVtYmVyLCBpOiBudW1iZXIsIGo6IG51bWJlciwgazogbnVtYmVyKSB7XG4gICAgdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgdGhpcy5zdHJpZGUxICogaiArIGtdICs9IHZhbHVlO1xuICB9XG5cbiAgbG9jVG9JbmRleChsb2NzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnN0cmlkZTAgKiBsb2NzWzBdICsgdGhpcy5zdHJpZGUxICogbG9jc1sxXSArIGxvY3NbMl07XG4gIH1cblxuICBpbmRleFRvTG9jKGluZGV4OiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGUwKTtcbiAgICBpbmRleCAtPSBpICogdGhpcy5zdHJpZGUwO1xuICAgIHJldHVybiBbaSwgTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMSksIGluZGV4ICUgdGhpcy5zdHJpZGUxXTtcbiAgfVxuXG4gIHN0YXRpYyB6ZXJvcyhzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogQXJyYXkzRCB7XG4gICAgcmV0dXJuIE5EQXJyYXkuemVyb3Moc2hhcGUpIGFzIEFycmF5M0Q7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFycmF5NEQgZXh0ZW5kcyBOREFycmF5IHtcbiAgc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBwcml2YXRlIHN0cmlkZTA6IG51bWJlcjtcbiAgcHJpdmF0ZSBzdHJpZGUxOiBudW1iZXI7XG4gIHByaXZhdGUgc3RyaWRlMjogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZGF0YTogTkRBcnJheURhdGEpIHtcbiAgICB1dGlsLmFzc2VydChzaGFwZS5sZW5ndGggPT09IDQsICdTaGFwZSBzaG91bGQgYmUgb2YgbGVuZ3RoIDQnKTtcbiAgICBzdXBlcihzaGFwZSwgZGF0YSk7XG4gICAgdGhpcy5zdHJpZGUwID0gdGhpcy5zdHJpZGVzWzBdO1xuICAgIHRoaXMuc3RyaWRlMSA9IHRoaXMuc3RyaWRlc1sxXTtcbiAgICB0aGlzLnN0cmlkZTIgPSB0aGlzLnN0cmlkZXNbMl07XG4gIH1cblxuICBzdGF0aWMgbmV3KFxuICAgICAgc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgdmFsdWVzOiBGbG9hdDMyQXJyYXl8bnVtYmVyW118bnVtYmVyW11bXVtdW10pIHtcbiAgICBpZiAoISh2YWx1ZXMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICBjb25zdCBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goXG4gICAgICAgICAgICBzaGFwZSwgaW5mZXJyZWRTaGFwZSxcbiAgICAgICAgICAgIGBFcnJvciB3aGVuIGNvbnN0cnVjdGluZyBBcnJheTRELiBTaGFwZSBvZiB2YWx1ZXMgYCArXG4gICAgICAgICAgICAgICAgYCR7aW5mZXJyZWRTaGFwZX0gZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHNoYXBlIGAgK1xuICAgICAgICAgICAgICAgIGAke3NoYXBlfS4gYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXk0RChzaGFwZSwge3ZhbHVlczogdG9UeXBlZEFycmF5KHZhbHVlcyl9KTtcbiAgfVxuXG4gIGdldChpOiBudW1iZXIsIGo6IG51bWJlciwgazogbnVtYmVyLCBsOiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoKVxuICAgICAgICBbdGhpcy5zdHJpZGUwICogaSArIHRoaXMuc3RyaWRlMSAqIGogKyB0aGlzLnN0cmlkZTIgKiBrICsgbF07XG4gIH1cblxuICBzZXQodmFsdWU6IG51bWJlciwgaTogbnVtYmVyLCBqOiBudW1iZXIsIGs6IG51bWJlciwgbDogbnVtYmVyKSB7XG4gICAgdGhpcy5nZXRWYWx1ZXMoKVxuICAgICAgICBbdGhpcy5zdHJpZGUwICogaSArIHRoaXMuc3RyaWRlMSAqIGogKyB0aGlzLnN0cmlkZTIgKiBrICsgbF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGFkZCh2YWx1ZTogbnVtYmVyLCBpOiBudW1iZXIsIGo6IG51bWJlciwgazogbnVtYmVyLCBsOiBudW1iZXIpIHtcbiAgICB0aGlzLmdldFZhbHVlcygpXG4gICAgICAgIFt0aGlzLnN0cmlkZTAgKiBpICsgdGhpcy5zdHJpZGUxICogaiArIHRoaXMuc3RyaWRlMiAqIGsgKyBsXSArPSB2YWx1ZTtcbiAgfVxuXG4gIGxvY1RvSW5kZXgobG9jczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnN0cmlkZTAgKiBsb2NzWzBdICsgdGhpcy5zdHJpZGUxICogbG9jc1sxXSArXG4gICAgICAgIHRoaXMuc3RyaWRlMiAqIGxvY3NbMl0gKyBsb2NzWzNdO1xuICB9XG5cbiAgaW5kZXhUb0xvYyhpbmRleDogbnVtYmVyKTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGUwKTtcbiAgICBpbmRleCAtPSBpICogdGhpcy5zdHJpZGUwO1xuICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGUxKTtcbiAgICBpbmRleCAtPSBqICogdGhpcy5zdHJpZGUxO1xuICAgIHJldHVybiBbaSwgaiwgTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMiksIGluZGV4ICUgdGhpcy5zdHJpZGUyXTtcbiAgfVxuXG4gIHN0YXRpYyB6ZXJvcyhzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBBcnJheTREIHtcbiAgICByZXR1cm4gTkRBcnJheS56ZXJvcyhzaGFwZSkgYXMgQXJyYXk0RDtcbiAgfVxufVxuXG50eXBlIEFycmF5RGF0YSA9IEZsb2F0MzJBcnJheXxudW1iZXJbXXxudW1iZXJbXVtdfG51bWJlcltdW11bXXxudW1iZXJbXVtdW11bXTtcblxuZnVuY3Rpb24gdG9UeXBlZEFycmF5KGE6IEFycmF5RGF0YSk6IEZsb2F0MzJBcnJheSB7XG4gIHJldHVybiAoYSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkgPyBhIDogbmV3IEZsb2F0MzJBcnJheSh1dGlsLmZsYXR0ZW4oYSkpO1xufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi9ncGdwdV9jb250ZXh0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XG4gIHJldHVybiBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIG1hdHJpeEE7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgbWF0cml4QjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBtYXRyaXhBU2NhbGFyO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIG1hdHJpeEJTY2FsYXI7XG4gICAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xuXG4gICAgY29uc3QgdmVjMiBoYWxmVGV4ZWwgPSB2ZWMyKDAuNSwgMC41KTtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIGZsb2F0IGEgPSB0ZXh0dXJlMkQobWF0cml4QSwgcmVzdWx0VVYpLnI7XG4gICAgICBmbG9hdCBiID0gdGV4dHVyZTJEKG1hdHJpeEIsIHJlc3VsdFVWKS5yO1xuICAgICAgZmxvYXQgYVNjYWxhciA9IHRleHR1cmUyRChtYXRyaXhBU2NhbGFyLCBoYWxmVGV4ZWwpLnI7XG4gICAgICBmbG9hdCBiU2NhbGFyID0gdGV4dHVyZTJEKG1hdHJpeEJTY2FsYXIsIGhhbGZUZXhlbCkucjtcbiAgICAgIHZlYzIgYWJTY2FsZWQgPSB2ZWMyKGEsIGIpICogdmVjMihhU2NhbGFyLCBiU2NhbGFyKTtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoYWJTY2FsZWQueCArIGFiU2NhbGVkLnksIDAsIDAsIDApO1xuICAgIH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkU2NhbGVkTWF0cmljZXMoXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgYWRkU2NhbGVkTWF0cmljZXNQcm9ncmFtOiBXZWJHTFByb2dyYW0sXG4gICAgYTogV2ViR0xUZXh0dXJlLCBiOiBXZWJHTFRleHR1cmUsIHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyLFxuICAgIGFTY2FsYXI6IFdlYkdMVGV4dHVyZSwgYlNjYWxhcjogV2ViR0xUZXh0dXJlLCByZXN1bHQ6IFdlYkdMVGV4dHVyZSkge1xuICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKHJlc3VsdCwgcm93cywgY29sdW1ucyk7XG4gIGdwZ3B1LnNldFByb2dyYW0oYWRkU2NhbGVkTWF0cmljZXNQcm9ncmFtKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKGEsICdtYXRyaXhBJywgMCk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShiLCAnbWF0cml4QicsIDEpO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUoYVNjYWxhciwgJ21hdHJpeEFTY2FsYXInLCAyKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKGJTY2FsYXIsICdtYXRyaXhCU2NhbGFyJywgMyk7XG4gIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRBZGRTY2FsZWRNYXRyaWNlc0Rvd25sb2FkKFxuICAgIGE6IEZsb2F0MzJBcnJheSwgYjogRmxvYXQzMkFycmF5LCByb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlcixcbiAgICBhU2NhbGFyOiBudW1iZXIsIGJTY2FsYXI6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XG4gIGNvbnN0IGdwZ3B1ID0gbmV3IEdQR1BVQ29udGV4dCgpO1xuICBjb25zdCBwcm9ncmFtOiBXZWJHTFByb2dyYW0gPSBncGdwdS5jcmVhdGVQcm9ncmFtKGdldEZyYWdtZW50U2hhZGVyU291cmNlKCkpO1xuXG4gIGNvbnN0IGFUZXggPSBncGdwdS5jcmVhdGVNYXRyaXhUZXh0dXJlKHJvd3MsIGNvbHVtbnMpO1xuICBjb25zdCBiVGV4ID0gZ3BncHUuY3JlYXRlTWF0cml4VGV4dHVyZShyb3dzLCBjb2x1bW5zKTtcbiAgY29uc3QgYVNjYWxhclRleCA9IGdwZ3B1LmNyZWF0ZU1hdHJpeFRleHR1cmUoMSwgMSk7XG4gIGNvbnN0IGJTY2FsYXJUZXggPSBncGdwdS5jcmVhdGVNYXRyaXhUZXh0dXJlKDEsIDEpO1xuICBjb25zdCByZXN1bHRUZXggPSBncGdwdS5jcmVhdGVNYXRyaXhUZXh0dXJlKHJvd3MsIGNvbHVtbnMpO1xuXG4gIGdwZ3B1LnVwbG9hZE1hdHJpeFRvVGV4dHVyZShhVGV4LCByb3dzLCBjb2x1bW5zLCBhKTtcbiAgZ3BncHUudXBsb2FkTWF0cml4VG9UZXh0dXJlKGJUZXgsIHJvd3MsIGNvbHVtbnMsIGIpO1xuICBncGdwdS51cGxvYWRNYXRyaXhUb1RleHR1cmUoYVNjYWxhclRleCwgMSwgMSwgbmV3IEZsb2F0MzJBcnJheShbYVNjYWxhcl0pKTtcbiAgZ3BncHUudXBsb2FkTWF0cml4VG9UZXh0dXJlKGJTY2FsYXJUZXgsIDEsIDEsIG5ldyBGbG9hdDMyQXJyYXkoW2JTY2FsYXJdKSk7XG5cbiAgYWRkU2NhbGVkTWF0cmljZXMoXG4gICAgICBncGdwdSwgcHJvZ3JhbSwgYVRleCwgYlRleCwgcm93cywgY29sdW1ucywgYVNjYWxhclRleCwgYlNjYWxhclRleCxcbiAgICAgIHJlc3VsdFRleCk7XG5cbiAgY29uc3QgcmVzdWx0ID0gZ3BncHUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZShyZXN1bHRUZXgsIHJvd3MsIGNvbHVtbnMpO1xuXG4gIGdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUoYVRleCk7XG4gIGdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUoYlRleCk7XG4gIGdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUocmVzdWx0VGV4KTtcbiAgZ3BncHUuZGVsZXRlTWF0cml4VGV4dHVyZShhU2NhbGFyVGV4KTtcbiAgZ3BncHUuZGVsZXRlTWF0cml4VGV4dHVyZShiU2NhbGFyVGV4KTtcbiAgZ3BncHUuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgZ3BncHUuZGlzcG9zZSgpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIGFyZ21pbm1heF9ncHUgZnJvbSAnLi9hcmdtaW5tYXhfZ3B1JztcbmltcG9ydCB7R1BHUFVQcm9ncmFtfSBmcm9tICcuL2dwZ3B1X21hdGgnO1xuXG5leHBvcnQgY2xhc3MgQXJnTWF4RXF1YWxzUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ0EnLCAnQiddO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgcGFyYW1zOiBBcnJheTx7fT4gPSBbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihhU2l6ZTogbnVtYmVyLCBiU2l6ZTogbnVtYmVyKSB7XG4gICAgY29uc3QgYVNuaXBwZXQgPSBhcmdtaW5tYXhfZ3B1LmdldEFyZ01pbk1heFNuaXBwZXQoJ21heCcsICdBJywgYVNpemUpO1xuICAgIGNvbnN0IGJTbmlwcGV0ID0gYXJnbWlubWF4X2dwdS5nZXRBcmdNaW5NYXhTbmlwcGV0KCdtYXgnLCAnQicsIGJTaXplKTtcbiAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgJHthU25pcHBldH1cbiAgICAgICR7YlNuaXBwZXR9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZmxvYXQgYXJnTWF4QSA9IGdldEFyZ01pbk1heEEoKTtcbiAgICAgICAgZmxvYXQgYXJnTWF4QiA9IGdldEFyZ01pbk1heEIoKTtcblxuICAgICAgICBmbG9hdCB2YWx1ZTtcbiAgICAgICAgaWYgKGlzTmFOKGFyZ01heEEpKSB7XG4gICAgICAgICAgdmFsdWUgPSBhcmdNYXhBO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKGFyZ01heEIpKSB7XG4gICAgICAgICAgdmFsdWUgPSBhcmdNYXhCO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gZmxvYXQoYXJnTWF4QSA9PSBhcmdNYXhCKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0dQR1BVUHJvZ3JhbX0gZnJvbSAnLi9ncGdwdV9tYXRoJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFyZ01pbk1heFNuaXBwZXQob3A6ICdtaW4nfCdtYXgnLCB0ZXhOYW1lOiBzdHJpbmcsXG4gICAgc2l6ZTogbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3QgY29tcE9wID0gKG9wID09PSAnbWluJykgPyAnPCcgOiAnPic7XG4gIHJldHVybiBgXG4gICAgZmxvYXQgZ2V0QXJnTWluTWF4JHt0ZXhOYW1lfSgpIHtcbiAgICAgIGZsb2F0IGJlc3RJbmRleCA9IDAuMDtcbiAgICAgIGZsb2F0IGJlc3RWYWx1ZSA9IGdldCR7dGV4TmFtZX1GbGF0KDAuMCk7XG5cbiAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtzaXplfTsgaSsrKSB7XG4gICAgICAgIGZsb2F0IGlfZmxvYXQgPSBmbG9hdChpKTtcbiAgICAgICAgZmxvYXQgY2FuZGlkYXRlID0gZ2V0JHt0ZXhOYW1lfUZsYXQoaV9mbG9hdCk7XG4gICAgICAgIGlmIChpc05hTihjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuZGlkYXRlICR7Y29tcE9wfSBiZXN0VmFsdWUpIHtcbiAgICAgICAgICBiZXN0VmFsdWUgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgYmVzdEluZGV4ID0gaV9mbG9hdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJlc3RJbmRleDtcbiAgICB9XG4gIGA7XG59XG5cbmV4cG9ydCBjbGFzcyBBcmdNaW5NYXhQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgcGFyYW1zOiBBcnJheTx7fT47XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoYVNpemU6IG51bWJlciwgb3BUeXBlOiAnbWluJ3wnbWF4Jykge1xuICAgIHRoaXMucGFyYW1zID0gW29wVHlwZV07XG4gICAgY29uc3QgYVNuaXBwZXQgPSBnZXRBcmdNaW5NYXhTbmlwcGV0KG9wVHlwZSwgJ0EnLCBhU2l6ZSk7XG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgICR7YVNuaXBwZXR9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgc2V0T3V0cHV0KGdldEFyZ01pbk1heEEoKSk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi9ncGdwdV9jb250ZXh0JztcbmltcG9ydCAqIGFzIHBvb2xfZ3B1IGZyb20gJy4vcG9vbF9ncHUnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJBdmdQb29sU291cmNlKFxuICAgIHhTaGFwZVJDRDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlcixcbiAgICBwYWQ6IG51bWJlcikge1xuICByZXR1cm4gcG9vbF9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJQb29sQ29tbW9uU291cmNlKFxuICAgICAgeFNoYXBlUkNELCBmU2l6ZSwgc3RyaWRlLCBwYWQsICdhdmcnLCBmYWxzZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdmdQb29sKFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgeDogV2ViR0xUZXh0dXJlLFxuICAgIHJlc3VsdDogV2ViR0xUZXh0dXJlLCByZXN1bHRTaGFwZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSkge1xuICBwb29sX2dwdS5wb29sQ29tbW9uKGdwZ3B1LCBwcm9ncmFtLCB4LCByZXN1bHQsIHJlc3VsdFNoYXBlUm93Q29sKTtcbn0iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL2dwZ3B1X2NvbnRleHQnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoXG4gICAgeFRleFNoYXBlUkM6IFtudW1iZXIsIG51bWJlcl0sIG1lYW5UZXhTaGFwZVJDOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgIHZhcmlhbmNlVGV4U2hhcGVSQzogW251bWJlciwgbnVtYmVyXSxcbiAgICBvZmZzZXRUZXhTaGFwZVJDOiBbbnVtYmVyLCBudW1iZXJdfG51bGwsXG4gICAgc2NhbGVUZXhTaGFwZVJDPzogW251bWJlciwgbnVtYmVyXXxudWxsLCB2YXJpYW5jZUVwc2lsb24gPSAwLjAwMSk6IHN0cmluZyB7XG4gIGxldCBvZmZzZXRTYW1wbGVyU25pcHBldCA9ICcnO1xuICBsZXQgb2Zmc2V0U2hhcGVJbml0aWFsaXphdGlvblNuaXBwZXQgPSAnJztcbiAgbGV0IG9mZnNldENvb3Jkc1NuaXBwZXQgPSAnJztcbiAgbGV0IG9mZnNldFVWU25pcHBldCA9ICcnO1xuICBsZXQgb2Zmc2V0VmFsdWVTbmlwcGV0ID0gJyc7XG4gIGxldCBvZmZzZXRPcGVyYXRpb25TbmlwcGV0ID0gJzAuMCc7XG5cbiAgbGV0IHNjYWxlU2FtcGxlclNuaXBwZXQgPSAnJztcbiAgbGV0IHNjYWxlU2hhcGVJbml0aWFsaXphdGlvblNuaXBwZXQgPSAnJztcbiAgbGV0IHNjYWxlQ29vcmRzU25pcHBldCA9ICcnO1xuICBsZXQgc2NhbGVVVlNuaXBwZXQgPSAnJztcbiAgbGV0IHNjYWxlVmFsdWVTbmlwcGV0ID0gJyc7XG4gIGxldCBzY2FsZU9wZXJhdGlvblNuaXBwZXQgPSAnJztcblxuICBpZiAob2Zmc2V0VGV4U2hhcGVSQyAhPSBudWxsKSB7XG4gICAgb2Zmc2V0U2FtcGxlclNuaXBwZXQgPSAndW5pZm9ybSBzYW1wbGVyMkQgb2Zmc2V0Oyc7XG4gICAgb2Zmc2V0U2hhcGVJbml0aWFsaXphdGlvblNuaXBwZXQgPSBgY29uc3QgdmVjMiBvZmZzZXRTaGFwZUNSID0gdmVjMihcbiAgICAgICAgICAgICR7b2Zmc2V0VGV4U2hhcGVSQ1sxXX0sICR7b2Zmc2V0VGV4U2hhcGVSQ1swXX0pO2A7XG4gICAgb2Zmc2V0Q29vcmRzU25pcHBldCA9ICd2ZWMyIG9mZnNldENvb3Jkc0NSID0gbW9kKHlUZXhDUiwgb2Zmc2V0U2hhcGVDUik7JztcbiAgICBvZmZzZXRVVlNuaXBwZXQgPVxuICAgICAgICAndmVjMiBvZmZzZXRVViA9IChvZmZzZXRDb29yZHNDUiArIGhhbGZDUikgLyBvZmZzZXRTaGFwZUNSOyc7XG4gICAgb2Zmc2V0VmFsdWVTbmlwcGV0ID0gJ2Zsb2F0IG9mZnNldFZhbHVlID0gdGV4dHVyZTJEKG9mZnNldCwgb2Zmc2V0VVYpLnI7JztcbiAgICBvZmZzZXRPcGVyYXRpb25TbmlwcGV0ID0gJ29mZnNldFZhbHVlJztcbiAgfVxuXG4gIGlmIChzY2FsZVRleFNoYXBlUkMgIT0gbnVsbCkge1xuICAgIHNjYWxlU2FtcGxlclNuaXBwZXQgPSAndW5pZm9ybSBzYW1wbGVyMkQgc2NhbGU7JztcbiAgICBzY2FsZVNoYXBlSW5pdGlhbGl6YXRpb25TbmlwcGV0ID0gYGNvbnN0IHZlYzIgc2NhbGVTaGFwZUNSID0gdmVjMihcbiAgICAgICAgICAgICR7c2NhbGVUZXhTaGFwZVJDWzFdfSwgJHtzY2FsZVRleFNoYXBlUkNbMF19KTtgO1xuICAgIHNjYWxlQ29vcmRzU25pcHBldCA9ICd2ZWMyIHNjYWxlQ29vcmRzQ1IgPSBtb2QoeVRleENSLCBzY2FsZVNoYXBlQ1IpOyc7XG4gICAgc2NhbGVVVlNuaXBwZXQgPSAndmVjMiBzY2FsZVVWID0gKHNjYWxlQ29vcmRzQ1IgKyBoYWxmQ1IpIC8gc2NhbGVTaGFwZUNSOyc7XG4gICAgc2NhbGVWYWx1ZVNuaXBwZXQgPSAnZmxvYXQgc2NhbGVWYWx1ZSA9IHRleHR1cmUyRChzY2FsZSwgc2NhbGVVVikucjsnO1xuICAgIHNjYWxlT3BlcmF0aW9uU25pcHBldCA9ICdpbnYgKj0gc2NhbGVWYWx1ZTsnO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgeDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBtZWFuO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHZhcmlhbmNlO1xuICAgICR7b2Zmc2V0U2FtcGxlclNuaXBwZXR9XG4gICAgJHtzY2FsZVNhbXBsZXJTbmlwcGV0fVxuXG4gICAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xuXG4gICAgY29uc3QgdmVjMiB4U2hhcGVDUiA9IHZlYzIoJHt4VGV4U2hhcGVSQ1sxXX0sICR7eFRleFNoYXBlUkNbMF19KTtcbiAgICBjb25zdCB2ZWMyIG1lYW5TaGFwZUNSID0gdmVjMigke21lYW5UZXhTaGFwZVJDWzFdfSwgJHttZWFuVGV4U2hhcGVSQ1swXX0pO1xuICAgIGNvbnN0IHZlYzIgdmFyaWFuY2VTaGFwZUNSID0gdmVjMihcbiAgICAgICAgJHt2YXJpYW5jZVRleFNoYXBlUkNbMV19LCAke3ZhcmlhbmNlVGV4U2hhcGVSQ1swXX0pO1xuXG4gICAgJHtvZmZzZXRTaGFwZUluaXRpYWxpemF0aW9uU25pcHBldH1cbiAgICAke3NjYWxlU2hhcGVJbml0aWFsaXphdGlvblNuaXBwZXR9XG5cbiAgICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xuICAgIGNvbnN0IGZsb2F0IHZhcmlhbmNlRXBzaWxvbiA9ICR7dmFyaWFuY2VFcHNpbG9ufTtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzIgeVRleENSID0gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnh5KTtcblxuICAgICAgdmVjMiBtZWFuQ29vcmRzQ1IgPSBtb2QoeVRleENSLCBtZWFuU2hhcGVDUik7XG4gICAgICB2ZWMyIHZhcmlhbmNlQ29vcmRzQ1IgPSBtb2QoeVRleENSLCB2YXJpYW5jZVNoYXBlQ1IpO1xuICAgICAgJHtvZmZzZXRDb29yZHNTbmlwcGV0fVxuICAgICAgJHtzY2FsZUNvb3Jkc1NuaXBwZXR9XG5cbiAgICAgIHZlYzIgbWVhblVWID0gKG1lYW5Db29yZHNDUiArIGhhbGZDUikgLyBtZWFuU2hhcGVDUjtcbiAgICAgIHZlYzIgdmFyaWFuY2VVViA9ICh2YXJpYW5jZUNvb3Jkc0NSICsgaGFsZkNSKSAvIHZhcmlhbmNlU2hhcGVDUjtcbiAgICAgICR7b2Zmc2V0VVZTbmlwcGV0fVxuICAgICAgJHtzY2FsZVVWU25pcHBldH1cblxuICAgICAgZmxvYXQgeFZhbHVlID0gdGV4dHVyZTJEKHgsIHJlc3VsdFVWKS5yO1xuICAgICAgZmxvYXQgbWVhblZhbHVlID0gdGV4dHVyZTJEKG1lYW4sIG1lYW5VVikucjtcbiAgICAgIGZsb2F0IHZhcmlhbmNlVmFsdWUgPSB0ZXh0dXJlMkQodmFyaWFuY2UsIHZhcmlhbmNlVVYpLnI7XG4gICAgICAke29mZnNldFZhbHVlU25pcHBldH1cbiAgICAgICR7c2NhbGVWYWx1ZVNuaXBwZXR9XG5cbiAgICAgIGZsb2F0IGludiA9IDEuMCAvIHNxcnQodmFyaWFuY2VWYWx1ZSArIHZhcmlhbmNlRXBzaWxvbik7XG4gICAgICAke3NjYWxlT3BlcmF0aW9uU25pcHBldH1cbiAgICAgIGZsb2F0IHhUaW1lc0ludiA9IHhWYWx1ZSAqIGludjtcbiAgICAgIGZsb2F0IG1lYW5UaW1lc0ludldpdGhPZmZzZXQgPSAke29mZnNldE9wZXJhdGlvblNuaXBwZXR9XG4gICAgICAgICAgLSBtZWFuVmFsdWUgKiBpbnY7XG5cbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoeFRpbWVzSW52ICsgbWVhblRpbWVzSW52V2l0aE9mZnNldCwgMCwgMCwgMCk7XG4gICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXRjaE5vcm1hbGl6YXRpb24oXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgcHJvZ3JhbTogV2ViR0xQcm9ncmFtLCB4OiBXZWJHTFRleHR1cmUsXG4gICAgeFNoYXBlUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdLCBtZWFuOiBXZWJHTFRleHR1cmUsXG4gICAgbWVhblNoYXBlUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdLCB2YXJpYW5jZTogV2ViR0xUZXh0dXJlLFxuICAgIHZhcmlhbmNlU2hhcGVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sIG9mZnNldDogV2ViR0xUZXh0dXJlfG51bGwsXG4gICAgb2Zmc2V0U2hhcGVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl18bnVsbCwgc2NhbGU6IFdlYkdMVGV4dHVyZXxudWxsLFxuICAgIHNjYWxlU2hhcGVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl18bnVsbCwgcmVzdWx0OiBXZWJHTFRleHR1cmUsXG4gICAgcmVzdWx0U2hhcGVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShcbiAgICAgIHJlc3VsdCwgcmVzdWx0U2hhcGVSb3dDb2xbMF0sIHJlc3VsdFNoYXBlUm93Q29sWzFdKTtcbiAgZ3BncHUuc2V0UHJvZ3JhbShwcm9ncmFtKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHgsICd4JywgMCk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShtZWFuLCAnbWVhbicsIDEpO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUodmFyaWFuY2UsICd2YXJpYW5jZScsIDIpO1xuICBsZXQgbmV4dEluZGV4ID0gMztcbiAgaWYgKG9mZnNldCAhPSBudWxsKSB7XG4gICAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKG9mZnNldCwgJ29mZnNldCcsIG5leHRJbmRleCk7XG4gICAgbmV4dEluZGV4Kys7XG4gIH1cbiAgaWYgKHNjYWxlICE9IG51bGwpIHtcbiAgICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUoc2NhbGUsICdzY2FsZScsIG5leHRJbmRleCk7XG4gIH1cbiAgZ3BncHUuZXhlY3V0ZVByb2dyYW0oKTtcbn0iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7R1BHUFVQcm9ncmFtfSBmcm9tICcuL2dwZ3B1X21hdGgnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi8uLi91dGlsJztcblxuZXhwb3J0IGNsYXNzIEJpbmFyeU9wUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ0EnLCAnQiddO1xuICBwYXJhbXM6IEFycmF5PHt9PjtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuICBzdXBwb3J0c0Jyb2FkY2FzdGluZzogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihvcDogJysnIHwgJy0nIHwgJyonIHwgJy8nLCBhU2hhcGU6IG51bWJlcltdLCBiU2hhcGU6IG51bWJlcltdKSB7XG4gICAgdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9IHRydWU7XG4gICAgdGhpcy5wYXJhbXMgPSBbb3BdO1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSB1dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdGVkU2hhcGUoYVNoYXBlLCBiU2hhcGUpO1xuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGZsb2F0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcbiAgICAgICAgZmxvYXQgYiA9IGdldEJBdE91dENvb3JkcygpO1xuICAgICAgICBzZXRPdXRwdXQoYSAke29wfSBiKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIGNvbnZfdXRpbCBmcm9tICcuLi9jb252X3V0aWwnO1xuaW1wb3J0IHtHUEdQVUNvbnRleHR9IGZyb20gJy4vZ3BncHVfY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlclNvdXJjZShcbiAgICB4MVNoYXBlUkNEOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHgyU2hhcGVSQ0Q6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICByZXN1bHRTaGFwZVJDRDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBheGlzOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCB4MVRleFNoYXBlUkMgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHgxU2hhcGVSQ0QpO1xuICBjb25zdCB4MlRleFNoYXBlUkMgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHgyU2hhcGVSQ0QpO1xuXG4gIGNvbnN0IHlBeGVzID0gWyd5UicsICd5QycsICd5RCddO1xuICBjb25zdCBjb25jYXRBeGlzID0geUF4ZXNbYXhpc107XG5cbiAgcmV0dXJuIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgeDE7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgeDI7XG5cbiAgICBjb25zdCB2ZWMyIHgxU2hhcGVDUiA9IHZlYzIoJHt4MVRleFNoYXBlUkNbMV19LCAke3gxVGV4U2hhcGVSQ1swXX0pO1xuICAgIGNvbnN0IHZlYzIgeDJTaGFwZUNSID0gdmVjMigke3gyVGV4U2hhcGVSQ1sxXX0uMCwgJHt4MlRleFNoYXBlUkNbMF19LjApO1xuXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzIgeVRleENSID0gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnh5KTtcblxuICAgICAgLy8gTWFwIGZyb20gMkQgKHlUZXhSLCB5VGV4QykgdG8gM0QgKHlSLCB5QywgeUQpLlxuICAgICAgZmxvYXQgeVIgPSB5VGV4Q1IueTtcbiAgICAgIGZsb2F0IHlDID0gZmxvb3IoeVRleENSLnggLyAke3Jlc3VsdFNoYXBlUkNEWzJdfS4wKTtcbiAgICAgIGZsb2F0IHlEID0gbW9kKHlUZXhDUi54LCAke3Jlc3VsdFNoYXBlUkNEWzJdfS4wKTtcblxuICAgICAgZmxvYXQgdmFsdWUgPSAwLjA7XG5cbiAgICAgIGlmICgke2NvbmNhdEF4aXN9IDwgJHt4MVNoYXBlUkNEW2F4aXNdfS4wKSB7XG4gICAgICAgIC8vIE1hcCB5UiwgeUMsIHlEIGJhY2sgdG8geDEgY29vcmRpbmF0ZXMuXG4gICAgICAgIHZlYzIgeDFDUiA9IHZlYzIoeUMgKiAke3gxU2hhcGVSQ0RbMl19LjAgKyB5RCwgeVIpO1xuICAgICAgICB2ZWMyIHgxVVYgPSAoeDFDUiArIGhhbGZDUikgLyB4MVNoYXBlQ1I7XG4gICAgICAgIHZhbHVlID0gdGV4dHVyZTJEKHgxLCB4MVVWKS5yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHtjb25jYXRBeGlzfSA9ICR7Y29uY2F0QXhpc30gLSAke3gxU2hhcGVSQ0RbYXhpc119LjA7XG5cbiAgICAgICAgLy8gTWFwIHlSLCB5QywgeUQgYmFjayB0byB4MiBjb29yZGluYXRlcy5cbiAgICAgICAgdmVjMiB4MkNSID0gdmVjMih5QyAqICR7eDJTaGFwZVJDRFsyXX0uMCArIHlELCB5Uik7XG4gICAgICAgIHZlYzIgeDJVViA9ICh4MkNSICsgaGFsZkNSKSAvIHgyU2hhcGVDUjtcbiAgICAgICAgdmFsdWUgPSB0ZXh0dXJlMkQoeDIsIHgyVVYpLnI7XG4gICAgICB9XG5cbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmFsdWUsIDAuMCwgMC4wLCAwLjApO1xuICAgIH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0M0QoXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgcHJvZ3JhbTogV2ViR0xQcm9ncmFtLCB4MTogV2ViR0xUZXh0dXJlLFxuICAgIHgyOiBXZWJHTFRleHR1cmUsIHJlc3VsdDogV2ViR0xUZXh0dXJlLCByZXN1bHRTaGFwZVJDOiBbbnVtYmVyLCBudW1iZXJdKSB7XG4gIGdwZ3B1LnNldE91dHB1dE1hdHJpeFRleHR1cmUocmVzdWx0LCByZXN1bHRTaGFwZVJDWzBdLCByZXN1bHRTaGFwZVJDWzFdKTtcbiAgZ3BncHUuc2V0UHJvZ3JhbShwcm9ncmFtKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHgxLCAneDEnLCAwKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHgyLCAneDInLCAxKTtcbiAgZ3BncHUuZXhlY3V0ZVByb2dyYW0oKTtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0ICogYXMgY29udl91dGlsIGZyb20gJy4uL2NvbnZfdXRpbCc7XG5cbmltcG9ydCAqIGFzIGNvbnZfZ3B1IGZyb20gJy4vY29udl9ncHUnO1xuaW1wb3J0IHtHUEdQVUNvbnRleHR9IGZyb20gJy4vZ3BncHVfY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlckRlcldlaWdodHNTb3VyY2UoXG4gICAgeFNoYXBlUm93Q29sRGVwdGg6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZlNpemU6IG51bWJlcixcbiAgICBvdXRwdXREZXB0aDogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgemVyb1BhZDogbnVtYmVyKSB7XG4gIGNvbnN0IGdldE1hdHJpeFZhbHVlT3JaZXJvUGFkID1cbiAgICAgIGNvbnZfZ3B1LmdldEZyYWdtZW50U2hhZGVyR2V0TWF0cml4VmFsdWVPclplcm9QYWRTb3VyY2UoKTtcbiAgY29uc3QgaW5wdXREZXB0aCA9IHhTaGFwZVJvd0NvbERlcHRoWzJdO1xuXG4gIGNvbnN0IHhUZXhTaGFwZVJDID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRCh4U2hhcGVSb3dDb2xEZXB0aCk7XG5cbiAgY29uc3QgeVNoYXBlID0gY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKFxuICAgICAgeFNoYXBlUm93Q29sRGVwdGgsIGZTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKTtcbiAgY29uc3QgeU51bVJvd3MgPSB5U2hhcGVbMF07XG4gIGNvbnN0IHlOdW1Db2xzID0geVNoYXBlWzFdO1xuICBjb25zdCB5VGV4U2hhcGVSQyA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoeVNoYXBlKTtcblxuICBjb25zdCBmU2l6ZVRpbWVzSW5wdXREZXB0aCA9IGZTaXplICogaW5wdXREZXB0aDtcblxuICBjb25zdCBwcm9sb2d1ZSA9IGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgeDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBkeTtcbiAgYDtcblxuICByZXR1cm4gcHJvbG9ndWUgKyAnXFxuJyArIGdldE1hdHJpeFZhbHVlT3JaZXJvUGFkICsgJ1xcbicgK1xuICAgICAgYFxuICAgIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XG4gICAgY29uc3QgdmVjMiB4U2hhcGVDUiA9IHZlYzIoJHt4VGV4U2hhcGVSQ1sxXX0sICR7eFRleFNoYXBlUkNbMF19KTtcbiAgICBjb25zdCB2ZWMyIGR5U2hhcGVDUiA9IHZlYzIoJHt5VGV4U2hhcGVSQ1sxXX0sICR7eVRleFNoYXBlUkNbMF19KTtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzIgd1RleENSID0gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnh5KTtcblxuICAgICAgLy8gTWFwIGZyb20gMkQgKHdUZXhSLCB3VGV4QykgdG8gNEQgKHdSLCB3QywgZDEsIGQyKS5cbiAgICAgIGZsb2F0IHdSID0gZmxvb3Iod1RleENSLnkgLyAke2ZTaXplVGltZXNJbnB1dERlcHRofS4wKTtcbiAgICAgIGZsb2F0IHdUZXhSTGVmdG92ZXIgPSB3VGV4Q1IueSAtIHdSICogJHtmU2l6ZVRpbWVzSW5wdXREZXB0aH0uMDtcbiAgICAgIGZsb2F0IHdDID0gZmxvb3Iod1RleFJMZWZ0b3ZlciAvICR7aW5wdXREZXB0aH0uMCk7XG4gICAgICBmbG9hdCBkMSA9IG1vZCh3VGV4UkxlZnRvdmVyLCAke2lucHV0RGVwdGh9LjApO1xuICAgICAgZmxvYXQgZDIgPSB3VGV4Q1IueDtcblxuICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCBkeSg6LCA6LCBkMikgdG8gZ2V0IGR3KHdSLCB3QywgZDEsIGQyKS5cbiAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcbiAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCAke3lOdW1Sb3dzfTsgeVIrKykge1xuICAgICAgICBmbG9hdCB5VGV4UiA9IGZsb2F0KHlSKTtcbiAgICAgICAgZmxvYXQgeFIgPSB3UiArIHlUZXhSICogJHtzdHJpZGV9LjAgLSAke3plcm9QYWR9LjA7XG4gICAgICAgIGZsb2F0IHhUZXhSID0geFI7XG5cbiAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8ICR7eU51bUNvbHN9OyB5QysrKSB7XG4gICAgICAgICAgZmxvYXQgeUNfZmxvYXQgPSBmbG9hdCh5Qyk7XG4gICAgICAgICAgZmxvYXQgeEMgPSB3QyArIHlDX2Zsb2F0ICogJHtzdHJpZGV9LjAgLSAke3plcm9QYWR9LjA7XG5cbiAgICAgICAgICAvLyBNYXAgZnJvbSAzRCAoeFIsIHhDLCBkMSkgdG8gMkQgKHhUZXhSLCB4VGV4QykuXG4gICAgICAgICAgLy8gTWFwIGZyb20gM0QgKHlSLCB5QywgZDIpIHRvIDJEICh5VGV4UiwgeVRleEMpLlxuICAgICAgICAgIHZlYzIgeHlUZXhDID1cbiAgICAgICAgICAgICAgdmVjMih4QywgeUNfZmxvYXQpICogdmVjMigke2lucHV0RGVwdGh9LjAsICR7b3V0cHV0RGVwdGh9LjApICtcbiAgICAgICAgICAgICAgdmVjMihkMSwgZDIpO1xuICAgICAgICAgIGZsb2F0IHhUZXhDID0geHlUZXhDLng7XG4gICAgICAgICAgZmxvYXQgeVRleEMgPSB4eVRleEMueTtcblxuICAgICAgICAgIC8vIFJlYWQgZHkoeVIsIHlDLCBkMikuXG4gICAgICAgICAgdmVjMiBkeVVWID0gKHZlYzIoeVRleEMsIHlUZXhSKSArIGhhbGZDUikgLyBkeVNoYXBlQ1I7XG4gICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IHRleHR1cmUyRChkeSwgZHlVVikucjtcblxuICAgICAgICAgIC8vIFJlYWQgeCh4UiwgeEMsIGQxKSAocG90ZW50aWFsbHkgemVyby1wYWRkZWQpLlxuICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9XG4gICAgICAgICAgICBnZXRNYXRyaXhWYWx1ZU9yWmVyb1BhZCh4LCB4U2hhcGVDUiwgdmVjMih4VGV4QywgeFRleFIpKTtcblxuICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGRvdFByb2QsIDAsIDAsIDApO1xuICAgIH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJDb252VHJhbnNwb3NlU291cmNlKFxuICAgIHhTaGFwZVJDRDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBmU2l6ZTogbnVtYmVyLCBvcmlnSW5wdXREZXB0aDogbnVtYmVyLFxuICAgIG9yaWdTdHJpZGU6IG51bWJlciwgb3JpZ1BhZDogbnVtYmVyLCBoYXNCaWFzOiBib29sZWFuKSB7XG4gIGNvbnN0IHBhZCA9IGZTaXplIC0gMSAtIG9yaWdQYWQ7XG4gIGNvbnN0IFt4Um93cywgeENvbHMsIG9yaWdPdXRwdXREZXB0aF0gPSB4U2hhcGVSQ0Q7XG5cbiAgY29uc3QgeFRleFNoYXBlUkMgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHhTaGFwZVJDRCk7XG4gIGNvbnN0IHdUZXhTaGFwZVJDID1cbiAgICAgIGNvbnZfdXRpbC5jb21wdXRlV2VpZ2h0c1RleFNoYXBlKG9yaWdJbnB1dERlcHRoLCBvcmlnT3V0cHV0RGVwdGgsIGZTaXplKTtcblxuICBjb25zdCBnZXRCaWFzVmFsdWUgPSBoYXNCaWFzID9cbiAgICAgIGNvbnZfZ3B1LmdldEZyYWdtZW50U2hhZGVyR2V0Qmlhc1ZhbHVlU291cmNlKG9yaWdJbnB1dERlcHRoKSA6XG4gICAgICAnJztcbiAgY29uc3QgYmlhc1Byb2xvZ3VlID0gaGFzQmlhcyA/ICd1bmlmb3JtIHNhbXBsZXIyRCBiaWFzZXM7JyA6ICcnO1xuICBjb25zdCBiaWFzT3BlcmF0aW9uID0gaGFzQmlhcyA/ICdkb3RQcm9kICs9IGdldEJpYXNWYWx1ZShiaWFzZXMsIGQyKTsnIDogJyc7XG5cbiAgY29uc3QgcHJvbG9ndWUgPSBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHg7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgd2VpZ2h0cztcbiAgICAke2JpYXNQcm9sb2d1ZX1cbiAgICBgO1xuXG4gIHJldHVybiBwcm9sb2d1ZSArICdcXG4nICsgZ2V0Qmlhc1ZhbHVlICsgJ1xcbicgK1xuICAgICAgYFxuICAgIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XG4gICAgY29uc3QgdmVjMiB4U2hhcGVDUiA9IHZlYzIoJHt4VGV4U2hhcGVSQ1sxXX0sICR7eFRleFNoYXBlUkNbMF19KTtcbiAgICBjb25zdCB2ZWMyIHdTaGFwZUNSID0gdmVjMigke3dUZXhTaGFwZVJDWzFdfSwgJHt3VGV4U2hhcGVSQ1swXX0pO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjMiB5VGV4Q1IgPSBmbG9vcihnbF9GcmFnQ29vcmQueHkpO1xuXG4gICAgICAvLyBNYXAgZnJvbSAyRCAoeVRleFIsIHlUZXhDKSB0byAzRCAoeVIsIHlDLCBkMikuXG4gICAgICBmbG9hdCB5UiA9IHlUZXhDUi55O1xuICAgICAgZmxvYXQgeUMgPSBmbG9vcih5VGV4Q1IueCAvICR7b3JpZ0lucHV0RGVwdGh9LjApO1xuICAgICAgZmxvYXQgZDIgPSBtb2QoeVRleENSLngsICR7b3JpZ0lucHV0RGVwdGh9LjApO1xuXG4gICAgICB2ZWMyIHhSQ0Nvcm5lciA9IHZlYzIoeVIsIHlDKSAtIHZlYzIoJHtwYWR9LjAsICR7cGFkfS4wKTtcbiAgICAgIGZsb2F0IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XG4gICAgICBmbG9hdCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xuXG4gICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDIsIGQxKSB0byBnZXQgeSh5UiwgeUMsIGQyKS5cbiAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcbiAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke2ZTaXplfTsgd1IrKykge1xuICAgICAgICBmbG9hdCB3Ul9mbG9hdCA9IGZsb2F0KHdSKTtcbiAgICAgICAgZmxvYXQgeFIgPSAoeFJDb3JuZXIgKyB3Ul9mbG9hdCkgLyAke29yaWdTdHJpZGV9LjA7XG4gICAgICAgIC8vIFRPRE8oc21pbGtvdik6IFNwbGljZSB0aGlzIHdpdGggYW5vdGhlciB2ZXJzaW9uIHdoZXJlIHlvdSBjYWxsXG4gICAgICAgIC8vIGdldE1hdHJpeFZhbHVlT3JaZXJvUGFkKCkuIEhlcmUgYW5kIGJlbG93LlxuICAgICAgICBpZiAoeFIgPCAwLjAgfHwgeFIgPj0gJHt4Um93c30uMCB8fCBmcmFjdCh4UikgPiAwLjApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsb2F0IHdSUGVybSA9ICR7ZlNpemV9LjAgLSAxLjAgLSB3Ul9mbG9hdDtcbiAgICAgICAgZmxvYXQgeFRleFIgPSB4UjtcblxuICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHtmU2l6ZX07IHdDKyspIHtcbiAgICAgICAgICBmbG9hdCB3Q19mbG9hdCA9IGZsb2F0KHdDKTtcbiAgICAgICAgICBmbG9hdCB4QyA9ICh4Q0Nvcm5lciArIHdDX2Zsb2F0KSAvICR7b3JpZ1N0cmlkZX0uMDtcbiAgICAgICAgICBpZiAoeEMgPCAwLjAgfHwgeEMgPj0gJHt4Q29sc30uMCB8fCBmcmFjdCh4QykgPiAwLjApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZsb2F0IHdDUGVybSA9ICR7ZlNpemV9LjAgLSAxLjAgLSB3Q19mbG9hdDtcbiAgICAgICAgICBmbG9hdCB3VGV4UiA9IHdSUGVybSAqICR7ZlNpemV9LjAgKiAke29yaWdJbnB1dERlcHRofS4wICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdDUGVybSAqICR7b3JpZ0lucHV0RGVwdGh9LjAgKyBkMjtcblxuICAgICAgICAgIGZvciAoaW50IGQxID0gMDsgZDEgPCAke29yaWdPdXRwdXREZXB0aH07IGQxKyspIHtcbiAgICAgICAgICAgIGZsb2F0IGQxX2Zsb2F0ID0gZmxvYXQoZDEpO1xuICAgICAgICAgICAgZmxvYXQgeFRleEMgPSB4QyAqICR7b3JpZ091dHB1dERlcHRofS4wICsgZDFfZmxvYXQ7XG4gICAgICAgICAgICBmbG9hdCB3VGV4QyA9IGQxX2Zsb2F0O1xuXG4gICAgICAgICAgICAvLyBSZWFkIHgoeFIsIHhDLCBkMSkuXG4gICAgICAgICAgICB2ZWMyIHhVViA9ICh2ZWMyKHhUZXhDLCB4VGV4UikgKyBoYWxmQ1IpIC8geFNoYXBlQ1I7XG4gICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSB0ZXh0dXJlMkQoeCwgeFVWKS5yO1xuXG4gICAgICAgICAgICAvLyBSZWFkIHcod1JQZXJtLCB3Q1Blcm0sIGQyLCBkMSkuXG4gICAgICAgICAgICB2ZWMyIHdVViA9ICh2ZWMyKHdUZXhDLCB3VGV4UikgKyBoYWxmQ1IpIC8gd1NoYXBlQ1I7XG4gICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSB0ZXh0dXJlMkQod2VpZ2h0cywgd1VWKS5yO1xuXG4gICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICR7Ymlhc09wZXJhdGlvbn1cbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZG90UHJvZCwgMCwgMCwgMCk7XG4gICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlckRlckJpYXNTb3VyY2UoXG4gICAgZHlTaGFwZVJDRDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKSB7XG4gIGNvbnN0IGR5VGV4U2hhcGVSQyA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoZHlTaGFwZVJDRCk7XG4gIGNvbnN0IFt5TnVtUm93cywgeU51bUNvbHMsIG91dHB1dERlcHRoXSA9IGR5U2hhcGVSQ0Q7XG5cbiAgcmV0dXJuIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgZHk7XG5cbiAgICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xuICAgIGNvbnN0IHZlYzIgZHlTaGFwZUNSID0gdmVjMigke2R5VGV4U2hhcGVSQ1sxXX0sICR7ZHlUZXhTaGFwZVJDWzBdfSk7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIGJpYXNUZXhDUiA9IGZsb29yKGdsX0ZyYWdDb29yZC54eSk7XG5cbiAgICAgIC8vIFRoZSBiaWFzIHRleHR1cmUgUkMgc2hhcGUgaXMgWzEsIGQyXS5cbiAgICAgIGZsb2F0IGQyID0gYmlhc1RleENSLng7XG5cbiAgICAgIGZsb2F0IGRlckJpYXMgPSAwLjA7XG4gICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgJHt5TnVtUm93c307IHlSKyspIHtcbiAgICAgICAgZmxvYXQgeVRleFIgPSBmbG9hdCh5Uik7XG5cbiAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8ICR7eU51bUNvbHN9OyB5QysrKSB7XG4gICAgICAgICAgZmxvYXQgeUNfZmxvYXQgPSBmbG9hdCh5Qyk7XG4gICAgICAgICAgLy8gTWFwIGZyb20gM0QgKHlSLCB5QywgZDIpIHRvIDJEICh5VGV4UiwgeVRleEMpLlxuICAgICAgICAgIGZsb2F0IHlUZXhDID0geUNfZmxvYXQgKiAke291dHB1dERlcHRofS4wICsgZDI7XG5cbiAgICAgICAgICAvLyBSZWFkIGR5KHlSLCB5QywgZDIpLlxuICAgICAgICAgIHZlYzIgZHlVViA9ICh2ZWMyKHlUZXhDLCB5VGV4UikgKyBoYWxmQ1IpIC8gZHlTaGFwZUNSO1xuICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSB0ZXh0dXJlMkQoZHksIGR5VVYpLnI7XG5cbiAgICAgICAgICBkZXJCaWFzICs9IGR5VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZGVyQmlhcywgMCwgMCwgMCk7XG4gICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXJCaWFzKFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgZHlUZXg6IFdlYkdMVGV4dHVyZSxcbiAgICByZXN1bHQ6IFdlYkdMVGV4dHVyZSwgcmVzdWx0VGV4U2hhcGVSQzogW251bWJlciwgbnVtYmVyXSkge1xuICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKFxuICAgICAgcmVzdWx0LCByZXN1bHRUZXhTaGFwZVJDWzBdLCByZXN1bHRUZXhTaGFwZVJDWzFdKTtcbiAgZ3BncHUuc2V0UHJvZ3JhbShwcm9ncmFtKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKGR5VGV4LCAnZHknLCAwKTtcbiAgZ3BncHUuZXhlY3V0ZVByb2dyYW0oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlcldlaWdodHMoXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgcHJvZ3JhbTogV2ViR0xQcm9ncmFtLCB4VGV4OiBXZWJHTFRleHR1cmUsXG4gICAgZHlUZXg6IFdlYkdMVGV4dHVyZSwgcmVzdWx0OiBXZWJHTFRleHR1cmUsXG4gICAgcmVzdWx0VGV4U2hhcGVSQzogW251bWJlciwgbnVtYmVyXSkge1xuICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKFxuICAgICAgcmVzdWx0LCByZXN1bHRUZXhTaGFwZVJDWzBdLCByZXN1bHRUZXhTaGFwZVJDWzFdKTtcbiAgZ3BncHUuc2V0UHJvZ3JhbShwcm9ncmFtKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHhUZXgsICd4JywgMCk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShkeVRleCwgJ2R5JywgMSk7XG4gIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252VHJhbnNwb3NlKFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgeFRleDogV2ViR0xUZXh0dXJlLFxuICAgIHdlaWdodHNUZXg6IFdlYkdMVGV4dHVyZSwgYmlhc2VzVGV4OiBXZWJHTFRleHR1cmV8bnVsbCxcbiAgICByZXN1bHRUZXg6IFdlYkdMVGV4dHVyZSwgcmVzdWx0VGV4U2hhcGVSQzogW251bWJlciwgbnVtYmVyXSkge1xuICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKFxuICAgICAgcmVzdWx0VGV4LCByZXN1bHRUZXhTaGFwZVJDWzBdLCByZXN1bHRUZXhTaGFwZVJDWzFdKTtcbiAgZ3BncHUuc2V0UHJvZ3JhbShwcm9ncmFtKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHhUZXgsICd4JywgMCk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZSh3ZWlnaHRzVGV4LCAnd2VpZ2h0cycsIDEpO1xuICBpZiAoYmlhc2VzVGV4ICE9IG51bGwpIHtcbiAgICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUoYmlhc2VzVGV4LCAnYmlhc2VzJywgMik7XG4gIH1cbiAgZ3BncHUuZXhlY3V0ZVByb2dyYW0oKTtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0ICogYXMgY29udl91dGlsIGZyb20gJy4uL2NvbnZfdXRpbCc7XG5pbXBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi9ncGdwdV9jb250ZXh0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50U2hhZGVyUHJvbG9ndWVTb3VyY2UoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgeDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB3ZWlnaHRzO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGJpYXNlcztcbiAgICB2YXJ5aW5nIHZlYzIgcmVzdWx0VVY7YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50U2hhZGVyR2V0TWF0cml4VmFsdWVPclplcm9QYWRTb3VyY2UoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBcbiAgICBmbG9hdCBnZXRNYXRyaXhWYWx1ZU9yWmVyb1BhZChpbiBzYW1wbGVyMkQgbWF0cml4LCB2ZWMyIG1hdHJpeFNoYXBlQ1IsXG4gICAgICAgIHZlYzIgcmVxdWVzdGVkQ1IpIHtcbiAgICAgIHZlYzIgdXYgPSAocmVxdWVzdGVkQ1IgKyB2ZWMyKDAuNSwgMC41KSkgLyBtYXRyaXhTaGFwZUNSO1xuICAgICAgZmxvYXQgdmFsdWUgPSB0ZXh0dXJlMkQobWF0cml4LCB1dikucjtcbiAgICAgIGJvb2wgbGVzc1RoYW5aZXJvID0gYW55KGxlc3NUaGFuKHV2LCB2ZWMyKDAsIDApKSk7XG4gICAgICBib29sIGdyZWF0ZXJUaGFuT25lID0gYW55KGdyZWF0ZXJUaGFuKHV2LCB2ZWMyKDEsIDEpKSk7XG4gICAgICBib29sIG91dHNpZGUgPSBsZXNzVGhhblplcm8gfHwgZ3JlYXRlclRoYW5PbmU7XG4gICAgICByZXR1cm4gbWl4KHZhbHVlLCAwLjAsIGZsb2F0KG91dHNpZGUpKTtcbiAgICB9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50U2hhZGVyQ29udm9sdmVTb3VyY2UoXG4gICAgeFNoYXBlUkNEOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGZTaXplOiBudW1iZXIsIG91dHB1dERlcHRoOiBudW1iZXIsXG4gICAgc3RyaWRlOiBudW1iZXIsIHBhZDogbnVtYmVyLCBoYXNCaWFzOiBib29sZWFuKSB7XG4gIGNvbnN0IGlucHV0RGVwdGggPSB4U2hhcGVSQ0RbMl07XG4gIGNvbnN0IHhUZXhTaGFwZVJDID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRCh4U2hhcGVSQ0QpO1xuICBjb25zdCB3VGV4U2hhcGVSQyA9XG4gICAgICBjb252X3V0aWwuY29tcHV0ZVdlaWdodHNUZXhTaGFwZShpbnB1dERlcHRoLCBvdXRwdXREZXB0aCwgZlNpemUpO1xuXG4gIHJldHVybiBgXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcbiAgICBjb25zdCB2ZWMyIHhTaGFwZUNSID0gdmVjMigke3hUZXhTaGFwZVJDWzFdfSwgJHt4VGV4U2hhcGVSQ1swXX0pO1xuICAgIGNvbnN0IHZlYzIgd1NoYXBlQ1IgPSB2ZWMyKCR7d1RleFNoYXBlUkNbMV19LCAke3dUZXhTaGFwZVJDWzBdfSk7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIHlUZXhDUiA9IGZsb29yKGdsX0ZyYWdDb29yZC54eSk7XG5cbiAgICAgIC8vIE1hcCBmcm9tIDJEICh5VGV4UiwgeVRleEMpIHRvIDNEICh5UiwgeUMsIGQyKS5cbiAgICAgIGZsb2F0IHlSID0geVRleENSLnk7XG4gICAgICBmbG9hdCB5QyA9IGZsb29yKHlUZXhDUi54IC8gJHtvdXRwdXREZXB0aH0uMCk7XG4gICAgICBmbG9hdCBkMiA9IG1vZCh5VGV4Q1IueCwgJHtvdXRwdXREZXB0aH0uMCk7XG4gICAgICBmbG9hdCB3VGV4QyA9IGQyO1xuXG4gICAgICB2ZWMyIHhSQ0Nvcm5lciA9IHZlYzIoeVIsIHlDKSAqIHZlYzIoJHtzdHJpZGV9LCAke3N0cmlkZX0pIC1cbiAgICAgICAgICB2ZWMyKCR7cGFkfS4wLCAke3BhZH0uMCk7XG4gICAgICBmbG9hdCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xuICAgICAgZmxvYXQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcblxuICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXG4gICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XG4gICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtmU2l6ZX07IHdSKyspIHtcbiAgICAgICAgZmxvYXQgd1JfZmxvYXQgPSBmbG9hdCh3Uik7XG4gICAgICAgIGZsb2F0IHhSID0geFJDb3JuZXIgKyB3Ul9mbG9hdDtcbiAgICAgICAgZmxvYXQgeFRleFIgPSB4UjtcblxuICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHtmU2l6ZX07IHdDKyspIHtcbiAgICAgICAgICBmbG9hdCB3Q19mbG9hdCA9IGZsb2F0KHdDKTtcbiAgICAgICAgICBmbG9hdCB4QyA9IHhDQ29ybmVyICsgd0NfZmxvYXQ7XG5cbiAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgJHtpbnB1dERlcHRofTsgZDErKykge1xuICAgICAgICAgICAgZmxvYXQgZDFfZmxvYXQgPSBmbG9hdChkMSk7XG4gICAgICAgICAgICBmbG9hdCB4VGV4QyA9IHhDICogJHtpbnB1dERlcHRofS4wICsgZDFfZmxvYXQ7XG4gICAgICAgICAgICBmbG9hdCB3VGV4UiA9IHdSX2Zsb2F0ICogJHtmU2l6ZSAqIGlucHV0RGVwdGh9LjAgK1xuICAgICAgICAgICAgICAgIHdDX2Zsb2F0ICogJHtpbnB1dERlcHRofS4wICsgZDFfZmxvYXQ7XG5cbiAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9XG4gICAgICAgICAgICAgICAgZ2V0TWF0cml4VmFsdWVPclplcm9QYWQoeCwgeFNoYXBlQ1IsIHZlYzIoeFRleEMsIHhUZXhSKSk7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgdyh3Uiwgd0MsIGQxLCBkMikuXG4gICAgICAgICAgICB2ZWMyIHdVViA9ICh2ZWMyKHdUZXhDLCB3VGV4UikgKyBoYWxmQ1IpIC8gd1NoYXBlQ1I7XG4gICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSB0ZXh0dXJlMkQod2VpZ2h0cywgd1VWKS5yO1xuXG4gICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgke2hhc0JpYXN9KSB7XG4gICAgICAgIGRvdFByb2QgKz0gZ2V0Qmlhc1ZhbHVlKGJpYXNlcywgZDIpO1xuICAgICAgfVxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChkb3RQcm9kLCAwLCAwLCAwKTtcbiAgICB9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50U2hhZGVyR2V0Qmlhc1ZhbHVlU291cmNlKG91dHB1dERlcHRoOiBudW1iZXIpOlxuICAgIHN0cmluZyB7XG4gIHJldHVybiBgXG4gICAgZmxvYXQgZ2V0Qmlhc1ZhbHVlKGluIHNhbXBsZXIyRCBiaWFzLCBmbG9hdCBiaWFzQykge1xuICAgICAgY29uc3QgdmVjMiBiaWFzU2hhcGVDUiA9IHZlYzIoJHtvdXRwdXREZXB0aH0sIDEpO1xuICAgICAgdmVjMiBiaWFzQ1IgPSB2ZWMyKG1vZChiaWFzQywgJHtvdXRwdXREZXB0aH0uMCksIDApO1xuICAgICAgdmVjMiBiaWFzVVYgPSAoYmlhc0NSICsgdmVjMigwLjUsIDAuNSkpIC8gYmlhc1NoYXBlQ1I7XG4gICAgICByZXR1cm4gdGV4dHVyZTJEKGJpYXMsIGJpYXNVVikucjtcbiAgICB9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50U2hhZGVyU291cmNlKFxuICAgIGFTaGFwZVJvd0NvbERlcHRoOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHJlc3VsdERlcHRoOiBudW1iZXIsXG4gICAgZmllbGRTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCB6ZXJvUGFkOiBudW1iZXIsXG4gICAgaGFzQmlhczogYm9vbGVhbik6IHN0cmluZyB7XG4gIGNvbnN0IHByb2xvZ3VlID0gZ2V0RnJhZ21lbnRTaGFkZXJQcm9sb2d1ZVNvdXJjZSgpO1xuICBjb25zdCBnZXRNYXRyaXhWYWx1ZU9yWmVyb1BhZCA9XG4gICAgICBnZXRGcmFnbWVudFNoYWRlckdldE1hdHJpeFZhbHVlT3JaZXJvUGFkU291cmNlKCk7XG4gIGNvbnN0IGNvbnZvbHZlID0gZ2V0RnJhZ21lbnRTaGFkZXJDb252b2x2ZVNvdXJjZShcbiAgICAgIGFTaGFwZVJvd0NvbERlcHRoLCBmaWVsZFNpemUsIHJlc3VsdERlcHRoLCBzdHJpZGUsIHplcm9QYWQsIGhhc0JpYXMpO1xuICBjb25zdCBnZXRCaWFzVmFsdWUgPSBnZXRGcmFnbWVudFNoYWRlckdldEJpYXNWYWx1ZVNvdXJjZShyZXN1bHREZXB0aCk7XG5cbiAgcmV0dXJuIFtcbiAgICBwcm9sb2d1ZSxcbiAgICBnZXRNYXRyaXhWYWx1ZU9yWmVyb1BhZCxcbiAgICBnZXRCaWFzVmFsdWUsXG4gICAgY29udm9sdmUsXG4gIF0uam9pbignXFxuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252b2x2ZShcbiAgICBncGdwdTogR1BHUFVDb250ZXh0LCBwcm9ncmFtOiBXZWJHTFByb2dyYW0sIGE6IFdlYkdMVGV4dHVyZSxcbiAgICB3ZWlnaHRzOiBXZWJHTFRleHR1cmUsIGJpYXNlczogV2ViR0xUZXh0dXJlfG51bGwsIHJlc3VsdDogV2ViR0xUZXh0dXJlLFxuICAgIHJlc3VsdFNoYXBlUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdKSB7XG4gIGdwZ3B1LnNldE91dHB1dE1hdHJpeFRleHR1cmUoXG4gICAgICByZXN1bHQsIHJlc3VsdFNoYXBlUm93Q29sWzBdLCByZXN1bHRTaGFwZVJvd0NvbFsxXSk7XG4gIGdwZ3B1LnNldFByb2dyYW0ocHJvZ3JhbSk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShhLCAneCcsIDApO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUod2VpZ2h0cywgJ3dlaWdodHMnLCAxKTtcbiAgaWYgKGJpYXNlcyAhPSBudWxsKSB7XG4gICAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKGJpYXNlcywgJ2JpYXNlcycsIDIpO1xuICB9XG4gIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL2dwZ3B1X2NvbnRleHQnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoXG4gICAgc291cmNlU2hhcGVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sIHNvdXJjZVNpemVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgZGVzdFNpemVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcge1xuICByZXR1cm4gYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBzb3VyY2U7XG4gICAgdW5pZm9ybSB2ZWMyIHNvdXJjZVN0YXJ0Q1I7XG4gICAgdW5pZm9ybSB2ZWMyIGRlc3RTdGFydENSO1xuXG4gICAgY29uc3QgdmVjMiBzb3VyY2VTaGFwZUNSID1cbiAgICAgIHZlYzIoJHtzb3VyY2VTaGFwZVJvd0NvbFsxXX0sICR7c291cmNlU2hhcGVSb3dDb2xbMF19KTtcbiAgICBjb25zdCB2ZWMyIHNvdXJjZVNpemVDUiA9XG4gICAgICB2ZWMyKCR7c291cmNlU2l6ZVJvd0NvbFsxXX0sICR7c291cmNlU2l6ZVJvd0NvbFswXX0pO1xuICAgIGNvbnN0IHZlYzIgZGVzdFNpemVDUiA9XG4gICAgICB2ZWMyKCR7ZGVzdFNpemVSb3dDb2xbMV19LCAke2Rlc3RTaXplUm93Q29sWzBdfSk7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIGRlc3RPZmZzZXRDUiA9IGZsb29yKGdsX0ZyYWdDb29yZC54eSkgLSBkZXN0U3RhcnRDUjtcbiAgICAgIGZsb2F0IGRlc3RPZmZzZXRGbGF0ID0gKGRlc3RPZmZzZXRDUi55ICogZGVzdFNpemVDUi54KSArIGRlc3RPZmZzZXRDUi54O1xuICAgICAgdmVjMiBzb3VyY2VPZmZzZXRDUiA9IHZlYzIobW9kKGRlc3RPZmZzZXRGbGF0LCBzb3VyY2VTaXplQ1IueCksXG4gICAgICAgIGZsb29yKGRlc3RPZmZzZXRGbGF0IC8gc291cmNlU2l6ZUNSLngpKTtcbiAgICAgIHZlYzIgc291cmNlQ1IgPSBzb3VyY2VTdGFydENSICsgc291cmNlT2Zmc2V0Q1I7XG4gICAgICB2ZWMyIHNvdXJjZVVWID0gKHNvdXJjZUNSICsgdmVjMigwLjUsIDAuNSkpIC8gc291cmNlU2hhcGVDUjtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRChzb3VyY2UsIHNvdXJjZVVWKTtcbiAgICB9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgcHJvZ3JhbTogV2ViR0xQcm9ncmFtLCBzb3VyY2U6IFdlYkdMVGV4dHVyZSxcbiAgICBzb3VyY2VTaGFwZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSwgc291cmNlU3RhcnRSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgc291cmNlU2l6ZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSwgZGVzdDogV2ViR0xUZXh0dXJlLFxuICAgIGRlc3RTaGFwZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSwgZGVzdFN0YXJ0Um93Q29sOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgIGRlc3RTaXplUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdKSB7XG4gIGdwZ3B1LnNldE91dHB1dE1hdHJpeFRleHR1cmUoZGVzdCwgZGVzdFNoYXBlUm93Q29sWzBdLCBkZXN0U2hhcGVSb3dDb2xbMV0pO1xuICBncGdwdS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbihcbiAgICAgIGRlc3RTdGFydFJvd0NvbFswXSwgZGVzdFNpemVSb3dDb2xbMF0sIGRlc3RTdGFydFJvd0NvbFsxXSxcbiAgICAgIGRlc3RTaXplUm93Q29sWzFdKTtcbiAgZ3BncHUuc2V0UHJvZ3JhbShwcm9ncmFtKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHNvdXJjZSwgJ3NvdXJjZScsIDApO1xuICBjb25zdCBzb3VyY2VTdGFydENSTG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKCdzb3VyY2VTdGFydENSJyk7XG4gIGdwZ3B1LmdsLnVuaWZvcm0yZihcbiAgICAgIHNvdXJjZVN0YXJ0Q1JMb2MsIHNvdXJjZVN0YXJ0Um93Q29sWzFdLCBzb3VyY2VTdGFydFJvd0NvbFswXSk7XG4gIGNvbnN0IGRlc3RTdGFydENSTG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKCdkZXN0U3RhcnRDUicpO1xuICBncGdwdS5nbC51bmlmb3JtMmYoZGVzdFN0YXJ0Q1JMb2MsIGRlc3RTdGFydFJvd0NvbFsxXSwgZGVzdFN0YXJ0Um93Q29sWzBdKTtcbiAgZ3BncHUuZXhlY3V0ZVByb2dyYW0oKTtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0ICogYXMgZ3BncHVfdXRpbCBmcm9tICcuL2dwZ3B1X3V0aWwnO1xuaW1wb3J0ICogYXMgdGV4X3V0aWwgZnJvbSAnLi90ZXhfdXRpbCc7XG5pbXBvcnQgKiBhcyB3ZWJnbF91dGlsIGZyb20gJy4vd2ViZ2xfdXRpbCc7XG5cbmltcG9ydCB7V2ViR0xMb3NlQ29udGV4dEV4dGVuc2lvbn0gZnJvbSAnLi93ZWJnbF91dGlsJztcblxuZXhwb3J0IGNsYXNzIEdQR1BVQ29udGV4dCB7XG4gIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gIHRleHR1cmVGbG9hdEV4dGVuc2lvbjoge307XG4gIGNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb246IHt9O1xuICBsb3NlQ29udGV4dEV4dGVuc2lvbjogV2ViR0xMb3NlQ29udGV4dEV4dGVuc2lvbjtcbiAgdmVydGV4QnVmZmVyOiBXZWJHTEJ1ZmZlcjtcbiAgaW5kZXhCdWZmZXI6IFdlYkdMQnVmZmVyO1xuICBmcmFtZWJ1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlcjtcbiAgb3V0cHV0VGV4dHVyZTogV2ViR0xUZXh0dXJlfG51bGwgPSBudWxsO1xuICBwcm9ncmFtOiBXZWJHTFByb2dyYW18bnVsbCA9IG51bGw7XG4gIHByaXZhdGUgZGlzcG9zZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBhdXRvRGVidWdWYWxpZGF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGdsPzogV2ViR0xSZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgaWYgKGdsICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nbCA9IGdwZ3B1X3V0aWwuY3JlYXRlV2ViR0xDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgLy8gV2ViR0wgMi4wIGVuYWJsZXMgdGV4dHVyZSBmbG9hdHMgd2l0aG91dCBhbiBleHRlbnNpb24uXG4gICAgaWYgKCF3ZWJnbF91dGlsLmlzV2ViR0wyRW5hYmxlZCgpKSB7XG4gICAgICB0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbiA9XG4gICAgICAgICAgd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsICdPRVNfdGV4dHVyZV9mbG9hdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24gPVxuICAgICAgICAgIHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xuICAgIH1cblxuICAgIHRoaXMubG9zZUNvbnRleHRFeHRlbnNpb24gPVxuICAgICAgICB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ1dFQkdMX2xvc2VfY29udGV4dCcpIGFzXG4gICAgICAgIFdlYkdMTG9zZUNvbnRleHRFeHRlbnNpb247XG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBncGdwdV91dGlsLmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLmdsKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gZ3BncHVfdXRpbC5jcmVhdGVJbmRleEJ1ZmZlcih0aGlzLmdsKTtcbiAgICB0aGlzLmZyYW1lYnVmZmVyID0gd2ViZ2xfdXRpbC5jcmVhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgfVxuXG4gIHB1YmxpYyBkaXNwb3NlKCkge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgaWYgKHRoaXMucHJvZ3JhbSAhPSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ0Rpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIFdlYkdMUHJvZ3JhbS4nICtcbiAgICAgICAgICAnIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIHByb2dyYW0gd2l0aCAnICtcbiAgICAgICAgICAnR1BHUFVDb250ZXh0LmRlbGV0ZVByb2dyYW0gYmVmb3JlIGRpc3Bvc2luZy4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3V0cHV0VGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ0Rpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIG91dHB1dCBtYXRyaXggJyArXG4gICAgICAgICAgJ3RleHR1cmUuICBUaGlzIGlzIHByb2JhYmx5IGEgcmVzb3VyY2UgbGVhaywgZGVsZXRlIHRoZSBvdXRwdXQgJyArXG4gICAgICAgICAgJ21hdHJpeCB0ZXh0dXJlIHdpdGggR1BHUFVDb250ZXh0LmRlbGV0ZU1hdHJpeFRleHR1cmUgYmVmb3JlICcgK1xuICAgICAgICAgICdkaXNwb3NpbmcuJyk7XG4gICAgfVxuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuZmluaXNoKCkpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlcikpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCkpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhCdWZmZXIpKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhcbiAgICAgICAgZ2wsICgpID0+IGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXIpKTtcbiAgICB0aGlzLmxvc2VDb250ZXh0RXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG4gICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgZW5hYmxlQXV0b21hdGljRGVidWdWYWxpZGF0aW9uKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlID0gZW5hYmxlZDtcbiAgICB3ZWJnbF91dGlsLmVuYWJsZURlYnVnV2ViR0xFcnJvckNoZWNraW5nKGVuYWJsZWQpO1xuICB9XG5cbiAgcHVibGljIGNyZWF0ZU1hdHJpeFRleHR1cmUocm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIpOiBXZWJHTFRleHR1cmUge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgcmV0dXJuIGdwZ3B1X3V0aWwuY3JlYXRlTWF0cml4VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zKTtcbiAgfVxuXG4gIHB1YmxpYyB1cGxvYWRQaXhlbERhdGFUb1RleHR1cmUoXG4gICAgICB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsXG4gICAgICBwaXhlbHM6IEltYWdlRGF0YXxIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIGdwZ3B1X3V0aWwudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKHRoaXMuZ2wsIHRleHR1cmUsIHBpeGVscyk7XG4gIH1cblxuICBwdWJsaWMgY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZShyb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlcik6XG4gICAgICBXZWJHTFRleHR1cmUge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgcmV0dXJuIGdwZ3B1X3V0aWwuY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zKTtcbiAgfVxuXG4gIHB1YmxpYyBkZWxldGVNYXRyaXhUZXh0dXJlKHRleHR1cmU6IFdlYkdMVGV4dHVyZSkge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgaWYgKHRoaXMub3V0cHV0VGV4dHVyZSA9PT0gdGV4dHVyZSkge1xuICAgICAgd2ViZ2xfdXRpbC51bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICB0aGlzLm91dHB1dFRleHR1cmUgPSBudWxsO1xuICAgIH1cbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCAoKSA9PiB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSkpO1xuICB9XG5cbiAgcHVibGljIHVwbG9hZE1hdHJpeFRvVGV4dHVyZShcbiAgICAgIHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgcm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIsXG4gICAgICBtYXRyaXg6IEZsb2F0MzJBcnJheSkge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgY29uc3QgbnVtQ2hhbm5lbHMgPSAxO1xuICAgIHJldHVybiBncGdwdV91dGlsLnVwbG9hZE1hdHJpeFRvVGV4dHVyZShcbiAgICAgICAgdGhpcy5nbCwgdGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4LCBudW1DaGFubmVscyk7XG4gIH1cblxuICBwdWJsaWMgdXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlKFxuICAgICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlLCByb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlcixcbiAgICAgIG1hdHJpeDogRmxvYXQzMkFycmF5KSB7XG4gICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICByZXR1cm4gZ3BncHVfdXRpbC51cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUoXG4gICAgICAgIHRoaXMuZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCk7XG4gIH1cblxuICBwdWJsaWMgZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZShcbiAgICAgIHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgcm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xuICAgIHJldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKFxuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICAoKSA9PlxuICAgICAgICAgICAgZ3BncHVfdXRpbC5kb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKHRoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpKTtcbiAgfVxuXG4gIHB1YmxpYyBkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRUZXh0dXJlKFxuICAgICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlLCByb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XG4gICAgcmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIoXG4gICAgICAgIHRleHR1cmUsXG4gICAgICAgICgpID0+IGdwZ3B1X3V0aWwuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZShcbiAgICAgICAgICAgIHRoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpKTtcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVQcm9ncmFtKGZyYWdtZW50U2hhZGVyU291cmNlOiBzdHJpbmcpOiBXZWJHTFByb2dyYW0ge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyOiBXZWJHTFNoYWRlciA9XG4gICAgICAgIHdlYmdsX3V0aWwuY3JlYXRlRnJhZ21lbnRTaGFkZXIoZ2wsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyID0gZ3BncHVfdXRpbC5jcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wpO1xuICAgIGNvbnN0IHByb2dyYW06IFdlYkdMUHJvZ3JhbSA9IHdlYmdsX3V0aWwuY3JlYXRlUHJvZ3JhbShnbCk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKSk7XG4gICAgd2ViZ2xfdXRpbC5saW5rUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG4gICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVQcm9ncmFtKGdsLCBwcm9ncmFtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfVxuXG4gIHB1YmxpYyBkZWxldGVQcm9ncmFtKHByb2dyYW06IFdlYkdMUHJvZ3JhbSkge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgaWYgKHByb2dyYW0gPT09IHRoaXMucHJvZ3JhbSkge1xuICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgKCkgPT4gdGhpcy5nbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0UHJvZ3JhbShwcm9ncmFtOiBXZWJHTFByb2dyYW18bnVsbCkge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICBpZiAoKHRoaXMucHJvZ3JhbSAhPSBudWxsKSAmJiB0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnByb2dyYW0pO1xuICAgIH1cbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCAoKSA9PiB0aGlzLmdsLnVzZVByb2dyYW0ocHJvZ3JhbSkpO1xuICB9XG5cbiAgcHVibGljIGdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZTogc3RyaW5nKTogV2ViR0xVbmlmb3JtTG9jYXRpb24ge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgdGhpcy50aHJvd0lmTm9Qcm9ncmFtKCk7XG4gICAgcmV0dXJuIHdlYmdsX3V0aWwuZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3coXG4gICAgICAgIHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSEsIHVuaWZvcm1OYW1lKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRJbnB1dE1hdHJpeFRleHR1cmUoXG4gICAgICBpbnB1dE1hdHJpeFRleHR1cmU6IFdlYkdMVGV4dHVyZSwgdW5pZm9ybU5hbWU6IHN0cmluZyxcbiAgICAgIHRleHR1cmVVbml0OiBudW1iZXIpIHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO1xuICAgIHdlYmdsX3V0aWwuYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcihcbiAgICAgICAgdGhpcy5nbCwgdGhpcy5wcm9ncmFtISwgaW5wdXRNYXRyaXhUZXh0dXJlLCB1bmlmb3JtTmFtZSwgdGV4dHVyZVVuaXQpO1xuICB9XG5cbiAgcHVibGljIHNldE91dHB1dE1hdHJpeFRleHR1cmUoXG4gICAgICBvdXRwdXRNYXRyaXhUZXh0dXJlOiBXZWJHTFRleHR1cmUsIHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyKSB7XG4gICAgdGhpcy5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKG91dHB1dE1hdHJpeFRleHR1cmUsIGNvbHVtbnMsIHJvd3MpO1xuICB9XG5cbiAgcHVibGljIHNldE91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUoXG4gICAgICBvdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlOiBXZWJHTFRleHR1cmUsIHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyKSB7XG4gICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPVxuICAgICAgICB0ZXhfdXRpbC5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKTtcbiAgICB0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIob3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cblxuICBwdWJsaWMgc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb24oXG4gICAgICBzdGFydFJvdzogbnVtYmVyLCBudW1Sb3dzOiBudW1iZXIsIHN0YXJ0Q29sdW1uOiBudW1iZXIsXG4gICAgICBudW1Db2x1bW5zOiBudW1iZXIpIHtcbiAgICB0aGlzLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyKFxuICAgICAgICBzdGFydENvbHVtbiwgc3RhcnRSb3csIG51bUNvbHVtbnMsIG51bVJvd3MpO1xuICB9XG5cbiAgcHVibGljIHNldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uKFxuICAgICAgc3RhcnRSb3c6IG51bWJlciwgbnVtUm93czogbnVtYmVyLCBzdGFydENvbHVtbjogbnVtYmVyLFxuICAgICAgbnVtQ29sdW1uczogbnVtYmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbiBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBwdWJsaWMgZGVidWdWYWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5wcm9ncmFtICE9IG51bGwpIHtcbiAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVQcm9ncmFtKHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSk7XG4gICAgfVxuICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgfVxuXG4gIHB1YmxpYyBleGVjdXRlUHJvZ3JhbSgpIHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBncGdwdV91dGlsLmJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtcyhcbiAgICAgICAgZ2wsIHRoaXMucHJvZ3JhbSEsIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgdGhpcy5kZWJ1Z1ZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKFxuICAgICAgICBnbCwgKCkgPT4gZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApKTtcbiAgfVxuXG4gIHB1YmxpYyBibG9ja1VudGlsQWxsUHJvZ3JhbXNDb21wbGV0ZWQoKSB7XG4gICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCAoKSA9PiB0aGlzLmdsLmZpbmlzaCgpKTtcbiAgfVxuXG4gIHByaXZhdGUgZG93bmxvYWRNYXRyaXhEcml2ZXIoXG4gICAgICB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsXG4gICAgICBkb3dubG9hZEFuZERlY29kZTogKCkgPT4gRmxvYXQzMkFycmF5KTogRmxvYXQzMkFycmF5IHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIHdlYmdsX3V0aWwuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIoXG4gICAgICAgIHRoaXMuZ2wsIHRleHR1cmUsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGRvd25sb2FkQW5kRGVjb2RlKCk7XG4gICAgaWYgKHRoaXMub3V0cHV0VGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICB3ZWJnbF91dGlsLmJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKFxuICAgICAgICAgIHRoaXMuZ2wsIHRoaXMub3V0cHV0VGV4dHVyZSwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdlYmdsX3V0aWwudW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKFxuICAgICAgb3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkOiBXZWJHTFRleHR1cmUsIHdpZHRoOiBudW1iZXIsXG4gICAgICBoZWlnaHQ6IG51bWJlcikge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIHdlYmdsX3V0aWwuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIoXG4gICAgICAgIGdsLCBvdXRwdXRNYXRyaXhUZXh0dXJlTWF5YmVQYWNrZWQsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlRnJhbWVidWZmZXIoZ2wpO1xuICAgIH1cbiAgICB0aGlzLm91dHB1dFRleHR1cmUgPSBvdXRwdXRNYXRyaXhUZXh0dXJlTWF5YmVQYWNrZWQ7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLnZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuc2Npc3NvcigwLCAwLCB3aWR0aCwgaGVpZ2h0KSk7XG4gIH1cblxuICBwcml2YXRlIHNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyKFxuICAgICAgeDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XG4gICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhcbiAgICAgICAgdGhpcy5nbCwgKCkgPT4gdGhpcy5nbC5zY2lzc29yKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgfVxuXG4gIHByaXZhdGUgdGhyb3dJZkRpc3Bvc2VkKCkge1xuICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byB1c2UgZGlzcG9zZWQgR1BHUFVDb250ZXh0LicpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdGhyb3dJZk5vUHJvZ3JhbSgpIHtcbiAgICBpZiAodGhpcy5wcm9ncmFtID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gR1BVIHByb2dyYW0gaXMgY3VycmVudGx5IHNldC4nKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtOREFycmF5fSBmcm9tICcuLi9uZGFycmF5JztcblxuaW1wb3J0IHtHUEdQVUNvbnRleHR9IGZyb20gJy4vZ3BncHVfY29udGV4dCc7XG5pbXBvcnQgKiBhcyBzaGFkZXJfY29tcGlsZXIgZnJvbSAnLi9zaGFkZXJfY29tcGlsZXInO1xuaW1wb3J0IHtTaGFwZUluZm99IGZyb20gJy4vc2hhZGVyX2NvbXBpbGVyJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vLi4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lczogc3RyaW5nW107XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgcGFyYW1zOiBBcnJheTx7fT47XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG4gIHN1cHBvcnRzQnJvYWRjYXN0aW5nPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHUEdQVUJpbmFyeSB7XG4gIHdlYkdMUHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xuICBwcm9ncmFtOiBHUEdQVVByb2dyYW07XG4gIGdwZ3B1OiBHUEdQVUNvbnRleHQ7XG4gIHNvdXJjZTogc3RyaW5nO1xuICBpblNoYXBlSW5mb3M6IFNoYXBlSW5mb1tdO1xuICBvdXRTaGFwZUluZm86IFNoYXBlSW5mbztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVQcm9ncmFtPFQgZXh0ZW5kcyBOREFycmF5LCBLIGV4dGVuZHMgTkRBcnJheT4oXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgcHJvZ3JhbTogR1BHUFVQcm9ncmFtLCBpbnB1dHM6IFRbXSxcbiAgICBvdXRwdXQ6IEspOiBHUEdQVUJpbmFyeSB7XG4gIGNvbnN0IHVzZXJDb2RlID0gcHJvZ3JhbS51c2VyQ29kZTtcbiAgY29uc3QgaW5wdXRJbmZvcyA9IHByb2dyYW0udmFyaWFibGVOYW1lcy5tYXAoKHgsIGkpID0+IHtcbiAgICBjb25zdCBzaGFwZUluZm8gPSB7XG4gICAgICBsb2dpY2FsU2hhcGU6IGlucHV0c1tpXS5zaGFwZSxcbiAgICAgIHRleFNoYXBlOiBpbnB1dHNbaV0uZ2V0VGV4dHVyZVNoYXBlUkMoKVxuICAgIH07XG4gICAgcmV0dXJuIHtuYW1lOiB4LCBzaGFwZUluZm99O1xuICB9KTtcbiAgY29uc3QgaW5TaGFwZUluZm9zID0gaW5wdXRJbmZvcy5tYXAoeCA9PiB4LnNoYXBlSW5mbyk7XG4gIGNvbnN0IG91dFNoYXBlSW5mbyA9IHtcbiAgICBsb2dpY2FsU2hhcGU6IG91dHB1dC5zaGFwZSxcbiAgICB0ZXhTaGFwZTogb3V0cHV0LmdldFRleHR1cmVTaGFwZVJDKClcbiAgfTtcbiAgY29uc3Qgc291cmNlID0gc2hhZGVyX2NvbXBpbGVyLm1ha2VTaGFkZXIoXG4gICAgICBpbnB1dEluZm9zLCBvdXRTaGFwZUluZm8sIHVzZXJDb2RlLFxuICAgICAgcHJvZ3JhbS5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9PT0gdHJ1ZSk7XG4gIHJldHVybiB7XG4gICAgcHJvZ3JhbSxcbiAgICBzb3VyY2UsXG4gICAgd2ViR0xQcm9ncmFtOiBncGdwdS5jcmVhdGVQcm9ncmFtKHNvdXJjZSksXG4gICAgZ3BncHUsXG4gICAgaW5TaGFwZUluZm9zLFxuICAgIG91dFNoYXBlSW5mb1xuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUJpbmFyeUFuZFByb2dyYW0oc2hhcGVJbmZvczogU2hhcGVJbmZvW10sIGJBcnJheXM6IE5EQXJyYXlbXSkge1xuICBzaGFwZUluZm9zLmZvckVhY2goKHMsIGkpID0+IHtcbiAgICBjb25zdCBzaGFwZUEgPSBzLmxvZ2ljYWxTaGFwZTtcbiAgICBjb25zdCB0ZXhTaGFwZUEgPSBzLnRleFNoYXBlO1xuICAgIGNvbnN0IHNoYXBlQiA9IGJBcnJheXNbaV0uc2hhcGU7XG4gICAgY29uc3QgdGV4U2hhcGVCID0gYkFycmF5c1tpXS5nZXRUZXh0dXJlU2hhcGVSQygpO1xuXG4gICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKHNoYXBlQSwgc2hhcGVCKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgc2hhcGVzIHRoYW4gYCArXG4gICAgICAgICAgYHRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlcyAke3NoYXBlQX0gYW5kICR7c2hhcGVCfSBtdXN0IG1hdGNoYCk7XG4gICAgfVxuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbCh0ZXhTaGFwZUEsIHRleFNoYXBlQikpIHtcbiAgICAgIHRocm93IEVycm9yKGBCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHRleHR1cmUgc2hhcGVzIHRoYW4gdGhlYCArXG4gICAgICAgICAgYCBjdXJyZW50IGFyZ3MuIFNoYXBlICR7dGV4U2hhcGVBfSBhbmQgJHt0ZXhTaGFwZUJ9IG11c3QgbWF0Y2hgKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVuUHJvZ3JhbTxUIGV4dGVuZHMgTkRBcnJheSwgSyBleHRlbmRzIE5EQXJyYXk+KFxuICAgIGJpbmFyeTogR1BHUFVCaW5hcnksIGlucHV0czogVFtdLCBvdXRwdXQ6IEspOiB2b2lkIHtcbiAgdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKGJpbmFyeS5pblNoYXBlSW5mb3MsIGlucHV0cyk7XG4gIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShbYmluYXJ5Lm91dFNoYXBlSW5mb10sIFtvdXRwdXRdKTtcblxuICBjb25zdCBvdXRUZXggPSBvdXRwdXQuZ2V0VGV4dHVyZSgpO1xuICBjb25zdCBvdXRUZXhTaGFwZSA9IG91dHB1dC5nZXRUZXh0dXJlU2hhcGVSQygpO1xuICBjb25zdCBncGdwdSA9IGJpbmFyeS5ncGdwdTtcbiAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShvdXRUZXgsIG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSk7XG4gIGdwZ3B1LnNldFByb2dyYW0oYmluYXJ5LndlYkdMUHJvZ3JhbSk7XG4gIGlucHV0cy5mb3JFYWNoKChpbnB1dCwgaSkgPT4ge1xuICAgIGNvbnN0IHRleCA9IGlucHV0LmdldFRleHR1cmUoKTtcbiAgICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUodGV4LCBiaW5hcnkucHJvZ3JhbS52YXJpYWJsZU5hbWVzW2ldLCBpKTtcbiAgfSk7XG4gIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlU2hhZGVyS2V5KFxuICAgIHByb2dyYW06IEdQR1BVUHJvZ3JhbSwgaW5wdXRzOiBOREFycmF5W10sXG4gICAgb3V0cHV0OiBOREFycmF5KTogc3RyaW5nIHtcbiAgY29uc3QgcGFyYW1zID0gcHJvZ3JhbS5wYXJhbXM7XG4gIGNvbnN0IGtleVN0YXJ0ID1cbiAgICAgIGlucHV0cy5jb25jYXQob3V0cHV0KS5tYXAoeCA9PiB4LnNoYXBlICsgJ18nICsgeC5nZXRUZXh0dXJlU2hhcGVSQygpKTtcbiAgY29uc3Qga2V5RW5kID0gcGFyYW1zLm1hcChwID0+IHAudG9TdHJpbmcoKSk7XG4gIGxldCBrZXkgPSBbcHJvZ3JhbS5jb25zdHJ1Y3Rvci5uYW1lXTtcbiAga2V5LnB1c2goKHByb2dyYW0uc3VwcG9ydHNCcm9hZGNhc3RpbmcgPT09IHRydWUpLnRvU3RyaW5nKCkpO1xuICBrZXkgPSBrZXkuY29uY2F0KGtleVN0YXJ0LCBrZXlFbmQpO1xuICByZXR1cm4ga2V5LmpvaW4oJ18nKTtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0ICogYXMgdGV4X3V0aWwgZnJvbSAnLi90ZXhfdXRpbCc7XG5pbXBvcnQgKiBhcyB3ZWJnbF91dGlsIGZyb20gJy4vd2ViZ2xfdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWJHTENvbnRleHRBdHRyaWJ1dGVzKCk6IFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMge1xuICByZXR1cm4ge1xuICAgIGFscGhhOiBmYWxzZSxcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG4gICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgICBkZXB0aDogZmFsc2UsXG4gICAgc3RlbmNpbDogZmFsc2UsXG4gICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdHJ1ZVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlV2ViR0xDb250ZXh0KGNhbnZhcz86IEhUTUxDYW52YXNFbGVtZW50KSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRXZWJHTENvbnRleHRBdHRyaWJ1dGVzKCk7XG4gIGxldCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICBpZiAoY2FudmFzICE9IG51bGwpIHtcbiAgICBnbCA9IHdlYmdsX3V0aWwuY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0RnJvbUNhbnZhcyhjYW52YXMsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIGdsID0gd2ViZ2xfdXRpbC5jcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHQoYXR0cmlidXRlcyk7XG4gIH1cbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCkpO1xuICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmRpc2FibGUoZ2wuQkxFTkQpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmRpc2FibGUoZ2wuRElUSEVSKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5kaXNhYmxlKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmRpc2FibGUoZ2wuU0FNUExFX0NPVkVSQUdFKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5jdWxsRmFjZShnbC5CQUNLKSk7XG4gIHJldHVybiBnbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZlcnRleFNoYWRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogV2ViR0xTaGFkZXIge1xuICBjb25zdCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIGF0dHJpYnV0ZSB2ZWMzIGNsaXBTcGFjZVBvcztcbiAgICBhdHRyaWJ1dGUgdmVjMiB1djtcbiAgICB2YXJ5aW5nIHZlYzIgcmVzdWx0VVY7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFNwYWNlUG9zLCAxKTtcbiAgICAgIHJlc3VsdFVWID0gdXY7XG4gICAgfWA7XG4gIHJldHVybiB3ZWJnbF91dGlsLmNyZWF0ZVZlcnRleFNoYWRlcihnbCwgdmVydGV4U2hhZGVyU291cmNlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZlcnRleEJ1ZmZlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogV2ViR0xCdWZmZXIge1xuICAvLyBbeCB5IHogdSB2XSAqIFt1cHBlci1sZWZ0LCBsb3dlci1sZWZ0LCB1cHBlci1yaWdodCwgbG93ZXItcmlnaHRdXG4gIGNvbnN0IHZlcnRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgIFstMSwgMSwgMCwgMCwgMSwgLTEsIC0xLCAwLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAxLCAtMSwgMCwgMSwgMF0pO1xuICByZXR1cm4gd2ViZ2xfdXRpbC5jcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXIoZ2wsIHZlcnRleEFycmF5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUluZGV4QnVmZmVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpOiBXZWJHTEJ1ZmZlciB7XG4gIC8vIE9wZW5HTCAoYW5kIFdlYkdMKSBoYXZlIFwiQ0NXID09IGZyb250XCIgd2luZGluZ1xuICBjb25zdCB0cmlhbmdsZVZlcnRleEluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDIsIDEsIDNdKTtcbiAgcmV0dXJuIHdlYmdsX3V0aWwuY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIoZ2wsIHRyaWFuZ2xlVmVydGV4SW5kaWNlcyk7XG59XG5cbmZ1bmN0aW9uIGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdChcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBudW1DaGFubmVsczogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKHdlYmdsX3V0aWwuaXNXZWJHTDJFbmFibGVkKCkpIHtcbiAgICBpZiAobnVtQ2hhbm5lbHMgPT09IDQpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgIHJldHVybiAoZ2wgYXMgYW55KS5SR0JBMzJGO1xuICAgIH1cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgcmV0dXJuIChnbCBhcyBhbnkpLlIzMkY7XG4gIH1cbiAgcmV0dXJuIGdsLlJHQkE7XG59XG5cbmZ1bmN0aW9uIGdldFRleHR1cmVGb3JtYXQoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgbnVtQ2hhbm5lbHM6IG51bWJlcik6IG51bWJlciB7XG4gIGlmICh3ZWJnbF91dGlsLmlzV2ViR0wyRW5hYmxlZCgpICYmIG51bUNoYW5uZWxzID09PSAxKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIHJldHVybiAoZ2wgYXMgYW55KS5SRUQ7XG4gIH1cbiAgcmV0dXJuIGdsLlJHQkE7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsXG4gICAgbnVtQ2hhbm5lbHM6IG51bWJlcik6IFdlYkdMVGV4dHVyZSB7XG4gIHdlYmdsX3V0aWwudmFsaWRhdGVUZXh0dXJlU2l6ZShnbCwgd2lkdGgsIGhlaWdodCk7XG4gIGNvbnN0IHRleHR1cmUgPSB3ZWJnbF91dGlsLmNyZWF0ZVRleHR1cmUoZ2wpO1xuXG4gIGNvbnN0IHRleDJkID0gZ2wuVEVYVFVSRV8yRDtcbiAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSBnZXRUZXh0dXJlSW50ZXJuYWxGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKTtcbiAgY29uc3QgZm9ybWF0ID0gZ2V0VGV4dHVyZUZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpO1xuICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYmluZFRleHR1cmUodGV4MmQsIHRleHR1cmUpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soXG4gICAgICBnbCwgKCkgPT4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soXG4gICAgICBnbCwgKCkgPT4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soXG4gICAgICBnbCwgKCkgPT4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKFxuICAgICAgZ2wsICgpID0+IGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCkpO1xuICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhcbiAgICAgIGdsLFxuICAgICAgKCkgPT4gZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICB0ZXgyZCwgMCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgZ2wuRkxPQVQsIG51bGwpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpKTtcbiAgcmV0dXJuIHRleHR1cmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXRyaXhUZXh0dXJlKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyKTogV2ViR0xUZXh0dXJlIHtcbiAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID1cbiAgICAgIHRleF91dGlsLmdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyk7XG4gIGNvbnN0IG51bUNoYW5uZWxzID0gMTtcbiAgcmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIG51bUNoYW5uZWxzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbG9yTWF0cml4VGV4dHVyZShcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCByb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlcik6IFdlYkdMVGV4dHVyZSB7XG4gIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9XG4gICAgICB0ZXhfdXRpbC5nZXRDb2xvck1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpO1xuICBjb25zdCBudW1DaGFubmVscyA9IDQ7XG4gIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyKTogV2ViR0xUZXh0dXJlIHtcbiAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID1cbiAgICAgIHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpO1xuICBjb25zdCBudW1DaGFubmVscyA9IDQ7XG4gIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgcHJvZ3JhbTogV2ViR0xQcm9ncmFtLFxuICAgIHZlcnRleEJ1ZmZlcjogV2ViR0xCdWZmZXIpIHtcbiAgY29uc3QgcG9zT2Zmc2V0ID0gMDsgICAgICAgICAgICAgICAvLyB4IGlzIHRoZSBmaXJzdCBidWZmZXIgZWxlbWVudFxuICBjb25zdCB1dk9mZnNldCA9IDMgKiA0OyAgICAgICAgICAgIC8vIHV2IGNvbWVzIGFmdGVyIFt4IHkgel1cbiAgY29uc3Qgc3RyaWRlID0gKDMgKiA0KSArICgyICogNCk7ICAvLyB4eXogKyB1diwgZWFjaCBlbnRyeSBpcyA0LWJ5dGUgZmxvYXQuXG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKFxuICAgICAgZ2wsICgpID0+IGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIpKTtcbiAgd2ViZ2xfdXRpbC5iaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlKFxuICAgICAgZ2wsIHByb2dyYW0sICdjbGlwU3BhY2VQb3MnLCB2ZXJ0ZXhCdWZmZXIsIDMsIHN0cmlkZSwgcG9zT2Zmc2V0KTtcbiAgdHJ5IHtcbiAgICB3ZWJnbF91dGlsLmJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUoXG4gICAgICAgIGdsLCBwcm9ncmFtLCAndXYnLCB2ZXJ0ZXhCdWZmZXIsIDIsIHN0cmlkZSwgdXZPZmZzZXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gUHJvZ3JhbXMgd2l0aCAxeDEgb3V0cHV0IHRleHR1cmVzIGRvbid0IHVzZSB0aGUgdXYgYXR0cmlidXRlLlxuICAgIC8vIFRoaXMgY2FuIGNhdXNlIHRoZSBzaGFkZXIgbGlua2VyIHRvIGRlYWQtc3RyaXAgaXQsIHNvIHdlIHNob3VsZG4ndFxuICAgIC8vIGNvbXBsYWluIG9yIGZhaWwgaWYgaXQncyBub3QgcHJlc2VudC5cbiAgICBpZiAoIWUuaGFzT3duUHJvcGVydHkoJ25hbWVkVmVydGV4QXR0cmlidXRlTm90Rm91bmQnKSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZShcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsXG4gICAgcGl4ZWxzOiBJbWFnZURhdGF8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50KSB7XG4gIGNvbnN0IG51bUNoYW5uZWxzID0gNDtcbiAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSBnZXRUZXh0dXJlSW50ZXJuYWxGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soXG4gICAgICBnbCxcbiAgICAgICgpID0+IGdsLnRleEltYWdlMkQoXG4gICAgICAgICAgZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIGdsLlJHQkEsIGdsLkZMT0FULCBwaXhlbHMpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpKTtcbn1cblxuZnVuY3Rpb24gdXBsb2FkRGF0YVRvVGV4dHVyZShcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsIGRhdGE6IEZsb2F0MzJBcnJheSwgbnVtQ2hhbm5lbHM6IG51bWJlcikge1xuICBjb25zdCB0ZXh0dXJlRm9ybWF0ID0gZ2V0VGV4dHVyZUZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpO1xuXG4gIHdlYmdsX3V0aWwudmFsaWRhdGVUZXh0dXJlU2l6ZShnbCwgd2lkdGgsIGhlaWdodCk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKFxuICAgICAgZ2wsXG4gICAgICAoKSA9PiBnbC50ZXhTdWJJbWFnZTJEKFxuICAgICAgICAgIGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIHRleHR1cmVGb3JtYXQsIGdsLkZMT0FULFxuICAgICAgICAgIGRhdGEpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwbG9hZE1hdHJpeFRvVGV4dHVyZShcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHJvd3M6IG51bWJlcixcbiAgICBjb2x1bW5zOiBudW1iZXIsIG1hdHJpeDogRmxvYXQzMkFycmF5LCBudW1DaGFubmVsczogbnVtYmVyKSB7XG4gIGNvbnN0IFt3LCBoXSA9XG4gICAgICB0ZXhfdXRpbC5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpO1xuXG4gIGNvbnN0IGNoYW5uZWxzUGVyVGV4dHVyZSA9XG4gICAgICBudW1DaGFubmVscyA9PT0gMSA/IHdlYmdsX3V0aWwuZ2V0Q2hhbm5lbHNQZXJUZXh0dXJlKCkgOiBudW1DaGFubmVscztcbiAgY29uc3QgdW5wYWNrZWRBcnJheSA9XG4gICAgICBuZXcgRmxvYXQzMkFycmF5KHRleF91dGlsLmdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUoXG4gICAgICAgICAgbWF0cml4Lmxlbmd0aCwgY2hhbm5lbHNQZXJUZXh0dXJlKSk7XG4gIHRleF91dGlsLmVuY29kZU1hdHJpeFRvVW5wYWNrZWRBcnJheShcbiAgICAgIG1hdHJpeCwgdW5wYWNrZWRBcnJheSwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcblxuICB1cGxvYWREYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCB3LCBoLCB1bnBhY2tlZEFycmF5LCBudW1DaGFubmVscyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgdGV4dHVyZTogV2ViR0xUZXh0dXJlLCByb3dzOiBudW1iZXIsXG4gICAgY29sdW1uczogbnVtYmVyLCBtYXRyaXg6IEZsb2F0MzJBcnJheSkge1xuICBjb25zdCBbdywgaF0gPSB0ZXhfdXRpbC5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKTtcbiAgY29uc3QgcGFja2VkUkdCQSA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICB0ZXhfdXRpbC5nZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHJvd3MsIGNvbHVtbnMpKTtcbiAgdGV4X3V0aWwuZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBKG1hdHJpeCwgcm93cywgY29sdW1ucywgcGFja2VkUkdCQSk7XG4gIGNvbnN0IG51bUNoYW5uZWxzID0gNDtcbiAgdXBsb2FkRGF0YVRvVGV4dHVyZShnbCwgdGV4dHVyZSwgdywgaCwgcGFja2VkUkdCQSwgbnVtQ2hhbm5lbHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZShcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCByb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XG4gIGNvbnN0IFt3LCBoXSA9XG4gICAgICB0ZXhfdXRpbC5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpO1xuXG4gIGNvbnN0IGNoYW5uZWxzUGVyVGV4dHVyZSA9IDQ7XG4gIGNvbnN0IHVucGFja2VkQXJyYXkgPVxuICAgICAgbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKFxuICAgICAgICAgIHJvd3MgKiBjb2x1bW5zLCBjaGFubmVsc1BlclRleHR1cmUpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soXG4gICAgICBnbCwgKCkgPT4gZ2wucmVhZFBpeGVscygwLCAwLCB3LCBoLCBnbC5SR0JBLCBnbC5GTE9BVCwgdW5wYWNrZWRBcnJheSkpO1xuXG4gIGNvbnN0IG1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkocm93cyAqIGNvbHVtbnMpO1xuICB0ZXhfdXRpbC5kZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRBcnJheShcbiAgICAgIHVucGFja2VkQXJyYXksIG1hdHJpeCwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgcmV0dXJuIG1hdHJpeDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmUoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgcm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xuICBjb25zdCBbdywgaF0gPSB0ZXhfdXRpbC5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKTtcbiAgY29uc3QgcGFja2VkUkdCQSA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICB0ZXhfdXRpbC5nZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHJvd3MsIGNvbHVtbnMpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soXG4gICAgICBnbCwgKCkgPT4gZ2wucmVhZFBpeGVscygwLCAwLCB3LCBoLCBnbC5SR0JBLCBnbC5GTE9BVCwgcGFja2VkUkdCQSkpO1xuICBjb25zdCBtYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHJvd3MgKiBjb2x1bW5zKTtcbiAgcmV0dXJuIHRleF91dGlsLmRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBKHBhY2tlZFJHQkEsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCk7XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7R1BHUFVQcm9ncmFtfSBmcm9tICcuL2dwZ3B1X21hdGgnO1xuXG5leHBvcnQgY2xhc3MgTG9nU3VtRXhwUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgcGFyYW1zOiBBcnJheTx7fT4gPSBbXTtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoYVNpemU6IG51bWJlcikge1xuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGZsb2F0IGFNYXggPSBnZXRBRmxhdCgwLjApO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7YVNpemV9OyBpKyspIHtcbiAgICAgICAgICBhTWF4ID0gbWF4KGFNYXgsIGdldEFGbGF0KGZsb2F0KGkpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmbG9hdCBleHBTdW0gPSAwLjA7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHthU2l6ZX07IGkrKykge1xuICAgICAgICAgIGV4cFN1bSArPSBleHAoZ2V0QUZsYXQoZmxvYXQoaSkpIC0gYU1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRPdXRwdXQoYU1heCArIGxvZyhleHBTdW0pKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIGNvbnZfdXRpbCBmcm9tICcuLi9jb252X3V0aWwnO1xuaW1wb3J0IHtHUEdQVUNvbnRleHR9IGZyb20gJy4vZ3BncHVfY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlck1heFBvb2xCYWNrcHJvcChcbiAgICBkeVNoYXBlUkNEOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGZTaXplOiBudW1iZXIsIG9yaWdTdHJpZGU6IG51bWJlcixcbiAgICBvcmlnUGFkOiBudW1iZXIpIHtcbiAgY29uc3Qgb3JpZ0lucHV0RGVwdGggPSBkeVNoYXBlUkNEWzJdO1xuICBjb25zdCBwYWQgPSBmU2l6ZSAtIDEgLSBvcmlnUGFkO1xuICBjb25zdCBbZHlSb3dzLCBkeUNvbHMsIGRlcHRoXSA9IGR5U2hhcGVSQ0Q7XG5cbiAgY29uc3QgZHlUZXhTaGFwZVJDID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRChkeVNoYXBlUkNEKTtcblxuICByZXR1cm4gYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBkeTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBtYXhQb3M7XG5cbiAgICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xuICAgIGNvbnN0IHZlYzIgZHlTaGFwZUNSID0gdmVjMigke2R5VGV4U2hhcGVSQ1sxXX0sICR7ZHlUZXhTaGFwZVJDWzBdfSk7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIGR4VGV4Q1IgPSBmbG9vcihnbF9GcmFnQ29vcmQueHkpO1xuXG4gICAgICAvLyBNYXAgZnJvbSAyRCAoZHhUZXhSLCBkeFRleEMpIHRvIDNEIChkeFIsIGR4QywgZCkuXG4gICAgICBmbG9hdCBkeFIgPSBkeFRleENSLnk7XG4gICAgICBmbG9hdCBkeEMgPSBmbG9vcihkeFRleENSLnggLyAke29yaWdJbnB1dERlcHRofS4wKTtcbiAgICAgIGZsb2F0IGQgPSBtb2QoZHhUZXhDUi54LCAke29yaWdJbnB1dERlcHRofS4wKTtcblxuICAgICAgdmVjMiBkeVJDQ29ybmVyID0gdmVjMihkeFIsIGR4QykgLSB2ZWMyKCR7cGFkfS4wLCAke3BhZH0uMCk7XG4gICAgICBmbG9hdCBkeVJDb3JuZXIgPSBkeVJDQ29ybmVyLng7XG4gICAgICBmbG9hdCBkeUNDb3JuZXIgPSBkeVJDQ29ybmVyLnk7XG5cbiAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHlSLCBkeEMsIGQpLlxuICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7ZlNpemV9OyB3UisrKSB7XG4gICAgICAgIGZsb2F0IHdSX2Zsb2F0ID0gZmxvYXQod1IpO1xuICAgICAgICBmbG9hdCBkeVIgPSAoZHlSQ29ybmVyICsgd1JfZmxvYXQpIC8gJHtvcmlnU3RyaWRlfS4wO1xuICAgICAgICAvLyBUT0RPKG5zdGhvcmF0KTogU3BsaWNlIHRoaXMgd2l0aCBhbm90aGVyIHZlcnNpb24gd2hlcmUgeW91IGNhbGxcbiAgICAgICAgLy8gZ2V0TWF0cml4VmFsdWVPclplcm9QYWQoKS4gSGVyZSBhbmQgYmVsb3cuXG4gICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZHlSb3dzfS4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsb2F0IGR5VGV4UiA9IGR5UjtcblxuICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHtmU2l6ZX07IHdDKyspIHtcbiAgICAgICAgICBmbG9hdCB3Q19mbG9hdCA9IGZsb2F0KHdDKTtcbiAgICAgICAgICBmbG9hdCBkeUMgPSAoZHlDQ29ybmVyICsgd0NfZmxvYXQpIC8gJHtvcmlnU3RyaWRlfS4wO1xuICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7ZHlDb2xzfS4wIHx8IGZyYWN0KGR5QykgPiAwLjApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZsb2F0IGR5VGV4QyA9IGR5QyAqICR7ZGVwdGh9LjAgKyBkO1xuXG4gICAgICAgICAgLy8gUmVhZCBkeShkeVIsIGR5QywgZCkuXG4gICAgICAgICAgdmVjMiBkeVVWID0gKHZlYzIoZHlUZXhDLCBkeVRleFIpICsgaGFsZkNSKSAvIGR5U2hhcGVDUjtcbiAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gdGV4dHVyZTJEKGR5LCBkeVVWKS5yO1xuXG4gICAgICAgICAgLy8gUmVhZCBtYXhQb3MoZHlSLCBkeUMsIGQpLlxuICAgICAgICAgIGZsb2F0IG1heFBvc1ZhbHVlID1cbiAgICAgICAgICAgICAgJHtmU2l6ZSAqIGZTaXplIC0gMX0uMCAtIHRleHR1cmUyRChtYXhQb3MsIGR5VVYpLnI7XG5cbiAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUsIGNoZWNrIGl0IGFnYWluc3QgdGhlIHZhbHVlIGZyb20gdGhlXG4gICAgICAgICAgLy8gcG9zaXRpb24gbWF0cml4LlxuICAgICAgICAgIGZsb2F0IGN1clBvc1ZhbHVlID0gd1JfZmxvYXQgKiAke2ZTaXplfS4wICsgd0NfZmxvYXQ7XG4gICAgICAgICAgZmxvYXQgbWFzayA9IGZsb2F0KG1heFBvc1ZhbHVlID09IGN1clBvc1ZhbHVlID8gMS4wIDogMC4wKTtcblxuICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIG1hc2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZG90UHJvZCwgMCwgMCwgMCk7XG4gICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXhQb29sQmFja3Byb3AoXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgcHJvZ3JhbTogV2ViR0xQcm9ncmFtLCBkeVRleDogV2ViR0xUZXh0dXJlLFxuICAgIG1heFBvc2l0aW9uc1RleDogV2ViR0xUZXh0dXJlLCByZXN1bHRUZXg6IFdlYkdMVGV4dHVyZSxcbiAgICByZXN1bHRUZXhTaGFwZVJDOiBbbnVtYmVyLCBudW1iZXJdKSB7XG4gIGdwZ3B1LnNldE91dHB1dE1hdHJpeFRleHR1cmUoXG4gICAgICByZXN1bHRUZXgsIHJlc3VsdFRleFNoYXBlUkNbMF0sIHJlc3VsdFRleFNoYXBlUkNbMV0pO1xuICBncGdwdS5zZXRQcm9ncmFtKHByb2dyYW0pO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUoZHlUZXgsICdkeScsIDApO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUobWF4UG9zaXRpb25zVGV4LCAnbWF4UG9zJywgMSk7XG4gIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL2dwZ3B1X2NvbnRleHQnO1xuaW1wb3J0ICogYXMgcG9vbF9ncHUgZnJvbSAnLi9wb29sX2dwdSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlck1heFBvb2xQb3NpdGlvbnNTb3VyY2UoXG4gICAgeFNoYXBlUkNEOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLFxuICAgIHBhZDogbnVtYmVyKSB7XG4gIHJldHVybiBnZXRGcmFnbWVudFNoYWRlck1heFBvb2xDb21tb25Tb3VyY2UoXG4gICAgICB4U2hhcGVSQ0QsIGZTaXplLCBzdHJpZGUsIHBhZCwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlck1heFBvb2xTb3VyY2UoXG4gICAgeFNoYXBlUkNEOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLFxuICAgIHBhZDogbnVtYmVyKSB7XG4gIHJldHVybiBnZXRGcmFnbWVudFNoYWRlck1heFBvb2xDb21tb25Tb3VyY2UoXG4gICAgICB4U2hhcGVSQ0QsIGZTaXplLCBzdHJpZGUsIHBhZCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlck1heFBvb2xDb21tb25Tb3VyY2UoXG4gICAgeFNoYXBlUkNEOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLFxuICAgIHBhZDogbnVtYmVyLCBjb21wdXRlTWF4UG9zaXRpb25zOiBib29sZWFuKSB7XG4gIHJldHVybiBwb29sX2dwdS5nZXRGcmFnbWVudFNoYWRlclBvb2xDb21tb25Tb3VyY2UoXG4gICAgICB4U2hhcGVSQ0QsIGZTaXplLCBzdHJpZGUsIHBhZCwgJ21heCcsIGNvbXB1dGVNYXhQb3NpdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF4UG9vbENvbW1vbihcbiAgICBncGdwdTogR1BHUFVDb250ZXh0LCBwcm9ncmFtOiBXZWJHTFByb2dyYW0sIHg6IFdlYkdMVGV4dHVyZSxcbiAgICByZXN1bHQ6IFdlYkdMVGV4dHVyZSwgcmVzdWx0U2hhcGVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgcG9vbF9ncHUucG9vbENvbW1vbihncGdwdSwgcHJvZ3JhbSwgeCwgcmVzdWx0LCByZXN1bHRTaGFwZVJvd0NvbCk7XG59IiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi9ncGdwdV9jb250ZXh0JztcbmltcG9ydCAqIGFzIHBvb2xfZ3B1IGZyb20gJy4vcG9vbF9ncHUnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJNaW5Qb29sU291cmNlKFxuICAgIHhTaGFwZVJDRDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlcixcbiAgICBwYWQ6IG51bWJlcikge1xuICByZXR1cm4gcG9vbF9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJQb29sQ29tbW9uU291cmNlKFxuICAgICAgeFNoYXBlUkNELCBmU2l6ZSwgc3RyaWRlLCBwYWQsICdtaW4nLCBmYWxzZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaW5Qb29sKFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgeDogV2ViR0xUZXh0dXJlLFxuICAgIHJlc3VsdDogV2ViR0xUZXh0dXJlLCByZXN1bHRTaGFwZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSkge1xuICBwb29sX2dwdS5wb29sQ29tbW9uKGdwZ3B1LCBwcm9ncmFtLCB4LCByZXN1bHQsIHJlc3VsdFNoYXBlUm93Q29sKTtcbn0iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7R1BHUFVQcm9ncmFtfSBmcm9tICcuL2dwZ3B1X21hdGgnO1xuXG5leHBvcnQgY2xhc3MgTWluTWF4UHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgcGFyYW1zOiBBcnJheTx7fT47XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGFTaXplOiBudW1iZXIsIG9wVHlwZTogJ21pbid8J21heCcpIHtcbiAgICB0aGlzLnBhcmFtcyA9IFtvcFR5cGVdO1xuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0QUZsYXQoMC4wKTtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2FTaXplfTsgaSsrKSB7XG4gICAgICAgICAgZmxvYXQgY2FuZGlkYXRlID0gZ2V0QUZsYXQoZmxvYXQoaSkpO1xuICAgICAgICAgIGlmIChpc05hTihjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICBzZXRPdXRwdXQoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSAke29wVHlwZX0odmFsdWUsIGNhbmRpZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7TWF0cml4T3JpZW50YXRpb259IGZyb20gJy4uL21hdGgnO1xuaW1wb3J0IHtHUEdQVVByb2dyYW19IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbmV4cG9ydCBjbGFzcyBNYXRNdWxQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsnbWF0cml4QScsICdtYXRyaXhCJ107XG4gIHBhcmFtczogQXJyYXk8e30+O1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoYVNoYXBlOiBbbnVtYmVyLCBudW1iZXJdLCBiU2hhcGU6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBhT3JpZW50ID0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUixcbiAgICAgIGJPcmllbnQgPSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSB7XG4gICAgdGhpcy5wYXJhbXMgPSBbYU9yaWVudCwgYk9yaWVudF07XG5cbiAgICBjb25zdCBvdXRlclNoYXBlQSA9XG4gICAgICAgIChhT3JpZW50ID09PSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGFTaGFwZVswXSA6IGFTaGFwZVsxXTtcbiAgICBjb25zdCBvdXRlclNoYXBlQiA9XG4gICAgICAgIChiT3JpZW50ID09PSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGJTaGFwZVsxXSA6IGJTaGFwZVswXTtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gW291dGVyU2hhcGVBLCBvdXRlclNoYXBlQl07XG5cbiAgICBjb25zdCBzaGFyZWREaW0gPVxuICAgICAgKGFPcmllbnQgPT09IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIgPyBhU2hhcGVbMV0gOiBhU2hhcGVbMF0pO1xuICAgIGNvbnN0IGFTbmlwcGV0ID0gKGFPcmllbnQgPT09IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID9cbiAgICAgICAgJ2FSb3csIGlfZmxvYXQnIDogJ2lfZmxvYXQsIGFSb3cnO1xuICAgIGNvbnN0IGJTbmlwcGV0ID0gKGJPcmllbnQgPT09IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID9cbiAgICAgICAgJ2lfZmxvYXQsIGJDb2wnIDogJ2JDb2wsIGlfZmxvYXQnO1xuXG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgIGNvbnN0IGludCBzaGFyZWREaW0gPSAke3NoYXJlZERpbX07XG5cbiAgICAgIGZsb2F0IGRvdEFSb3dCQ29sKGZsb2F0IGFSb3csIGZsb2F0IGJDb2wpIHtcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gMC4wO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHNoYXJlZERpbTsgaSsrKSB7XG4gICAgICAgICAgZmxvYXQgaV9mbG9hdCA9IGZsb2F0KGkpO1xuICAgICAgICAgIGZsb2F0IGEgPSBnZXRNYXRyaXhBKCR7YVNuaXBwZXR9KTtcbiAgICAgICAgICBmbG9hdCBiID0gZ2V0TWF0cml4Qigke2JTbmlwcGV0fSk7XG4gICAgICAgICAgcmVzdWx0ICs9IChhICogYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWMyIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIHNldE91dHB1dChkb3RBUm93QkNvbChyZXNSQy54LCByZXNSQy55KSk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuXG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIGNvbnZfdXRpbCBmcm9tICcuLi9jb252X3V0aWwnO1xuaW1wb3J0IHtHUEdQVUNvbnRleHR9IGZyb20gJy4vZ3BncHVfY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlclBvb2xDb21tb25Tb3VyY2UoXG4gICAgeFNoYXBlUkNEOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLFxuICAgIHBhZDogbnVtYmVyLCBwb29sVHlwZTogJ21heCd8J21pbid8J2F2ZycsIGNvbXB1dGVQb3NpdGlvbnM6IGJvb2xlYW4pIHtcbiAgaWYgKHBvb2xUeXBlID09PSAnYXZnJyAmJiBjb21wdXRlUG9zaXRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcHV0ZSBwb3NpdGlvbnMgZm9yIGF2ZXJhZ2UgcG9vbC4nKTtcbiAgfVxuXG4gIGNvbnN0IGRlcHRoID0geFNoYXBlUkNEWzJdO1xuXG4gIGNvbnN0IHhUZXhTaGFwZVJDID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRCh4U2hhcGVSQ0QpO1xuXG4gIGxldCByZXR1cm5WYWx1ZSA9ICdtaW5NYXhWYWx1ZSc7XG4gIGlmIChjb21wdXRlUG9zaXRpb25zKSB7XG4gICAgcmV0dXJuVmFsdWUgPSAnbWluTWF4UG9zaXRpb24nO1xuICB9IGVsc2UgaWYgKHBvb2xUeXBlID09PSAnYXZnJykge1xuICAgIHJldHVyblZhbHVlID0gJ2F2Z1ZhbHVlJztcbiAgfVxuXG4gIHJldHVybiBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHg7XG4gICAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xuXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcbiAgICBjb25zdCB2ZWMyIHhTaGFwZUNSID0gdmVjMigke3hUZXhTaGFwZVJDWzFdfSwgJHt4VGV4U2hhcGVSQ1swXX0pO1xuXG4gICAgYm9vbCBpc05hTihmbG9hdCB2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgPT0gdmFsID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzIgeVRleENSID0gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnh5KTtcblxuICAgICAgLy8gTWFwIGZyb20gMkQgKHlUZXhSLCB5VGV4QykgdG8gM0QgKHlSLCB5QywgZDIpLlxuICAgICAgZmxvYXQgeVIgPSB5VGV4Q1IueTtcbiAgICAgIGZsb2F0IHlDID0gZmxvb3IoeVRleENSLnggLyAke2RlcHRofS4wKTtcbiAgICAgIGZsb2F0IGQgPSBtb2QoeVRleENSLngsICR7ZGVwdGh9LjApO1xuXG4gICAgICB2ZWMyIHhSQ0Nvcm5lciA9IHZlYzIoeVIsIHlDKSAqIHZlYzIoJHtzdHJpZGV9LCAke3N0cmlkZX0pIC1cbiAgICAgICAgICB2ZWMyKCR7cGFkfS4wLCAke3BhZH0uMCk7XG4gICAgICBmbG9hdCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xuICAgICAgZmxvYXQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcblxuICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXG4gICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxuICAgICAgZmxvYXQgbWluTWF4VmFsdWUgPSAwLjA7XG4gICAgICBmbG9hdCBtaW5NYXhWYWx1ZUZvdW5kID0gMC4wO1xuICAgICAgZmxvYXQgbWluTWF4UG9zaXRpb24gPSAwLjA7XG4gICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcblxuICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7ZlNpemV9OyB3UisrKSB7XG4gICAgICAgIGZsb2F0IHdSX2Zsb2F0ID0gZmxvYXQod1IpO1xuICAgICAgICBmbG9hdCB4UiA9IHhSQ29ybmVyICsgd1JfZmxvYXQ7XG4gICAgICAgIGZsb2F0IHhUZXhSID0geFI7XG5cbiAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZlNpemV9OyB3QysrKSB7XG4gICAgICAgICAgZmxvYXQgd0NfZmxvYXQgPSBmbG9hdCh3Qyk7XG4gICAgICAgICAgZmxvYXQgeEMgPSB4Q0Nvcm5lciArIHdDX2Zsb2F0O1xuICAgICAgICAgIGZsb2F0IHhUZXhDID0geEMgKiAke2RlcHRofS4wICsgZDtcblxuICAgICAgICAgIHZlYzIgdGV4Q1IgPSB2ZWMyKHhUZXhDLCB4VGV4Uik7XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcmVxdWVzdGVkIFVWIGlzIGludmFsaWQuXG4gICAgICAgICAgdmVjMiB1diA9ICh0ZXhDUiArIGhhbGZDUikgLyB4U2hhcGVDUjtcbiAgICAgICAgICBib29sIGxlc3NUaGFuWmVybyA9IGFueShsZXNzVGhhbih1diwgdmVjMigwLCAwKSkpO1xuICAgICAgICAgIGJvb2wgZ3JlYXRlclRoYW5PbmUgPSBhbnkoZ3JlYXRlclRoYW4odXYsIHZlYzIoMSwgMSkpKTtcbiAgICAgICAgICBib29sIG91dHNpZGUgPSBsZXNzVGhhblplcm8gfHwgZ3JlYXRlclRoYW5PbmU7XG4gICAgICAgICAgaWYgKG91dHNpZGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gdGV4dHVyZTJEKHgsIHV2KS5yO1xuICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmFsdWUsIDAsIDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJHtwb29sVHlwZSA9PT0gJ2F2Zyd9KSB7XG4gICAgICAgICAgICBhdmdWYWx1ZSArPSB2YWx1ZSAvICR7ZlNpemUgKiBmU2l6ZX0uMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYSBtaW4gLyBtYXggdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgdXNlIGl0LiBJZiBub3QsIHVzZVxuICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAgICBmbG9hdCBjdXJyZW50TWluTWF4VmFsdWUgPSBtaXgoXG4gICAgICAgICAgICAgICAgdmFsdWUsIG1pbk1heFZhbHVlLCBtaW5NYXhWYWx1ZUZvdW5kKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAke3Bvb2xUeXBlID09PSAnbWluJyA/ICc8PScgOiAnPj0nfSBjdXJyZW50TWluTWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgbWluTWF4VmFsdWVGb3VuZCA9IDEuMDtcbiAgICAgICAgICAgICAgaWYgKCR7Y29tcHV0ZVBvc2l0aW9uc30pIHtcbiAgICAgICAgICAgICAgICBtaW5NYXhQb3NpdGlvbiA9IHdSX2Zsb2F0ICogJHtmU2l6ZX0uMCArIHdDX2Zsb2F0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCR7cmV0dXJuVmFsdWV9LCAwLCAwLCAwKTtcbiAgICB9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvb2xDb21tb24oXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgcHJvZ3JhbTogV2ViR0xQcm9ncmFtLCB4OiBXZWJHTFRleHR1cmUsXG4gICAgcmVzdWx0OiBXZWJHTFRleHR1cmUsIHJlc3VsdFNoYXBlUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdKSB7XG4gIGdwZ3B1LnNldE91dHB1dE1hdHJpeFRleHR1cmUoXG4gICAgICByZXN1bHQsIHJlc3VsdFNoYXBlUm93Q29sWzBdLCByZXN1bHRTaGFwZVJvd0NvbFsxXSk7XG4gIGdwZ3B1LnNldFByb2dyYW0ocHJvZ3JhbSk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZSh4LCAneCcsIDApO1xuICBncGdwdS5leGVjdXRlUHJvZ3JhbSgpO1xufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0dQR1BVUHJvZ3JhbX0gZnJvbSAnLi9ncGdwdV9tYXRoJztcblxuZXhwb3J0IGNsYXNzIFJlZHVjZVN1bVByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWydBJ107XG4gIHBhcmFtczogQXJyYXk8e30+ID0gW107XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBhU2l6ZTogbnVtYmVyKSB7XG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZmxvYXQgc3VtID0gMC4wO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7YVNpemV9OyBpKyspIHtcbiAgICAgICAgICBzdW0gKz0gZ2V0QUZsYXQoZmxvYXQoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChzdW0pO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtHUEdQVUNvbnRleHR9IGZyb20gJy4vZ3BncHVfY29udGV4dCc7XG5cbmltcG9ydCAqIGFzIHdlYmdsX3V0aWwgZnJvbSAnLi93ZWJnbF91dGlsJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbmRlclJHQlNoYWRlcihcbiAgICBncGdwdTogR1BHUFVDb250ZXh0LCBkZXN0aW5hdGlvbldpZHRoOiBudW1iZXIpOiBXZWJHTFByb2dyYW0ge1xuICBjb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgc291cmNlO1xuICAgIHZhcnlpbmcgdmVjMiByZXN1bHRVVjtcblxuICAgIGNvbnN0IGZsb2F0IGRlc3RpbmF0aW9uV2lkdGggPSAke2Rlc3RpbmF0aW9uV2lkdGh9LjA7XG4gICAgY29uc3QgZmxvYXQgYSA9IDEuMDtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIGZsb2F0IHhyID0gZmxvb3IocmVzdWx0VVYucyAqIGRlc3RpbmF0aW9uV2lkdGgpICogMy4wO1xuICAgICAgdmVjMyB4ID0geHIgKyB2ZWMzKDAsIDEsIDIpO1xuXG4gICAgICBmbG9hdCBzb3VyY2VXaWR0aCA9IGRlc3RpbmF0aW9uV2lkdGggKiAzLjA7XG4gICAgICB2ZWMzIHUgPSAoeCArIDAuNSkgLyBzb3VyY2VXaWR0aDtcbiAgICAgIGZsb2F0IHYgPSAxLjAgLSByZXN1bHRVVi50O1xuXG4gICAgICBmbG9hdCByID0gdGV4dHVyZTJEKHNvdXJjZSwgdmVjMih1WzBdLCB2KSkucjtcbiAgICAgIGZsb2F0IGcgPSB0ZXh0dXJlMkQoc291cmNlLCB2ZWMyKHVbMV0sIHYpKS5yO1xuICAgICAgZmxvYXQgYiA9IHRleHR1cmUyRChzb3VyY2UsIHZlYzIodVsyXSwgdikpLnI7XG5cbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQociwgZywgYiwgYSk7XG4gICAgfWA7XG5cbiAgcmV0dXJuIGdwZ3B1LmNyZWF0ZVByb2dyYW0oZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyVG9DYW52YXMoXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgcmVuZGVyU2hhZGVyOiBXZWJHTFByb2dyYW0sIHNvdXJjZVRleDogV2ViR0xUZXh0dXJlKSB7XG4gIHdlYmdsX3V0aWwuYmluZENhbnZhc1RvRnJhbWVidWZmZXIoZ3BncHUuZ2wpO1xuICByZW5kZXJUb0ZyYW1lYnVmZmVyKGdwZ3B1LCByZW5kZXJTaGFkZXIsIHNvdXJjZVRleCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJUb0ZyYW1lYnVmZmVyKFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHJlbmRlclNoYWRlcjogV2ViR0xQcm9ncmFtLCBzb3VyY2VUZXg6IFdlYkdMVGV4dHVyZSkge1xuICBncGdwdS5zZXRQcm9ncmFtKHJlbmRlclNoYWRlcik7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShzb3VyY2VUZXgsICdzb3VyY2UnLCAwKTtcbiAgZ3BncHUuZXhlY3V0ZVByb2dyYW0oKTtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL2dwZ3B1X2NvbnRleHQnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgbWF0cml4QTtcbiAgICB1bmlmb3JtIHZlYzIgaW5wdXREaW1DUjtcbiAgICB1bmlmb3JtIHZlYzIgcmVzdWx0RGltQ1I7XG4gICAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xuICAgIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIHJlc3VsdENSID0gZmxvb3IocmVzdWx0VVYgKiByZXN1bHREaW1DUik7XG4gICAgICAvLyBpbmRleEluRmxhdCA9IHJvdyAqIHN0cmlkZSArIGNvbHVtbiwgd2hlcmUgc3RyaWRlID09IG51bU91dHB1dENvbHVtbnNcbiAgICAgIGZsb2F0IGluZGV4SW5GbGF0ID0gcmVzdWx0Q1IueSAqIHJlc3VsdERpbUNSLnggKyByZXN1bHRDUi54O1xuXG4gICAgICB2ZWMyIGlucHV0Q1IgPSB2ZWMyKFxuICAgICAgICBtb2QoaW5kZXhJbkZsYXQsIGlucHV0RGltQ1IueCksIC8vIGNvbCA9IGluZGV4SW5GbGF0ICUgbnVtSW5wdXRDb2x1bW5zXG4gICAgICAgIGZsb29yKGluZGV4SW5GbGF0IC8gaW5wdXREaW1DUi54KSAvLyByb3cgPSBpbmRleEluRmxhdCAvIG51bUlucHV0Q29sdW1uc1xuICAgICAgKSArIGhhbGZDUjtcblxuICAgICAgdmVjMiBpbnB1dFVWID0gaW5wdXRDUiAvIGlucHV0RGltQ1I7XG4gICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQobWF0cml4QSwgaW5wdXRVVik7XG4gICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNoYXBlKFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHJlc2hhcGVQcm9ncmFtOiBXZWJHTFByb2dyYW0sIGE6IFdlYkdMVGV4dHVyZSxcbiAgICBhTnVtUm93czogbnVtYmVyLCBhTnVtQ29sczogbnVtYmVyLCByZXN1bHQ6IFdlYkdMVGV4dHVyZSxcbiAgICByZXN1bHROdW1Sb3dzOiBudW1iZXIsIHJlc3VsdE51bUNvbHM6IG51bWJlcikge1xuICBjb25zdCBpbnB1dFNpemUgPSBhTnVtUm93cyAqIGFOdW1Db2xzO1xuICBjb25zdCBvdXRwdXRTaXplID0gcmVzdWx0TnVtQ29scyAqIHJlc3VsdE51bVJvd3M7XG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgaW5wdXRTaXplID09PSBvdXRwdXRTaXplLFxuICAgICAgYFRoZSBpbnB1dCBzaXplICgke2lucHV0U2l6ZX0pIGFuZCBvdXRwdXQgc2l6ZSAoJHtvdXRwdXRTaXplfSkgYCArXG4gICAgICAgICAgYG11c3QgbWF0Y2hgKTtcblxuICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKHJlc3VsdCwgcmVzdWx0TnVtUm93cywgcmVzdWx0TnVtQ29scyk7XG4gIGdwZ3B1LnNldFByb2dyYW0ocmVzaGFwZVByb2dyYW0pO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUoYSwgJ21hdHJpeEEnLCAwKTtcblxuICBjb25zdCBpbnB1dERpbUNSTG9jYXRpb24gPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24oJ2lucHV0RGltQ1InKTtcbiAgZ3BncHUuZ2wudW5pZm9ybTJmKGlucHV0RGltQ1JMb2NhdGlvbiwgYU51bUNvbHMsIGFOdW1Sb3dzKTtcblxuICBjb25zdCByZXN1bHREaW1DUkxvY2F0aW9uID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKCdyZXN1bHREaW1DUicpO1xuICBncGdwdS5nbC51bmlmb3JtMmYocmVzdWx0RGltQ1JMb2NhdGlvbiwgcmVzdWx0TnVtQ29scywgcmVzdWx0TnVtUm93cyk7XG5cbiAgZ3BncHUuZXhlY3V0ZVByb2dyYW0oKTtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0ICogYXMgY29udl91dGlsIGZyb20gJy4uL2NvbnZfdXRpbCc7XG5cbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL2dwZ3B1X2NvbnRleHQnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoXG4gICAgaW5wdXRTaGFwZVJDRDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgIG91dHB1dERpbWVuc2lvbnNSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sIGFsaWduQ29ybmVyczogYm9vbGVhbik6IHN0cmluZyB7XG4gIGNvbnN0IGRlcHRoID0gaW5wdXRTaGFwZVJDRFsyXTtcblxuICBjb25zdCBpbnB1dFRleFNoYXBlUkMgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKGlucHV0U2hhcGVSQ0QpO1xuXG4gIGNvbnN0IGVmZmVjdGl2ZUlucHV0U2hhcGVSQ0QgPSBhbGlnbkNvcm5lcnMgP1xuICAgICAgW2lucHV0U2hhcGVSQ0RbMF0gLSAxLCBpbnB1dFNoYXBlUkNEWzFdIC0gMSwgZGVwdGhdIDpcbiAgICAgIGlucHV0U2hhcGVSQ0Q7XG5cbiAgY29uc3QgZWZmZWN0aXZlT3V0cHV0U2hhcGVSQ0QgPSBhbGlnbkNvcm5lcnMgP1xuICAgICAgW291dHB1dERpbWVuc2lvbnNSb3dDb2xbMF0gLSAxLCBvdXRwdXREaW1lbnNpb25zUm93Q29sWzFdIC0gMSwgZGVwdGhdIDpcbiAgICAgIFtvdXRwdXREaW1lbnNpb25zUm93Q29sWzBdLCBvdXRwdXREaW1lbnNpb25zUm93Q29sWzFdLCBkZXB0aF07XG5cbiAgcmV0dXJuIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgbWF0cml4QTtcbiAgICB2YXJ5aW5nIHZlYzIgcmVzdWx0VVY7XG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcblxuICAgIGNvbnN0IHZlYzIgaW5wdXRTaGFwZUNSID0gdmVjMigke2lucHV0U2hhcGVSQ0RbMV19LCAke2lucHV0U2hhcGVSQ0RbMF19KTtcbiAgICBjb25zdCB2ZWMyIGlucHV0U2hhcGVUZXhDUiA9IHZlYzIoXG4gICAgICAgICR7aW5wdXRUZXhTaGFwZVJDWzFdfSwgJHtpbnB1dFRleFNoYXBlUkNbMF19KTtcblxuICAgIGNvbnN0IHZlYzIgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9DUiA9IHZlYzIoXG4gICAgICAgICR7ZWZmZWN0aXZlSW5wdXRTaGFwZVJDRFsxXSAvIGVmZmVjdGl2ZU91dHB1dFNoYXBlUkNEWzFdfSxcbiAgICAgICAgJHtlZmZlY3RpdmVJbnB1dFNoYXBlUkNEWzBdIC8gZWZmZWN0aXZlT3V0cHV0U2hhcGVSQ0RbMF19KTtcblxuICAgIGZsb2F0IHNhbXBsZUlucHV0KGZsb2F0IGNvbCwgZmxvYXQgcm93LCBmbG9hdCBkKSB7XG4gICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sICogJHtkZXB0aH0uMCArIGQsIHJvdykgKyBoYWxmQ1IpIC8gaW5wdXRTaGFwZVRleENSO1xuICAgICAgcmV0dXJuIHRleHR1cmUyRChtYXRyaXhBLCB1dikucjtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIHlUZXhDUiA9IGZsb29yKGdsX0ZyYWdDb29yZC54eSk7XG5cbiAgICAgIC8vIE1hcCBmcm9tIDJEICh5VGV4UiwgeVRleEMpIHRvIDNEICh5UiwgeUMsIGQpLlxuICAgICAgdmVjMiB5Q1IgPSB2ZWMyKGZsb29yKHlUZXhDUi54IC8gJHtkZXB0aH0uMCksIHlUZXhDUi55KTtcbiAgICAgIGZsb2F0IGQgPSBtb2QoeVRleENSLngsICR7ZGVwdGh9LjApO1xuXG4gICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cbiAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4Q1IgPSB5Q1IgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb0NSO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cbiAgICAgIHZlYzIgc291cmNlRmxvb3JDUiA9IGZsb29yKHNvdXJjZUZyYWNJbmRleENSKTtcbiAgICAgIHZlYzIgc291cmNlQ2VpbENSID0gbWluKGlucHV0U2hhcGVDUiAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhDUikpO1xuXG4gICAgICBmbG9hdCB0b3BMZWZ0ID0gc2FtcGxlSW5wdXQoc291cmNlRmxvb3JDUlswXSwgc291cmNlRmxvb3JDUlsxXSwgZCk7XG4gICAgICBmbG9hdCBib3R0b21MZWZ0ID0gc2FtcGxlSW5wdXQoc291cmNlRmxvb3JDUlswXSwgc291cmNlQ2VpbENSWzFdLCBkKTtcbiAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gc2FtcGxlSW5wdXQoc291cmNlQ2VpbENSWzBdLCBzb3VyY2VGbG9vckNSWzFdLCBkKTtcbiAgICAgIGZsb2F0IGJvdHRvbVJpZ2h0ID0gc2FtcGxlSW5wdXQoc291cmNlQ2VpbENSWzBdLCBzb3VyY2VDZWlsQ1JbMV0sIGQpO1xuXG4gICAgICB2ZWMyIGZyYWNDUiA9IHNvdXJjZUZyYWNJbmRleENSIC0gc291cmNlRmxvb3JDUjtcblxuICAgICAgZmxvYXQgdG9wID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogZnJhY0NSWzBdO1xuICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY0NSWzBdO1xuICAgICAgZmxvYXQgbmV3VmFsdWUgPSB0b3AgKyAoYm90dG9tIC0gdG9wKSAqIGZyYWNDUlsxXTtcblxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChuZXdWYWx1ZSwgMC4wLCAwLjAsIDAuMCk7XG4gICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNpemVCaWxpbmVhcihcbiAgICBncGdwdTogR1BHUFVDb250ZXh0LCByZXNpemVCaWxpbmVhclByb2dyYW06IFdlYkdMUHJvZ3JhbSwgYTogV2ViR0xUZXh0dXJlLFxuICAgIHJlc3VsdDogV2ViR0xUZXh0dXJlLCByZXN1bHRTaGFwZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSkge1xuICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKFxuICAgICAgcmVzdWx0LCByZXN1bHRTaGFwZVJvd0NvbFswXSwgcmVzdWx0U2hhcGVSb3dDb2xbMV0pO1xuICBncGdwdS5zZXRQcm9ncmFtKHJlc2l6ZUJpbGluZWFyUHJvZ3JhbSk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShhLCAnbWF0cml4QScsIDApO1xuICBncGdwdS5leGVjdXRlUHJvZ3JhbSgpO1xufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uLy4uL3V0aWwnO1xuXG5leHBvcnQgdHlwZSBTaGFwZUluZm8gPSB7XG4gIGxvZ2ljYWxTaGFwZTogbnVtYmVyW10sXG4gIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdO1xufTtcblxuZXhwb3J0IHR5cGUgSW5wdXRJbmZvID0ge1xuICBuYW1lOiBzdHJpbmcsXG4gIHNoYXBlSW5mbzogU2hhcGVJbmZvXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVNoYWRlcihpbnB1dHNJbmZvOiBJbnB1dEluZm9bXSwgb3V0cHV0U2hhcGU6IFNoYXBlSW5mbyxcbiAgICB1c2VyQ29kZTogc3RyaW5nLCBicm9hZGNhc3Q6IGJvb2xlYW4pOiBzdHJpbmcge1xuICBjb25zdCBpbnB1dFByZWZpeFNuaXBwZXQgPVxuICAgICAgaW5wdXRzSW5mby5tYXAoeCA9PiBgdW5pZm9ybSBzYW1wbGVyMkQgJHt4Lm5hbWV9O2ApLmpvaW4oJ1xcbicpO1xuICBjb25zdCBpbnB1dFNhbXBsaW5nU25pcHBldCA9XG4gICAgICBpbnB1dHNJbmZvLm1hcCh4ID0+IGdldElucHV0U2FtcGxpbmdTbmlwcGV0KHgsIG91dHB1dFNoYXBlLCBicm9hZGNhc3QpKVxuICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgY29uc3Qgb3V0VGV4U2hhcGUgPSBvdXRwdXRTaGFwZS50ZXhTaGFwZTtcbiAgY29uc3Qgb3V0cHV0U2FtcGxpbmdTbmlwcGV0ID1cbiAgICAgIGdldE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRTaGFwZS5sb2dpY2FsU2hhcGUsIG91dFRleFNoYXBlKTtcbiAgY29uc3Qgc291cmNlID0gW1xuICAgIFNIQURFUl9QUkVGSVgsIGlucHV0UHJlZml4U25pcHBldCwgU0FNUExFXzFEX1NOSVBQRVQsIFNBTVBMRV8yRF9TTklQUEVULFxuICAgIFNBTVBMRV8zRF9TTklQUEVULCBTQU1QTEVfNERfU05JUFBFVCwgaW5wdXRTYW1wbGluZ1NuaXBwZXQsXG4gICAgb3V0cHV0U2FtcGxpbmdTbmlwcGV0LCB1c2VyQ29kZVxuICBdLmpvaW4oJ1xcbicpO1xuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBnZXRJbnB1dFNhbXBsaW5nU25pcHBldChcbiAgICBpbkluZm86IElucHV0SW5mbywgb3V0U2hhcGVJbmZvOiBTaGFwZUluZm8sIGJyb2FkY2FzdDogYm9vbGVhbikge1xuICBjb25zdCBzaGFwZSA9IGluSW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICBjb25zdCB0ZXhTaGFwZSA9IGluSW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gIGNvbnN0IG91dFRleFNoYXBlID0gb3V0U2hhcGVJbmZvLnRleFNoYXBlO1xuXG4gIGxldCByZXMgPSAnJztcbiAgc3dpdGNoIChzaGFwZS5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXMgKz0gZ2V0U2FtcGxlclNjYWxhcihpbkluZm8ubmFtZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICByZXMgKz0gZ2V0U2FtcGxlcjFEKGluSW5mby5uYW1lLCB0ZXhTaGFwZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICByZXMgKz0gZ2V0U2FtcGxlcjJEKGluSW5mby5uYW1lLCBzaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICByZXMgKz0gZ2V0U2FtcGxlcjNEKFxuICAgICAgICAgIGluSW5mby5uYW1lLCBzaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIHJlcyArPSBnZXRTYW1wbGVyNEQoXG4gICAgICAgICAgaW5JbmZvLm5hbWUsIHNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke3NoYXBlLmxlbmd0aH0tRCBpbnB1dCBzYW1wbGluZ2AgK1xuICAgICAgICAgIGAgaXMgbm90IHlldCBzdXBwb3J0ZWRgKTtcbiAgfVxuICAvLyBJZiBpbnB1dCBhbmQgb3V0cHV0IGhhdmUgbWF0Y2hpbmcgbG9naWNhbCBzaGFwZXMsIGFkZFxuICAvLyBnZXRUZXhOYW1lQXRPdXRDb29yZCgpIG1ldGhvZCB0aGF0IHNhbXBsZXMgdGhlIGlucHV0IHRleHR1cmUgdXNpbmcgdGhlXG4gIC8vIG91dHB1dCBjb29yZGluYXRlcy5cbiAgaWYgKGJyb2FkY2FzdCB8fCB1dGlsLmFycmF5c0VxdWFsKFxuICAgICAgICAgIGluSW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLCBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlKSkge1xuICAgIHJlcyArPVxuICAgICAgICBnZXRTYW1wbGVyQXRPdXRwdXRDb29yZHMoaW5JbmZvLm5hbWUsIHRleFNoYXBlLCBvdXRUZXhTaGFwZSwgYnJvYWRjYXN0KTtcbiAgfVxuICByZXMgKz0gZ2V0U2FtcGxlckZsYXQoaW5JbmZvLm5hbWUsIHRleFNoYXBlKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KFxuICAgIG91dFNoYXBlOiBudW1iZXJbXSwgb3V0VGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcge1xuICBzd2l0Y2ggKG91dFNoYXBlLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIC8vIERvZXNuJ3QgbWFrZSBzZW5zZSB0byBjYWxsIGdldE91dHB1dENvb3JkcygpIHdoZW4gb3V0cHV0IGlzIHNjYWxhci5cbiAgICAgIHJldHVybiAnJztcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZ2V0T3V0cHV0MURDb29yZHMob3V0U2hhcGUgYXMgW251bWJlcl0sIG91dFRleFNoYXBlKTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZ2V0T3V0cHV0MkRDb29yZHMob3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSwgb3V0VGV4U2hhcGUpO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBnZXRPdXRwdXQzRENvb3JkcyhvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgICAgICAgb3V0VGV4U2hhcGUpO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBnZXRPdXRwdXQ0RENvb3JkcyhvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgICAgb3V0VGV4U2hhcGUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7b3V0U2hhcGUubGVuZ3RofS1EIG91dHB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZGApO1xuICB9XG59XG5cbmNvbnN0IFNIQURFUl9QUkVGSVggPSBgXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xuICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xuXG4gIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHZhbCkge1xuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmFsLCAwLCAwLCAwKTtcbiAgfVxuXG4gIGJvb2wgaXNOYU4oZmxvYXQgdmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PSB2YWwgPyBmYWxzZSA6IHRydWU7XG4gIH1cbmA7XG5cbmNvbnN0IFNBTVBMRV8xRF9TTklQUEVUID0gYFxuICBmbG9hdCBzYW1wbGUxRChzYW1wbGVyMkQgdGV4dHVyZSwgZmxvYXQgdGV4TnVtUiwgZmxvYXQgdGV4TnVtQywgZmxvYXQgaW5kZXgpIHtcbiAgICBmbG9hdCB0ZXhSID0gZmxvb3IoaW5kZXggLyB0ZXhOdW1DKTtcbiAgICBmbG9hdCB0ZXhDID0gbW9kKGluZGV4LCB0ZXhOdW1DKTtcbiAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbiAgICByZXR1cm4gdGV4dHVyZTJEKHRleHR1cmUsIHV2KS5yO1xuICB9XG5gO1xuXG5jb25zdCBTQU1QTEVfMkRfU05JUFBFVCA9IGBcbiAgZmxvYXQgc2FtcGxlMkQoc2FtcGxlcjJEIHRleHR1cmUsIGZsb2F0IHRleE51bVIsIGZsb2F0IHRleE51bUMsIGZsb2F0IG51bUMsXG4gICAgICBmbG9hdCByb3csIGZsb2F0IGNvbCkge1xuICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKG51bUMsIDEuMCkpO1xuICAgIGZsb2F0IHRleFIgPSBmbG9vcihpbmRleCAvIHRleE51bUMpO1xuICAgIGZsb2F0IHRleEMgPSBtb2QoaW5kZXgsIHRleE51bUMpO1xuICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xuICAgIHJldHVybiB0ZXh0dXJlMkQodGV4dHVyZSwgdXYpLnI7XG4gIH1cbmA7XG5cbmNvbnN0IFNBTVBMRV8zRF9TTklQUEVUID0gYFxuICBmbG9hdCBzYW1wbGUzRChzYW1wbGVyMkQgdGV4dHVyZSwgZmxvYXQgdGV4TnVtUiwgZmxvYXQgdGV4TnVtQywgZmxvYXQgc3RyaWRlMCxcbiAgICAgIGZsb2F0IHN0cmlkZTEsIGZsb2F0IHJvdywgZmxvYXQgY29sLCBmbG9hdCBkZXB0aCkge1xuICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsIGRlcHRoKSwgdmVjMyhzdHJpZGUwLCBzdHJpZGUxLCAxLjApKTtcbiAgICBmbG9hdCB0ZXhSID0gZmxvb3IoaW5kZXggLyB0ZXhOdW1DKTtcbiAgICBmbG9hdCB0ZXhDID0gbW9kKGluZGV4LCB0ZXhOdW1DKTtcbiAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbiAgICByZXR1cm4gdGV4dHVyZTJEKHRleHR1cmUsIHV2KS5yO1xuICB9XG5gO1xuXG5jb25zdCBTQU1QTEVfNERfU05JUFBFVCA9IGBcbiAgZmxvYXQgc2FtcGxlNEQoc2FtcGxlcjJEIHRleHR1cmUsIGZsb2F0IHRleE51bVIsIGZsb2F0IHRleE51bUMsIGZsb2F0IHN0cmlkZTAsXG4gICAgICBmbG9hdCBzdHJpZGUxLCBmbG9hdCBzdHJpZGUyLCBmbG9hdCByb3csIGZsb2F0IGNvbCwgZmxvYXQgZGVwdGgsXG4gICAgICBmbG9hdCBkZXB0aDIpIHtcbiAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcbiAgICAgICAgICAgICAgICAgICAgICB2ZWM0KHN0cmlkZTAsIHN0cmlkZTEsIHN0cmlkZTIsIDEuMCkpO1xuICAgIGZsb2F0IHRleFIgPSBmbG9vcihpbmRleCAvIHRleE51bUMpO1xuICAgIGZsb2F0IHRleEMgPSBtb2QoaW5kZXgsIHRleE51bUMpO1xuICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xuICAgIHJldHVybiB0ZXh0dXJlMkQodGV4dHVyZSwgdXYpLnI7XG4gIH1cbmA7XG5cbmZ1bmN0aW9uIGdldE91dHB1dDFEQ29vcmRzKFxuICAgIHNoYXBlOiBbbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcge1xuICBpZiAodGV4U2hhcGVbMF0gPT09IDEpIHtcbiAgICByZXR1cm4gYFxuICAgICAgZmxvYXQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICByZXR1cm4gZmxvb3IoZ2xfRnJhZ0Nvb3JkLngpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbiAgaWYgKHRleFNoYXBlWzFdID09PSAxKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIGZsb2F0IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIGZsb29yKGdsX0ZyYWdDb29yZC55KTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG4gIHJldHVybiBgXG4gICAgZmxvYXQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgdmVjMiByZXNUZXhSQyA9IGZsb29yKGdsX0ZyYWdDb29yZC55eCk7XG4gICAgICByZXR1cm4gZG90KHJlc1RleFJDLCB2ZWMyKCR7dGV4U2hhcGVbMV19LjAsIDEuMCkpO1xuICAgIH1cbiAgYDtcbn1cblxuZnVuY3Rpb24gZ2V0T3V0cHV0M0RDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IHN0cmluZyB7XG4gIGNvbnN0IHN0cmlkZTAgPSBzaGFwZVsxXSAqIHNoYXBlWzJdO1xuICBjb25zdCBzdHJpZGUxID0gc2hhcGVbMl07XG4gIHJldHVybiBgXG4gICAgdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICB2ZWMyIHJlc1RleFJDID0gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnl4KTtcbiAgICAgIGZsb2F0IGluZGV4ID0gZG90KHJlc1RleFJDLCB2ZWMyKCR7dGV4U2hhcGVbMV19LjAsIDEuMCkpO1xuICAgICAgZmxvYXQgciA9IGZsb29yKGluZGV4IC8gJHtzdHJpZGUwfS4wKTtcbiAgICAgIGluZGV4IC09IHIgKiAke3N0cmlkZTB9LjA7XG4gICAgICBmbG9hdCBjID0gZmxvb3IoaW5kZXggLyAke3N0cmlkZTF9LjApO1xuICAgICAgZmxvYXQgZCA9IG1vZChpbmRleCwgJHtzdHJpZGUxfS4wKTtcbiAgICAgIHJldHVybiB2ZWMzKHIsIGMsIGQpO1xuICAgIH1cbiAgYDtcbn1cblxuZnVuY3Rpb24gZ2V0T3V0cHV0NERDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IHN0cmluZyB7XG4gIGNvbnN0IHN0cmlkZTIgPSBzaGFwZVszXTtcbiAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgY29uc3Qgc3RyaWRlMCA9IHNoYXBlWzFdICogc3RyaWRlMTtcbiAgcmV0dXJuIGBcbiAgICB2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIHZlYzIgcmVzVGV4UkMgPSBmbG9vcihnbF9GcmFnQ29vcmQueXgpO1xuICAgICAgZmxvYXQgaW5kZXggPSBkb3QocmVzVGV4UkMsIHZlYzIoJHt0ZXhTaGFwZVsxXX0uMCwgMS4wKSk7XG5cbiAgICAgIGZsb2F0IHIgPSBmbG9vcihpbmRleCAvICR7c3RyaWRlMH0uMCk7XG4gICAgICBpbmRleCAtPSByICogJHtzdHJpZGUwfS4wO1xuXG4gICAgICBmbG9hdCBjID0gZmxvb3IoaW5kZXggLyAke3N0cmlkZTF9LjApO1xuICAgICAgaW5kZXggLT0gYyAqICR7c3RyaWRlMX0uMDtcblxuICAgICAgZmxvYXQgZCA9IGZsb29yKGluZGV4IC8gJHtzdHJpZGUyfS4wKTtcbiAgICAgIGZsb2F0IGQyID0gbW9kKGluZGV4LCAke3N0cmlkZTJ9LjApO1xuXG4gICAgICByZXR1cm4gdmVjNChyLCBjLCBkLCBkMik7XG4gICAgfVxuICBgO1xufVxuXG5mdW5jdGlvbiBnZXRPdXRwdXQyRENvb3JkcyhcbiAgICBzaGFwZTogW251bWJlciwgbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcge1xuICBpZiAodXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIHZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICByZXR1cm4gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnl4KTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG4gIHJldHVybiBgXG4gICAgdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICB2ZWMyIHJlc1RleFJDID0gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnl4KTtcbiAgICAgIGZsb2F0IGluZGV4ID0gZG90KHJlc1RleFJDLCB2ZWMyKCR7dGV4U2hhcGVbMV19LjAsIDEuMCkpO1xuICAgICAgZmxvYXQgciA9IGZsb29yKGluZGV4IC8gJHtzaGFwZVsxXX0uMCk7XG4gICAgICBmbG9hdCBjID0gbW9kKGluZGV4LCAke3NoYXBlWzFdfS4wKTtcbiAgICAgIHJldHVybiB2ZWMyKHIsIGMpO1xuICAgIH1cbiAgYDtcbn1cblxuZnVuY3Rpb24gZ2V0U2FtcGxlclNjYWxhcih0ZXhOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gIHJldHVybiBgXG4gICAgZmxvYXQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICByZXR1cm4gdGV4dHVyZTJEKCR7dGV4TmFtZX0sIGhhbGZDUikucjtcbiAgICB9XG4gIGA7XG59XG5cbmZ1bmN0aW9uIGdldFNhbXBsZXIxRChcbiAgICB0ZXhOYW1lOiBzdHJpbmcsIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nIHtcbiAgY29uc3QgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICBjb25zdCB0UiA9IHRleFNoYXBlWzBdO1xuICBjb25zdCB0QyA9IHRleFNoYXBlWzFdO1xuICBpZiAodGV4U2hhcGVbMF0gPT09IDEgJiYgdGV4U2hhcGVbMV0gPT09IDEpIHtcbiAgICByZXR1cm4gYFxuICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oZmxvYXQgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRleHR1cmUyRCgke3RleE5hbWV9LCBoYWxmQ1IpLnI7XG4gICAgICB9XG4gICAgYDtcbiAgfVxuICBpZiAodGV4U2hhcGVbMV0gPT09IDEpIHtcbiAgICByZXR1cm4gYFxuICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oZmxvYXQgaW5kZXgpIHtcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoaW5kZXggKyAwLjUpIC8gJHt0Un0uMCk7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlMkQoJHt0ZXhOYW1lfSwgdXYpLnI7XG4gICAgICB9XG4gICAgYDtcbiAgfVxuICBpZiAodGV4U2hhcGVbMF0gPT09IDEpIHtcbiAgICByZXR1cm4gYFxuICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oZmxvYXQgaW5kZXgpIHtcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoKGluZGV4ICsgMC41KSAvICR7dEN9LjAsIDAuNSk7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlMkQoJHt0ZXhOYW1lfSwgdXYpLnI7XG4gICAgICB9XG4gICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgIGZsb2F0ICR7ZnVuY05hbWV9KGZsb2F0IGluZGV4KSB7XG4gICAgICByZXR1cm4gc2FtcGxlMUQoJHt0ZXhOYW1lfSwgJHt0Un0uMCwgJHt0Q30uMCwgaW5kZXgpO1xuICAgIH1cbiAgYDtcbn1cblxuZnVuY3Rpb24gZ2V0U2FtcGxlcjNEKFxuICAgIHRleE5hbWU6IHN0cmluZywgc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IHN0cmluZyB7XG4gIGNvbnN0IGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgY29uc3QgdFIgPSB0ZXhTaGFwZVswXTtcbiAgY29uc3QgdEMgPSB0ZXhTaGFwZVsxXTtcbiAgY29uc3Qgc3RyaWRlMCA9IHNoYXBlWzFdICogc2hhcGVbMl07XG4gIGNvbnN0IHN0cmlkZTEgPSBzaGFwZVsyXTtcbiAgcmV0dXJuIGBcbiAgICBmbG9hdCAke2Z1bmNOYW1lfShmbG9hdCByb3csIGZsb2F0IGNvbCwgZmxvYXQgZGVwdGgpIHtcbiAgICAgIHJldHVybiBzYW1wbGUzRCgke3RleE5hbWV9LCAke3RSfS4wLCAke3RDfS4wLCAke3N0cmlkZTB9LjAsICR7c3RyaWRlMX0uMCxcbiAgICAgICAgICByb3csIGNvbCwgZGVwdGgpO1xuICAgIH1cbiAgYDtcbn1cblxuZnVuY3Rpb24gZ2V0U2FtcGxlcjREKFxuICAgIHRleE5hbWU6IHN0cmluZywgc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nIHtcbiAgY29uc3QgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICBjb25zdCB0UiA9IHRleFNoYXBlWzBdO1xuICBjb25zdCB0QyA9IHRleFNoYXBlWzFdO1xuICBjb25zdCBzdHJpZGUyID0gc2hhcGVbM107XG4gIGNvbnN0IHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gIGNvbnN0IHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG5cbiAgcmV0dXJuIGBcbiAgZmxvYXQgJHtmdW5jTmFtZX0oZmxvYXQgcm93LCBmbG9hdCBjb2wsIGZsb2F0IGRlcHRoLCBmbG9hdCBkZXB0aDIpIHtcbiAgICByZXR1cm4gc2FtcGxlNEQoJHt0ZXhOYW1lfSwgJHt0Un0uMCwgJHt0Q30uMCwgJHtzdHJpZGUwfS4wLCAke3N0cmlkZTF9LjAsXG4gICAgICAgICR7c3RyaWRlMn0uMCwgcm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpO1xuICB9XG5gO1xufVxuXG5mdW5jdGlvbiBnZXRTYW1wbGVyMkQoXG4gICAgdGV4TmFtZTogc3RyaW5nLCBzaGFwZTogW251bWJlciwgbnVtYmVyXSxcbiAgICB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IHN0cmluZyB7XG4gIGNvbnN0IGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgY29uc3QgdFIgPSB0ZXhTaGFwZVswXTtcbiAgY29uc3QgdEMgPSB0ZXhTaGFwZVsxXTtcbiAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoc2hhcGUsIHRleFNoYXBlKSkge1xuICAgIHJldHVybiBgXG4gICAgICBmbG9hdCAke2Z1bmNOYW1lfShmbG9hdCByb3csIGZsb2F0IGNvbCkge1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoJHt0Q30uMCwgJHt0Un0uMCk7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlMkQoJHt0ZXhOYW1lfSwgdXYpLnI7XG4gICAgICB9XG4gICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgIGZsb2F0ICR7ZnVuY05hbWV9KGZsb2F0IHJvdywgZmxvYXQgY29sKSB7XG4gICAgICByZXR1cm4gc2FtcGxlMkQoJHt0ZXhOYW1lfSwgJHt0Un0uMCwgJHt0Q30uMCwgJHtzaGFwZVsxXX0uMCwgcm93LCBjb2wpO1xuICAgIH1cbiAgYDtcbn1cblxuZnVuY3Rpb24gZ2V0U2FtcGxlckZsYXQodGV4TmFtZTogc3RyaW5nLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IHN0cmluZyB7XG4gIGNvbnN0IGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKSArXG4gICAgICAnRmxhdCc7XG4gIGNvbnN0IHROdW1SID0gdGV4U2hhcGVbMF07XG4gIGNvbnN0IHROdW1DID0gdGV4U2hhcGVbMV07XG4gIGlmICh0TnVtQyA9PT0gMSAmJiB0TnVtUiA9PT0gMSkge1xuICAgIHJldHVybiBgXG4gICAgICBmbG9hdCAke2Z1bmNOYW1lfShmbG9hdCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGV4dHVyZTJEKCR7dGV4TmFtZX0sIGhhbGZDUikucjtcbiAgICAgIH1cbiAgICBgO1xuICB9XG4gIGlmICh0TnVtQyA9PT0gMSkge1xuICAgIHJldHVybiBgXG4gICAgICBmbG9hdCAke2Z1bmNOYW1lfShmbG9hdCBpbmRleCkge1xuICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChpbmRleCArIDAuNSkgLyAke3ROdW1SfS4wKTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmUyRCgke3RleE5hbWV9LCB1dikucjtcbiAgICAgIH1cbiAgICBgO1xuICB9XG4gIGlmICh0TnVtUiA9PT0gMSkge1xuICAgIHJldHVybiBgXG4gICAgICBmbG9hdCAke2Z1bmNOYW1lfShmbG9hdCBpbmRleCkge1xuICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHt0TnVtQ30uMCwgMC41KTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmUyRCgke3RleE5hbWV9LCB1dikucjtcbiAgICAgIH1cbiAgICBgO1xuICB9XG4gIHJldHVybiBgXG4gICAgZmxvYXQgJHtmdW5jTmFtZX0oZmxvYXQgaW5kZXgpIHtcbiAgICAgIGZsb2F0IHRleFIgPSBmbG9vcihpbmRleCAvICR7dE51bUN9LjApO1xuICAgICAgZmxvYXQgdGV4QyA9IG1vZChpbmRleCwgJHt0TnVtQ30uMCk7XG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMigke3ROdW1DfS4wLCAke3ROdW1SfS4wKTtcbiAgICAgIHJldHVybiB0ZXh0dXJlMkQoJHt0ZXhOYW1lfSwgdXYpLnI7XG4gICAgfVxuICBgO1xufVxuXG5mdW5jdGlvbiBnZXRTYW1wbGVyQXRPdXRwdXRDb29yZHModGV4TmFtZTogc3RyaW5nLCBpblRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgIG91dFRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdLCBicm9hZGNhc3Q6IGJvb2xlYW4pIHtcbiAgY29uc3QgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpICtcbiAgICAnQXRPdXRDb29yZHMnO1xuICBpZiAodXRpbC5hcnJheXNFcXVhbChpblRleFNoYXBlLCBvdXRUZXhTaGFwZSkpIHtcbiAgICByZXR1cm4gYFxuICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlMkQoJHt0ZXhOYW1lfSwgcmVzdWx0VVYpLnI7XG4gICAgICB9XG4gICAgYDtcbiAgfVxuICBjb25zdCBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoaW5UZXhTaGFwZSk7XG4gIGNvbnN0IGJyb2FkY2FzdFNuaXBwZXQgPSBicm9hZGNhc3QgPyBgaW5kZXggPSBtb2QoaW5kZXgsICR7aW5TaXplfS4wKTtgIDogJyc7XG5cbiAgcmV0dXJuIGBcbiAgICBmbG9hdCAke2Z1bmNOYW1lfSgpIHtcbiAgICAgIHZlYzIgcmVzVGV4UkMgPSBmbG9vcihnbF9GcmFnQ29vcmQueXgpO1xuICAgICAgZmxvYXQgaW5kZXggPSBkb3QocmVzVGV4UkMsIHZlYzIoJHtvdXRUZXhTaGFwZVsxXX0uMCwgMS4wKSk7XG4gICAgICAke2Jyb2FkY2FzdFNuaXBwZXR9XG4gICAgICBmbG9hdCB0ZXhSID0gZmxvb3IoaW5kZXggLyAke2luVGV4U2hhcGVbMV19LjApO1xuICAgICAgZmxvYXQgdGV4QyA9IG1vZChpbmRleCwgJHtpblRleFNoYXBlWzFdfS4wKTtcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xuICAgICAgICAgICAgICAgICB2ZWMyKCR7aW5UZXhTaGFwZVsxXX0uMCwgJHtpblRleFNoYXBlWzBdfS4wKTtcbiAgICAgIHJldHVybiB0ZXh0dXJlMkQoJHt0ZXhOYW1lfSwgdXYpLnI7XG4gICAgfVxuICBgO1xufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChcbiAgICByb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0ge1xuICByZXR1cm4gW2NvbHVtbnMsIHJvd3NdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShcbiAgICBtYXRyaXhTaXplOiBudW1iZXIsIGNoYW5uZWxzUGVyVGV4dHVyZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIG1hdHJpeFNpemUgKiBjaGFubmVsc1BlclRleHR1cmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xvck1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KFxuICAgIHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSB7XG4gIHJldHVybiBbY29sdW1ucyAqIDQsIHJvd3NdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF0cml4U2l6ZUZyb21VbnBhY2tlZEFycmF5U2l6ZShcbiAgICB1bnBhY2tlZFNpemU6IG51bWJlciwgY2hhbm5lbHNQZXJUZXh0dXJlOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAodW5wYWNrZWRTaXplICUgY2hhbm5lbHNQZXJUZXh0dXJlICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAndW5wYWNrZWRTaXplICgnICsgdW5wYWNrZWRTaXplICsgJykgbXVzdCBiZSBhIG11bHRpcGxlIG9mICcgK1xuICAgICAgICBjaGFubmVsc1BlclRleHR1cmUpO1xuICB9XG4gIHJldHVybiB1bnBhY2tlZFNpemUgLyBjaGFubmVsc1BlclRleHR1cmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXkoXG4gICAgbWF0cml4OiBGbG9hdDMyQXJyYXksIHVucGFja2VkQXJyYXk6IEZsb2F0MzJBcnJheSxcbiAgICBjaGFubmVsc1BlclRleHR1cmU6IG51bWJlcikge1xuICBjb25zdCByZXF1aXJlZFNpemUgPVxuICAgICAgZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShtYXRyaXgubGVuZ3RoLCBjaGFubmVsc1BlclRleHR1cmUpO1xuICBpZiAodW5wYWNrZWRBcnJheS5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICd1bnBhY2tlZEFycmF5IGxlbmd0aCAoJyArIHVucGFja2VkQXJyYXkubGVuZ3RoICtcbiAgICAgICAgJykgbXVzdCBiZSA+PSAnICsgcmVxdWlyZWRTaXplKTtcbiAgfVxuICBsZXQgZHN0ID0gMDtcbiAgZm9yIChsZXQgc3JjID0gMDsgc3JjIDwgbWF0cml4Lmxlbmd0aDsgKytzcmMpIHtcbiAgICB1bnBhY2tlZEFycmF5W2RzdF0gPSBtYXRyaXhbc3JjXTtcbiAgICBkc3QgKz0gY2hhbm5lbHNQZXJUZXh0dXJlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRBcnJheShcbiAgICB1bnBhY2tlZEFycmF5OiBGbG9hdDMyQXJyYXksIG1hdHJpeDogRmxvYXQzMkFycmF5LFxuICAgIGNoYW5uZWxzUGVyVGV4dHVyZTogbnVtYmVyKSB7XG4gIGNvbnN0IHJlcXVpcmVkU2l6ZSA9IGdldE1hdHJpeFNpemVGcm9tVW5wYWNrZWRBcnJheVNpemUoXG4gICAgICB1bnBhY2tlZEFycmF5Lmxlbmd0aCwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgaWYgKG1hdHJpeC5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdtYXRyaXggbGVuZ3RoICgnICsgbWF0cml4Lmxlbmd0aCArICcpIG11c3QgYmUgPj0gJyArIHJlcXVpcmVkU2l6ZSk7XG4gIH1cbiAgbGV0IGRzdCA9IDA7XG4gIGZvciAobGV0IHNyYyA9IDA7IHNyYyA8IHVucGFja2VkQXJyYXkubGVuZ3RoOyBzcmMgKz0gY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgbWF0cml4W2RzdCsrXSA9IHVucGFja2VkQXJyYXlbc3JjXTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQoXG4gICAgcm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgcmV0dXJuIFtNYXRoLmNlaWwoY29sdW1ucyAvIDIpLCBNYXRoLmNlaWwocm93cyAvIDIpXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUoXG4gICAgcm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBbdywgaF0gPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKTtcbiAgcmV0dXJuIHcgKiBoICogNDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZU1hdHJpeFRvUGFja2VkUkdCQShcbiAgICBtYXRyaXg6IEZsb2F0MzJBcnJheSwgcm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIsXG4gICAgcGFja2VkUkdCQTogRmxvYXQzMkFycmF5KSB7XG4gIGNvbnN0IHJlcXVpcmVkU2l6ZSA9IGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUocm93cywgY29sdW1ucyk7XG4gIGlmIChwYWNrZWRSR0JBLmxlbmd0aCA8IHJlcXVpcmVkU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3BhY2tlZFJHQkEgbGVuZ3RoICgnICsgcGFja2VkUkdCQS5sZW5ndGggK1xuICAgICAgICAnKSBtdXN0IGJlID49ICcgKyByZXF1aXJlZFNpemUpO1xuICB9XG4gIC8qXG4gICAgVW5wYWNrZWQgbWF0cml4LCByb3ctbWFqb3Igb3JkZXIgaW4gRmxvYXQzMkFycmF5WzE2XTogIEEgQiBDIERcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRSBGIEcgSFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJIEogSyBMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE0gTiBPIFBcblxuICAgIFBhY2tlZCBtYXRyaXgsIDJ4MiBSR0JBMzIgdGV4dHVyZSAobWVtb3J5IHZpZXcpOiAgICAgICBBQkVGIENER0ggSUpNTiBLTE9QXG5cbiAgICBQYWNrZWQgbWF0cml4LCAyeDIgUkdCQTMyIHRleHR1cmUgKG1hdHJpeCB2aWV3KTogICAgICAgQUJ8Q0RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRUZ8R0hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0rLS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSUp8S0xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTU58T1BcbiAgICovXG4gIGNvbnN0IFt0ZXh0dXJlV2lkdGgsIHRleHR1cmVIZWlnaHRdID1cbiAgICAgIGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpO1xuICBjb25zdCBvZGRXaWR0aCA9IChjb2x1bW5zICUgMikgPT09IDE7XG4gIGNvbnN0IG9kZEhlaWdodCA9IChyb3dzICUgMikgPT09IDE7XG4gIGNvbnN0IHdpZHRoSW5GdWxsQmxvY2tzID0gTWF0aC5mbG9vcihjb2x1bW5zIC8gMik7XG4gIGNvbnN0IGhlaWdodEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3Iocm93cyAvIDIpO1xuXG4gIC8vIGxvb3Agb3ZlciBmdWxsIDJ4MiBibG9ja3NcbiAge1xuICAgIGNvbnN0IGRzdFN0cmlkZSA9IChvZGRXaWR0aCA/IDQgOiAwKTtcbiAgICBjb25zdCBvbmVSb3cgPSBjb2x1bW5zO1xuICAgIGxldCBkc3QgPSAwO1xuICAgIGZvciAobGV0IGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgIGNvbnN0IG1hdHJpeFNyY1JvdyA9IChibG9ja1kgKiAyICogY29sdW1ucyk7XG4gICAgICBmb3IgKGxldCBibG9ja1ggPSAwOyBibG9ja1ggPCB3aWR0aEluRnVsbEJsb2NrczsgKytibG9ja1gpIHtcbiAgICAgICAgY29uc3QgbWF0cml4U3JjQ29sID0gYmxvY2tYICogMjtcbiAgICAgICAgY29uc3Qgc3JjID0gbWF0cml4U3JjUm93ICsgbWF0cml4U3JjQ29sO1xuICAgICAgICBwYWNrZWRSR0JBW2RzdF0gPSBtYXRyaXhbc3JjXTtcbiAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAxXSA9IG1hdHJpeFtzcmMgKyAxXTtcbiAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAyXSA9IG1hdHJpeFtzcmMgKyBvbmVSb3ddO1xuICAgICAgICBwYWNrZWRSR0JBW2RzdCArIDNdID0gbWF0cml4W3NyYyArIG9uZVJvdyArIDFdO1xuICAgICAgICBkc3QgKz0gNDtcbiAgICAgIH1cbiAgICAgIGRzdCArPSBkc3RTdHJpZGU7XG4gICAgfVxuICB9XG5cbiAgLy8gbG9vcCBkb3duIGZpbmFsIG9kZCBjb2x1bW5cbiAgaWYgKG9kZFdpZHRoKSB7XG4gICAgbGV0IHNyYyA9IGNvbHVtbnMgLSAxO1xuICAgIGxldCBkc3QgPSAodGV4dHVyZVdpZHRoIC0gMSkgKiA0O1xuICAgIGNvbnN0IHNyY1N0cmlkZSA9IDIgKiBjb2x1bW5zO1xuICAgIGNvbnN0IGRzdFN0cmlkZSA9IHRleHR1cmVXaWR0aCAqIDQ7XG4gICAgZm9yIChsZXQgYmxvY2tZID0gMDsgYmxvY2tZIDwgaGVpZ2h0SW5GdWxsQmxvY2tzOyArK2Jsb2NrWSkge1xuICAgICAgcGFja2VkUkdCQVtkc3RdID0gbWF0cml4W3NyY107XG4gICAgICBwYWNrZWRSR0JBW2RzdCArIDJdID0gbWF0cml4W3NyYyArIGNvbHVtbnNdO1xuICAgICAgc3JjICs9IHNyY1N0cmlkZTtcbiAgICAgIGRzdCArPSBkc3RTdHJpZGU7XG4gICAgfVxuICB9XG5cbiAgLy8gbG9vcCBhY3Jvc3MgZmluYWwgcm93XG4gIGlmIChvZGRIZWlnaHQpIHtcbiAgICBsZXQgc3JjID0gKHJvd3MgLSAxKSAqIGNvbHVtbnM7XG4gICAgbGV0IGRzdCA9ICh0ZXh0dXJlSGVpZ2h0IC0gMSkgKiB0ZXh0dXJlV2lkdGggKiA0O1xuICAgIGZvciAobGV0IGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgcGFja2VkUkdCQVtkc3QrK10gPSBtYXRyaXhbc3JjKytdO1xuICAgICAgcGFja2VkUkdCQVtkc3QrK10gPSBtYXRyaXhbc3JjKytdO1xuICAgICAgZHN0ICs9IDI7XG4gICAgfVxuICB9XG5cbiAgLy8gZmlsbCBpbiBib3R0b20tcmlnaHQgdGV4ZWxcbiAgaWYgKG9kZFdpZHRoICYmIG9kZEhlaWdodCkge1xuICAgIHBhY2tlZFJHQkFbcGFja2VkUkdCQS5sZW5ndGggLSA0XSA9IG1hdHJpeFttYXRyaXgubGVuZ3RoIC0gMV07XG4gIH1cblxuICByZXR1cm4gcGFja2VkUkdCQTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBKFxuICAgIHBhY2tlZFJHQkE6IEZsb2F0MzJBcnJheSwgcm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIsXG4gICAgbWF0cml4OiBGbG9hdDMyQXJyYXkpOiBGbG9hdDMyQXJyYXkge1xuICBjb25zdCByZXF1aXJlZFNpemUgPSByb3dzICogY29sdW1ucztcbiAgaWYgKHJlcXVpcmVkU2l6ZSA8IG1hdHJpeC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdtYXRyaXggbGVuZ3RoICgnICsgbWF0cml4Lmxlbmd0aCArICcpIG11c3QgYmUgPj0gJyArIHJlcXVpcmVkU2l6ZSk7XG4gIH1cbiAgY29uc3Qgb2RkV2lkdGggPSAoY29sdW1ucyAlIDIpID09PSAxO1xuICBjb25zdCBvZGRIZWlnaHQgPSAocm93cyAlIDIpID09PSAxO1xuICBjb25zdCB3aWR0aEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3IoY29sdW1ucyAvIDIpO1xuICBjb25zdCBoZWlnaHRJbkZ1bGxCbG9ja3MgPSBNYXRoLmZsb29yKHJvd3MgLyAyKTtcbiAgY29uc3QgW3RleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodF0gPVxuICAgICAgZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyk7XG5cbiAgLy8gbG9vcCBvdmVyIGZ1bGwgMngyIGJsb2Nrc1xuICB7XG4gICAgY29uc3Qgc3JjU3RyaWRlID0gb2RkV2lkdGggPyA0IDogMDtcbiAgICBjb25zdCBkc3RTdHJpZGUgPSBjb2x1bW5zICsgKG9kZFdpZHRoID8gMSA6IDApO1xuICAgIGxldCBzcmMgPSAwO1xuICAgIGxldCBkc3RSb3cxID0gMDtcbiAgICBsZXQgZHN0Um93MiA9IGNvbHVtbnM7XG4gICAgZm9yIChsZXQgYmxvY2tZID0gMDsgYmxvY2tZIDwgaGVpZ2h0SW5GdWxsQmxvY2tzOyArK2Jsb2NrWSkge1xuICAgICAgZm9yIChsZXQgYmxvY2tYID0gMDsgYmxvY2tYIDwgd2lkdGhJbkZ1bGxCbG9ja3M7ICsrYmxvY2tYKSB7XG4gICAgICAgIG1hdHJpeFtkc3RSb3cxKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgIG1hdHJpeFtkc3RSb3cxKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgIG1hdHJpeFtkc3RSb3cyKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgIG1hdHJpeFtkc3RSb3cyKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICB9XG4gICAgICBzcmMgKz0gc3JjU3RyaWRlO1xuICAgICAgZHN0Um93MSArPSBkc3RTdHJpZGU7XG4gICAgICBkc3RSb3cyICs9IGRzdFN0cmlkZTtcbiAgICB9XG4gIH1cblxuICAvLyBsb29wIGRvd24gZmluYWwgY29sdW1uXG4gIGlmIChvZGRXaWR0aCkge1xuICAgIGxldCBzcmMgPSAodGV4dHVyZVdpZHRoIC0gMSkgKiA0O1xuICAgIGxldCBkc3QgPSBjb2x1bW5zIC0gMTtcbiAgICBjb25zdCBzcmNTdHJpZGUgPSB0ZXh0dXJlV2lkdGggKiA0O1xuICAgIGNvbnN0IGRzdFN0cmlkZSA9IDIgKiBjb2x1bW5zO1xuICAgIGZvciAobGV0IGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgIG1hdHJpeFtkc3RdID0gcGFja2VkUkdCQVtzcmNdO1xuICAgICAgbWF0cml4W2RzdCArIGNvbHVtbnNdID0gcGFja2VkUkdCQVtzcmMgKyAyXTtcbiAgICAgIHNyYyArPSBzcmNTdHJpZGU7XG4gICAgICBkc3QgKz0gZHN0U3RyaWRlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGxvb3AgYWNyb3NzIGZpbmFsIHJvd1xuICBpZiAob2RkSGVpZ2h0KSB7XG4gICAgbGV0IHNyYyA9ICh0ZXh0dXJlSGVpZ2h0IC0gMSkgKiB0ZXh0dXJlV2lkdGggKiA0O1xuICAgIGxldCBkc3QgPSAocm93cyAtIDEpICogY29sdW1ucztcbiAgICBmb3IgKGxldCBibG9ja1ggPSAwOyBibG9ja1ggPCB3aWR0aEluRnVsbEJsb2NrczsgKytibG9ja1gpIHtcbiAgICAgIG1hdHJpeFtkc3QrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgIG1hdHJpeFtkc3QrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgIHNyYyArPSAyO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpbGwgaW4gYm90dG9tLXJpZ2h0IGNlbGxcbiAgaWYgKG9kZFdpZHRoICYmIG9kZEhlaWdodCkge1xuICAgIG1hdHJpeFttYXRyaXgubGVuZ3RoIC0gMV0gPSBwYWNrZWRSR0JBW3BhY2tlZFJHQkEubGVuZ3RoIC0gNF07XG4gIH1cblxuICByZXR1cm4gbWF0cml4O1xufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi9ncGdwdV9jb250ZXh0JztcblxuZXhwb3J0IGNsYXNzIFRleHR1cmVNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBudW1Vc2VkVGV4dHVyZXMgPSAwO1xuICBwcml2YXRlIG51bUZyZWVUZXh0dXJlcyA9IDA7XG4gIHByaXZhdGUgZnJlZVRleHR1cmVzOiB7W3NoYXBlOiBzdHJpbmddOiBXZWJHTFRleHR1cmVbXX0gPSB7fTtcbiAgcHJpdmF0ZSBsb2dFbmFibGVkID0gZmFsc2U7XG4gIHByaXZhdGUgdXNlZFRleHR1cmVDb3VudDoge1tzaGFwZTogc3RyaW5nXTogbnVtYmVyfSA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZ3BncHU6IEdQR1BVQ29udGV4dCkge31cblxuICBhY3F1aXJlVGV4dHVyZShzaGFwZVJDOiBbbnVtYmVyLCBudW1iZXJdKTogV2ViR0xUZXh0dXJlIHtcbiAgICBjb25zdCBzaGFwZUtleSA9IGdldEtleUZyb21UZXh0dXJlU2hhcGUoc2hhcGVSQyk7XG4gICAgaWYgKCEoc2hhcGVLZXkgaW4gdGhpcy5mcmVlVGV4dHVyZXMpKSB7XG4gICAgICB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0gPSBbXTtcbiAgICB9XG4gICAgaWYgKCEoc2hhcGVLZXkgaW4gdGhpcy51c2VkVGV4dHVyZUNvdW50KSkge1xuICAgICAgdGhpcy51c2VkVGV4dHVyZUNvdW50W3NoYXBlS2V5XSA9IDA7XG4gICAgfVxuICAgIHRoaXMudXNlZFRleHR1cmVDb3VudFtzaGFwZUtleV0rKztcblxuICAgIGlmICh0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0ubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5udW1GcmVlVGV4dHVyZXMtLTtcbiAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzKys7XG4gICAgICB0aGlzLmxvZygpO1xuICAgICAgcmV0dXJuIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XS5zaGlmdCgpITtcbiAgICB9XG4gICAgdGhpcy5udW1Vc2VkVGV4dHVyZXMrKztcbiAgICB0aGlzLmxvZygpO1xuXG4gICAgcmV0dXJuIHRoaXMuZ3BncHUuY3JlYXRlTWF0cml4VGV4dHVyZShzaGFwZVJDWzBdLCBzaGFwZVJDWzFdKTtcbiAgfVxuXG4gIHJlbGVhc2VUZXh0dXJlKHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgc2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiB2b2lkIHtcbiAgICBjb25zdCBzaGFwZUtleSA9IGdldEtleUZyb21UZXh0dXJlU2hhcGUoc2hhcGUpO1xuICAgIGlmICghKHNoYXBlS2V5IGluIHRoaXMuZnJlZVRleHR1cmVzKSkge1xuICAgICAgdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldID0gW107XG4gICAgfVxuICAgIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XS5wdXNoKHRleHR1cmUpO1xuICAgIHRoaXMubnVtRnJlZVRleHR1cmVzKys7XG4gICAgdGhpcy5udW1Vc2VkVGV4dHVyZXMtLTtcbiAgICB0aGlzLnVzZWRUZXh0dXJlQ291bnRbc2hhcGVLZXldLS07XG4gICAgdGhpcy5sb2coKTtcbiAgfVxuXG4gIHByaXZhdGUgbG9nKCkge1xuICAgIGlmICghdGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5udW1GcmVlVGV4dHVyZXMgKyB0aGlzLm51bVVzZWRUZXh0dXJlcztcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgJ0ZyZWUvVXNlZCcsIHRoaXMubnVtRnJlZVRleHR1cmVzICsgJyAvICcgKyB0aGlzLm51bVVzZWRUZXh0dXJlcyxcbiAgICAgICAgYCgke3RvdGFsfSlgKTtcbiAgfVxuXG4gIGdldE51bVVzZWRUZXh0dXJlcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm51bVVzZWRUZXh0dXJlcztcbiAgfVxuXG4gIGdldE51bUZyZWVUZXh0dXJlcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm51bUZyZWVUZXh0dXJlcztcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChjb25zdCBzaGFwZSBpbiB0aGlzLmZyZWVUZXh0dXJlcykge1xuICAgICAgaWYgKHRoaXMuZnJlZVRleHR1cmVzLmhhc093blByb3BlcnR5KHNoYXBlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZ3BncHUuZGVsZXRlTWF0cml4VGV4dHVyZSh0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZV1baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEtleUZyb21UZXh0dXJlU2hhcGUoc2hhcGVSb3dzQ29sOiBbbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nIHtcbiAgcmV0dXJuIHNoYXBlUm93c0NvbFswXSArICdfJyArIHNoYXBlUm93c0NvbFsxXTtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtHUEdQVVByb2dyYW19IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbmV4cG9ydCBlbnVtIFVuYXJ5T3Age1xuICBFWFAsIExPRywgTkVHLCBSRUxVLCBTSUdNT0lELCBTVEVQLCBTSU4sIFRBTkhcbn1cblxuZXhwb3J0IGNsYXNzIFVuYXJ5T3BQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICBwYXJhbXM6IEFycmF5PHt9PjtcbiAgdXNlckNvZGU6IHN0cmluZztcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuXG4gIGNvbnN0cnVjdG9yKGFTaGFwZTogbnVtYmVyW10sIG9wOiBVbmFyeU9wKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGFTaGFwZTtcbiAgICB0aGlzLnBhcmFtcyA9IFtvcF07XG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZmxvYXQgdiA9IGdldEFBdE91dENvb3JkcygpO1xuICAgICAgICAke2dldE9wU25pcHBldChvcCl9XG4gICAgICAgIHNldE91dHB1dChyKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE9wU25pcHBldChvcDogVW5hcnlPcCkge1xuICBzd2l0Y2gob3ApIHtcbiAgICBjYXNlIFVuYXJ5T3AuRVhQOlxuICAgICAgcmV0dXJuICdmbG9hdCByID0gZXhwKHYpOyc7XG4gICAgY2FzZSBVbmFyeU9wLkxPRzpcbiAgICAgIHJldHVybiAnZmxvYXQgciA9IGxvZyh2KTsnO1xuICAgIGNhc2UgVW5hcnlPcC5ORUc6XG4gICAgICByZXR1cm4gJ2Zsb2F0IHIgPSAtdjsnO1xuICAgIGNhc2UgVW5hcnlPcC5SRUxVOlxuICAgICAgcmV0dXJuICdmbG9hdCByID0gKHYgPCAwLjApID8gMC4wIDogdjsnO1xuICAgIGNhc2UgVW5hcnlPcC5TSUdNT0lEOlxuICAgICAgcmV0dXJuICdmbG9hdCByID0gMS4wIC8gKDEuMCArIGV4cCgtMS4wICogdikpOyc7XG4gICAgY2FzZSBVbmFyeU9wLlNURVA6XG4gICAgICByZXR1cm4gJ2Zsb2F0IHIgPSAodiA9PSB2KSA/ICh2ID4gMC4wID8gMS4wIDogMC4wKSA6IHY7JztcbiAgICBjYXNlIFVuYXJ5T3AuU0lOOlxuICAgICAgcmV0dXJuICdmbG9hdCByID0gc2luKHYpOyc7XG4gICAgY2FzZSBVbmFyeU9wLlRBTkg6XG4gICAgICByZXR1cm4gYGZsb2F0IGUyeCA9IGV4cCgtMi4wICogYWJzKHYpKTtcbiAgICAgICAgICAgICAgZmxvYXQgciA9IHNpZ24odikgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO2A7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKCdVbnJlY29nbml6ZWQgdW5hcnkgb3AgdHlwZSAnICsgb3ApO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmxldCBVU0VfV0VCR0wyX1dIRU5fQVZBSUxBQkxFID0gdHJ1ZTtcbmxldCBXRUJHTDJfRU5BQkxFRDogYm9vbGVhbnx1bmRlZmluZWQgPSBudWxsITtcbmxldCBNQVhfVEVYVFVSRV9TSVpFOiBudW1iZXIgPSBudWxsITtcblxuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi8uLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBXZWJHTENvbnRleHRBdHRyaWJ1dGVzIHtcbiAgYWxwaGE/OiBib29sZWFuO1xuICBhbnRpYWxpYXM/OiBib29sZWFuO1xuICBwcmVtdWx0aXBsaWVkQWxwaGE/OiBib29sZWFuO1xuICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI/OiBib29sZWFuO1xuICBkZXB0aD86IGJvb2xlYW47XG4gIHN0ZW5jaWw/OiBib29sZWFuO1xuICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXZWJHTExvc2VDb250ZXh0RXh0ZW5zaW9uIHsgbG9zZUNvbnRleHQoKTogdm9pZDsgfVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0KGF0dHJpYnV0ZXM6IFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMpOlxuICAgIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBjYW52YXMud2lkdGggPSAxO1xuICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgcmV0dXJuIGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMoY2FudmFzLCBhdHRyaWJ1dGVzKTtcbn1cblxuLyoqXG4gKiBGb3JjZSB0aGUgbGlicmFyeSB0byBwcmVmZXIgV2ViR0wgMS4wIGluc3RlYWQgb2YgV2ViR0wgMi4wIGV2ZW4gd2hlbiBXZWJHTFxuICogMi4wIGlzIGF2YWlsYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWZlcldlYkdMMSgpIHtcbiAgVVNFX1dFQkdMMl9XSEVOX0FWQUlMQUJMRSA9IGZhbHNlO1xuICBXRUJHTDJfRU5BQkxFRCA9IG51bGw7XG59XG5cbi8qKlxuICogUHJlZmVyIFdlYkdMIDIuMCB0byBXZWJHTCAxLjAuIFRoaXMgaXMgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWZlcldlYkdMMigpIHtcbiAgVVNFX1dFQkdMMl9XSEVOX0FWQUlMQUJMRSA9IHRydWU7XG4gIFdFQkdMMl9FTkFCTEVEID0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzV2ViR0wyRW5hYmxlZCgpIHtcbiAgaWYgKCFVU0VfV0VCR0wyX1dIRU5fQVZBSUxBQkxFKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFdFQkdMMl9FTkFCTEVEID09IG51bGwpIHtcbiAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY29uc3QgZ2wgPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicpO1xuICAgIGlmIChnbCAhPSBudWxsKSB7XG4gICAgICBXRUJHTDJfRU5BQkxFRCA9IHRydWU7XG5cbiAgICAgIGNvbnN0IGxvc2VDb250ZXh0RXh0ZW5zaW9uID1cbiAgICAgICAgICBnZXRFeHRlbnNpb25PclRocm93KFxuICAgICAgICAgICAgICBnbCBhcyBXZWJHTFJlbmRlcmluZ0NvbnRleHQsICdXRUJHTF9sb3NlX2NvbnRleHQnKSBhc1xuICAgICAgICAgIFdlYkdMTG9zZUNvbnRleHRFeHRlbnNpb247XG4gICAgICBsb3NlQ29udGV4dEV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBXRUJHTDJfRU5BQkxFRCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gV0VCR0wyX0VOQUJMRUQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzKFxuICAgIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXG4gICAgYXR0cmlidXRlczogV2ViR0xDb250ZXh0QXR0cmlidXRlcyk6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCB7XG4gIGxldCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICBpZiAoaXNXZWJHTDJFbmFibGVkKCkpIHtcbiAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBhdHRyaWJ1dGVzKSBhcyBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgZ2wgPSAoY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcykpIGFzXG4gICAgICAgIFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgfVxuXG4gIGlmIChnbCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJHTC4nKTtcbiAgfVxuICByZXR1cm4gZ2w7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsQW5kQ2hlY2s8VD4oZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgZnVuYzogKCkgPT4gVCk6IFQge1xuICBjb25zdCByZXR1cm5WYWx1ZSA9IGZ1bmMoKTtcbiAgY2hlY2tXZWJHTEVycm9yKGdsKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5sZXQgd2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZyhlbmFibGVkOiBib29sZWFuKSB7XG4gIHdlYkdMRGVidWdFcnJvckNoZWNraW5nRW5hYmxlZCA9IGVuYWJsZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1dlYkdMRXJyb3IoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCkge1xuICBpZiAod2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkKSB7XG4gICAgY29uc3QgZXJyb3IgPSBnbC5nZXRFcnJvcigpO1xuICAgIGlmIChlcnJvciAhPT0gZ2wuTk9fRVJST1IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wgRXJyb3I6ICcgKyBnZXRXZWJHTEVycm9yTWVzc2FnZShnbCwgZXJyb3IpKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFdlYkdMRXJyb3JNZXNzYWdlKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHN0YXR1czogbnVtYmVyKTogc3RyaW5nIHtcbiAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICBjYXNlIGdsLk5PX0VSUk9SOlxuICAgICAgcmV0dXJuICdOT19FUlJPUic7XG4gICAgY2FzZSBnbC5JTlZBTElEX0VOVU06XG4gICAgICByZXR1cm4gJ0lOVkFMSURfRU5VTSc7XG4gICAgY2FzZSBnbC5JTlZBTElEX1ZBTFVFOlxuICAgICAgcmV0dXJuICdJTlZBTElEX1ZBTFVFJztcbiAgICBjYXNlIGdsLklOVkFMSURfT1BFUkFUSU9OOlxuICAgICAgcmV0dXJuICdJTlZBTElEX09QRVJBVElPTic7XG4gICAgY2FzZSBnbC5JTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTjpcbiAgICAgIHJldHVybiAnSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04nO1xuICAgIGNhc2UgZ2wuT1VUX09GX01FTU9SWTpcbiAgICAgIHJldHVybiAnT1VUX09GX01FTU9SWSc7XG4gICAgY2FzZSBnbC5DT05URVhUX0xPU1RfV0VCR0w6XG4gICAgICByZXR1cm4gJ0NPTlRFWFRfTE9TVF9XRUJHTCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnVW5rbm93biBlcnJvciBjb2RlICcgKyBzdGF0dXM7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEV4dGVuc2lvbk9yVGhyb3coXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgZXh0ZW5zaW9uTmFtZTogc3RyaW5nKToge30ge1xuICByZXR1cm4gdGhyb3dJZk51bGw8e30+KFxuICAgICAgZ2wsICgpID0+IGdsLmdldEV4dGVuc2lvbihleHRlbnNpb25OYW1lKSxcbiAgICAgICdFeHRlbnNpb24gXCInICsgZXh0ZW5zaW9uTmFtZSArICdcIiBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZlcnRleFNoYWRlcihcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB2ZXJ0ZXhTaGFkZXJTb3VyY2U6IHN0cmluZyk6IFdlYkdMU2hhZGVyIHtcbiAgY29uc3QgdmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlciA9IHRocm93SWZOdWxsPFdlYkdMU2hhZGVyPihcbiAgICAgIGdsLCAoKSA9PiBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUiksXG4gICAgICAnVW5hYmxlIHRvIGNyZWF0ZSB2ZXJ0ZXggV2ViR0xTaGFkZXIuJyk7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuc2hhZGVyU291cmNlKHZlcnRleFNoYWRlciwgdmVydGV4U2hhZGVyU291cmNlKSk7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpKTtcbiAgaWYgKGdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICBjb25zb2xlLmxvZyhnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcikpO1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbXBpbGUgdmVydGV4IHNoYWRlci4nKTtcbiAgfVxuICByZXR1cm4gdmVydGV4U2hhZGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRTaGFkZXIoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IHN0cmluZyk6IFdlYkdMU2hhZGVyIHtcbiAgY29uc3QgZnJhZ21lbnRTaGFkZXI6IFdlYkdMU2hhZGVyID0gdGhyb3dJZk51bGw8V2ViR0xTaGFkZXI+KFxuICAgICAgZ2wsICgpID0+IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpLFxuICAgICAgJ1VuYWJsZSB0byBjcmVhdGUgZnJhZ21lbnQgV2ViR0xTaGFkZXIuJyk7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNoYWRlclNvdXJjZSkpO1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpKTtcbiAgaWYgKGdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgIGNvbnNvbGUubG9nKGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIGZyYWdtZW50IHNoYWRlci4nKTtcbiAgfVxuICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpOiBXZWJHTFByb2dyYW0ge1xuICByZXR1cm4gdGhyb3dJZk51bGw8V2ViR0xQcm9ncmFtPihcbiAgICAgIGdsLCAoKSA9PiBnbC5jcmVhdGVQcm9ncmFtKCksICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMUHJvZ3JhbS4nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmtQcm9ncmFtKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSkge1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pKTtcbiAgaWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpID09PSBmYWxzZSkge1xuICAgIGNvbnNvbGUubG9nKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsaW5rIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy4nKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQcm9ncmFtKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSkge1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLnZhbGlkYXRlUHJvZ3JhbShwcm9ncmFtKSk7XG4gIGlmIChnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUykgPT09IGZhbHNlKSB7XG4gICAgY29uc29sZS5sb2coZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgIHRocm93IG5ldyBFcnJvcignU2hhZGVyIHByb2dyYW0gdmFsaWRhdGlvbiBmYWlsZWQuJyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcihcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBkYXRhOiBGbG9hdDMyQXJyYXkpOiBXZWJHTEJ1ZmZlciB7XG4gIGNvbnN0IGJ1ZmZlcjogV2ViR0xCdWZmZXIgPSB0aHJvd0lmTnVsbDxXZWJHTEJ1ZmZlcj4oXG4gICAgICBnbCwgKCkgPT4gZ2wuY3JlYXRlQnVmZmVyKCksICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyJyk7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcikpO1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVykpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgZGF0YTogVWludDE2QXJyYXkpOiBXZWJHTEJ1ZmZlciB7XG4gIGNvbnN0IGJ1ZmZlcjogV2ViR0xCdWZmZXIgPSB0aHJvd0lmTnVsbDxXZWJHTEJ1ZmZlcj4oXG4gICAgICBnbCwgKCkgPT4gZ2wuY3JlYXRlQnVmZmVyKCksICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyJyk7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnVmZmVyKSk7XG4gIGNhbGxBbmRDaGVjayhcbiAgICAgIGdsLCAoKSA9PiBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVykpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlNYXhUZXh0dXJlU2l6ZShnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogbnVtYmVyIHtcbiAgaWYgKE1BWF9URVhUVVJFX1NJWkUgIT0gbnVsbCkge1xuICAgIHJldHVybiBNQVhfVEVYVFVSRV9TSVpFO1xuICB9XG4gIE1BWF9URVhUVVJFX1NJWkUgPVxuICAgICAgY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbCEuZ2V0UGFyYW1ldGVyKGdsIS5NQVhfVEVYVFVSRV9TSVpFKSk7XG4gIHJldHVybiBNQVhfVEVYVFVSRV9TSVpFO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhbm5lbHNQZXJUZXh0dXJlKCk6IG51bWJlciB7XG4gIGlmIChpc1dlYkdMMkVuYWJsZWQoKSkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiA0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogV2ViR0xUZXh0dXJlIHtcbiAgcmV0dXJuIHRocm93SWZOdWxsPFdlYkdMVGV4dHVyZT4oXG4gICAgICBnbCwgKCkgPT4gZ2wuY3JlYXRlVGV4dHVyZSgpLCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFRleHR1cmUuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVRleHR1cmVTaXplKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XG4gIGNvbnN0IG1heFRleHR1cmVTaXplOiBudW1iZXIgPSBxdWVyeU1heFRleHR1cmVTaXplKGdsKTtcbiAgaWYgKCh3aWR0aCA8PSAwKSB8fCAoaGVpZ2h0IDw9IDApKSB7XG4gICAgY29uc3QgcmVxdWVzdGVkID0gJ1snICsgd2lkdGggKyAneCcgKyBoZWlnaHQgKyAnXSc7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplICcgKyByZXF1ZXN0ZWQgKyAnIGlzIGludmFsaWQuJyk7XG4gIH1cbiAgaWYgKCh3aWR0aCA+IG1heFRleHR1cmVTaXplKSB8fCAoaGVpZ2h0ID4gbWF4VGV4dHVyZVNpemUpKSB7XG4gICAgY29uc3QgcmVxdWVzdGVkID0gJ1snICsgd2lkdGggKyAneCcgKyBoZWlnaHQgKyAnXSc7XG4gICAgY29uc3QgbWF4ID0gJ1snICsgbWF4VGV4dHVyZVNpemUgKyAneCcgKyBtYXhUZXh0dXJlU2l6ZSArICddJztcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplICcgKyByZXF1ZXN0ZWQgK1xuICAgICAgICAnIGdyZWF0ZXIgdGhhbiBXZWJHTCBtYXhpbXVtIG9uIHRoaXMgYnJvd3NlciAvIEdQVSAnICsgbWF4ICsgJy4nKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJhbWVidWZmZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCk6IFdlYkdMRnJhbWVidWZmZXIge1xuICByZXR1cm4gdGhyb3dJZk51bGw8V2ViR0xGcmFtZWJ1ZmZlcj4oXG4gICAgICBnbCwgKCkgPT4gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xGcmFtZWJ1ZmZlci4nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgcHJvZ3JhbTogV2ViR0xQcm9ncmFtLCBhdHRyaWJ1dGU6IHN0cmluZyxcbiAgICBidWZmZXI6IFdlYkdMQnVmZmVyLCBhcnJheUVudHJpZXNQZXJJdGVtOiBudW1iZXIsIGl0ZW1TdHJpZGVJbkJ5dGVzOiBudW1iZXIsXG4gICAgaXRlbU9mZnNldEluQnl0ZXM6IG51bWJlcikge1xuICBjb25zdCBsb2MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJ1dGUpO1xuICBpZiAobG9jID09PSAtMSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnVW5hYmxlIHRvIGdldCBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiIG9uIFdlYkdMUHJvZ3JhbS4nKTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgKGVycm9yIGFzIGFueSkubmFtZWRWZXJ0ZXhBdHRyaWJ1dGVOb3RGb3VuZCA9IGF0dHJpYnV0ZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpKTtcbiAgY2FsbEFuZENoZWNrKFxuICAgICAgZ2wsXG4gICAgICAoKSA9PiBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgIGxvYywgYXJyYXlFbnRyaWVzUGVySXRlbSwgZ2wuRkxPQVQsIGZhbHNlLCBpdGVtU3RyaWRlSW5CeXRlcyxcbiAgICAgICAgICBpdGVtT2Zmc2V0SW5CeXRlcykpO1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvYykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmluZFRleHR1cmVVbml0KFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgdGV4dHVyZVVuaXQ6IG51bWJlcikge1xuICB2YWxpZGF0ZVRleHR1cmVVbml0KGdsLCB0ZXh0dXJlVW5pdCk7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KSk7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5iaW5kVGV4dHVyZVVuaXQoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgdGV4dHVyZVVuaXQ6IG51bWJlcikge1xuICB2YWxpZGF0ZVRleHR1cmVVbml0KGdsLCB0ZXh0dXJlVW5pdCk7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KSk7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3coXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgcHJvZ3JhbTogV2ViR0xQcm9ncmFtLFxuICAgIHVuaWZvcm1OYW1lOiBzdHJpbmcpOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB7XG4gIHJldHVybiB0aHJvd0lmTnVsbDxXZWJHTFVuaWZvcm1Mb2NhdGlvbj4oXG4gICAgICBnbCwgKCkgPT4gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKSxcbiAgICAgICd1bmlmb3JtIFwiJyArIHVuaWZvcm1OYW1lICsgJ1wiIG5vdCBwcmVzZW50IGluIHByb2dyYW0uJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgdGV4dHVyZTogV2ViR0xUZXh0dXJlLFxuICAgIHVuaWZvcm1TYW1wbGVyTmFtZTogc3RyaW5nLCB0ZXh0dXJlVW5pdDogbnVtYmVyKSB7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gYmluZFRleHR1cmVVbml0KGdsLCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCkpO1xuICBjb25zdCBzYW1wbGVyTG9jYXRpb24gPVxuICAgICAgZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3coZ2wsIHByb2dyYW0sIHVuaWZvcm1TYW1wbGVyTmFtZSk7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wudW5pZm9ybTFpKHNhbXBsZXJMb2NhdGlvbiwgdGV4dHVyZVVuaXQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpIHtcbiAgY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpKTtcbiAgY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpKTtcbiAgY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5zY2lzc29yKDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgdGV4dHVyZTogV2ViR0xUZXh0dXJlLFxuICAgIGZyYW1lYnVmZmVyOiBXZWJHTEZyYW1lYnVmZmVyKSB7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcikpO1xuICBjYWxsQW5kQ2hlY2soXG4gICAgICBnbCxcbiAgICAgICgpID0+IGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICAgIGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGZyYW1lYnVmZmVyOiBXZWJHTEZyYW1lYnVmZmVyKSB7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcikpO1xuICBjYWxsQW5kQ2hlY2soXG4gICAgICBnbCxcbiAgICAgICgpID0+IGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICAgIGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgbnVsbCwgMCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGcmFtZWJ1ZmZlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KSB7XG4gIGNvbnN0IHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xuICBpZiAoc3RhdHVzICE9PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Vycm9yIGJpbmRpbmcgZnJhbWVidWZmZXI6ICcgKyBnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZShnbCwgc3RhdHVzKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHN0YXR1czogbnVtYmVyKTogc3RyaW5nIHtcbiAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpcbiAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UJztcbiAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOlxuICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCc7XG4gICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6XG4gICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUyc7XG4gICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpcbiAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJ3Vua25vd24gZXJyb3IgJyArIHN0YXR1cztcbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0lmTnVsbDxUPihcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCByZXR1cm5UT3JOdWxsOiAoKSA9PiBUIHwgbnVsbCxcbiAgICBmYWlsdXJlTWVzc2FnZTogc3RyaW5nKTogVCB7XG4gIGNvbnN0IHRPck51bGw6IFR8bnVsbCA9IGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gcmV0dXJuVE9yTnVsbCgpKTtcbiAgaWYgKHRPck51bGwgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihmYWlsdXJlTWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIHRPck51bGwgYXMgVDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUZXh0dXJlVW5pdChnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB0ZXh0dXJlVW5pdDogbnVtYmVyKSB7XG4gIGNvbnN0IG1heFRleHR1cmVVbml0ID0gZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMgLSAxO1xuICBjb25zdCBnbFRleHR1cmVVbml0ID0gdGV4dHVyZVVuaXQgKyBnbC5URVhUVVJFMDtcbiAgaWYgKGdsVGV4dHVyZVVuaXQgPCBnbC5URVhUVVJFMCB8fCBnbFRleHR1cmVVbml0ID4gbWF4VGV4dHVyZVVuaXQpIHtcbiAgICBjb25zdCB0ZXh0dXJlVW5pdFJhbmdlID0gJ1tnbC5URVhUVVJFMCwgZ2wuVEVYVFVSRScgKyBtYXhUZXh0dXJlVW5pdCArICddJztcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RleHR1cmVVbml0IG11c3QgYmUgaW4gJyArIHRleHR1cmVVbml0UmFuZ2UgKyAnLicpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGxvZ2ljYWxTaGFwZTogbnVtYmVyW10sXG4gICAgcHJlZmVycmVkVGV4U2hhcGU/OiBbbnVtYmVyLCBudW1iZXJdKTogW251bWJlciwgbnVtYmVyXSB7XG4gIGNvbnN0IG1heFRleFNpemUgPSBxdWVyeU1heFRleHR1cmVTaXplKGdsKTtcbiAgY29uc3Qgc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShsb2dpY2FsU2hhcGUpO1xuICBpZiAocHJlZmVycmVkVGV4U2hhcGUgIT0gbnVsbCkge1xuICAgIGNvbnN0IHNpemVQcmVmZXJyZWQgPSB1dGlsLnNpemVGcm9tU2hhcGUocHJlZmVycmVkVGV4U2hhcGUpO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBzaXplID09PSBzaXplUHJlZmVycmVkLFxuICAgICAgICBgU2l6ZSBvZiBzaGFwZSAoJHtzaXplfSkgbXVzdCBtYXRjaCBzaXplIG9mIGAgK1xuICAgICAgICAgICAgYHByZWZlcnJlZFNoYXBlICgke3NpemVQcmVmZXJyZWR9KWApO1xuICAgIGlmIChwcmVmZXJyZWRUZXhTaGFwZVswXSA8PSBtYXhUZXhTaXplICYmXG4gICAgICAgIHByZWZlcnJlZFRleFNoYXBlWzFdIDw9IG1heFRleFNpemUpIHtcbiAgICAgIHJldHVybiBwcmVmZXJyZWRUZXhTaGFwZTtcbiAgICB9XG4gIH1cblxuICBpZiAobG9naWNhbFNoYXBlLmxlbmd0aCA8PSAxICYmIHNpemUgPD0gbWF4VGV4U2l6ZSkge1xuICAgIHJldHVybiBbc2l6ZSwgMV07XG4gIH0gZWxzZSBpZiAoXG4gICAgICBsb2dpY2FsU2hhcGUubGVuZ3RoID09PSAyICYmIGxvZ2ljYWxTaGFwZVswXSA8PSBtYXhUZXhTaXplICYmXG4gICAgICBsb2dpY2FsU2hhcGVbMV0gPD0gbWF4VGV4U2l6ZSkge1xuICAgIHJldHVybiBsb2dpY2FsU2hhcGUgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgfSBlbHNlIGlmIChcbiAgICAgIGxvZ2ljYWxTaGFwZS5sZW5ndGggPT09IDMgJiYgbG9naWNhbFNoYXBlWzBdIDw9IG1heFRleFNpemUgJiZcbiAgICAgIGxvZ2ljYWxTaGFwZVsxXSAqIGxvZ2ljYWxTaGFwZVsyXSA8PSBtYXhUZXhTaXplKSB7XG4gICAgcmV0dXJuIFtsb2dpY2FsU2hhcGVbMF0sIGxvZ2ljYWxTaGFwZVsxXSAqIGxvZ2ljYWxTaGFwZVsyXV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHV0aWwuc2l6ZVRvU3F1YXJpc2hTaGFwZShzaXplKTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG5pbXBvcnQge0FkZE5vZGUsIEFyZ01heEVxdWFsc05vZGUsIEFyZ01heE5vZGUsIENvbmNhdDNETm9kZSwgQ29udm9sdXRpb24yRE5vZGUsIERpdmlkZU5vZGUsIEV4cE5vZGUsIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLCBMb2dOb2RlLCBNYXRNdWxOb2RlLCBNYXhQb29sTm9kZSwgTWVhblNxdWFyZWRDb3N0Tm9kZSwgTXVsdGlwbHlOb2RlLCBOb2RlLCBSZWR1Y2VTdW1Ob2RlLCBSZUxVTm9kZSwgUmVzaGFwZU5vZGUsIFNpZ21vaWROb2RlLCBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUsIFNvZnRtYXhOb2RlLCBTcGxpdE5vZGUsIFNxdWFyZU5vZGUsIFN1YnRyYWN0Tm9kZSwgVGFuSE5vZGV9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0ICogYXMgZ3JhcGhfdXRpbCBmcm9tICcuL2dyYXBoX3V0aWwnO1xuaW1wb3J0IHtBZGR9IGZyb20gJy4vb3BzL2FkZCc7XG5pbXBvcnQge0FyZ01heH0gZnJvbSAnLi9vcHMvYXJnbWF4JztcbmltcG9ydCB7QXJnTWF4RXF1YWxzfSBmcm9tICcuL29wcy9hcmdtYXhlcXVhbHMnO1xuaW1wb3J0IHtDb25jYXQzRH0gZnJvbSAnLi9vcHMvY29uY2F0M2QnO1xuaW1wb3J0IHtDb252b2x1dGlvbjJEfSBmcm9tICcuL29wcy9jb252b2x1dGlvbic7XG5pbXBvcnQge0RpdmlkZX0gZnJvbSAnLi9vcHMvZGl2aWRlJztcbmltcG9ydCB7UmVMVSwgU2lnbW9pZCwgU3F1YXJlLCBUYW5IfSBmcm9tICcuL29wcy9lbGVtZW50X3dpc2VfYWN0aXZhdGlvbic7XG5pbXBvcnQge01lYW5TcXVhcmVkQ29zdH0gZnJvbSAnLi9vcHMvZWxlbWVudF93aXNlX2Nvc3QnO1xuaW1wb3J0IHtFeHB9IGZyb20gJy4vb3BzL2V4cCc7XG5pbXBvcnQge0xpbmVhckNvbWJpbmF0aW9ufSBmcm9tICcuL29wcy9saW5lYXJfY29tYmluYXRpb24nO1xuaW1wb3J0IHtMb2d9IGZyb20gJy4vb3BzL2xvZyc7XG5pbXBvcnQge01hdE11bH0gZnJvbSAnLi9vcHMvbWF0bXVsJztcbmltcG9ydCB7TWF4UG9vbH0gZnJvbSAnLi9vcHMvbWF4X3Bvb2wnO1xuaW1wb3J0IHtNdWx0aXBseX0gZnJvbSAnLi9vcHMvbXVsdGlwbHknO1xuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3BzL29wJztcbmltcG9ydCB7UmVkdWNlU3VtfSBmcm9tICcuL29wcy9yZWR1Y2Vfc3VtJztcbmltcG9ydCB7UmVzaGFwZX0gZnJvbSAnLi9vcHMvcmVzaGFwZSc7XG5pbXBvcnQge1NvZnRtYXgsIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0fSBmcm9tICcuL29wcy9zb2Z0bWF4JztcbmltcG9ydCB7U3BsaXR9IGZyb20gJy4vb3BzL3NwbGl0JztcbmltcG9ydCB7U3VidHJhY3R9IGZyb20gJy4vb3BzL3N1YnRyYWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGVtaXRGcm9tR3JhcGhOb2Rlcyhub2RlczogTm9kZVtdKTogT3BlcmF0aW9uW10ge1xuICBjb25zdCBvcHM6IE9wZXJhdGlvbltdID0gW107XG4gIG5vZGVzLmZvckVhY2gobm9kZSA9PiBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvcHMsIGVtaXRPcEZyb21Ob2RlKG5vZGUpKSk7XG4gIHJldHVybiBvcHM7XG59XG5cbmZ1bmN0aW9uIGVtaXRPcEZyb21Ob2RlKG5vZGU6IE5vZGUpOiBPcGVyYXRpb25bXSB7XG4gIGlmIChub2RlIGluc3RhbmNlb2YgUmVzaGFwZU5vZGUpIHtcbiAgICByZXR1cm4gW25ldyBSZXNoYXBlKG5vZGUuaW5wdXRzW1Jlc2hhcGVOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBNYXRNdWxOb2RlKSB7XG4gICAgY29uc3QgeDEgPSBub2RlLmlucHV0c1tNYXRNdWxOb2RlLlgxXTtcbiAgICBjb25zdCB4MiA9IG5vZGUuaW5wdXRzW01hdE11bE5vZGUuWDJdO1xuICAgIHJldHVybiBbbmV3IE1hdE11bCh4MSwgeDIsIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIENvbnZvbHV0aW9uMkROb2RlKSB7XG4gICAgY29uc3QgdyA9IG5vZGUuaW5wdXRzW0NvbnZvbHV0aW9uMkROb2RlLlddO1xuICAgIGNvbnN0IHggPSBub2RlLmlucHV0c1tDb252b2x1dGlvbjJETm9kZS5YXTtcbiAgICBjb25zdCBiID0gbm9kZS5pbnB1dHNbQ29udm9sdXRpb24yRE5vZGUuQl07XG4gICAgcmV0dXJuIFtuZXcgQ29udm9sdXRpb24yRChcbiAgICAgICAgdywgeCwgYiwgbm9kZS5vdXRwdXQsIG5vZGUuZmllbGRTaXplLCBub2RlLm91dHB1dERlcHRoLCBub2RlLnN0cmlkZSxcbiAgICAgICAgbm9kZS56ZXJvUGFkKV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE1heFBvb2xOb2RlKSB7XG4gICAgY29uc3QgeCA9IG5vZGUuaW5wdXRzW01heFBvb2xOb2RlLlhdO1xuICAgIHJldHVybiBbbmV3IE1heFBvb2woXG4gICAgICAgIHgsIG5vZGUub3V0cHV0LCBub2RlLmZpZWxkU2l6ZSwgbm9kZS5zdHJpZGUsIG5vZGUuemVyb1BhZCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBFeHBOb2RlKSB7XG4gICAgcmV0dXJuIFtuZXcgRXhwKG5vZGUuaW5wdXRzW0V4cE5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIExvZ05vZGUpIHtcbiAgICByZXR1cm4gW25ldyBMb2cobm9kZS5pbnB1dHNbTG9nTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUmVMVU5vZGUpIHtcbiAgICByZXR1cm4gW25ldyBSZUxVKG5vZGUuaW5wdXRzW1JlTFVOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBUYW5ITm9kZSkge1xuICAgIHJldHVybiBbbmV3IFRhbkgobm9kZS5pbnB1dHNbVGFuSE5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFNpZ21vaWROb2RlKSB7XG4gICAgcmV0dXJuIFtuZXcgU2lnbW9pZChub2RlLmlucHV0c1tTaWdtb2lkTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlKSB7XG4gICAgY29uc3QgeCA9IG5vZGUuaW5wdXRzW1NvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZS5YXTtcbiAgICBjb25zdCB0YXJnZXQgPSBub2RlLmlucHV0c1tTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUuVEFSR0VUXTtcbiAgICByZXR1cm4gW25ldyBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCh4LCB0YXJnZXQsIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFNvZnRtYXhOb2RlKSB7XG4gICAgcmV0dXJuIFtuZXcgU29mdG1heChub2RlLmlucHV0c1tTb2Z0bWF4Tm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgTWVhblNxdWFyZWRDb3N0Tm9kZSkge1xuICAgIGNvbnN0IGxhYmVsID0gbm9kZS5pbnB1dHNbTWVhblNxdWFyZWRDb3N0Tm9kZS5MQUJFTF07XG4gICAgY29uc3QgcHJlZGljdGlvbiA9IG5vZGUuaW5wdXRzW01lYW5TcXVhcmVkQ29zdE5vZGUuUFJFRElDVElPTl07XG4gICAgcmV0dXJuIFtuZXcgTWVhblNxdWFyZWRDb3N0KGxhYmVsLCBwcmVkaWN0aW9uLCBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcmdNYXhFcXVhbHNOb2RlKSB7XG4gICAgcmV0dXJuIFtuZXcgQXJnTWF4RXF1YWxzKFxuICAgICAgICBub2RlLmlucHV0c1tBcmdNYXhFcXVhbHNOb2RlLlgxXSwgbm9kZS5pbnB1dHNbQXJnTWF4RXF1YWxzTm9kZS5YMl0sXG4gICAgICAgIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFyZ01heE5vZGUpIHtcbiAgICByZXR1cm4gW25ldyBBcmdNYXgobm9kZS54LCBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSkge1xuICAgIHJldHVybiBbbmV3IExpbmVhckNvbWJpbmF0aW9uKFxuICAgICAgICBub2RlLmlucHV0c1tGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5UMV0sXG4gICAgICAgIG5vZGUuaW5wdXRzW0Z1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLlQyXSxcbiAgICAgICAgbm9kZS5pbnB1dHNbRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuQzFdLFxuICAgICAgICBub2RlLmlucHV0c1tGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5DMl0sIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIENvbmNhdDNETm9kZSkge1xuICAgIHJldHVybiBbbmV3IENvbmNhdDNEKFxuICAgICAgICBub2RlLmlucHV0c1tDb25jYXQzRE5vZGUuWDFdLCBub2RlLmlucHV0c1tDb25jYXQzRE5vZGUuWDJdLCBub2RlLmF4aXMsXG4gICAgICAgIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFNxdWFyZU5vZGUpIHtcbiAgICByZXR1cm4gW25ldyBTcXVhcmUobm9kZS5pbnB1dHNbU3F1YXJlTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQWRkTm9kZSkge1xuICAgIHJldHVybiBbbmV3IEFkZChcbiAgICAgICAgbm9kZS5pbnB1dHNbQWRkTm9kZS5UMV0sIG5vZGUuaW5wdXRzW0FkZE5vZGUuVDJdLCBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBTdWJ0cmFjdE5vZGUpIHtcbiAgICByZXR1cm4gW25ldyBTdWJ0cmFjdChcbiAgICAgICAgbm9kZS5pbnB1dHNbU3VidHJhY3ROb2RlLlQxXSwgbm9kZS5pbnB1dHNbU3VidHJhY3ROb2RlLlQyXSxcbiAgICAgICAgbm9kZS5vdXRwdXQpXTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgTXVsdGlwbHlOb2RlKSB7XG4gICAgcmV0dXJuIFtuZXcgTXVsdGlwbHkoXG4gICAgICAgIG5vZGUuaW5wdXRzW011bHRpcGx5Tm9kZS5UMV0sIG5vZGUuaW5wdXRzW011bHRpcGx5Tm9kZS5UMl0sXG4gICAgICAgIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIERpdmlkZU5vZGUpIHtcbiAgICByZXR1cm4gW25ldyBEaXZpZGUoXG4gICAgICAgIG5vZGUuaW5wdXRzW0RpdmlkZU5vZGUuVDFdLCBub2RlLmlucHV0c1tEaXZpZGVOb2RlLlQyXSwgbm9kZS5vdXRwdXQpXTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgU3BsaXROb2RlKSB7XG4gICAgcmV0dXJuIFtuZXcgU3BsaXQobm9kZS5pbnB1dHNbU3BsaXROb2RlLlhdLCBub2RlLm91dHB1dHMpXTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUmVkdWNlU3VtTm9kZSkge1xuICAgIHJldHVybiBbbmV3IFJlZHVjZVN1bShub2RlLmlucHV0c1tSZWR1Y2VTdW1Ob2RlLlhdLCBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKGdyYXBoX3V0aWwuaXNJbnB1dE5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCBub2RlIHR5cGU6ICcgKyAobm9kZS5jb25zdHJ1Y3RvciBhcyBhbnkpLm5hbWUpO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi9ncmFwaCc7XG5pbXBvcnQgKiBhcyBncmFwaF91dGlsIGZyb20gJy4uL2dyYXBoX3V0aWwnO1xuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi4vbWF0aC9tYXRoJztcbmltcG9ydCB7TkRBcnJheSwgU2NhbGFyfSBmcm9tICcuLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwnO1xuXG5pbXBvcnQge09wZXJhdGlvbn0gZnJvbSAnLi9vcCc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQWRkIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgcHJpdmF0ZSBkeVNpemVTY2FsYXI6IFNjYWxhcjtcblxuICAvKiogRWxlbWVudC13aXNlIGFkZCBvcGVyYXRpb24uIEJyb2FkY2FzdHMgaWYgb25lIG9mIHRoZSB0ZW5zb3JzIGlzIHNjYWxhci4gKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHgxVGVuc29yOiBUZW5zb3IsIHByaXZhdGUgeDJUZW5zb3I6IFRlbnNvcixcbiAgICAgIHByaXZhdGUgeVRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHgxVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHgyVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh4MVRlbnNvci5zaGFwZSwgeDJUZW5zb3Iuc2hhcGUpLFxuICAgICAgICAnT25lIG9mIHQxIG9yIHQyIG11c3QgYmUgYSBzY2FsYXIsIG9yIHQxIGFuZCB0MiBtdXN0IGhhdmUgJyArXG4gICAgICAgICAgICAndGhlIHNhbWUgc2hhcGUnKTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgIGNvbnN0IHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGxldCByZXN1bHQ6IE5EQXJyYXk7XG4gICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHgxLnNoYXBlKSkge1xuICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclBsdXNBcnJheSh4MSwgeDIpO1xuICAgICAgfSBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoeDIuc2hhcGUpKSB7XG4gICAgICAgIHJlc3VsdCA9IG1hdGguc2NhbGFyUGx1c0FycmF5KHgyLCB4MSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBtYXRoLmFkZCh4MSwgeDIpO1xuICAgICAgfVxuICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldCh0aGlzLnlUZW5zb3IsIGtlZXAocmVzdWx0KSk7XG4gICAgfSk7XG4gIH1cblxuICBiYWNrUHJvcChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodGhpcy54MVRlbnNvci5zaGFwZSkpIHtcbiAgICAgICAgICBjb25zdCBzdW0gPSBtYXRoLnN1bShkeSk7XG4gICAgICAgICAgaWYgKHRoaXMuZHlTaXplU2NhbGFyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHlTaXplU2NhbGFyID0gU2NhbGFyLm5ldyhkeS5zaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KFxuICAgICAgICAgICAgICB0aGlzLngxVGVuc29yLCBrZWVwKG1hdGguZGl2aWRlKHN1bSwgdGhpcy5keVNpemVTY2FsYXIpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMueDFUZW5zb3IsIGR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLngyVGVuc29yKSkge1xuICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHRoaXMueDJUZW5zb3Iuc2hhcGUpKSB7XG4gICAgICAgICAgY29uc3Qgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgIGlmICh0aGlzLmR5U2l6ZVNjYWxhciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmR5U2l6ZVNjYWxhciA9IFNjYWxhci5uZXcoZHkuc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLnNldChcbiAgICAgICAgICAgICAgdGhpcy54MlRlbnNvciwga2VlcChtYXRoLmRpdmlkZShzdW0sIHRoaXMuZHlTaXplU2NhbGFyKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLngyVGVuc29yLCBkeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuZHlTaXplU2NhbGFyICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHlTaXplU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIEFyZ01heCBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBBbiBBcmdNYXggb3BlcmF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB4VGVuc29yOiBUZW5zb3IsIHByaXZhdGUgeVRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KHRoaXMueVRlbnNvciwga2VlcChtYXRoLmFyZ01heCh4KSkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXJnTWF4IGJhY2twcm9wIHVuaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vZ3JhcGgnO1xuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi4vbWF0aC9tYXRoJztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4uL3RlbnNvcl9hcnJheV9tYXAnO1xuXG5pbXBvcnQge09wZXJhdGlvbn0gZnJvbSAnLi9vcCc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQXJnTWF4RXF1YWxzIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIEFuIEFyZ01heEVxdWFscyBvcGVyYXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgeDFUZW5zb3I6IFRlbnNvciwgcHJpdmF0ZSB4MlRlbnNvcjogVGVuc29yLFxuICAgICAgcHJpdmF0ZSB5VGVuc29yOiBUZW5zb3IpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgZmVlZEZvcndhcmQobWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgY29uc3QgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQodGhpcy55VGVuc29yLCBrZWVwKG1hdGguYXJnTWF4RXF1YWxzKHgxLCB4MikpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ01heEVxdWFscyBiYWNrcHJvcCB1bmltcGxlbWVudGVkJyk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCAqIGFzIGNvbmNhdDNkX3V0aWwgZnJvbSAnLi4vbWF0aC9jb25jYXQzZF91dGlsJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge0FycmF5M0R9IGZyb20gJy4uL21hdGgvbmRhcnJheSc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbmNhdDNEIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIEEgQ29uY2F0IDNEIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQ29uY2F0cyB0d28gM0QgdGVuc29ycyBhbG9uZyBhbiBheGlzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHgxVGVuc29yOiBUZW5zb3IsIHByaXZhdGUgeDJUZW5zb3I6IFRlbnNvciwgcHJpdmF0ZSBheGlzOiBudW1iZXIsXG4gICAgICBwcml2YXRlIHlUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKCk7XG4gICAgY29uY2F0M2RfdXRpbC5hc3NlcnRDb25jYXQzRFNoYXBlc01hdGNoKFxuICAgICAgICB4MVRlbnNvci5zaGFwZSwgeDJUZW5zb3Iuc2hhcGUsIGF4aXMpO1xuICB9XG5cbiAgZmVlZEZvcndhcmQobWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcikgYXMgQXJyYXkzRDtcbiAgICBjb25zdCB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcikgYXMgQXJyYXkzRDtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGNvbnN0IGNvbmNhdFJlc3VsdCA9IG1hdGguY29uY2F0M0QoeDEsIHgyLCB0aGlzLmF4aXMpO1xuICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldCh0aGlzLnlUZW5zb3IsIGtlZXAoY29uY2F0UmVzdWx0KSk7XG4gICAgfSk7XG4gIH1cblxuICBiYWNrUHJvcChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25jYXQzRCBiYWNrcHJvcCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCAqIGFzIGNvbnZfdXRpbCBmcm9tICcuLi9tYXRoL2NvbnZfdXRpbCc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtBcnJheTFELCBBcnJheTNELCBBcnJheTREfSBmcm9tICcuLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwnO1xuXG5pbXBvcnQge09wZXJhdGlvbn0gZnJvbSAnLi9vcCc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQ29udm9sdXRpb24yRCBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIHByaXZhdGUgemVyb1BhZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgY29udm9sdXRpb24gb3Agd2l0aCB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dFNoYXBlIFRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgbmRhcnJheS5cbiAgICogQHBhcmFtIGZpZWxkU2l6ZSBUaGUgc2l6ZSBvZiB0aGUgZmlsdGVyIChyb3dzL2NvbHMgb2Ygc2xpZGluZyB3aW5kb3cpLlxuICAgKiBAcGFyYW0gb3V0cHV0RGVwdGggVGhlIGRlcHRoIG9mIHRoZSBvdXRwdXQgKE51bWJlciBvZiBmaWx0ZXJzKS5cbiAgICogQHBhcmFtIHN0cmlkZSBIb3cgbWFueSBwaXhlbHMgdG8gc2hpZnQgdGhlIGZpbHRlciBieSB3aGVuIHNsaWRpbmcuXG4gICAqICAgICBEZWZhdWx0cyB0byAxLlxuICAgKiBAcGFyYW0gemVyb1BhZCBIb3cgbWFueSBwaXhlbHMgdG8gcGFkIHRoZSBpbnB1dCBmcm9tIGVhY2ggc2lkZS4gRGVmYXVsdHMgdG9cbiAgICogICAgIGEgdmFsdWUgc28gdGhhdCB0aGUgcm93cyBhbmQgY29sdW1ucyBvZiB0aGUgb3V0cHV0IG5kYXJyYXkgaXNcbiAgICogICAgIHRoZSBzYW1lIGFzIHRoZSBpbnB1dCBuZGFycmF5LlxuICAgKiBAcGFyYW0gd2VpZ2h0cyBPcHRpb25hbC4gVGhlIHdlaWdodHMgb2YgdGhlIGZpbHRlcnMuXG4gICAqIEBwYXJhbSBiaWFzZXMgT3B0aW9uYWwuIFRoZSBiaWFzIHRlcm1zIG9mIHRoZSBmaWx0ZXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHdUZW5zb3I6IFRlbnNvciwgcHJpdmF0ZSB4VGVuc29yOiBUZW5zb3IsIHByaXZhdGUgYlRlbnNvcjogVGVuc29yLFxuICAgICAgcHJpdmF0ZSB5VGVuc29yOiBUZW5zb3IsIHByaXZhdGUgZmllbGRTaXplOiBudW1iZXIsXG4gICAgICBwcml2YXRlIG91dHB1dERlcHRoOiBudW1iZXIsIHByaXZhdGUgc3RyaWRlID0gMSwgemVyb1BhZD86IG51bWJlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hc3NlcnRXZWlnaHRzU2hhcGUod1RlbnNvci5zaGFwZSk7XG4gICAgdGhpcy56ZXJvUGFkID0gemVyb1BhZCAhPSBudWxsID9cbiAgICAgICAgemVyb1BhZCA6XG4gICAgICAgIGNvbnZfdXRpbC5jb21wdXRlRGVmYXVsdFBhZChcbiAgICAgICAgICAgIHRoaXMueFRlbnNvci5zaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHRoaXMuZmllbGRTaXplLFxuICAgICAgICAgICAgdGhpcy5zdHJpZGUpO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB1dGlsLmlzSW50KHRoaXMuemVyb1BhZCksXG4gICAgICAgIGBUaGUgemVybyBwYWRkaW5nICgke3RoaXMuemVyb1BhZH0pIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBgICtcbiAgICAgICAgICAgIGBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNgKTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3Qgd2VpZ2h0cyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy53VGVuc29yKSBhcyBBcnJheTREO1xuICAgIGNvbnN0IGJpYXNlcyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5iVGVuc29yKSBhcyBBcnJheTFEO1xuICAgIGNvbnN0IHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcikgYXMgQXJyYXkzRDtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoXG4gICAgICAgICAgdGhpcy55VGVuc29yLFxuICAgICAgICAgIGtlZXAobWF0aC5jb252MmQoeCwgd2VpZ2h0cywgYmlhc2VzLCB0aGlzLnN0cmlkZSwgdGhpcy56ZXJvUGFkKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHdlaWdodHMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMud1RlbnNvcikgYXMgQXJyYXk0RDtcbiAgICBjb25zdCB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpIGFzIEFycmF5M0Q7XG4gICAgY29uc3QgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKSBhcyBBcnJheTNEO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgY29uc3Qge2R3LCBkYiwgZHh9ID1cbiAgICAgICAgICBtYXRoLmNvbnYyZEJhY2tQcm9wKHgsIGR5LCB3ZWlnaHRzLCB0aGlzLnN0cmlkZSwgdGhpcy56ZXJvUGFkKTtcbiAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLndUZW5zb3IsIGtlZXAoZHcpKTtcbiAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLmJUZW5zb3IsIGtlZXAoZGIpKTtcbiAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLnhUZW5zb3IsIGtlZXAoZHgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXNzZXJ0V2VpZ2h0c1NoYXBlKHdlaWdodHNTaGFwZTogbnVtYmVyW10pIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgd2VpZ2h0c1NoYXBlWzBdID09PSB0aGlzLmZpZWxkU2l6ZSAmJlxuICAgICAgICAgICAgd2VpZ2h0c1NoYXBlWzFdID09PSB0aGlzLmZpZWxkU2l6ZSAmJlxuICAgICAgICAgICAgd2VpZ2h0c1NoYXBlWzJdID09PSB0aGlzLnhUZW5zb3Iuc2hhcGVbMl0gJiZcbiAgICAgICAgICAgIHdlaWdodHNTaGFwZVszXSA9PT0gdGhpcy5vdXRwdXREZXB0aCxcbiAgICAgICAgYHdlaWdodHMgbXVzdCBiZSBvZiBzaGFwZSBbJHt0aGlzLmZpZWxkU2l6ZX0sJHt0aGlzLmZpZWxkU2l6ZX0sYCArXG4gICAgICAgICAgICBgJHt0aGlzLnhUZW5zb3Iuc2hhcGVbMl19LCR7dGhpcy5vdXRwdXREZXB0aH1dIGJ1dCB0aGV5IGFyZSBvZmAgK1xuICAgICAgICAgICAgYHNoYXBlIFske3dlaWdodHNTaGFwZX1dYCk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCAqIGFzIGdyYXBoX3V0aWwgZnJvbSAnLi4vZ3JhcGhfdXRpbCc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtOREFycmF5fSBmcm9tICcuLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwnO1xuXG5pbXBvcnQge09wZXJhdGlvbn0gZnJvbSAnLi9vcCc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgRGl2aWRlIGV4dGVuZHMgT3BlcmF0aW9uIHtcblxuICAvKipcbiAgICogRWxlbWVudC13aXNlIGRpdmlkZSBvcGVyYXRpb24uIEJyb2FkY2FzdHMgaWYgb25lIG9mIHRoZSB0ZW5zb3JzIGlzXG4gICAqIHNjYWxhci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSB4MVRlbnNvcjogVGVuc29yLCBwcml2YXRlIHgyVGVuc29yOiBUZW5zb3IsXG4gICAgICBwcml2YXRlIHlUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh4MVRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh4MlRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwoeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlKSxcbiAgICAgICAgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlJyk7XG4gIH1cblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHQxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICBjb25zdCB0MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0OiBOREFycmF5O1xuICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0MS5zaGFwZSkpIHtcbiAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJEaXZpZGVkQnlBcnJheSh0MSwgdDIpO1xuICAgICAgfSBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodDIuc2hhcGUpKSB7XG4gICAgICAgIHJlc3VsdCA9IG1hdGguYXJyYXlEaXZpZGVkQnlTY2FsYXIodDEsIHQyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG1hdGguZGl2aWRlKHQxLCB0Mik7XG4gICAgICB9XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KHRoaXMueVRlbnNvciwga2VlcChyZXN1bHQpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgY29uc3QgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgIGNvbnN0IGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG5cbiAgICBjb25zdCB4MUlzU2NhbGFyID0gdXRpbC5pc1NjYWxhclNoYXBlKHgxLnNoYXBlKTtcbiAgICBjb25zdCB4MklzU2NhbGFyID0gdXRpbC5pc1NjYWxhclNoYXBlKHgyLnNoYXBlKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgIGlmICh4MUlzU2NhbGFyKSB7XG4gICAgICAgICAgY29uc3QgZGl2ID0gbWF0aC5kaXZpZGUoZHksIHgyKTtcblxuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLngxVGVuc29yLCBrZWVwKG1hdGguc3VtKGRpdikpKTtcblxuICAgICAgICAgIGRpdi5kaXNwb3NlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoeDJJc1NjYWxhcikge1xuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLnNldChcbiAgICAgICAgICAgICAgdGhpcy54MVRlbnNvciwga2VlcChtYXRoLmFycmF5RGl2aWRlZEJ5U2NhbGFyKGR5LCB4MikpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54MVRlbnNvciwga2VlcChtYXRoLmRpdmlkZShkeSwgeDIpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AodGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgLy8gZHgyID0gLTEgKiB4MSAqIHgyIF4gLTIuXG4gICAgICAgIGNvbnN0IHgyU3F1YXJlZCA9IG1hdGguZWxlbWVudFdpc2VNdWwoeDIsIHgyKTtcblxuICAgICAgICBsZXQgeDFPdmVyWDJTcXVhcmVkOiBOREFycmF5O1xuICAgICAgICBpZiAoeDJJc1NjYWxhcikge1xuICAgICAgICAgIHgxT3ZlclgyU3F1YXJlZCA9IG1hdGguYXJyYXlEaXZpZGVkQnlTY2FsYXIoeDEsIHgyU3F1YXJlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoeDFJc1NjYWxhcikge1xuICAgICAgICAgIHgxT3ZlclgyU3F1YXJlZCA9IG1hdGguc2NhbGFyRGl2aWRlZEJ5QXJyYXkoeDEsIHgyU3F1YXJlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeDFPdmVyWDJTcXVhcmVkID0gbWF0aC5kaXZpZGUoeDEsIHgyU3F1YXJlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkeDIgPSBtYXRoLm5lZyh4MU92ZXJYMlNxdWFyZWQpO1xuICAgICAgICBjb25zdCBkeVRpbWVzRGVyaXZhdGl2ZSA9IG1hdGguZWxlbWVudFdpc2VNdWwoZHksIGR4Mik7XG5cbiAgICAgICAgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54MlRlbnNvciwga2VlcChtYXRoLnN1bShkeVRpbWVzRGVyaXZhdGl2ZSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54MlRlbnNvciwga2VlcChkeVRpbWVzRGVyaXZhdGl2ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbmltcG9ydCB7QWN0aXZhdGlvbkZ1bmN0aW9uLCBSZUxVRnVuYywgU2lnbW9pZEZ1bmMsIFNxdWFyZUZ1bmMsIFRhbkhGdW5jfSBmcm9tICcuLi9tYXRoL2FjdGl2YXRpb25fZnVuY3Rpb25zJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIEVsZW1lbnRXaXNlQWN0aXZhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJvdGVjdGVkIHhUZW5zb3I6IFRlbnNvciwgcHJvdGVjdGVkIHlUZW5zb3I6IFRlbnNvcixcbiAgICAgIHByaXZhdGUgZnVuYzogQWN0aXZhdGlvbkZ1bmN0aW9uKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQodGhpcy55VGVuc29yLCBrZWVwKHRoaXMuZnVuYy5vdXRwdXQobWF0aCwgeCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICAvLyBkRS9keF9pID0gc3VtX2ogZEUvZHlfaiAqIGR5X2ovZHhfaVxuICAgIC8vICAgICAgICAgPSBkRS9keV9pICogZHlfaS9keF9pXG4gICAgY29uc3QgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICBjb25zdCB5ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgIGNvbnN0IGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBjb25zdCBkeWR4ID0gdGhpcy5mdW5jLmRlcihtYXRoLCB4LCB5KTtcbiAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLnhUZW5zb3IsIGtlZXAobWF0aC5lbGVtZW50V2lzZU11bChkeSwgZHlkeCkpKTtcbiAgICAgIGR5ZHguZGlzcG9zZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgUmVMVSBleHRlbmRzIEVsZW1lbnRXaXNlQWN0aXZhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHhUZW5zb3I6IFRlbnNvciwgeVRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoeFRlbnNvciwgeVRlbnNvciwgbmV3IFJlTFVGdW5jKCkpO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgVGFuSCBleHRlbmRzIEVsZW1lbnRXaXNlQWN0aXZhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHhUZW5zb3I6IFRlbnNvciwgeVRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoeFRlbnNvciwgeVRlbnNvciwgbmV3IFRhbkhGdW5jKCkpO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgU2lnbW9pZCBleHRlbmRzIEVsZW1lbnRXaXNlQWN0aXZhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHhUZW5zb3I6IFRlbnNvciwgeVRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoeFRlbnNvciwgeVRlbnNvciwgbmV3IFNpZ21vaWRGdW5jKCkpO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgU3F1YXJlIGV4dGVuZHMgRWxlbWVudFdpc2VBY3RpdmF0aW9uIHtcbiAgY29uc3RydWN0b3IoeFRlbnNvcjogVGVuc29yLCB5VGVuc29yOiBUZW5zb3IpIHtcbiAgICBzdXBlcih4VGVuc29yLCB5VGVuc29yLCBuZXcgU3F1YXJlRnVuYygpKTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vZ3JhcGgnO1xuaW1wb3J0ICogYXMgZ3JhcGhfdXRpbCBmcm9tICcuLi9ncmFwaF91dGlsJztcbmltcG9ydCB7RWxlbWVudFdpc2VDb3N0RnVuY3Rpb24sIFNxdWFyZUNvc3RGdW5jfSBmcm9tICcuLi9tYXRoL2Nvc3RfZnVuY3Rpb25zJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge1NjYWxhcn0gZnJvbSAnLi4vbWF0aC9uZGFycmF5JztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4uL3RlbnNvcl9hcnJheV9tYXAnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIEVsZW1lbnRXaXNlQ29zdCBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIHByaXZhdGUgb25lT3Zlck5TY2FsYXI6IFNjYWxhcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByb3RlY3RlZCB4MVRlbnNvcjogVGVuc29yLCBwcm90ZWN0ZWQgeDJUZW5zb3I6IFRlbnNvcixcbiAgICAgIHByb3RlY3RlZCB5VGVuc29yOiBUZW5zb3IsIHByb3RlY3RlZCBmdW5jOiBFbGVtZW50V2lzZUNvc3RGdW5jdGlvbikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vbmVPdmVyTlNjYWxhciA9IFNjYWxhci5uZXcoMSAvIHV0aWwuc2l6ZUZyb21TaGFwZSh4MVRlbnNvci5zaGFwZSkpO1xuICB9XG5cbiAgZmVlZEZvcndhcmQobWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgY29uc3QgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudFdpc2VDb3N0ID0gdGhpcy5mdW5jLmNvc3QobWF0aCwgeDEsIHgyKTtcbiAgICAgIGNvbnN0IHN1bSA9IG1hdGguc3VtKGVsZW1lbnRXaXNlQ29zdCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBtYXRoLnNjYWxhclRpbWVzQXJyYXkodGhpcy5vbmVPdmVyTlNjYWxhciwgc3VtKTtcbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQodGhpcy55VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICBjb25zdCB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLngxVGVuc29yKSkge1xuICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54MVRlbnNvciwga2VlcCh0aGlzLmZ1bmMuZGVyKG1hdGgsIHgxLCB4MikpKTtcbiAgICAgIH1cbiAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLngyVGVuc29yLCBrZWVwKHRoaXMuZnVuYy5kZXIobWF0aCwgeDIsIHgxKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmZ1bmMuZGlzcG9zZSgpO1xuICAgIHRoaXMub25lT3Zlck5TY2FsYXIuZGlzcG9zZSgpO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgTWVhblNxdWFyZWRDb3N0IGV4dGVuZHMgRWxlbWVudFdpc2VDb3N0IHtcbiAgY29uc3RydWN0b3IoeDFUZW5zb3I6IFRlbnNvciwgeDJUZW5zb3I6IFRlbnNvciwgeVRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yLCBuZXcgU3F1YXJlQ29zdEZ1bmMoKSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCAqIGFzIGdyYXBoX3V0aWwgZnJvbSAnLi4vZ3JhcGhfdXRpbCc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5cbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHAgZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAvKipcbiAgICogRXhwb25lbnRhdGlvbiBvcGVyYXRpb24gLSBlXnguXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHhUZW5zb3I6IFRlbnNvciwgcHJpdmF0ZSB5VGVuc29yOiBUZW5zb3IpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgZmVlZEZvcndhcmQobWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldCh0aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5leHAoeCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB5ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgIGNvbnN0IGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLnhUZW5zb3IpKSB7XG4gICAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLnhUZW5zb3IsIGtlZXAobWF0aC5lbGVtZW50V2lzZU11bCh5LCBkeSkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vZ3JhcGgnO1xuaW1wb3J0ICogYXMgZ3JhcGhfdXRpbCBmcm9tICcuLi9ncmFwaF91dGlsJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIExpbmVhckNvbWJpbmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIEEgMi10ZW5zb3IgbGluZWFyIGNvbWJpbmF0aW9uIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQ29tYmluZXMgdGVuc29ycyB4MSBhbmQgeDIgKG9mIHRoZSBzYW1lIHNoYXBlKSB3aXRoIHdlaWdodHMgYzEgJiBjMjtcbiAgICogQ29tcHV0ZXMgYzEqeDEgKyBjMip4Mi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSB4MVRlbnNvcjogVGVuc29yLCBwcml2YXRlIHgyVGVuc29yOiBUZW5zb3IsXG4gICAgICBwcml2YXRlIGMxVGVuc29yOiBUZW5zb3IsIHByaXZhdGUgYzJUZW5zb3I6IFRlbnNvcixcbiAgICAgIHByaXZhdGUgb3V0VGVuc29yOiBUZW5zb3IpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgZmVlZEZvcndhcmQobWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgY29uc3QgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgIGNvbnN0IGMxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmMxVGVuc29yKS5hc1NjYWxhcigpO1xuICAgIGNvbnN0IGMyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmMyVGVuc29yKS5hc1NjYWxhcigpO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChcbiAgICAgICAgICB0aGlzLm91dFRlbnNvciwga2VlcChtYXRoLnNjYWxlZEFycmF5QWRkKGMxLCB4MSwgYzIsIHgyKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICBjb25zdCB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgY29uc3QgYzEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYzFUZW5zb3IpO1xuICAgIGNvbnN0IGMyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmMyVGVuc29yKTtcbiAgICBjb25zdCBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLm91dFRlbnNvcik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLngxVGVuc29yKSkge1xuICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54MVRlbnNvciwga2VlcChtYXRoLnNjYWxhclRpbWVzQXJyYXkoYzEsIGR5KSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLngyVGVuc29yKSkge1xuICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54MlRlbnNvciwga2VlcChtYXRoLnNjYWxhclRpbWVzQXJyYXkoYzIsIGR5KSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLmMxVGVuc29yKSkge1xuICAgICAgICBjb25zdCBkb3RQcm9kdWN0MSA9IG1hdGguZWxlbWVudFdpc2VNdWwoeDEsIGR5KTtcbiAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMuYzFUZW5zb3IsIGtlZXAobWF0aC5zdW0oZG90UHJvZHVjdDEpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMuYzJUZW5zb3IpKSB7XG4gICAgICAgIGNvbnN0IGRvdFByb2R1Y3QyID0gbWF0aC5lbGVtZW50V2lzZU11bCh4MiwgZHkpO1xuICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy5jMlRlbnNvciwga2VlcChtYXRoLnN1bShkb3RQcm9kdWN0MikpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vZ3JhcGgnO1xuaW1wb3J0ICogYXMgZ3JhcGhfdXRpbCBmcm9tICcuLi9ncmFwaF91dGlsJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZyBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBOYXR1cmFsIGxvZyBvcGVyYXRpb24gLSBsbih4KVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB4VGVuc29yOiBUZW5zb3IsIHByaXZhdGUgeVRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQodGhpcy55VGVuc29yLCBrZWVwKG1hdGgubG9nKHgpKSk7XG4gICAgfSk7XG4gIH1cblxuICBiYWNrUHJvcChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICBjb25zdCBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AodGhpcy54VGVuc29yKSkge1xuICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54VGVuc29yLCBrZWVwKG1hdGguZGl2aWRlKGR5LCB4KSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi9ncmFwaCc7XG5pbXBvcnQgKiBhcyBncmFwaF91dGlsIGZyb20gJy4uL2dyYXBoX3V0aWwnO1xuaW1wb3J0IHtNYXRyaXhPcmllbnRhdGlvbiwgTkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge0FycmF5MUQsIEFycmF5MkR9IGZyb20gJy4uL21hdGgvbmRhcnJheSc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIE1hdE11bCBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSB4MVRlbnNvcjogVGVuc29yLCBwcml2YXRlIHgyVGVuc29yOiBUZW5zb3IsXG4gICAgICBwcml2YXRlIHlUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICBjb25zdCB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpZiAoeDEuc2hhcGUubGVuZ3RoID09PSAyICYmIHgyLnNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KFxuICAgICAgICAgICAgdGhpcy55VGVuc29yLCBrZWVwKG1hdGgubWF0TXVsKHgxIGFzIEFycmF5MkQsIHgyIGFzIEFycmF5MkQpKSk7XG4gICAgICB9IGVsc2UgaWYgKHgxLnNoYXBlLmxlbmd0aCA9PT0gMiAmJiB4Mi5zaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChcbiAgICAgICAgICAgIHRoaXMueVRlbnNvcixcbiAgICAgICAgICAgIGtlZXAobWF0aC5tYXRyaXhUaW1lc1ZlY3Rvcih4MSBhcyBBcnJheTJELCB4MiBhcyBBcnJheTFEKSkpO1xuICAgICAgfSBlbHNlIGlmICh4MS5zaGFwZS5sZW5ndGggPT09IDEgJiYgeDIuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoXG4gICAgICAgICAgICB0aGlzLnlUZW5zb3IsXG4gICAgICAgICAgICBrZWVwKG1hdGgudmVjdG9yVGltZXNNYXRyaXgoeDEgYXMgQXJyYXkxRCwgeDIgYXMgQXJyYXkyRCkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBsZXQgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgIGxldCB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgbGV0IGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG5cbiAgICBpZiAoeDEuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICB4MSA9IHgxLnJlc2hhcGUoWzEsIHgxLnNpemVdKTtcbiAgICAgIGR5ID0gZHkucmVzaGFwZShbMSwgZHkuc2l6ZV0pO1xuICAgIH1cbiAgICBpZiAoeDIuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICB4MiA9IHgyLnJlc2hhcGUoW3gyLnNpemUsIDFdKTtcbiAgICAgIGR5ID0gZHkucmVzaGFwZShbZHkuc2l6ZSwgMV0pO1xuICAgIH1cblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIC8vIHkgPSB4MSAqIHgyXG4gICAgICAvLyBkeDEgPSBkeSAqIHgyVFxuICAgICAgLy8gZHgyID0geDFUICogZHlcbiAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgIGNvbnN0IGR4MSA9IG1hdGgubWF0TXVsKFxuICAgICAgICAgICAgZHkgYXMgQXJyYXkyRCwgeDIgYXMgQXJyYXkyRCwgTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUixcbiAgICAgICAgICAgIE1hdHJpeE9yaWVudGF0aW9uLlRSQU5TUE9TRUQpO1xuICAgICAgICBncmFkaWVudEFycmF5cy5zZXQoXG4gICAgICAgICAgICB0aGlzLngxVGVuc29yLFxuICAgICAgICAgICAga2VlcCh0aGlzLngxVGVuc29yLnNoYXBlLmxlbmd0aCA9PT0gMSA/IGR4MS5hczFEKCkgOiBkeDEpKTtcbiAgICAgIH1cbiAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgIGNvbnN0IGR4MiA9IG1hdGgubWF0TXVsKFxuICAgICAgICAgICAgeDEgYXMgQXJyYXkyRCwgZHkgYXMgQXJyYXkyRCwgTWF0cml4T3JpZW50YXRpb24uVFJBTlNQT1NFRCxcbiAgICAgICAgICAgIE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpO1xuICAgICAgICBncmFkaWVudEFycmF5cy5zZXQoXG4gICAgICAgICAgICB0aGlzLngyVGVuc29yLFxuICAgICAgICAgICAga2VlcCh0aGlzLngyVGVuc29yLnNoYXBlLmxlbmd0aCA9PT0gMSA/IGR4Mi5hczFEKCkgOiBkeDIpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vZ3JhcGgnO1xuaW1wb3J0ICogYXMgY29udl91dGlsIGZyb20gJy4uL21hdGgvY29udl91dGlsJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge0FycmF5M0R9IGZyb20gJy4uL21hdGgvbmRhcnJheSc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXhQb29sIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgcHJpdmF0ZSBwYWQ6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgeFRlbnNvcjogVGVuc29yLCBwcml2YXRlIHlUZW5zb3I6IFRlbnNvcixcbiAgICAgIHByaXZhdGUgZmllbGRTaXplOiBudW1iZXIsIHByaXZhdGUgc3RyaWRlID0gMSwgcGFkPzogbnVtYmVyKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmIChwYWQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5wYWQgPSBwYWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFkID0gY29udl91dGlsLmNvbXB1dGVEZWZhdWx0UGFkKFxuICAgICAgICAgIHhUZW5zb3Iuc2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0aGlzLmZpZWxkU2l6ZSxcbiAgICAgICAgICB0aGlzLnN0cmlkZSk7XG4gICAgfVxuXG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuaXNJbnQodGhpcy5wYWQpLFxuICAgICAgICBgVGhlIHplcm8gcGFkZGluZyAoJHt0aGlzLnBhZH0pIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBgICtcbiAgICAgICAgICAgIGBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNgKTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKSBhcyBBcnJheTNEO1xuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoXG4gICAgICAgICAgdGhpcy55VGVuc29yLFxuICAgICAgICAgIGtlZXAobWF0aC5tYXhQb29sKHgsIHRoaXMuZmllbGRTaXplLCB0aGlzLnN0cmlkZSwgdGhpcy5wYWQpKSk7XG4gICAgfSk7XG4gIH1cblxuICBiYWNrUHJvcChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKSBhcyBBcnJheTNEO1xuICAgIGNvbnN0IGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcikgYXMgQXJyYXkzRDtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGdyYWRpZW50QXJyYXlzLnNldChcbiAgICAgICAgICB0aGlzLnhUZW5zb3IsXG4gICAgICAgICAga2VlcChtYXRoLm1heFBvb2xCYWNrcHJvcChcbiAgICAgICAgICAgICAgZHksIHgsIHRoaXMuZmllbGRTaXplLCB0aGlzLnN0cmlkZSwgdGhpcy5wYWQpKSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCAqIGFzIGdyYXBoX3V0aWwgZnJvbSAnLi4vZ3JhcGhfdXRpbCc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtOREFycmF5fSBmcm9tICcuLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwnO1xuXG5pbXBvcnQge09wZXJhdGlvbn0gZnJvbSAnLi9vcCc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgTXVsdGlwbHkgZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAvKipcbiAgICogRWxlbWVudC13aXNlIG11bHRpcGx5IG9wZXJhdGlvbi4gQnJvYWRjYXN0cyBpZiBvbmUgb2YgdGhlIHRlbnNvcnMgaXNcbiAgICogc2NhbGFyLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHgxVGVuc29yOiBUZW5zb3IsIHByaXZhdGUgeDJUZW5zb3I6IFRlbnNvcixcbiAgICAgIHByaXZhdGUgeVRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHgxVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHgyVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh4MVRlbnNvci5zaGFwZSwgeDJUZW5zb3Iuc2hhcGUpLFxuICAgICAgICAnT25lIG9mIHQxIG9yIHQyIG11c3QgYmUgYSBzY2FsYXIsIG9yIHQxIGFuZCB0MiBtdXN0IGhhdmUgJyArXG4gICAgICAgICAgICAndGhlIHNhbWUgc2hhcGUnKTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgdDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgIGNvbnN0IHQyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGxldCByZXN1bHQ6IE5EQXJyYXk7XG4gICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQxLnNoYXBlKSkge1xuICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclRpbWVzQXJyYXkodDEsIHQyKTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQyLnNoYXBlKSkge1xuICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclRpbWVzQXJyYXkodDIsIHQxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG1hdGguZWxlbWVudFdpc2VNdWwodDEsIHQyKTtcbiAgICAgIH1cbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQodGhpcy55VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICBjb25zdCB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgY29uc3QgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodGhpcy54MVRlbnNvci5zaGFwZSkpIHtcbiAgICAgICAgICBjb25zdCBtdWwgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKGR5LCB4Mik7XG5cbiAgICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54MVRlbnNvciwga2VlcChtYXRoLnN1bShtdWwpKSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoeDIuc2hhcGUpKSB7XG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KFxuICAgICAgICAgICAgICB0aGlzLngxVGVuc29yLCBrZWVwKG1hdGguc2NhbGFyVGltZXNBcnJheSh4MiwgZHkpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMueDFUZW5zb3IsIGtlZXAobWF0aC5lbGVtZW50V2lzZU11bCh4MiwgZHkpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AodGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0aGlzLngyVGVuc29yLnNoYXBlKSkge1xuICAgICAgICAgIGNvbnN0IG11bCA9IG1hdGguZWxlbWVudFdpc2VNdWwoZHksIHgxKTtcblxuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLngyVGVuc29yLCBrZWVwKG1hdGguc3VtKG11bCkpKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh4MS5zaGFwZSkpIHtcbiAgICAgICAgICBncmFkaWVudEFycmF5cy5zZXQoXG4gICAgICAgICAgICAgIHRoaXMueDJUZW5zb3IsIGtlZXAobWF0aC5zY2FsYXJUaW1lc0FycmF5KHgxLCBkeSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54MlRlbnNvciwga2VlcChtYXRoLmVsZW1lbnRXaXNlTXVsKHgxLCBkeSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBPcGVyYXRpb24ge1xuICBhYnN0cmFjdCBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCk6XG4gICAgICB2b2lkO1xuXG4gIGFic3RyYWN0IGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApOiB2b2lkO1xuXG4gIGRpc3Bvc2VUcmFuc2llbnRBcnJheXMoXG4gICAgICBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLCBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHt9XG5cbiAgZGlzcG9zZSgpIHt9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi9ncmFwaCc7XG5pbXBvcnQgKiBhcyBncmFwaF91dGlsIGZyb20gJy4uL2dyYXBoX3V0aWwnO1xuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi4vbWF0aC9tYXRoJztcbmltcG9ydCB7TkRBcnJheX0gZnJvbSAnLi4vbWF0aC9uZGFycmF5JztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4uL3RlbnNvcl9hcnJheV9tYXAnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlZHVjZVN1bSBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIC8qKiBFbGVtZW50LXdpc2UgYWRkIG9wZXJhdGlvbi4gQnJvYWRjYXN0cyBpZiBvbmUgb2YgdGhlIHRlbnNvcnMgaXMgc2NhbGFyLiAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHg6IFRlbnNvciwgcHJpdmF0ZSBvdXRUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKCk7XG4gICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChvdXRUZW5zb3Iuc2hhcGUsIFtdKTtcbiAgfVxuXG4gIHByaXZhdGUgb25lczogTkRBcnJheTtcblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueCk7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KHRoaXMub3V0VGVuc29yLCBrZWVwKG1hdGguc3VtKHgpKSk7XG4gICAgfSk7XG4gIH1cblxuICBiYWNrUHJvcChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgaWYgKCFncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMueCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBjb25zdCBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLm91dFRlbnNvcik7XG4gICAgICBpZiAodGhpcy5vbmVzID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeEFycmF5ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngpO1xuICAgICAgICB0aGlzLm9uZXMgPSBOREFycmF5Lnplcm9zTGlrZSh4QXJyYXkpO1xuICAgICAgICB0aGlzLm9uZXMuZmlsbCgxKTtcbiAgICAgIH1cbiAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLngsIGtlZXAobWF0aC5zY2FsYXJUaW1lc0FycmF5KGR5LCB0aGlzLm9uZXMpKSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge05EQXJyYXl9IGZyb20gJy4uL21hdGgvbmRhcnJheSc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wJztcblxuZXhwb3J0IGNsYXNzIFJlc2hhcGU8VDEgZXh0ZW5kcyBOREFycmF5LCBUMiBleHRlbmRzIE5EQXJyYXk+IGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB4VGVuc29yOiBUZW5zb3IsIHByaXZhdGUgeVRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB4U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh4VGVuc29yLnNoYXBlKTtcbiAgICBjb25zdCB5U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh5VGVuc29yLnNoYXBlKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgeFNpemUgPT09IHlTaXplLFxuICAgICAgICBgVGhlIGlucHV0IHNpemUgKCR7eFNpemV9KSBhbmQgb3V0cHV0IHNpemUgKCR7eVNpemV9KSBtdXN0IG1hdGNoYCk7XG4gIH1cblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcikgYXMgVDE7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KFxuICAgICAgICAgIHRoaXMueVRlbnNvciwga2VlcChtYXRoLnJlc2hhcGU8VDEsIFQyPih4LCB0aGlzLnlUZW5zb3Iuc2hhcGUpKSk7XG4gICAgfSk7XG4gIH1cblxuICBiYWNrUHJvcChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKSBhcyBUMjtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGdyYWRpZW50QXJyYXlzLnNldChcbiAgICAgICAgICB0aGlzLnhUZW5zb3IsIGtlZXAobWF0aC5yZXNoYXBlPFQyLCBUMT4oZHksIHRoaXMueFRlbnNvci5zaGFwZSkpKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vZ3JhcGgnO1xuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi4vbWF0aC9tYXRoJztcbmltcG9ydCB7QXJyYXkxRCwgU2NhbGFyfSBmcm9tICcuLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwnO1xuXG5pbXBvcnQge09wZXJhdGlvbn0gZnJvbSAnLi9vcCc7XG5cbmV4cG9ydCBjbGFzcyBTb2Z0bWF4IGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBsb2dpdHNUZW5zb3I6IFRlbnNvciwgcHJpdmF0ZSBvdXRwdXQ6IFRlbnNvcikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IGxvZ2l0cyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5sb2dpdHNUZW5zb3IpIGFzIEFycmF5MUQ7XG4gICAgcmV0dXJuIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQodGhpcy5vdXRwdXQsIGtlZXAobWF0aC5zb2Z0bWF4KGxvZ2l0cykpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKCkge1xuICAgIHRocm93IEVycm9yKCdTb2Z0bWF4IGJhY2twcm9wIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU29mdG1heENyb3NzRW50cm9weUNvc3QgZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgbG9naXRzVGVuc29yOiBUZW5zb3IsIHByaXZhdGUgbGFiZWxUZW5zb3I6IFRlbnNvcixcbiAgICAgIHByaXZhdGUgeVRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNvZnRtYXhUZW5zb3IgPSBuZXcgVGVuc29yKGxvZ2l0c1RlbnNvci5zaGFwZSk7XG4gIH1cblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IGxvZ2l0cyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5sb2dpdHNUZW5zb3IpIGFzIEFycmF5MUQ7XG4gICAgY29uc3QgbGFiZWwgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMubGFiZWxUZW5zb3IpIGFzIEFycmF5MUQ7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBjb25zdCBzb2Z0bWF4UmVzdWx0ID0gbWF0aC5zb2Z0bWF4KGxvZ2l0cyk7XG5cbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQodGhpcy5zb2Z0bWF4VGVuc29yLCBrZWVwKHNvZnRtYXhSZXN1bHQpKTtcbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoXG4gICAgICAgICAgdGhpcy55VGVuc29yLFxuICAgICAgICAgIGtlZXAoY3Jvc3NFbnRyb3B5Q29zdChtYXRoLCBzb2Z0bWF4UmVzdWx0LCBsYWJlbCwgdGhpcy5lcHNpbG9uKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHNvZnRtYXggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuc29mdG1heFRlbnNvcik7XG4gICAgY29uc3QgbGFiZWwgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMubGFiZWxUZW5zb3IpO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMubG9naXRzVGVuc29yLCBrZWVwKG1hdGguc3ViKHNvZnRtYXgsIGxhYmVsKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzcG9zZVRyYW5zaWVudEFycmF5cyhcbiAgICAgIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGluZmVyZW5jZUFycmF5cy5kaXNwb3NlQXJyYXkodGhpcy5zb2Z0bWF4VGVuc29yKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5lcHNpbG9uLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIHByaXZhdGUgc29mdG1heFRlbnNvcjogVGVuc29yO1xuICBwcml2YXRlIGVwc2lsb24gPSBTY2FsYXIubmV3KDFlLTUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3NFbnRyb3B5Q29zdChcbiAgICBtYXRoOiBOREFycmF5TWF0aCwgeTogQXJyYXkxRCwgdGFyZ2V0OiBBcnJheTFELCBlcHNpbG9uOiBTY2FsYXIpOiBTY2FsYXIge1xuICB1dGlsLmFzc2VydChcbiAgICAgIHkuc2l6ZSA9PT0gdGFyZ2V0LnNpemUsICdUaGUgb3V0cHV0IGFuZCB0YXJnZXQgbXVzdCBiZSB0aGUgc2FtZSBzaXplJyk7XG5cbiAgcmV0dXJuIG1hdGguc2NvcGUoKCkgPT4ge1xuICAgIGNvbnN0IHlQbHVzRXBzID0gbWF0aC5zY2FsYXJQbHVzQXJyYXkoZXBzaWxvbiwgeSk7XG4gICAgY29uc3QgbG9nT3V0cHV0ID0gbWF0aC5sb2coeVBsdXNFcHMpO1xuICAgIGNvbnN0IHRhckxvZ091dHB1dCA9IG1hdGguZWxlbWVudFdpc2VNdWwodGFyZ2V0LCBsb2dPdXRwdXQpO1xuICAgIGNvbnN0IGNvc3RWZWN0b3IgPSBtYXRoLm5lZyh0YXJMb2dPdXRwdXQpO1xuICAgIHJldHVybiBtYXRoLnN1bShjb3N0VmVjdG9yKTtcbiAgfSk7XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi9ncmFwaCc7XG5pbXBvcnQgKiBhcyBncmFwaF91dGlsIGZyb20gJy4uL2dyYXBoX3V0aWwnO1xuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi4vbWF0aC9tYXRoJztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4uL3RlbnNvcl9hcnJheV9tYXAnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIFNwbGl0IG9wcyBhcmUgdXNlZCB0byBhY2N1bXVsYXRlIGJhY2twcm9wIGRlcml2YXRpdmVzIHdoZW4gYSBub2RlJ3Mgb3V0cHV0XG4gKiB0ZW5zb3IgaXMgY29uc3VtZWQgYnkgbXVsdGlwbGUgbm9kZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGxpdCBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5wdXQ6IFRlbnNvciwgcHJpdmF0ZSBvdXRwdXRzOiBUZW5zb3JbXSkge1xuICAgIHN1cGVyKCk7XG4gICAgb3V0cHV0cy5mb3JFYWNoKG91dHB1dCA9PiB7XG4gICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGlucHV0LnNoYXBlLCBvdXRwdXQuc2hhcGUpO1xuICAgIH0pO1xuICB9XG5cbiAgZmVlZEZvcndhcmQobWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCBpbnB1dEFycmF5ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmlucHV0KTtcbiAgICB0aGlzLm91dHB1dHMuZm9yRWFjaChvdXRwdXQgPT4ge1xuICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChvdXRwdXQsIGlucHV0QXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGlmICghZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLmlucHV0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGxldCBkeCA9IG1hdGguYWRkKFxuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLm91dHB1dHNbMF0pLFxuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLm91dHB1dHNbMV0pKTtcbiAgICAgIC8vIFN1bSBhY3Jvc3MgYWxsIHRoZSBkZXJpdmF0aXZlcyBvZiB0aGUgY29uc3VtZXJzIG9mIHRoaXMgbm9kZS5cbiAgICAgIHRoaXMub3V0cHV0cy5zbGljZSgyKS5mb3JFYWNoKG91dHB1dCA9PiB7XG4gICAgICAgIGR4ID0gbWF0aC5hZGQoZHgsIGdyYWRpZW50QXJyYXlzLmdldChvdXRwdXQpKTtcbiAgICAgIH0pO1xuICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMuaW5wdXQsIGtlZXAoZHgpKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vZ3JhcGgnO1xuaW1wb3J0ICogYXMgZ3JhcGhfdXRpbCBmcm9tICcuLi9ncmFwaF91dGlsJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge05EQXJyYXksIFNjYWxhcn0gZnJvbSAnLi4vbWF0aC9uZGFycmF5JztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4uL3RlbnNvcl9hcnJheV9tYXAnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG5leHBvcnQgY2xhc3MgU3VidHJhY3QgZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBwcml2YXRlIGR5U2l6ZVNjYWxhcjogU2NhbGFyO1xuXG4gIC8qKlxuICAgKiBFbGVtZW50LXdpc2Ugc3VidHJhY3Qgb3BlcmF0aW9uLiBCcm9hZGNhc3RzIGlmIG9uZSBvZiB0aGUgdGVuc29ycyBpc1xuICAgKiBzY2FsYXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgdDE6IFRlbnNvciwgcHJpdmF0ZSB0MjogVGVuc29yLCBwcml2YXRlIG91dFRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHQxLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHQyLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh0MS5zaGFwZSwgdDIuc2hhcGUpLFxuICAgICAgICAnT25lIG9mIHQxIG9yIHQyIG11c3QgYmUgYSBzY2FsYXIsIG9yIHQxIGFuZCB0MiBtdXN0IGhhdmUgJyArXG4gICAgICAgICAgICAndGhlIHNhbWUgc2hhcGUnKTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgdDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMudDEpO1xuICAgIGNvbnN0IHQyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnQyKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGxldCByZXN1bHQ6IE5EQXJyYXk7XG4gICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQxLnNoYXBlKSkge1xuICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhck1pbnVzQXJyYXkodDEsIHQyKTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQyLnNoYXBlKSkge1xuICAgICAgICByZXN1bHQgPSBtYXRoLmFycmF5TWludXNTY2FsYXIodDEsIHQyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG1hdGguc3ViKHQxLCB0Mik7XG4gICAgICB9XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KHRoaXMub3V0VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMub3V0VGVuc29yKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMudDEpKSB7XG4gICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodGhpcy50MS5zaGFwZSkpIHtcbiAgICAgICAgICBjb25zdCBzdW0gPSBtYXRoLnN1bShkeSk7XG4gICAgICAgICAgaWYgKHRoaXMuZHlTaXplU2NhbGFyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHlTaXplU2NhbGFyID0gU2NhbGFyLm5ldyhkeS5zaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KFxuICAgICAgICAgICAgICB0aGlzLnQxLCBrZWVwKG1hdGguZGl2aWRlKHN1bSwgdGhpcy5keVNpemVTY2FsYXIpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMudDEsIGtlZXAoZHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLnQyKSkge1xuICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHRoaXMudDIuc2hhcGUpKSB7XG4gICAgICAgICAgY29uc3Qgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgIGNvbnN0IG5lZ1N1bSA9IG1hdGgubmVnKHN1bSk7XG4gICAgICAgICAgaWYgKHRoaXMuZHlTaXplU2NhbGFyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHlTaXplU2NhbGFyID0gU2NhbGFyLm5ldyhkeS5zaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KFxuICAgICAgICAgICAgICB0aGlzLnQyLCBrZWVwKG1hdGguZGl2aWRlKG5lZ1N1bSwgdGhpcy5keVNpemVTY2FsYXIpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMudDIsIGtlZXAobWF0aC5uZWcoZHkpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuZHlTaXplU2NhbGFyICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHlTaXplU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtOb2RlLCBWYXJpYWJsZU5vZGV9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtTZXNzaW9uUnVudGltZX0gZnJvbSAnLi9zZXNzaW9uJztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4vdGVuc29yX2FycmF5X21hcCc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBPcHRpbWl6ZXIge1xuICBwcm90ZWN0ZWQgdmFyaWFibGVOb2RlczogVmFyaWFibGVOb2RlW107XG4gIHByb3RlY3RlZCBzcGVjaWZpZWRWYXJpYWJsZU5vZGVzOiBWYXJpYWJsZU5vZGVbXXxudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHNwZWNpZmllZFZhcmlhYmxlTGlzdD86IE5vZGVbXSkge1xuICAgIGlmIChzcGVjaWZpZWRWYXJpYWJsZUxpc3QgIT0gbnVsbCkge1xuICAgICAgdGhpcy5zcGVjaWZpZWRWYXJpYWJsZU5vZGVzID0gc3BlY2lmaWVkVmFyaWFibGVMaXN0IGFzIFZhcmlhYmxlTm9kZVtdO1xuICAgIH1cbiAgfVxuXG4gIGFic3RyYWN0IGJlZm9yZUJhdGNoKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGJhdGNoU2l6ZTogbnVtYmVyLCBydW50aW1lOiBTZXNzaW9uUnVudGltZSxcbiAgICAgIGFjdGl2YXRpb25BcnJheU1hcDogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5TWFwOiBUZW5zb3JBcnJheU1hcCk6IHZvaWQ7XG5cbiAgYWJzdHJhY3QgYWZ0ZXJFeGFtcGxlKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIHJ1bnRpbWU6IFNlc3Npb25SdW50aW1lLFxuICAgICAgYWN0aXZhdGlvbkFycmF5TWFwOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlNYXA6IFRlbnNvckFycmF5TWFwKTogdm9pZDtcblxuICBhYnN0cmFjdCBhZnRlckJhdGNoKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGJhdGNoU2l6ZTogbnVtYmVyLCBydW50aW1lOiBTZXNzaW9uUnVudGltZSxcbiAgICAgIGFjdGl2YXRpb25BcnJheU1hcDogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5TWFwOiBUZW5zb3JBcnJheU1hcCk6IHZvaWQ7XG5cbiAgYWJzdHJhY3QgZGlzcG9zZSgpOiB2b2lkO1xufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG4vKipcbiAqIERlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgdGhlIHByaW9yaXR5IHF1ZXVlLlxuICogQHBhcmFtIGEgVGhlIGZpcnN0IGVsZW1lbnQgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgZWxlbWVudCB0byBjb21wYXJlLlxuICogQHJldHVybiBcImEgPiBiXCIgcmV0dXJucyA+IDAuIFwiYSA8IGJcIiByZXR1cm5zIDwgMC4gXCJhID09PSBiXCIgcmV0dXJucyAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdENvbXBhcmU8VD4oYTogVCwgYjogVCk6IG51bWJlciB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn1cblxuLyoqXG4gKiBBIENvbXBhcmF0b3IgaXMgYSB1c2VyLXByb3ZpZGVkIGZ1bmN0aW9uIHRoYXQgY29tcGFyZXMgdHdvIFQgaW5zdGFuY2VzLiBUaGVcbiAqIGNvbnZlbnRpb24gZm9yIGRlZmF1bHRDb21wYXJlIGlzIGV4cGVjdGVkIHRvIGJlIGZvbGxvd2VkIHRvIG1haW50YWluIHRoZVxuICogYmluYXJ5IG1pbi1oZWFwIGludGVncml0eS5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBlbGVtZW50IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIGVsZW1lbnQgdG8gY29tcGFyZS5cbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGFyYXRvcjxUPiA9IChhOiBULCBiOiBUKSA9PiBudW1iZXI7XG5cbi8qKlxuICogSW5kZXhPYnNlcnZlciBpcyBhIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhhdCBpbmZvcm1zIHRoZSBjYWxsZXIgd2hlbiBhblxuICogZWxlbWVudCBpbiB0aGUgcHJpb3JpdHkgcXVldWUncyBiaW5hcnkgbWluLWhlYXAgaGFzIGJlZW4gcmVsb2NhdGVkLlxuICogQHBhcmFtIHQgVGhlIGVsZW1lbnQgdGhhdCB3YXMgcmVsb2NhdGVkLlxuICogQHBhcmFtIG5ld0luZGV4IFRoZSBuZXcgbG9jYXRpb24gaW4gdGhlIGJpbmFyeSBtaW4taGVhcCBvZiB0aGUgZWxlbWVudC5cbiAqL1xuZXhwb3J0IHR5cGUgSW5kZXhPYnNlcnZlcjxUPiA9ICh0OiBULCBuZXdJbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuXG4vKipcbiAqIEEgcHJpb3JpdHkgcXVldWUsIGltcGxlbWVudGVkIGluIHRlcm1zIG9mIGEgYmluYXJ5IG1pbi1oZWFwLiBMb3dlciBwcmlvcml0eVxuICogbnVtYmVycyBhcmUgY29uc2lkZXJlZCBoaWdoZXIgcHJpb3JpdHkuXG4gKiBlbnF1ZXVlLCBkZXF1ZXVlLCBhbmQgdXBkYXRlIGFyZSBhbGwgTyhsb2cgTikgd2l0aCByZXNwZWN0IHRvIHRoZSBudW1iZXIgb2ZcbiAqIGVsZW1lbnRzIGluIHRoZSBxdWV1ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFByaW9yaXR5UXVldWU8VD4ge1xuICBwcml2YXRlIGhlYXA6IFRbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gY29tcGFyYXRvciBBIGZ1bmN0aW9uIHRoYXQgY29tcGFyZXMgdHdvIHF1ZXVlIGVsZW1lbnRzLlxuICAgKiBAcGFyYW0gaW5kZXhPYnNlcnZlciBBbiBvcHRpb25hbCBjYWxsYmFjayByYWlzZWQgd2hlbiB0aGUgcHJpb3JpdHkgcXVldWVcbiAgICogY2hhbmdlcyB0aGUgb3JkZXIgb2YgZWxlbWVudHMgaW4gaXRzIG1pbi1oZWFwLiBVc2VmdWwgZm9yIHRyYWNraW5nIHRoZVxuICAgKiBwb3NpdGlvbnMgb2YgZWxlbWVudHMgdGhhdCBuZWVkIHVwZGF0aW5nLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIGNvbXBhcmF0b3I6IENvbXBhcmF0b3I8VD4sXG4gICAgICBwcml2YXRlIGluZGV4T2JzZXJ2ZXI/OiBJbmRleE9ic2VydmVyPFQ+KSB7fVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZWxlbWVudCB0byB0aGUgcHJpb3JpdHkgcXVldWUuXG4gICAqIEBwYXJhbSB0IFRoZSBlbGVtZW50IHRvIGVucXVldWUuXG4gICAqL1xuICBlbnF1ZXVlKHQ6IFQpIHtcbiAgICB0aGlzLmhlYXAucHVzaCh0KTtcbiAgICB0aGlzLm9uSW5kZXhDaGFuZ2VkKHQsIHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcbiAgICB0aGlzLnNpZnRVcCh0aGlzLmhlYXAubGVuZ3RoIC0gMSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGVsZW1lbnQgZnJvbSB0aGUgcHJpb3JpdHkgcXVldWUuXG4gICAqIEByZXR1cm4gVGhlIGVsZW1lbnQgaW4gdGhlIHByaW9yaXR5IHF1ZXVlIHdpdGggdGhlIGhpZ2hlc3QgcHJpb3JpdHlcbiAgICogKGxvd2VzdCBudW1lcmljIHByaW9yaXR5IHZhbHVlKS5cbiAgICovXG4gIGRlcXVldWUoKTogVCB7XG4gICAgaWYgKHRoaXMuZW1wdHkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXF1ZXVlIGNhbGxlZCBvbiBlbXB0eSBwcmlvcml0eSBxdWV1ZS4nKTtcbiAgICB9XG4gICAgY29uc3QgdCA9IHRoaXMuaGVhcFswXTtcbiAgICB0aGlzLnN3YXAoMCwgdGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgIHRoaXMuaGVhcC5wb3AoKTtcbiAgICB0aGlzLnNpZnREb3duKDApO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LiBUaGlzIGNhbiBiZSBhIGZ1bGwgZWxlbWVudFxuICAgKiByZXBsYWNlbWVudCwgb3IgaXQgY2FuIGJlIGFuIGluLXBsYWNlIHVwZGF0ZS4gVGhlIHByaW9yaXR5IGlzIGFzc3VtZWQgdG8gYmVcbiAgICogY2hhbmdlZCwgYW5kIHRoZSBpbnRlcm5hbCBzdG9yYWdlIGlzIHVwZGF0ZWQuIFRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VmdWxcbiAgICogaWYgdGhlIHN0b3JhZ2UgaW5kZXggb2YgdGhlIHVwZGF0ZWQgZWxlbWVudCBpcyBrbm93bjsgY29uc3RydWN0IHRoZVxuICAgKiBQcmlvcml0eVF1ZXVlIHdpdGggYW4gSW5kZXhPYnNlcnZlciB0byB0cmFjayBlbGVtZW50IGxvY2F0aW9ucy5cbiAgICogQHBhcmFtIG5ld1QgVGhlIG5ldyBlbGVtZW50IHRvIHJlcGxhY2UgaW4gdGhlIHByaW9yaXR5IHF1ZXVlLlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCB0aGUgbmV3IGVsZW1lbnQgaW50by5cbiAgICovXG4gIHVwZGF0ZShuZXdUOiBULCBpbmRleDogbnVtYmVyKSB7XG4gICAgLyogSWYgdGhlIGVsZW1lbnQgaXMgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBoZWFwLCBubyBzaWZ0aW5nIGlzIG5lY2Vzc2FyeSxcbiAgICAgKiBpdCBjYW4gYmUgc2FmZWx5IHJlbW92ZWQuICovXG4gICAgY29uc3QgbGFzdCA9IChpbmRleCA9PT0gdGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgIGlmICghbGFzdCkge1xuICAgICAgdGhpcy5zd2FwKGluZGV4LCB0aGlzLmhlYXAubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIHRoaXMuaGVhcC5wb3AoKTtcbiAgICBpZiAoIWxhc3QpIHtcbiAgICAgIC8qIFRoZSBlbGVtZW50IGF0ICdpbmRleCcgaGFzIGJlZW4gcmVtb3ZlZCwgYW5kIHJlcGxhY2VkIHdpdGggd2hhdGV2ZXIgd2FzXG4gICAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBoZWFwLiBTaW5jZSB0aGF0IGVsZW1lbnQgbWlnaHQgaGF2ZSBjb21lIGZyb20gYVxuICAgICAgICogZGlmZmVyZW50IHN1YnRyZWUgKGFuZCBub3QgYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiB0aGUgbm9kZSBhdFxuICAgICAgICogJ2luZGV4JyksIHdlIG1pZ2h0IG5lZWQgdG8gc2lmdCB0aGlzIG5ldyB2YWx1ZSB1cCBpbnN0ZWFkIG9mIGRvd24uIFRlc3RcbiAgICAgICAqIGJvdGggZGlyZWN0aW9ucywgYW5kIHNpZnQgdG8gd2hlcmV2ZXIgdGhlIG5vZGUgbmVlZHMgdG8gZ28uXG4gICAgICAgKi9cbiAgICAgIGlmICh0aGlzLnNpZnRVcEluZGV4KGluZGV4KSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5zaWZ0VXAoaW5kZXgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNpZnREb3duSW5kZXgoaW5kZXgpICE9PSAtMSkge1xuICAgICAgICB0aGlzLnNpZnREb3duKGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbnF1ZXVlKG5ld1QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZWRpY2F0ZSBmb3IgdGVzdGluZyB3aGV0aGVyIHRoZSBQcmlvcml0eVF1ZXVlIGlzIGVtcHR5LlxuICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIFByaW9yaXR5UXVldWUgaXMgZW1wdHksIG90aGVyd2lzZSBGYWxzZS5cbiAgICovXG4gIGVtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmhlYXAubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkluZGV4Q2hhbmdlZCh0OiBULCBuZXdJbmRleDogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuaW5kZXhPYnNlcnZlcikge1xuICAgICAgdGhpcy5pbmRleE9ic2VydmVyKHQsIG5ld0luZGV4KTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBTdGFuZGFyZCB6ZXJvLWluZGV4ZWQgYmluYXJ5IGhlYXAgYXJyYXkgbGF5b3V0OlxuICAgKiAgIFBhcmVudChOKSA9IEZsb29yKChOIC0gMSkgLyAyKVxuICAgKiAgIExlZnRDaGlsZChOKSA9IChOICogMikgKyAxXG4gICAqICAgUmlnaHRDaGlsZChOKSA9IChOICogMikgKyAyXG4gICAqL1xuXG4gIHByaXZhdGUgZ2V0UGFyZW50SW5kZXgoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKChpbmRleCAtIDEpIC8gMik7XG4gIH1cblxuICBwcml2YXRlIGdldExlZnRDaGlsZEluZGV4KGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGluZGV4ICogMiArIDE7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZSA8IHRoaXMuaGVhcC5sZW5ndGggPyBjYW5kaWRhdGUgOiAtMTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UmlnaHRDaGlsZEluZGV4KGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGluZGV4ICogMiArIDI7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZSA8IHRoaXMuaGVhcC5sZW5ndGggPyBjYW5kaWRhdGUgOiAtMTtcbiAgfVxuXG4gIHByaXZhdGUgc2lmdFVwSW5kZXgoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgcGFyZW50SW5kZXggPSB0aGlzLmdldFBhcmVudEluZGV4KGluZGV4KTtcbiAgICBpZiAocGFyZW50SW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbXBhcmUocGFyZW50SW5kZXgsIGluZGV4KSA+IDApIHtcbiAgICAgIHJldHVybiBwYXJlbnRJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcHJpdmF0ZSBzaWZ0VXAoaW5kZXg6IG51bWJlcikge1xuICAgIGxldCBzaWZ0SW5kZXggPSB0aGlzLnNpZnRVcEluZGV4KGluZGV4KTtcbiAgICB3aGlsZSAoc2lmdEluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5zd2FwKGluZGV4LCBzaWZ0SW5kZXgpO1xuICAgICAgaW5kZXggPSBzaWZ0SW5kZXg7XG4gICAgICBzaWZ0SW5kZXggPSB0aGlzLnNpZnRVcEluZGV4KGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNpZnREb3duSW5kZXgoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGluZGV4ID49IHRoaXMuaGVhcC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgbGV0IGxhcmdlc3RDaGlsZEluZGV4ID0gaW5kZXg7XG4gICAgY29uc3QgbGVmdENoaWxkSW5kZXggPSB0aGlzLmdldExlZnRDaGlsZEluZGV4KGluZGV4KTtcbiAgICBpZiAoKGxlZnRDaGlsZEluZGV4ICE9PSAtMSkgJiZcbiAgICAgICAgKHRoaXMuY29tcGFyZShsZWZ0Q2hpbGRJbmRleCwgbGFyZ2VzdENoaWxkSW5kZXgpIDwgMCkpIHtcbiAgICAgIGxhcmdlc3RDaGlsZEluZGV4ID0gbGVmdENoaWxkSW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IHJpZ2h0Q2hpbGRJbmRleCA9IHRoaXMuZ2V0UmlnaHRDaGlsZEluZGV4KGluZGV4KTtcbiAgICBpZiAoKHJpZ2h0Q2hpbGRJbmRleCAhPT0gLTEpICYmXG4gICAgICAgICh0aGlzLmNvbXBhcmUocmlnaHRDaGlsZEluZGV4LCBsYXJnZXN0Q2hpbGRJbmRleCkgPCAwKSkge1xuICAgICAgbGFyZ2VzdENoaWxkSW5kZXggPSByaWdodENoaWxkSW5kZXg7XG4gICAgfVxuICAgIHJldHVybiAobGFyZ2VzdENoaWxkSW5kZXggPT09IGluZGV4KSA/IC0xIDogbGFyZ2VzdENoaWxkSW5kZXg7XG4gIH1cblxuICBwcml2YXRlIHNpZnREb3duKGluZGV4OiBudW1iZXIpIHtcbiAgICBsZXQgc2lmdEluZGV4ID0gdGhpcy5zaWZ0RG93bkluZGV4KGluZGV4KTtcbiAgICB3aGlsZSAoc2lmdEluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5zd2FwKGluZGV4LCBzaWZ0SW5kZXgpO1xuICAgICAgaW5kZXggPSBzaWZ0SW5kZXg7XG4gICAgICBzaWZ0SW5kZXggPSB0aGlzLnNpZnREb3duSW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29tcGFyZShhSW5kZXg6IG51bWJlciwgYkluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmF0b3IodGhpcy5oZWFwW2FJbmRleF0sIHRoaXMuaGVhcFtiSW5kZXhdKTtcbiAgfVxuXG4gIHByaXZhdGUgc3dhcChhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICAgIGNvbnN0IHRlbXAgPSB0aGlzLmhlYXBbYV07XG4gICAgdGhpcy5oZWFwW2FdID0gdGhpcy5oZWFwW2JdO1xuICAgIHRoaXMuaGVhcFtiXSA9IHRlbXA7XG4gICAgdGhpcy5vbkluZGV4Q2hhbmdlZCh0aGlzLmhlYXBbYV0sIGEpO1xuICAgIHRoaXMub25JbmRleENoYW5nZWQodGhpcy5oZWFwW2JdLCBiKTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0dyYXBoLCBOb2RlLCBUZW5zb3J9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtJbnB1dFByb3ZpZGVyfSBmcm9tICcuL2lucHV0X3Byb3ZpZGVyJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4vbWF0aC9tYXRoJztcbmltcG9ydCB7TkRBcnJheSwgU2NhbGFyfSBmcm9tICcuL21hdGgvbmRhcnJheSc7XG5pbXBvcnQgKiBhcyBvcGVyYXRpb25fZW1pdHRlciBmcm9tICcuL29wZXJhdGlvbl9lbWl0dGVyJztcbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wcy9vcCc7XG5pbXBvcnQge09wdGltaXplcn0gZnJvbSAnLi9vcHRpbWl6ZXInO1xuaW1wb3J0ICogYXMgc2Vzc2lvbl91dGlsIGZyb20gJy4vc2Vzc2lvbl91dGlsJztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4vdGVuc29yX2FycmF5X21hcCc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogRmVlZEVudHJ5IGFzc29jaWF0ZXMgYSB0ZW5zb3Igd2l0aCB1c2VyLXByb3ZpZGVkIE5EQXJyYXkgZGF0YS5cbiAqL1xuZXhwb3J0IHR5cGUgRmVlZEVudHJ5ID0ge1xuICB0ZW5zb3I6IFRlbnNvcixcbiAgZGF0YTogTkRBcnJheXxJbnB1dFByb3ZpZGVyXG59O1xuXG4vKipcbiAqIEEgRmVlZERpY3Rpb25hcnkgaG9sZHMgYSBtYXAgZnJvbSB0ZW5zb3JzIHRvIHVzZXItcHJvdmlkZWQgTkRBcnJheXMuIEZlZWRcbiAqIGRpY3Rpb25hcmllcyByZXByZXNlbnQgdGhlICdlbnRyeSBwb2ludHMnIG9mIGV2YWx1YXRpb24sIHNpbmNlIGdyYXBoIG5vZGVzXG4gKiB0aGF0IGFyZSByZXBsYWNlZCBieSBmZWVkcyBkb24ndCBuZWVkIHRvIGhhdmUgdGhlaXIgaW5wdXQgbm9kZXMgZXZhbHVhdGVkLlxuICogRmVlZCBkaWN0aW9uYXJpZXMgdXN1YWxseSBwcm92aWRlIE5EQXJyYXkgZGF0YSBmb3IgUGxhY2Vob2xkZXIgbm9kZXMsIGJ1dCBhbnlcbiAqIG5vZGUgaW4gdGhlIGdyYXBoIGNhbiBiZSByZXBsYWNlZCBieSBhIGZlZWQgZGljdGlvbmFyeSBlbnRyeS5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWVkRGljdGlvbmFyeSB7XG4gIGRpY3Q6IHtbdGVuc29ySUQ6IG51bWJlcl06IEZlZWRFbnRyeX0gPSB7fTtcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBjb25zdHJ1Y3QgYSBGZWVkRGljdGlvbmFyeSBmcm9tIGFuIGFycmF5IG9mIGVudHJpZXMuXG4gICAqIEBwYXJhbSBmZWVkRW50cmllcyBPcHRpb25hbCBhcnJheSBvZiBGZWVkRW50cnkgb2JqZWN0cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGZlZWRFbnRyaWVzPzogRmVlZEVudHJ5W10pIHtcbiAgICBpZiAoZmVlZEVudHJpZXMpIHtcbiAgICAgIGZlZWRFbnRyaWVzLmZvckVhY2goZW50cnkgPT4gdGhpcy5kaWN0W2VudHJ5LnRlbnNvci5pZF0gPSBlbnRyeSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBlbnVtIENvc3RSZWR1Y3Rpb24ge1xuICBOT05FLFxuICBTVU0sXG4gIE1FQU5cbn1cblxuLyoqXG4gKiBBIFNlc3Npb24gbWFpbnRhaW5zIHRoZSBydW50aW1lIHN0YXRlIHJlcXVpcmVkIHRvIGVmZmljaWVudGx5IGV2YWx1YXRlIG5vZGVzLlxuICogT24gdGhlaXIgb3duLCBncmFwaCBvYmplY3RzIGFyZSB2ZXJ5IGxpZ2h0d2VpZ2h0IGxvZ2ljYWwgdG9wb2xvZ2llczsgdGhleVxuICogaGF2ZSBubyByZWxhdGlvbnNoaXAgd2l0aCB0aGUgR1BVLiBTZXNzaW9ucyBlbmNhcHN1bGF0ZSB0aGUgZXZhbHVhdGlvbiBvZlxuICogbm9kZXMsIHRoZSBtYW5hZ2VtZW50IG9mIEdQVSByZXNvdXJjZXMsIHRoZSBjYWNoaW5nIG9mIGV2YWx1YXRpb24gcGF0aHMsIGFuZFxuICogYW55dGhpbmcgZWxzZSByZXF1aXJlZCB0byBldmFsdWF0ZSBvciB0cmFpbiBhIG5ldHdvcmsuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXNzaW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBncmFwaCBUaGUgZ3JhcGggdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBTZXNzaW9uLlxuICAgKiBAcGFyYW0gbWF0aCBUaGUgTkRBcnJheU1hdGggaW50ZXJmYWNlIHRoYXQgdGhpcyBTZXNzaW9uIHNob3VsZCB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHByaXZhdGUgbWF0aDogTkRBcnJheU1hdGgpIHt9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2UgYWxsIHN5c3RlbSByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2Vzc2lvbi5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXAuZGlzcG9zZSgpO1xuICAgIE9iamVjdC5rZXlzKHRoaXMucnVudGltZUNhY2hlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBydW50aW1lID0gdGhpcy5ydW50aW1lQ2FjaGVba2V5XTtcbiAgICAgIGlmIChydW50aW1lLm9wZXJhdGlvbnMpIHtcbiAgICAgICAgcnVudGltZS5vcGVyYXRpb25zLmZvckVhY2gob3AgPT4gb3AuZGlzcG9zZSgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJ1bnRpbWVDYWNoZSA9IHt9O1xuICAgIGlmICh0aGlzLmJhdGNoU2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmJhdGNoU2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHRoaXMub25lU2NhbGFyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBhIGxpc3Qgb2YgdGVuc29ycywgdXNpbmcgdGhlIHByb3ZpZGVkIGZlZWQgZW50cmllcyB0byBwcm92aWRlXG4gICAqIHVwc3RyZWFtIE5EQXJyYXkgaW5wdXQuXG4gICAqIFdoZW4gdXNpbmcgYSBgTkRBcnJheU1hdGhgIG9iamVjdCBpbiBzYWZlIG1vZGUgdGhpcyBtdXN0IGJlIHVzZWQgaW4gYVxuICAgKiBtYXRoLnNjb3BlKCkuXG4gICAqIEBwYXJhbSB0ZW5zb3JzIFRoZSBsaXN0IG9mIHRlbnNvcnMgdG8gZXZhbHVhdGUuXG4gICAqIEBwYXJhbSBmZWVkRW50cmllcyBMaXN0IG9mIGBGZWVkRW50cnlgIHRvIHJlYWQgd2hlbiByZXBsYWNpbmcgZ3JhcGhcbiAgICogdGVuc29ycyB3aXRoIE5EQXJyYXlzLlxuICAgKiBAcmV0dXJuIFRoZSBjb21wdXRlZCB2YWx1ZXMgb2YgdGhlIHRlbnNvcnMuXG4gICAqL1xuICBldmFsQWxsKHRlbnNvcnM6IFRlbnNvcltdLCBmZWVkRW50cmllczogRmVlZEVudHJ5W10pOiBOREFycmF5W10ge1xuICAgIHJldHVybiB0aGlzLm1hdGguc2NvcGUoKCkgPT4ge1xuICAgICAgY29uc3QgZmVlZCA9IG5ldyBGZWVkRGljdGlvbmFyeShmZWVkRW50cmllcyk7XG4gICAgICBjb25zdCBydW50aW1lID0gdGhpcy5nZXRPckNyZWF0ZVJ1bnRpbWUodGVuc29ycywgZmVlZCk7XG5cbiAgICAgIGNvbnN0IGFjdGl2YXRpb25zID0gdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXA7XG5cbiAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbk91dHB1dHMoXG4gICAgICAgICAgcnVudGltZS5ub2RlcywgYWN0aXZhdGlvbnMpO1xuICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VUcmFuc2llbnRPcGVyYXRpb25BcnJheXMoXG4gICAgICAgICAgcnVudGltZS5vcGVyYXRpb25zLCB0aGlzLmFjdGl2YXRpb25BcnJheU1hcCwgdGhpcy5ncmFkaWVudEFycmF5TWFwKTtcblxuICAgICAgc2Vzc2lvbl91dGlsLmFkZFBlcnNpc3RlbnRBcnJheXNUb1RlbnNvckFycmF5TWFwKFxuICAgICAgICAgIHJ1bnRpbWUubm9kZXMsIGFjdGl2YXRpb25zKTtcbiAgICAgIHNlc3Npb25fdXRpbC5sb2FkSW5wdXRzRnJvbUZlZWREaWN0aW9uYXJ5VG9UZW5zb3JBcnJheU1hcChcbiAgICAgICAgICBmZWVkLCBhY3RpdmF0aW9ucywgdGhpcy5tYXRoKTtcblxuICAgICAgcnVudGltZS5vcGVyYXRpb25zLmZvckVhY2gob3AgPT4gb3AuZmVlZEZvcndhcmQodGhpcy5tYXRoLCBhY3RpdmF0aW9ucykpO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gdGVuc29ycy5tYXAoeCA9PiBhY3RpdmF0aW9ucy5nZXQoeCkpO1xuICAgICAgdGVuc29ycy5mb3JFYWNoKHggPT4gYWN0aXZhdGlvbnMuZGVsZXRlKHgpKTtcblxuICAgICAgc2Vzc2lvbl91dGlsLnJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcChcbiAgICAgICAgICBmZWVkLCBhY3RpdmF0aW9ucywgdGhpcy5tYXRoKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGUgYSB0ZW5zb3IsIHVzaW5nIHRoZSBwcm92aWRlZCBmZWVkIGVudHJpZXMgdG8gcHJvdmlkZVxuICAgKiB1cHN0cmVhbSBOREFycmF5IGlucHV0LlxuICAgKlxuICAgKiBAcGFyYW0gdGVuc29yIFRoZSB0ZW5zb3IgdG8gZXZhbHVhdGUuXG4gICAqIEBwYXJhbSBmZWVkRW50cmllcyBMaXN0IG9mIGBGZWVkRW50cnlgIHRvIHJlYWQgd2hlbiByZXBsYWNpbmcgZ3JhcGhcbiAgICogdGVuc29ycyB3aXRoIE5EQXJyYXlzLlxuICAgKiBAcmV0dXJuIFRoZSBjb21wdXRlZCB2YWx1ZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgZXZhbCh0ZW5zb3I6IFRlbnNvciwgZmVlZEVudHJpZXM6IEZlZWRFbnRyeVtdKTogTkRBcnJheSB7XG4gICAgcmV0dXJuIHRoaXMuZXZhbEFsbChbdGVuc29yXSwgZmVlZEVudHJpZXMpWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYWlucyBhIGJhdGNoLlxuICAgKiBSZXR1cm5zIGEgcmVkdWNlZCBjb3N0IGlmIHRoZSBjb3N0UmVkdWN0aW9uIHBhcmFtZXRlciBpcyBzZXQuXG4gICAqIFdoZW4gdXNpbmcgYSBgTkRBcnJheU1hdGhgIG9iamVjdCBpbiBzYWZlIG1vZGUgdGhpcyBtdXN0IGJlIHVzZWQgaW4gYVxuICAgKiBtYXRoLnNjb3BlKCkuXG4gICAqIEBwYXJhbSBjb3N0VGVuc29yIEEgdGVuc29yIHJlcHJlc2VudGluZyB0aGUgY29zdCB0byBvcHRpbWl6ZS4gU2hvdWxkIGJlIGFcbiAgICogc2NhbGFyLlxuICAgKiBAcGFyYW0gZmVlZEVudHJpZXMgRmVlZCBlbnRyaWVzIGZvciB0aGlzIHRyYWluIHJ1bi4gUHJvdmlkZXMgaW5wdXRzLlxuICAgKiBAcGFyYW0gYmF0Y2hTaXplIEJhdGNoIHNpemUgZm9yIHRoaXMgdHJhaW4gbG9vcC5cbiAgICogQHBhcmFtIG9wdGltaXplciBBbiBvcHRpbWl6ZXIgdG8gcGVyZm9ybSB3ZWlnaHQgdXBkYXRlcy5cbiAgICogQHBhcmFtIGNvc3RSZWR1Y3Rpb24gQW4gb3B0aW9uIHRvIGFsbG93IHRoZSB1c2VyIHRvIGdldCBhIHN1bW1lZCwgYXZlcmFnZWQsXG4gICAqIG9yIG5vIGNvc3QgYmFjay5cbiAgICogQHJldHVybiBUaGUgcmVkdWNlZCBjb3N0LCBpZiBjb3N0IHJlZHVjdGlvbiBpcyBub3QgTk9ORS4gVGhlIHVzZXIgaXNcbiAgICogcmVzcG9uc2libGUgZm9yIGRpc3Bvc2luZyB0aGUgY29zdCBOREFycmF5IGJldHdlZW4gdHJhaW4gbG9vcHMuXG4gICAqL1xuICB0cmFpbihcbiAgICAgIGNvc3RUZW5zb3I6IFRlbnNvciwgZmVlZEVudHJpZXM6IEZlZWRFbnRyeVtdLCBiYXRjaFNpemU6IG51bWJlcixcbiAgICAgIG9wdGltaXplcjogT3B0aW1pemVyLCBjb3N0UmVkdWN0aW9uID0gQ29zdFJlZHVjdGlvbi5OT05FKTogU2NhbGFyIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdXRpbC5pc1NjYWxhclNoYXBlKGNvc3RUZW5zb3Iuc2hhcGUpLFxuICAgICAgICAnQ29zdCB0ZW5zb3IgZm9yIHRyYWluaW5nIG11c3QgYmUgYSBzY2FsYXIgdmFsdWUuJyk7XG5cbiAgICBpZiAodGhpcy5wcmV2QmF0Y2hTaXplICE9PSBiYXRjaFNpemUpIHtcbiAgICAgIHRoaXMucHJldkJhdGNoU2l6ZSA9IGJhdGNoU2l6ZTtcbiAgICAgIHRoaXMuYmF0Y2hTaXplU2NhbGFyID0gU2NhbGFyLm5ldyhiYXRjaFNpemUpO1xuICAgIH1cblxuICAgIGNvbnN0IGZlZWQgPSBuZXcgRmVlZERpY3Rpb25hcnkoZmVlZEVudHJpZXMpO1xuICAgIHNlc3Npb25fdXRpbC50aHJvd0lmRmVlZERpY3Rpb25hcnlDb250YWluc05EQXJyYXlzKGZlZWQpO1xuXG4gICAgY29uc3QgcnVudGltZSA9IHRoaXMuZ2V0T3JDcmVhdGVSdW50aW1lKFtjb3N0VGVuc29yXSwgZmVlZCk7XG4gICAgY29uc3QgaW5mZXJlbmNlT3BlcmF0aW9ucyA9IHJ1bnRpbWUub3BlcmF0aW9ucztcbiAgICBjb25zdCBiYWNrUHJvcE9wZXJhdGlvbnMgPSBydW50aW1lLm9wZXJhdGlvbnMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgY29uc3QgYWN0aXZhdGlvbnMgPSB0aGlzLmFjdGl2YXRpb25BcnJheU1hcDtcbiAgICBjb25zdCBncmFkaWVudHMgPSB0aGlzLmdyYWRpZW50QXJyYXlNYXA7XG4gICAgZ3JhZGllbnRzLnNldChjb3N0VGVuc29yLCB0aGlzLm9uZVNjYWxhcik7XG5cbiAgICBzZXNzaW9uX3V0aWwuYWRkUGVyc2lzdGVudEFycmF5c1RvVGVuc29yQXJyYXlNYXAoXG4gICAgICAgIHJ1bnRpbWUubm9kZXMsIGFjdGl2YXRpb25zKTtcblxuICAgIG9wdGltaXplci5iZWZvcmVCYXRjaChcbiAgICAgICAgdGhpcy5tYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpO1xuXG4gICAgcmV0dXJuIHRoaXMubWF0aC5zY29wZSgoa2VlcCwgdHJhY2spID0+IHtcbiAgICAgIGxldCBjb3N0ID0gdHJhY2soU2NhbGFyLm5ldygwKSk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hTaXplOyArK2kpIHtcbiAgICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uT3V0cHV0cyhcbiAgICAgICAgICAgIHJ1bnRpbWUubm9kZXMsIGFjdGl2YXRpb25zKTtcbiAgICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uSW5wdXRHcmFkaWVudHMoXG4gICAgICAgICAgICBydW50aW1lLm5vZGVzLCBncmFkaWVudHMpO1xuICAgICAgICBzZXNzaW9uX3V0aWwuZGlzcG9zZVRyYW5zaWVudE9wZXJhdGlvbkFycmF5cyhcbiAgICAgICAgICAgIHJ1bnRpbWUub3BlcmF0aW9ucywgYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7XG5cbiAgICAgICAgc2Vzc2lvbl91dGlsLmxvYWRJbnB1dHNGcm9tRmVlZERpY3Rpb25hcnlUb1RlbnNvckFycmF5TWFwKFxuICAgICAgICAgICAgZmVlZCwgYWN0aXZhdGlvbnMsIHRoaXMubWF0aCk7XG5cbiAgICAgICAgaW5mZXJlbmNlT3BlcmF0aW9ucy5mb3JFYWNoKFxuICAgICAgICAgICAgb3AgPT4gb3AuZmVlZEZvcndhcmQodGhpcy5tYXRoLCBhY3RpdmF0aW9ucykpO1xuICAgICAgICBiYWNrUHJvcE9wZXJhdGlvbnMuZm9yRWFjaChcbiAgICAgICAgICAgIG9wID0+IG9wLmJhY2tQcm9wKHRoaXMubWF0aCwgYWN0aXZhdGlvbnMsIGdyYWRpZW50cykpO1xuXG4gICAgICAgIG9wdGltaXplci5hZnRlckV4YW1wbGUodGhpcy5tYXRoLCBydW50aW1lLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTtcblxuICAgICAgICBzZXNzaW9uX3V0aWwucmVsZWFzZUZlZWREaWN0aW9uYXJ5SW5wdXRzRnJvbVRlbnNvckFycmF5TWFwKFxuICAgICAgICAgICAgZmVlZCwgYWN0aXZhdGlvbnMsIHRoaXMubWF0aCk7XG5cbiAgICAgICAgY29zdCA9IHRoaXMudXBkYXRlQ29zdEZvckV4YW1wbGUoXG4gICAgICAgICAgICBjb3N0LCBhY3RpdmF0aW9ucy5nZXQoY29zdFRlbnNvciksIGNvc3RSZWR1Y3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBvcHRpbWl6ZXIuYWZ0ZXJCYXRjaChcbiAgICAgICAgICB0aGlzLm1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7XG5cbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNvc3RGb3JCYXRjaChjb3N0LCBjb3N0UmVkdWN0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlQ29zdEZvckV4YW1wbGUoXG4gICAgICB0b3RhbENvc3Q6IFNjYWxhciwgY3VyckNvc3Q6IFNjYWxhcixcbiAgICAgIGNvc3RSZWR1Y3Rpb246IENvc3RSZWR1Y3Rpb24pOiBTY2FsYXIge1xuICAgIGlmIChjb3N0UmVkdWN0aW9uID09PSBDb3N0UmVkdWN0aW9uLk1FQU4gfHxcbiAgICAgICAgY29zdFJlZHVjdGlvbiA9PT0gQ29zdFJlZHVjdGlvbi5TVU0pIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdGguYWRkKHRvdGFsQ29zdCwgY3VyckNvc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG90YWxDb3N0O1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDb3N0Rm9yQmF0Y2godG90YWxDb3N0OiBTY2FsYXIsIGNvc3RSZWR1Y3Rpb246IENvc3RSZWR1Y3Rpb24pOlxuICAgICAgU2NhbGFyIHtcbiAgICBpZiAoY29zdFJlZHVjdGlvbiA9PT0gQ29zdFJlZHVjdGlvbi5NRUFOKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRoLmRpdmlkZSh0b3RhbENvc3QsIHRoaXMuYmF0Y2hTaXplU2NhbGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsQ29zdDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0T3JDcmVhdGVSdW50aW1lKHRlbnNvcnM6IFRlbnNvcltdLCBmZWVkOiBGZWVkRGljdGlvbmFyeSk6XG4gICAgICBTZXNzaW9uUnVudGltZSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5tYWtlUnVudGltZUNhY2hlS2V5KHRlbnNvcnMsIGZlZWQpO1xuICAgIGxldCBydW50aW1lID0gdGhpcy5ydW50aW1lQ2FjaGVba2V5XTtcbiAgICBpZiAocnVudGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgbm9kZXMgPVxuICAgICAgICAgIHNlc3Npb25fdXRpbC5nZXRPcmRlcmVkRXZhbHVhdGlvblNldEZyb21FdmFsVGVuc29yKHRlbnNvcnMsIGZlZWQpO1xuICAgICAgLy8gSW4gaW5mZXJlbmNlIG1vZGUgc3BsaXQgbm9kZXMgYXJlIG5vdCBuZWVkZWQsIGJ1dCB0aGVpciBjb3N0IGlzXG4gICAgICAvLyBuZWdsaWdpYmxlLCBhbmQgYWx3YXlzIGFkZGluZyB0aGVtIGluIGFsbG93cyBmb3IgY2FjaGluZyBvZiAxIHJ1bnRpbWVcbiAgICAgIC8vIGZvciBib3RoIHRyYWluL2V2YWwuXG4gICAgICBub2RlcyA9IHNlc3Npb25fdXRpbC5hZGRTcGxpdE5vZGVzKG5vZGVzKTtcbiAgICAgIHNlc3Npb25fdXRpbC5yZW1vdmVGZWVkRGljdGlvbmFyeU5vZGVzRnJvbUV2YWx1YXRpb25TZXQoZmVlZCwgbm9kZXMpO1xuICAgICAgc2Vzc2lvbl91dGlsLnRocm93RXJyb3JJZkV2YWx1YXRpb25TZXRDb250YWluc1BsYWNlaG9sZGVyTm9kZXMobm9kZXMpO1xuICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9IG9wZXJhdGlvbl9lbWl0dGVyLmVtaXRGcm9tR3JhcGhOb2Rlcyhub2Rlcyk7XG4gICAgICBydW50aW1lID0ge25vZGVzLCBvcGVyYXRpb25zfTtcbiAgICAgIHRoaXMucnVudGltZUNhY2hlW2tleV0gPSBydW50aW1lO1xuICAgIH1cblxuICAgIHJldHVybiBydW50aW1lO1xuICB9XG5cbiAgcHJpdmF0ZSBtYWtlUnVudGltZUNhY2hlS2V5KHRlbnNvcnM6IFRlbnNvcltdLCBmZWVkOiBGZWVkRGljdGlvbmFyeSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRlbnNvcnMubWFwKHggPT4geC5pZCkuc29ydCgpLmpvaW4oJ18nKSArICdfXycgK1xuICAgICAgICBPYmplY3Qua2V5cyhmZWVkLmRpY3QpLnNvcnQoKS5qb2luKCdfJyk7XG4gIH1cblxuICAvKiogTWFwcyBlYWNoIG91dHB1dCB0ZW5zb3Igb2YgdGhlIGdyYXBoIHRvIGl0cyBhY3RpdmF0aW9uIHZhbHVlLiAqL1xuICBhY3RpdmF0aW9uQXJyYXlNYXAgPSBuZXcgVGVuc29yQXJyYXlNYXAoKTtcbiAgLyoqIE1hcHMgZWFjaCB0ZW5zb3Igb2YgdGhlIGdyYXBoIHRvIGl0cyBkZXJpdmF0aXZlIHdydCB0aGUgY29zdCBmdW5jdGlvbi4gKi9cbiAgZ3JhZGllbnRBcnJheU1hcCA9IG5ldyBUZW5zb3JBcnJheU1hcCgpO1xuICBwcml2YXRlIHJ1bnRpbWVDYWNoZToge1trZXk6IHN0cmluZ106IFNlc3Npb25SdW50aW1lfSA9IHt9O1xuICAvKiogQmF0Y2ggc2l6ZSBvZiB0aGUgcHJldmlvdXMgdHJhaW4oKSBjYWxsLiAqL1xuICBwcml2YXRlIHByZXZCYXRjaFNpemU6IG51bWJlcjtcbiAgcHJpdmF0ZSBiYXRjaFNpemVTY2FsYXI6IFNjYWxhcjtcbiAgcHJpdmF0ZSBvbmVTY2FsYXIgPSBTY2FsYXIubmV3KDEpO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IHR5cGUgU2Vzc2lvblJ1bnRpbWUgPSB7XG4gIG5vZGVzOiBOb2RlW107IG9wZXJhdGlvbnM6IE9wZXJhdGlvbltdO1xufTtcbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuaW1wb3J0IHtDb25zdGFudE5vZGUsIE5vZGUsIFBsYWNlaG9sZGVyTm9kZSwgU3BsaXROb2RlLCBUZW5zb3IsIFZhcmlhYmxlTm9kZX0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQgKiBhcyBncmFwaF91dGlsIGZyb20gJy4vZ3JhcGhfdXRpbCc7XG5pbXBvcnQge0lucHV0UHJvdmlkZXJ9IGZyb20gJy4vaW5wdXRfcHJvdmlkZXInO1xuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtOREFycmF5fSBmcm9tICcuL21hdGgvbmRhcnJheSc7XG5pbXBvcnQge09wZXJhdGlvbn0gZnJvbSAnLi9vcHMvb3AnO1xuaW1wb3J0IHtGZWVkRGljdGlvbmFyeX0gZnJvbSAnLi9zZXNzaW9uJztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4vdGVuc29yX2FycmF5X21hcCc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncmFwaCBub2RlcyB0aGF0IHN0b3AgdHJhdmVyc2FsLCBiYXNlZCBvbiB0aGUgY29udGVudHNcbiAqIG9mIHRoZSBwcm92aWRlZCBGZWVkRGljdGlvbmFyeS4gVGhpcyBpcyBhIHNpbXBsZSAxOjEgZXh0cmFjdGlvbiBvZiBub2RlcyBmcm9tXG4gKiB0aGUgRmVlZERpY3Rpb25hcnkuXG4gKlxuICogQGhpZGRlblxuICogQHBhcmFtIGZlZWREaWN0aW9uYXJ5IFRoZSBGZWVkRGljdGlvbmFyeSB0byBzY2FuIGZvciB0ZXJtaW5hdGlvbiBub2Rlcy5cbiAqIEByZXR1cm4gYW4gYXJyYXkgb2YgTm9kZXMgd2hpY2ggaGFsdCB0cmF2ZXJzYWwgd2hlbiB2aXNpdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGVybWluYXRpbmdOb2Rlc0Zyb21GZWVkRGljdGlvbmFyeShcbiAgICBmZWVkRGljdGlvbmFyeTogRmVlZERpY3Rpb25hcnkpOiBOb2RlW10ge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZmVlZERpY3Rpb25hcnkuZGljdClcbiAgICAgIC5tYXAodGVuc29ySUQgPT4gZmVlZERpY3Rpb25hcnkuZGljdFsrdGVuc29ySURdLnRlbnNvci5ub2RlKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIHRlbnNvciBhbmQgYSBmZWVkIGRpY3Rpb25hcnksIGNvbXB1dGVzIHRoZSBzZXQgb2Ygbm9kZXMgdGhhdCBuZWVkIHRvXG4gKiBiZSBldmFsdWF0ZWQgdG8gcGVyZm9ybSBpbmZlcmVuY2UuXG4gKlxuICogQGhpZGRlblxuICogQHBhcmFtIGV2YWxUZW5zb3JzIFRoZSBsaXN0IG9mIHRlbnNvcnMgdG8gZXZlbnR1YWxseSBiZSBldmFsdWF0ZWQuXG4gKiBAcGFyYW0gZmVlZERpY3Rpb25hcnkgVGhlIHBvcHVsYXRlZCBmZWVkIGRpY3Rpb25hcnkuXG4gKiBAcmV0dXJuIFRoZSBzZXQgb2Ygbm9kZXMgdG8gZXZhbHVhdGUsIGluIGV2YWx1YXRpb24gb3JkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmRlcmVkRXZhbHVhdGlvblNldEZyb21FdmFsVGVuc29yKFxuICAgIGV2YWxUZW5zb3JzOiBUZW5zb3JbXSwgZmVlZERpY3Rpb25hcnk6IEZlZWREaWN0aW9uYXJ5KTogTm9kZVtdIHtcbiAgY29uc3QgdGVybWluYXRpbmdOb2RlcyA9XG4gICAgICBnZXRUZXJtaW5hdGluZ05vZGVzRnJvbUZlZWREaWN0aW9uYXJ5KGZlZWREaWN0aW9uYXJ5KTtcbiAgY29uc3QgZXZhbE5vZGVzID0gZXZhbFRlbnNvcnMubWFwKHggPT4geC5ub2RlKTtcbiAgY29uc3QgdW5vcmRlcmVkRXZhbHVhdGlvblNldCA9XG4gICAgICBncmFwaF91dGlsLmdldFVub3JkZXJlZEV2YWx1YXRpb25TZXQoZXZhbE5vZGVzLCB0ZXJtaW5hdGluZ05vZGVzKTtcbiAgY29uc3Qgb3JkZXJlZEV2YWx1YXRpb25TZXQgPVxuICAgICAgZ3JhcGhfdXRpbC5nZXRPcmRlcmVkRXZhbHVhdGlvblNldCh1bm9yZGVyZWRFdmFsdWF0aW9uU2V0KTtcbiAgcmV0dXJuIG9yZGVyZWRFdmFsdWF0aW9uU2V0O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgcHJvdmlkZWQgbm9kZSBhcnJheSBhbmQgYWRkcyBhbGwgcGVyc2lzdGVudCBub2RlIE5EQXJyYXlzIHRvXG4gKiB0aGUgcHJvdmlkZWQgVGVuc29yQXJyYXlNYXAuXG4gKlxuICogQGhpZGRlblxuICogQHBhcmFtIGV2YWx1YXRpb25TZXQgVGhlIGFycmF5IG9mIG5vZGVzIHRvIHNjYW4uXG4gKiBAcGFyYW0gdGVuc29yQXJyYXlNYXAgVGhlIG1hcCB0aGF0IHJlY2VpdmVzIHRoZSBOREFycmF5cyBmcm9tIHBlcnNpc3RlbnRcbiAqIG5vZGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUGVyc2lzdGVudEFycmF5c1RvVGVuc29yQXJyYXlNYXAoXG4gICAgZXZhbHVhdGlvblNldDogTm9kZVtdLCB0ZW5zb3JBcnJheU1hcDogVGVuc29yQXJyYXlNYXApIHtcbiAgZXZhbHVhdGlvblNldC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgVmFyaWFibGVOb2RlIHx8IG5vZGUgaW5zdGFuY2VvZiBDb25zdGFudE5vZGUpIHtcbiAgICAgIHRlbnNvckFycmF5TWFwLnNldChub2RlLm91dHB1dCwgbm9kZS5kYXRhKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhcmlhYmxlTm9kZXNGcm9tRXZhbHVhdGlvblNldChldmFsdWF0aW9uU2V0OiBOb2RlW10pOlxuICAgIFZhcmlhYmxlTm9kZVtdIHtcbiAgY29uc3Qgbm9kZXM6IFZhcmlhYmxlTm9kZVtdID0gW107XG4gIGV2YWx1YXRpb25TZXQuZm9yRWFjaChub2RlID0+IHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFZhcmlhYmxlTm9kZSkge1xuICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbm9kZXM7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dJZkZlZWREaWN0aW9uYXJ5Q29udGFpbnNOREFycmF5cyhcbiAgICBmZWVkRGljdGlvbmFyeTogRmVlZERpY3Rpb25hcnkpIHtcbiAgT2JqZWN0LmtleXMoZmVlZERpY3Rpb25hcnkuZGljdCkuZm9yRWFjaCh0ZW5zb3JJRCA9PiB7XG4gICAgaWYgKGZlZWREaWN0aW9uYXJ5LmRpY3RbK3RlbnNvcklEXS5kYXRhIGluc3RhbmNlb2YgTkRBcnJheSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICd0cmFpbmluZyByZXF1aXJlcyBGZWVkRGljdGlvbmFyeSBlbnRyaWVzIHRvIGJlIElucHV0UHJvdmlkZXJzJyArXG4gICAgICAgICAgJ2FuZCBub3QgTkRBcnJheXMuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW5wdXRzRnJvbUZlZWREaWN0aW9uYXJ5VG9UZW5zb3JBcnJheU1hcChcbiAgICBiYXRjaEZlZWQ6IEZlZWREaWN0aW9uYXJ5LCBhY3RpdmF0aW9uczogVGVuc29yQXJyYXlNYXAsIG1hdGg6IE5EQXJyYXlNYXRoKSB7XG4gIE9iamVjdC5rZXlzKGJhdGNoRmVlZC5kaWN0KS5mb3JFYWNoKHRlbnNvcklEID0+IHtcbiAgICBjb25zdCBmZWVkRW50cnkgPSBiYXRjaEZlZWQuZGljdFsrdGVuc29ySURdO1xuXG4gICAgbGV0IGRhdGE6IE5EQXJyYXk7XG4gICAgaWYgKGZlZWRFbnRyeS5kYXRhIGluc3RhbmNlb2YgTkRBcnJheSkge1xuICAgICAgZGF0YSA9IGZlZWRFbnRyeS5kYXRhIGFzIE5EQXJyYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gZmVlZEVudHJ5LmRhdGEgYXMgSW5wdXRQcm92aWRlcjtcbiAgICAgIGRhdGEgPSBwcm92aWRlci5nZXROZXh0Q29weShtYXRoKTtcbiAgICB9XG5cbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdXRpbC5hcnJheXNFcXVhbChmZWVkRW50cnkudGVuc29yLnNoYXBlLCBkYXRhLnNoYXBlKSxcbiAgICAgICAgYEVycm9yIGxvYWRpbmcgRmVlZEVudHJ5OiBmZWVkaW5nIE5EQXJyYXkgb2Ygc2hhcGUgJHtkYXRhLnNoYXBlfSBgICtcbiAgICAgICAgICAgIGBkb2VzIG5vdCBtYXRjaCBUZW5zb3IgKGlkOiAke2ZlZWRFbnRyeS50ZW5zb3IuaWR9KSBzaGFwZTogYCArXG4gICAgICAgICAgICBgJHtmZWVkRW50cnkudGVuc29yLnNoYXBlfS5gKTtcbiAgICBhY3RpdmF0aW9ucy5zZXQoZmVlZEVudHJ5LnRlbnNvciwgZGF0YSk7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVsZWFzZUZlZWREaWN0aW9uYXJ5SW5wdXRzRnJvbVRlbnNvckFycmF5TWFwKFxuICAgIGJhdGNoRmVlZDogRmVlZERpY3Rpb25hcnksIGFjdGl2YXRpb25zOiBUZW5zb3JBcnJheU1hcCwgbWF0aDogTkRBcnJheU1hdGgpIHtcbiAgT2JqZWN0LmtleXMoYmF0Y2hGZWVkLmRpY3QpLmZvckVhY2godGVuc29ySUQgPT4ge1xuICAgIGNvbnN0IGZlZWRFbnRyeSA9IGJhdGNoRmVlZC5kaWN0Wyt0ZW5zb3JJRF07XG5cbiAgICBpZiAoIShmZWVkRW50cnkuZGF0YSBpbnN0YW5jZW9mIE5EQXJyYXkpKSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGZlZWRFbnRyeS5kYXRhIGFzIElucHV0UHJvdmlkZXI7XG5cbiAgICAgIGNvbnN0IGZlZWRFbnRyeUFycmF5ID0gYWN0aXZhdGlvbnMuZ2V0KGZlZWRFbnRyeS50ZW5zb3IpO1xuICAgICAgcHJvdmlkZXIuZGlzcG9zZUNvcHkobWF0aCwgZmVlZEVudHJ5QXJyYXkpO1xuICAgIH1cblxuICAgIGFjdGl2YXRpb25zLmRlbGV0ZShmZWVkRW50cnkudGVuc29yKTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgbm9kZXMgZnJvbSB0aGUgcHJvdmlkZWQgTm9kZSBhcnJheSB3aG9zZSBvdXRwdXQgdGVuc29ycyBleGlzdCBpblxuICogdGhlIHByb3ZpZGVkIGZlZWQgZGljdGlvbmFyeS4gQWZ0ZXIgY2FsbGluZyB0aGlzLCB0aGUgTm9kZSBhcnJheSBzaG91bGRcbiAqIGNvbnRhaW4gemVybyBQbGFjZWhvbGRlciBub2Rlcywgb3IgdGhlIHVzZXIgaGFzIGZhaWxlZCB0byBwcm92aWRlIGEgZmVlZCBmb3JcbiAqIGEgUGxhY2Vob2xkZXIgbm9kZS5cbiAqXG4gKiBAaGlkZGVuXG4gKiBAcGFyYW0gZmVlZERpY3Rpb25hcnkgVGhlIEZlZWREaWN0aW9uYXJ5IHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0gZXZhbHVhdGlvblNldCBUaGUgYXJyYXkgb2Ygbm9kZXMgdG8gcmVtb3ZlIGlucHV0IG5vZGVzIGZyb20uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVGZWVkRGljdGlvbmFyeU5vZGVzRnJvbUV2YWx1YXRpb25TZXQoXG4gICAgZmVlZERpY3Rpb25hcnk6IEZlZWREaWN0aW9uYXJ5LCBldmFsdWF0aW9uU2V0OiBOb2RlW10pIHtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGV2YWx1YXRpb25TZXQubGVuZ3RoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGV2YWx1YXRpb25TZXRbaV07XG4gICAgaWYgKGZlZWREaWN0aW9uYXJ5LmRpY3Rbbm9kZS5vdXRwdXQuaWRdICE9IG51bGwpIHtcbiAgICAgIGV2YWx1YXRpb25TZXQuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICArK2k7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzcG9zZXMgYW55IE5EQXJyYXlzIG9uIHRoZSB0ZW5zb3JBcnJheU1hcCBmcm9tIG9wZXJhdGlvbiBvdXRwdXRzIGFuZCBzZXRzXG4gKiB0aGUgdmFsdWUgdG8gbnVsbC5cbiAqXG4gKiBAaGlkZGVuXG4gKiBAcGFyYW0gZXZhbHVhdGlvblNldCBUaGUgc2V0IG9mIG5vZGVzIHRvIGJlIGV2YWx1YXRlZC5cbiAqIEBwYXJhbSB0ZW5zb3JBcnJheU1hcCBUaGUgbWFwIHRvIGRpc3Bvc2UgYW5kIGluaXRpYWxpemUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbk91dHB1dHMoXG4gICAgZXZhbHVhdGlvblNldDogTm9kZVtdLCB0ZW5zb3JBcnJheU1hcDogVGVuc29yQXJyYXlNYXApIHtcbiAgZXZhbHVhdGlvblNldC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgIGlmICghZ3JhcGhfdXRpbC5pc0lucHV0Tm9kZShub2RlKSkge1xuICAgICAgaWYgKCFncmFwaF91dGlsLmlzUGFzc3Rocm91Z2hOb2RlKG5vZGUsIHRlbnNvckFycmF5TWFwKSkge1xuICAgICAgICB0ZW5zb3JBcnJheU1hcC5kaXNwb3NlQXJyYXkobm9kZS5vdXRwdXQpO1xuICAgICAgfVxuICAgICAgdGVuc29yQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBudWxsKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIERpc3Bvc2VzIGFueSBOREFycmF5cyBvbiB0aGUgdGVuc29yQXJyYXlNYXAgZnJvbSBkZXJpdmF0aXZlcyBvZiBvcGVyYXRpb25cbiAqIGlucHV0cyBhbmQgc2V0cyB0aGUgdmFsdWUgdG8gbnVsbC5cbiAqXG4gKiBAaGlkZGVuXG4gKiBAcGFyYW0gZXZhbHVhdGlvblNldCBUaGUgc2V0IG9mIG5vZGVzIHRvIGJlIGV2YWx1YXRlZC5cbiAqIEBwYXJhbSBncmFkaWVudHMgVGhlIGdyYWRpZW50IG1hcCB0byBkaXNwb3NlIGFuZCBpbml0aWFsaXplLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25JbnB1dEdyYWRpZW50cyhcbiAgICBldmFsdWF0aW9uU2V0OiBOb2RlW10sIGdyYWRpZW50czogVGVuc29yQXJyYXlNYXApIHtcbiAgZXZhbHVhdGlvblNldC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgIE9iamVjdC5rZXlzKG5vZGUuaW5wdXRzKS5mb3JFYWNoKGlucHV0TmFtZSA9PiB7XG4gICAgICBjb25zdCBpbnB1dCA9IG5vZGUuaW5wdXRzW2lucHV0TmFtZV07XG4gICAgICBpZiAoZ3JhZGllbnRzLmdldChpbnB1dCwgdHJ1ZSkgIT09IGdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQsIHRydWUpKSB7XG4gICAgICAgIGdyYWRpZW50cy5kaXNwb3NlQXJyYXkoaW5wdXQpO1xuICAgICAgfVxuICAgICAgZ3JhZGllbnRzLnNldChpbnB1dCwgbnVsbCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogQ2FsbHMgdW5kZXJseWluZyBvcGVyYXRpb24gZGlzcG9zZVRyYW5zaWVudEFycmF5cyBtZXRob2RzIHdoaWNoIGNsZWFuIHVwIGFueVxuICogTkRBcnJheXMgd2hpY2ggb3BlcmF0aW9ucyBtYXkgaGF2ZSBjcmVhdGVkIGR1cmluZyBhIHJ1bi5cbiAqXG4gKiBAaGlkZGVuXG4gKiBAcGFyYW0gb3BlcmF0aW9uTm9kZXMgVGhlIGFycmF5IG9mIE5vZGVzIHRvIHRyYXZlcnNlLlxuICogQHBhcmFtIG91dHB1dFRlbnNvciBUaGUgdGVuc29yIGJlaW5nIGV2YWx1YXRlZC5cbiAqIEBwYXJhbSBtYXAgVGhlIFRlbnNvckFycmF5TWFwIHRvIG9wZXJhdGUgb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlVHJhbnNpZW50T3BlcmF0aW9uQXJyYXlzKFxuICAgIG9wZXJhdGlvbnM6IE9wZXJhdGlvbltdLCBhY3RpdmF0aW9uczogVGVuc29yQXJyYXlNYXAsXG4gICAgZ3JhZGllbnRzOiBUZW5zb3JBcnJheU1hcCkge1xuICBvcGVyYXRpb25zLmZvckVhY2gob3AgPT4gb3AuZGlzcG9zZVRyYW5zaWVudEFycmF5cyhhY3RpdmF0aW9ucywgZ3JhZGllbnRzKSk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhlIHByb3ZpZGVkIE5vZGUgYXJyYXkgYW5kIHRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlcmUgYXJlIGFueVxuICogUGxhY2Vob2xkZXIgbm9kZXMgcHJlc2VudC4gQ2FsbCBhZnRlciB0aGUgZXZhbHVhdGlvbiBzZXQgaGFzIGJlZW4gcHJ1bmVkIHdpdGhcbiAqIHRoZSBhY2NvbXBhbnlpbmcgRmVlZERpY3Rpb25hcnkgdG8gZW5zdXJlIHRoYXQgYWxsIGlucHV0cyBoYXZlIGJlZW4gcmVzb2x2ZWQuXG4gKlxuICogQGhpZGRlblxuICogQHBhcmFtIGV2YWx1YXRpb25TZXQgVGhlIGFycmF5IG9mIG5vZGVzIHRvIHNjYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd0Vycm9ySWZFdmFsdWF0aW9uU2V0Q29udGFpbnNQbGFjZWhvbGRlck5vZGVzKFxuICAgIGV2YWx1YXRpb25TZXQ6IE5vZGVbXSkge1xuICBldmFsdWF0aW9uU2V0LmZvckVhY2gobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBQbGFjZWhvbGRlck5vZGUpIHtcbiAgICAgIGNvbnN0IHNoYXBlID0gJ1snICsgbm9kZS5vdXRwdXQuc2hhcGUuam9pbignLCAnKSArICddJztcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnUGxhY2Vob2xkZXIgbm9kZSBcIicgKyBub2RlLm5hbWUgKyAnXCIgJyArIHNoYXBlICtcbiAgICAgICAgICAnIG5vdCBwcmVzZW50IGluIGZlZWQgZGljdGlvbmFyeS4nKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEluamVjdHMgc3BsaXRzIG5vZGVzIGFmdGVyIGV2ZXJ5IG5vZGUgdGhhdCBoYXMgbXVsdGlwbGUgY29uc3VtZXJzLlxuICpcbiAqIEBoaWRkZW5cbiAqIEBwYXJhbSBub2RlcyBUaGUgbm9kZSBsaXN0IGluIGV2YWx1YXRpb24gb3JkZXIuXG4gKiBAcmV0dXJuIFRoZSBub2RlIGxpc3Qgd2l0aCBzcGxpdCBub2RlcyBpbmplY3RlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFNwbGl0Tm9kZXMobm9kZXM6IE5vZGVbXSk6IE5vZGVbXSB7XG4gIGNvbnN0IG5vZGVJZFRvTnVtQ29uc3VtZXJzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBub2RlSWRUb1NwbGl0Tm9kZToge1tub2RlSWQ6IG51bWJlcl06IFNwbGl0Tm9kZX0gPSB7fTtcblxuICAvLyBGaW5kIG5vZGVzIHRoYXQgaGF2ZSBtdWx0aXBsZSBjb25zdW1lcnMuXG4gIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUuaW5wdXRzKTtcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGlucHV0VGVuc29yID0gbm9kZS5pbnB1dHNba2V5XTtcbiAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRUZW5zb3Iubm9kZTtcbiAgICAgIGlmIChub2RlSWRUb051bUNvbnN1bWVyc1tpbnB1dC5pZF0gPT0gbnVsbCkge1xuICAgICAgICBub2RlSWRUb051bUNvbnN1bWVyc1tpbnB1dC5pZF0gPSAwO1xuICAgICAgfVxuICAgICAgbm9kZUlkVG9OdW1Db25zdW1lcnNbaW5wdXQuaWRdKys7XG4gICAgICBpZiAobm9kZUlkVG9OdW1Db25zdW1lcnNbaW5wdXQuaWRdID4gMSAmJlxuICAgICAgICAgIG5vZGVJZFRvU3BsaXROb2RlW2lucHV0LmlkXSA9PSBudWxsKSB7XG4gICAgICAgIG5vZGVJZFRvU3BsaXROb2RlW2lucHV0LmlkXSA9IG5ldyBTcGxpdE5vZGUoaW5wdXQuZ3JhcGgsIGlucHV0VGVuc29yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gSW5qZWN0IGEgc3BsaXQgbm9kZSBhZnRlciBlYWNoIG5vZGUgdGhhdCBoYXMgbXVsdGlwbGUgY29uc3VtZXJzIGFuZFxuICAvLyByZXdpcmUgdGhlIGlucHV0cyBvZiB0aGUgY29uc3VtZXJzIHRvIGNvbnN1bWUgdGhlIG91dHB1dCB0ZW5zb3JzIG9mIHRoZVxuICAvLyBzcGxpdCBub2RlIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIG5vZGUuIEVhY2ggY29uc3VtZXIgY29uc3VtZXMgYVxuICAvLyBkaWZmZXJlbnQgb3V0cHV0IHRlbnNvciBzbyB0aGF0IGRlcml2YXRpdmVzIGFyZSBub3Qgb3ZlcndyaXR0ZW4uXG4gIC8vIHgtLT55ICBiZWNvbWVzIHgtLT5zLS0+eSAgIHdoZXJlIHkgY29uc3VtZXMgdGhlIDFzdCBvdXRwdXQgdGVuc29yIG9mIHNcbiAgLy8gfC0tPnogICAgICAgICAgICAgIHwtLT56ICAgICBhbmQgeiBjb25zdW1lcyB0aGUgMm5kIG91dHB1dCB0ZW5zb3Igb2Ygc1xuICBjb25zdCBuZXdOb2RlczogTm9kZVtdID0gW107XG4gIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgbmV3Tm9kZXMucHVzaChub2RlKTtcbiAgICBpZiAobm9kZS5pZCBpbiBub2RlSWRUb1NwbGl0Tm9kZSkge1xuICAgICAgY29uc3Qgc3BsaXROb2RlID0gbm9kZUlkVG9TcGxpdE5vZGVbbm9kZS5pZF07XG4gICAgICBuZXdOb2Rlcy5wdXNoKHNwbGl0Tm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhub2RlLmlucHV0cyk7XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBpbnB1dFRlbnNvciA9IG5vZGUuaW5wdXRzW2tleV07XG4gICAgICBjb25zdCBpbnB1dElkID0gaW5wdXRUZW5zb3Iubm9kZS5pZDtcbiAgICAgIGlmIChpbnB1dElkIGluIG5vZGVJZFRvU3BsaXROb2RlKSB7XG4gICAgICAgIG5vZGUuaW5wdXRzW2tleV0gPSBub2RlSWRUb1NwbGl0Tm9kZVtpbnB1dElkXS5nZXROZXdPdXRwdXRUZW5zb3IoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBuZXdOb2Rlcztcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtOb2RlfSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4vbWF0aC9tYXRoJztcbmltcG9ydCB7TkRBcnJheSwgU2NhbGFyfSBmcm9tICcuL21hdGgvbmRhcnJheSc7XG5pbXBvcnQge09wdGltaXplcn0gZnJvbSAnLi9vcHRpbWl6ZXInO1xuaW1wb3J0IHtTZXNzaW9uUnVudGltZX0gZnJvbSAnLi9zZXNzaW9uJztcbmltcG9ydCAqIGFzIHNlc3Npb25fdXRpbCBmcm9tICcuL3Nlc3Npb25fdXRpbCc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuL3RlbnNvcl9hcnJheV9tYXAnO1xuXG5leHBvcnQgY2xhc3MgU0dET3B0aW1pemVyIGV4dGVuZHMgT3B0aW1pemVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBsZWFybmluZ1JhdGU6IG51bWJlciwgc3BlY2lmaWVkVmFyaWFibGVMaXN0PzogTm9kZVtdKSB7XG4gICAgc3VwZXIoc3BlY2lmaWVkVmFyaWFibGVMaXN0KTtcbiAgfVxuXG4gIGJlZm9yZUJhdGNoKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGJhdGNoU2l6ZTogbnVtYmVyLCBydW50aW1lOiBTZXNzaW9uUnVudGltZSxcbiAgICAgIGFjdGl2YXRpb25BcnJheU1hcDogVGVuc29yQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXA6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgdGhpcy52YXJpYWJsZU5vZGVzID0gdGhpcy5zcGVjaWZpZWRWYXJpYWJsZU5vZGVzID09IG51bGwgP1xuICAgICAgICBzZXNzaW9uX3V0aWwuZ2V0VmFyaWFibGVOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0KHJ1bnRpbWUubm9kZXMpIDpcbiAgICAgICAgdGhpcy5zcGVjaWZpZWRWYXJpYWJsZU5vZGVzO1xuICAgIGlmIChiYXRjaFNpemUgIT09IHRoaXMucHJldkJhdGNoU2l6ZSkge1xuICAgICAgdGhpcy5wcmV2QmF0Y2hTaXplID0gYmF0Y2hTaXplO1xuICAgICAgdGhpcy5jID0gU2NhbGFyLm5ldygtdGhpcy5sZWFybmluZ1JhdGUgLyBiYXRjaFNpemUpO1xuICAgIH1cbiAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChcbiAgICAgICAgbm9kZSA9PiB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLnNldChcbiAgICAgICAgICAgIG5vZGUub3V0cHV0LCBOREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSkpO1xuICB9XG5cbiAgYWZ0ZXJFeGFtcGxlKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIHJ1bnRpbWU6IFNlc3Npb25SdW50aW1lLFxuICAgICAgYWN0aXZhdGlvbkFycmF5TWFwOiBUZW5zb3JBcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcDogVGVuc29yQXJyYXlNYXApIHtcbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICB0aGlzLnZhcmlhYmxlTm9kZXMhLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IGdyYWRpZW50ID0gZ3JhZGllbnRBcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICBjb25zdCBhY2N1bXVsYXRlZEdyYWRpZW50ID0gdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLnNldChcbiAgICAgICAgICAgIG5vZGUub3V0cHV0LCBrZWVwKG1hdGguYWRkKGdyYWRpZW50LCBhY2N1bXVsYXRlZEdyYWRpZW50KSkpO1xuICAgICAgICBhY2N1bXVsYXRlZEdyYWRpZW50LmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYWZ0ZXJCYXRjaChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBiYXRjaFNpemU6IG51bWJlciwgcnVudGltZTogU2Vzc2lvblJ1bnRpbWUsXG4gICAgICBhY3RpdmF0aW9uQXJyYXlNYXA6IFRlbnNvckFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIHRoaXMudmFyaWFibGVOb2RlcyEuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgY29uc3Qgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgY29uc3QgZ3JhZGllbnQgPSB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlID1cbiAgICAgICAgICAgIG1hdGguc2NhbGVkQXJyYXlBZGQodGhpcy5jISwgZ3JhZGllbnQsIHRoaXMub25lISwgb2xkVmFyaWFibGUpO1xuICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuXG4gICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyBUZW5zb3JBcnJheU1hcCgpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5jICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYy5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHRoaXMub25lLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIHNldExlYXJuaW5nUmF0ZShsZWFybmluZ1JhdGU6IG51bWJlcikge1xuICAgIHRoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICB9XG5cbiAgcHJpdmF0ZSB2YXJpYWJsZUdyYWRpZW50cyA9IG5ldyBUZW5zb3JBcnJheU1hcCgpO1xuICBwcml2YXRlIHByZXZCYXRjaFNpemU6IG51bWJlcjtcbiAgcHJpdmF0ZSBvbmUgPSBTY2FsYXIubmV3KDEpO1xuICBwcml2YXRlIGM6IFNjYWxhcjtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtOREFycmF5fSBmcm9tICcuL21hdGgvbmRhcnJheSc7XG5cbi8qKlxuICogVGVuc29yQXJyYXlNYXAgaXMgYW4gaW50ZXJuYWwgbWFwIGZyb20gVGVuc29yIElEcyB0byBOREFycmF5cy4gU2luY2UgTkRBcnJheXNcbiAqIGNhbiBiZSBiYWNrZWQgYnkgV2ViR0wgdGV4dHVyZXMsIHRoZSBUZW5zb3JBcnJheU1hcCBpcyBvbmx5IHVzZWQgaW5zaWRlIG9mIGFcbiAqIFNlc3Npb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW5zb3JBcnJheU1hcCB7XG4gIC8qKlxuICAgKiBBZGQgb3IgcmVwbGFjZSBhbiBlbnRyeSBpbiB0aGUgbWFwLlxuICAgKiBAcGFyYW0gdGVuc29yIFRoZSB0ZW5zb3Iga2V5LlxuICAgKiBAcGFyYW0gYXJyYXkgVGhlIE5EQXJyYXkgdmFsdWUsIGNhbiBiZSBudWxsLlxuICAgKi9cbiAgc2V0KHRlbnNvcjogVGVuc29yLCBhcnJheTogTkRBcnJheXxudWxsKSB7XG4gICAgdGhpcy5kaWN0W3RlbnNvci5pZF0gPSBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBOREFycmF5IGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgdGVuc29yLiBXaWxsIHRocm93IGFuXG4gICAqIGV4Y2VwdGlvbiBpZiB0aGUgdGVuc29yIGlzIG5vdCBhIGtleSBpbiB0aGUgbWFwLCBvciBpZiB0aGUgYXNzb2NpYXRlZFxuICAgKiBOREFycmF5IGlzIG51bGwuXG4gICAqIEBwYXJhbSB0ZW5zb3IgVGhlIHRlbnNvciBrZXkuXG4gICAqIEBwYXJhbSBza2lwQ2hlY2tzIEZhbHNlIGJ5IGRlZmF1bHQuIElmIHRydWUgd2lsbCBza2lwIGFsbCBjaGVja3MuXG4gICAqIEByZXR1cm4gVGhlIE5EQXJyYXkgYXNzb2NpYXRlZCB3aXRoIHRoZSB0ZW5zb3IuXG4gICAqL1xuICBnZXQodGVuc29yOiBUZW5zb3IsIHNraXBDaGVja3MgPSBmYWxzZSk6IE5EQXJyYXkge1xuICAgIGlmICghc2tpcENoZWNrcyAmJiB0aGlzLmRpY3RbdGVuc29yLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RlbnNvciAnICsgdGVuc29yLmlkICsgJyBub3QgaW4gYXJyYXkgbWFwLicpO1xuICAgIH1cbiAgICBjb25zdCBuZGEgPSB0aGlzLmRpY3RbdGVuc29yLmlkXTtcbiAgICBpZiAoIXNraXBDaGVja3MgJiYgbmRhID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RlbnNvciAnICsgdGVuc29yLmlkICsgJyBoYXMgbnVsbCBhcnJheS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5kYSE7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHRlbnNvci9OREFycmF5IHBhaXIgZnJvbSB0aGUgbWFwLlxuICAgKiBAcGFyYW0gdGVuc29yIFRoZSB0ZW5zb3Iga2V5LlxuICAgKi9cbiAgZGVsZXRlKHRlbnNvcjogVGVuc29yKSB7XG4gICAgZGVsZXRlIHRoaXMuZGljdFt0ZW5zb3IuaWRdO1xuICB9XG5cbiAgZGlzcG9zZUFycmF5KHRlbnNvcjogVGVuc29yKSB7XG4gICAgaWYgKHRoaXMuZGljdFt0ZW5zb3IuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmRhID0gdGhpcy5kaWN0W3RlbnNvci5pZF07XG4gICAgaWYgKG5kYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBuZGEuZGlzcG9zZSgpO1xuICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFRoZSBudW1iZXIgb2YgdGVuc29yL05EQXJyYXkgcGFpcnMgaW4gdGhlIG1hcC5cbiAgICovXG4gIHNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kaWN0KS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGFsbCBjb250YWluZWQgTkRBcnJheSB2YWx1ZXMgYW5kIGRpc3Bvc2UgdGhlbS5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5kaWN0KS5mb3JFYWNoKHRlbnNvcklEID0+IHtcbiAgICAgIGNvbnN0IG5kYSA9IHRoaXMuZGljdFsrdGVuc29ySURdO1xuICAgICAgaWYgKG5kYSkge1xuICAgICAgICBuZGEuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZGljdCA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3RzIHRvIHNlZSBpZiBhIHRlbnNvciBoYXMgYSBudWxsIGFzc29jaWF0ZWQgd2l0aCBpdC4gVGhyb3dzXG4gICAqIGlmIHRoZSB0ZW5zb3IgaXMgbm90IGEga2V5IGluIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB0ZW5zb3IgVGhlIHRlbnNvciBrZXkuXG4gICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgYXNzb2NpYXRlZCBOREFycmF5IGlzIG51bGwsIGVsc2UgRmFsc2UuXG4gICAqL1xuICBoYXNOdWxsQXJyYXkodGVuc29yOiBUZW5zb3IpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5kaWN0W3RlbnNvci5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3IgJyArIHRlbnNvci5pZCArICcgbm90IGluIGFycmF5IG1hcC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGljdFt0ZW5zb3IuaWRdID09PSBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBkaWN0OiB7W3RlbnNvcklEOiBudW1iZXJdOiBOREFycmF5IHwgbnVsbH0gPSB7fTtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuZXhwb3J0IHR5cGUgVmVjdG9yID0gbnVtYmVyW10gfCBGbG9hdDY0QXJyYXkgfCBGbG9hdDMyQXJyYXkgfCBJbnQzMkFycmF5IHxcbiAgICBJbnQ4QXJyYXkgfCBJbnQxNkFycmF5O1xuXG4vKiogU2h1ZmZsZXMgdGhlIGFycmF5IHVzaW5nIEZpc2hlci1ZYXRlcyBhbGdvcml0aG0uICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG5leHBvcnQgZnVuY3Rpb24gc2h1ZmZsZShhcnJheTogYW55W118VWludDMyQXJyYXl8SW50MzJBcnJheXxcbiAgICAgICAgICAgICAgICAgICAgICAgIEZsb2F0MzJBcnJheSk6IHZvaWQge1xuICBsZXQgY291bnRlciA9IGFycmF5Lmxlbmd0aDtcbiAgbGV0IHRlbXAgPSAwO1xuICBsZXQgaW5kZXggPSAwO1xuICAvLyBXaGlsZSB0aGVyZSBhcmUgZWxlbWVudHMgaW4gdGhlIGFycmF5XG4gIHdoaWxlIChjb3VudGVyID4gMCkge1xuICAgIC8vIFBpY2sgYSByYW5kb20gaW5kZXhcbiAgICBpbmRleCA9IChNYXRoLnJhbmRvbSgpICogY291bnRlcikgfCAwO1xuICAgIC8vIERlY3JlYXNlIGNvdW50ZXIgYnkgMVxuICAgIGNvdW50ZXItLTtcbiAgICAvLyBBbmQgc3dhcCB0aGUgbGFzdCBlbGVtZW50IHdpdGggaXRcbiAgICB0ZW1wID0gYXJyYXlbY291bnRlcl07XG4gICAgYXJyYXlbY291bnRlcl0gPSBhcnJheVtpbmRleF07XG4gICAgYXJyYXlbaW5kZXhdID0gdGVtcDtcbiAgfVxufVxuXG4vKiogQ2xhbXBzIGEgdmFsdWUgdG8gYSBzcGVjaWZpZWQgcmFuZ2UuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhbXAobWluOiBudW1iZXIsIHg6IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih4LCBtYXgpKTtcbn1cblxuLyoqIFJldHVybnMgYSBzYW1wbGUgZnJvbSBhIHVuaWZvcm0gW2EsIGJdIGRpc3RyaWJ1dGlvbi4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kVW5pZm9ybShhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChiIC0gYSkgKyBhO1xufVxuXG4vKipcbiAqIFNhbXBsZXMgZnJvbSBhIGdhdXNzaWFuIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBAcGFyYW0gbWVhbiBUaGUgbWVhbi4gRGVmYXVsdCBpcyAwLlxuICogQHBhcmFtIHN0ZERldiBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uLiBEZWZhdWx0IGlzIDEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kR2F1c3MobWVhbiA9IDAsIHN0ZERldiA9IDEsIHRydW5jYXRlZCA9IGZhbHNlKTogbnVtYmVyIHtcbiAgbGV0IHYxOiBudW1iZXIsIHYyOiBudW1iZXIsIHM6IG51bWJlcjtcbiAgZG8ge1xuICAgIHYxID0gMiAqIE1hdGgucmFuZG9tKCkgLSAxO1xuICAgIHYyID0gMiAqIE1hdGgucmFuZG9tKCkgLSAxO1xuICAgIHMgPSB2MSAqIHYxICsgdjIgKiB2MjtcbiAgfSB3aGlsZSAocyA+IDEpO1xuXG4gIGNvbnN0IHJlc3VsdCA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHMpIC8gcykgKiB2MTtcbiAgaWYgKHRydW5jYXRlZCAmJiByZXN1bHQgPiAyKSB7XG4gICAgcmV0dXJuIHJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIHRydWUpO1xuICB9XG4gIHJldHVybiBtZWFuICsgc3RkRGV2ICogcmVzdWx0O1xufVxuXG4vKiogUmV0dXJucyBzcXVhcmVkIGV1Y2xlZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWN0b3JzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RTcXVhcmVkKGE6IFZlY3RvciwgYjogVmVjdG9yKTogbnVtYmVyIHtcbiAgbGV0IHJlc3VsdCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGRpZmYgPSBhW2ldIC0gYltpXTtcbiAgICByZXN1bHQgKz0gZGlmZiAqIGRpZmY7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChleHByOiBib29sZWFuLCBtc2c6IHN0cmluZykge1xuICBpZiAoIWV4cHIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U2hhcGVzTWF0Y2goXG4gICAgc2hhcGVBOiBudW1iZXJbXSwgc2hhcGVCOiBudW1iZXJbXSwgZXJyb3JNZXNzYWdlUHJlZml4ID0gJycpOiB2b2lkIHtcbiAgYXNzZXJ0KFxuICAgICAgYXJyYXlzRXF1YWwoc2hhcGVBLCBzaGFwZUIpLFxuICAgICAgZXJyb3JNZXNzYWdlUHJlZml4ICsgYFNoYXBlcyAke3NoYXBlQX0gYW5kICR7c2hhcGVCfSBtdXN0IG1hdGNoYCk7XG59XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGFycjogYW55W10sIHJldD86IG51bWJlcltdKTogbnVtYmVyW10ge1xuICByZXQgPSAocmV0ID09PSB1bmRlZmluZWQgPyBbXSA6IHJldCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyW2ldKSkge1xuICAgICAgZmxhdHRlbihhcnJbaV0sIHJldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wdXNoKGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCB0eXBlIEFycmF5RGF0YSA9IG51bWJlcnxudW1iZXJbXXxudW1iZXJbXVtdfG51bWJlcltdW11bXXxudW1iZXJbXVtdW11bXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGluZmVyU2hhcGUoYXJyOiBBcnJheURhdGEpOiBudW1iZXJbXSB7XG4gIGNvbnN0IHNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICB3aGlsZSAoYXJyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBzaGFwZS5wdXNoKGFyci5sZW5ndGgpO1xuICAgIGFyciA9IGFyclswXTtcbiAgfVxuICByZXR1cm4gc2hhcGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaXplRnJvbVNoYXBlKHNoYXBlOiBudW1iZXJbXSk6IG51bWJlciB7XG4gIGlmIChzaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBTY2FsYXIuXG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgbGV0IHNpemUgPSBzaGFwZVswXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBzaGFwZS5sZW5ndGg7IGkrKykge1xuICAgIHNpemUgKj0gc2hhcGVbaV07XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NjYWxhclNoYXBlKHNoYXBlOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICByZXR1cm4gc2hhcGUubGVuZ3RoID09PSAwO1xufVxuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlzRXF1YWwobjE6IGFueVtdfEZsb2F0MzJBcnJheSwgbjI6IGFueVtdfEZsb2F0MzJBcnJheSkge1xuICBpZiAobjEubGVuZ3RoICE9PSBuMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuMS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuMVtpXSAhPT0gbjJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ludChhOiBudW1iZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIGEgJSAxID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGFuaCh4OiBudW1iZXIpOiBudW1iZXIge1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gIGlmICgoTWF0aCBhcyBhbnkpLnRhbmggIT0gbnVsbCkge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICByZXR1cm4gKE1hdGggYXMgYW55KS50YW5oKHgpO1xuICB9XG4gIGlmICh4ID09PSBJbmZpbml0eSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKHggPT09IC1JbmZpbml0eSkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBlMnggPSBNYXRoLmV4cCgyICogeCk7XG4gICAgcmV0dXJuIChlMnggLSAxKSAvIChlMnggKyAxKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2l6ZVRvU3F1YXJpc2hTaGFwZShzaXplOiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgZm9yIChsZXQgYSA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KHNpemUpKTsgYSA+IDE7IC0tYSkge1xuICAgIGlmIChzaXplICUgYSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFthLCBzaXplIC8gYV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbMSwgc2l6ZV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaHVmZmxlZEluZGljZXMobjogbnVtYmVyKTogVWludDMyQXJyYXkge1xuICBjb25zdCBzaHVmZmxlZEluZGljZXMgPSBuZXcgVWludDMyQXJyYXkobik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgc2h1ZmZsZWRJbmRpY2VzW2ldID0gaTtcbiAgfVxuICBzaHVmZmxlKHNodWZmbGVkSW5kaWNlcyk7XG4gIHJldHVybiBzaHVmZmxlZEluZGljZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKFxuICAgIHNoYXBlQTogbnVtYmVyW10sIHNoYXBlQjogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gIGNvbnN0IHJlc3VsdDogbnVtYmVyW10gPSBbXTtcbiAgbGV0IG5leHRBRGltTXVzdEJlT25lID0gZmFsc2U7XG4gIGxldCBuZXh0QkRpbU11c3RCZU9uZSA9IGZhbHNlO1xuICBjb25zdCBlcnJNc2cgPSBgT3BlcmFuZHMgY291bGQgbm90IGJlIGJyb2FkY2FzdCB0b2dldGhlciB3aXRoIHNoYXBlcyBgICtcbiAgICAgIGAke3NoYXBlQX0gYW5kICR7c2hhcGVCfS4gQ3VycmVudGx5LCB3ZSBvbmx5IHN1cHBvcnQgYSBgICtcbiAgICAgIGBzdHJpY3RlciB2ZXJzaW9uIG9mIGJyb2FkY2FzdGluZyB0aGFuIG51bXB5LmA7XG4gIGNvbnN0IGwgPSBNYXRoLm1heChzaGFwZUEubGVuZ3RoLCBzaGFwZUIubGVuZ3RoKTtcblxuICBzaGFwZUEgPSBzaGFwZUEuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIHNoYXBlQiA9IHNoYXBlQi5zbGljZSgpLnJldmVyc2UoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBhID0gc2hhcGVBW2ldIHx8IDE7XG4gICAgY29uc3QgYiA9IHNoYXBlQltpXSB8fCAxO1xuICAgIGlmICgoYiA+IDEgJiYgbmV4dEJEaW1NdXN0QmVPbmUpIHx8IChhID4gMSAmJiBuZXh0QURpbU11c3RCZU9uZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGVyck1zZyk7XG4gICAgfVxuICAgIGlmIChhID4gMSAmJiBiID09PSAxKSB7XG4gICAgICBuZXh0QkRpbU11c3RCZU9uZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChiID4gMSAmJiBhID09PSAxKSB7XG4gICAgICBuZXh0QURpbU11c3RCZU9uZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChhID4gMSAmJiBiID4gMSAmJiBhICE9PSBiKSB7XG4gICAgICB0aHJvdyBFcnJvcihlcnJNc2cpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChNYXRoLm1heChhLCBiKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5yZXZlcnNlKCk7XG59XG4iXX0=
