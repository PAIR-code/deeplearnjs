{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1532457398879},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1530637734514}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DTYPE_VALUE_SIZE_MAP = {\n    'float32': 4,\n    'int32': 4,\n    'uint16': 2,\n    'uint8': 1,\n    'bool': 1\n};","map":{"mappings":[{"source":"../src/io/types.ts","name":null,"original":{"line":23,"column":13},"generated":{"line":4,"column":0}},{"source":"../src/io/types.ts","name":null,"original":{"line":23,"column":13},"generated":{"line":4,"column":8}},{"source":"../src/io/types.ts","name":null,"original":{"line":23,"column":13},"generated":{"line":4,"column":28}},{"source":"../src/io/types.ts","name":null,"original":{"line":23,"column":63},"generated":{"line":4,"column":31}},{"source":"../src/io/types.ts","name":null,"original":{"line":24,"column":2},"generated":{"line":5,"column":0}},{"source":"../src/io/types.ts","name":null,"original":{"line":24,"column":13},"generated":{"line":5,"column":15}},{"source":"../src/io/types.ts","name":null,"original":{"line":23,"column":63},"generated":{"line":5,"column":16}},{"source":"../src/io/types.ts","name":null,"original":{"line":25,"column":2},"generated":{"line":6,"column":0}},{"source":"../src/io/types.ts","name":null,"original":{"line":25,"column":11},"generated":{"line":6,"column":13}},{"source":"../src/io/types.ts","name":null,"original":{"line":23,"column":63},"generated":{"line":6,"column":14}},{"source":"../src/io/types.ts","name":null,"original":{"line":26,"column":2},"generated":{"line":7,"column":0}},{"source":"../src/io/types.ts","name":null,"original":{"line":26,"column":12},"generated":{"line":7,"column":14}},{"source":"../src/io/types.ts","name":null,"original":{"line":23,"column":63},"generated":{"line":7,"column":15}},{"source":"../src/io/types.ts","name":null,"original":{"line":27,"column":2},"generated":{"line":8,"column":0}},{"source":"../src/io/types.ts","name":null,"original":{"line":27,"column":11},"generated":{"line":8,"column":13}},{"source":"../src/io/types.ts","name":null,"original":{"line":23,"column":63},"generated":{"line":8,"column":14}},{"source":"../src/io/types.ts","name":null,"original":{"line":28,"column":2},"generated":{"line":9,"column":0}},{"source":"../src/io/types.ts","name":null,"original":{"line":28,"column":10},"generated":{"line":9,"column":12}},{"source":"../src/io/types.ts","name":null,"original":{"line":23,"column":63},"generated":{"line":10,"column":0}},{"source":"../src/io/types.ts","name":null,"original":{"line":23,"column":13},"generated":{"line":10,"column":1}}],"sources":{"../src/io/types.ts":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/* Type definitions for exporting and importing of models. */\n\n/**\n * A map from Tensor dtype to number of bytes per element of the Tensor.\n */\nexport const DTYPE_VALUE_SIZE_MAP: {[dtype: string]: number} = {\n  'float32': 4,\n  'int32': 4,\n  'uint16': 2,\n  'uint8': 1,\n  'bool': 1,\n};\n\n/**\n * A weight manifest.\n *\n * The weight manifest consists of an ordered list of weight-manifest groups.\n * Each weight-manifest group (\"group\" for short hereafter) consists of a\n * number of weight values stored in a number of paths.\n * See the documentation of `WeightManifestGroupConfig` below for more details.\n */\nexport declare type WeightsManifestConfig = WeightsManifestGroupConfig[];\n\n/**\n * A weight-manifest group.\n *\n * Consists of an ordered list of weight values encoded in binary format,\n * stored in an ordered list of paths.\n */\nexport declare interface WeightsManifestGroupConfig {\n  /**\n   * An ordered list of paths.\n   *\n   * Paths are intentionally abstract in order to be general. For example, they\n   * can be relative URL paths or relative paths on the file system.\n   */\n  paths: string[];\n\n  /**\n   * Specifications of the weights stored in the paths.\n   */\n  weights: WeightsManifestEntry[];\n}\n\n/**\n * An entry in the weight manifest.\n *\n * The entry contains specification of a weight.\n */\nexport declare interface WeightsManifestEntry {\n  /**\n   * Name of the weight, e.g., 'Dense_1/bias'\n   */\n  name: string;\n\n  /**\n   * Shape of the weight.\n   */\n  shape: number[];\n\n  /**\n   * Data type of the weight.\n   */\n  dtype: 'float32'|'int32'|'bool';\n\n  /**\n   * Information for dequantization of the weight.\n   */\n  quantization?: {\n    scale: number,           // The scaling constant to multiply by.\n    min: number,             // The (possibly nudged) minimum weight to add.\n    dtype: 'uint16'|'uint8'  // The dtype of the quantized weights.\n  };\n}\n\n/**\n * Options for saving a model.\n */\nexport interface SaveConfig {\n  /**\n   * Whether to save only the trainable weights of the model, ignoring the\n   * untrainable ones.\n   */\n  trainableOnly?: boolean;\n}\n\n/**\n * Result of a saving operation.\n */\nexport interface SaveResult {\n  /**\n   * Information about the model artifacts saved.\n   */\n  modelArtifactsInfo: ModelArtifactsInfo;\n\n  /**\n   * HTTP responses from the server that handled the model-saving request (if\n   * any). This is applicable only to server-based saving routes.\n   */\n  responses?: Response[];\n\n  /**\n   * Error messages and related data (if any).\n   */\n  errors?: Array<{}|string>;\n}\n\nexport declare interface ModelArtifactsInfo {\n  /**\n   * Timestamp for when the model is saved.\n   */\n  dateSaved: Date;\n\n  /**\n   * Type of the model topology\n   *\n   * Possible values:\n   *   - JSON: JSON config (human-readable, e.g., Keras JSON).\n   *   - GraphDef: TensorFlow\n   *     [GraphDef](https://www.tensorflow.org/extend/tool_developers/#graphdef)\n   *     protocal buffer (binary).\n   */\n  modelTopologyType: 'JSON'|'GraphDef';\n\n  /**\n   * Size of model topology (Keras JSON or GraphDef), in bytes.\n   */\n  modelTopologyBytes?: number;\n\n  /**\n   * Size of weight specification or manifest, in bytes.\n   */\n  weightSpecsBytes?: number;\n\n  /**\n   * Size of weight value data, in bytes.\n   */\n  weightDataBytes?: number;\n}\n\n/**\n * The serialized artifacts of a model, including topology and weights.\n *\n * The `modelTopology`, `weightSpecs` and `weightData` fields of this interface\n * are optional, in order to support topology- or weights-only saving and\n * loading.\n */\nexport declare interface ModelArtifacts {\n  /**\n   * Model topology.\n   *\n   * For Keras-style `tf.Model`s, this is a JSON object.\n   * For TensorFlow-style models (e.g., `FrozenModel`), this is a binary buffer\n   * carrying the `GraphDef` protocol buffer.\n   */\n  modelTopology?: {}|ArrayBuffer;\n\n  /**\n   * Weight specifications.\n   *\n   * This corresponds to the weightsData below.\n   */\n  weightSpecs?: WeightsManifestEntry[];\n\n  /**\n   * Binary buffer for all weight values concatenated in the order specified\n   * by `weightSpecs`.\n   */\n  weightData?: ArrayBuffer;\n}\n\n/**\n * Type definition for handlers of loading operations.\n */\nexport type LoadHandler = () => Promise<ModelArtifacts>;\n\n/**\n * Type definition for handlers of saving operations.\n */\nexport type SaveHandler = (modelArtifact: ModelArtifacts) =>\n    Promise<SaveResult>;\n\n/**\n * Interface for a model import/export handler.\n *\n * The `save` and `load` handlers are both optional, in order to allow handlers\n * that support only saving or loading.\n */\n// tslint:disable-next-line:interface-name\nexport interface IOHandler {\n  save?: SaveHandler;\n  load?: LoadHandler;\n}\n\n/**\n * An interface for the manager of a model store.\n *\n * A model store is defined as a storage medium on which multiple models can\n * be stored. Each stored model has a unique `path` as its identifier.\n * A `ModelStoreManager` for the store allows actions including\n *\n * - Listing the models stored in the store.\n * - Deleting a model from the store.\n */\nexport interface ModelStoreManager {\n  /**\n   * List all models in the model store.\n   *\n   * @returns A dictionary mapping paths of existing models to their\n   *   model artifacts info. Model artifacts info include type of the model's\n   *   topology, byte sizes of the topology, weights, etc.\n   */\n  listModels(): Promise<{[path: string]: ModelArtifactsInfo}>;\n\n  /**\n   * Remove a model specified by `path`.\n   *\n   * @param path\n   * @returns ModelArtifactsInfo of the deleted model (if and only if deletion\n   *   is successful).\n   * @throws Error if deletion fails, e.g., if no model exists at `path`.\n   */\n  removeModel(path: string): Promise<ModelArtifactsInfo>;\n}\n"},"lineCount":null}},"hash":"4ff8f7388b6c1d8b8c28c1ed82858ef3","cacheData":{"env":{}}}